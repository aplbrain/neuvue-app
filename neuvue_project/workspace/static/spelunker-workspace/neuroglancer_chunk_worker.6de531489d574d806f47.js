var ic={4242:(te,Se,x)=>{x.d(Se,{y6:()=>j});var me=x(8796);/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var j=(ae=>(ae[ae.MIN_REPRESENTATIVE=0]="MIN_REPRESENTATIVE",ae[ae.MAX_REPRESENTATIVE=1]="MAX_REPRESENTATIVE",ae[ae.REPRESENTATIVE_EXCLUDED=2]="REPRESENTATIVE_EXCLUDED",ae[ae.NONREPRESENTATIVE_EXCLUDED=4]="NONREPRESENTATIVE_EXCLUDED",ae))(j||{});function J(ae){return!(ae.high>>>31)}const be=new me.R(4294967295,4294967295)},3206:(te,Se,x)=>{x.d(Se,{B0:()=>be,DN:()=>ae,no:()=>ke});var me=x(5716),j=x(2596),J=x(4038);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class be{constructor(D){this.value_=D,this.changed=new J.IY}get value(){return this.value_}set value(D){D!==this.value_&&(this.value_=D,this.changed.dispatch())}}class ae extends be{constructor(D,q,$=D){super(D),this.validator=q,this.defaultValue=$}toJSON(){const{value_:D}=this;if(D!==this.defaultValue)return this.value_}reset(){this.value=this.defaultValue}restoreState(D){if(D!==void 0){const{validator:q}=this;try{this.value=q(D);return}catch{}}this.value=this.defaultValue}}class ye extends j.O8{constructor(D,q){super(),this.changed=new J.IY,this.f=D,this.ws=q;for(const $ of q)this.registerDisposer($.changed.add(this.changed.dispatch))}get value(){return this.f(...this.ws.map(D=>D.value))}}function Me(z,...D){return new ye(z,D)}class Ee extends j.O8{constructor(D,q){super(),this.changed=new J.IY,this.valueGeneration=-1,this.f=D,this.ws=q;for(const $ of q)this.registerDisposer($.changed.add(this.changed.dispatch))}get value(){const D=this.changed.count;return D!==this.valueGeneration&&(this.value_=this.f(...this.ws.map(q=>q.value)),this.valueGeneration=D),this.value_}}function re(z,...D){return new Ee(z,D)}class ue extends j.O8{constructor(D,q=($,_)=>$===_){super(),this.changed=new J.HN,this.value=D.value,this.registerDisposer(D.changed.add(()=>{const $=D.value;q(this.value,$)||(this.value=$,this.changed.dispatch())}))}}function Q(z,D,q){const $=new ye(z,D),_=new ue($,q);return _.registerDisposer($),_}class ze extends j.O8{constructor(D){super(),this.changed=new J.IY;const q=D(this),$=Object.keys(q),_=()=>{const Te=Array.isArray(q)?[]:{};for(const se of $)Te[se]=q[se].value;this.value=Te,this.changed.dispatch()};_();for(const Te of $){const se=q[Te];this.registerDisposer(se.changed.add(()=>_()))}}}class Ke extends j.O8{constructor(D,...q){super(),this.f=D,this.changed=new J.IY;for(const $ of q)this.registerDisposer($.add(this.changed.dispatch))}get value(){return this.f()}}class Je extends j.O8{constructor(){super(...arguments),this.changed=new J.IY}get value(){return this.value_}set value(D){const{value_:q}=this;if(this.value_=D,q!==void 0&&(q.dispose(),q.unregisterDisposer(this.valueHandler),this.valueHandler=void 0),D!==void 0){const $=this.valueHandler=()=>{this.value_===D&&(this.value_=void 0,this.changed.dispatch())};D.registerDisposer($)}D!==q&&this.changed.dispatch()}reset(){this.value=void 0}disposed(){this.value_!==void 0&&(this.value_.unregisterDisposer(this.valueHandler),this.value_.dispose()),this.value_=void 0,super.disposed()}}class et extends Je{constructor(D,q){super(),this.validator=D,this.jsonConverter=q}toJSON(){const{value:D}=this;return D&&this.jsonConverter(D)}restoreState(D){this.value=this.validator(D)}}class De{constructor(D){this.changed=new J.HN,D===void 0?this.values=new Set:this.values=new Set(D)}add(D){const{values:q}=this;return q.has(D)||(q.add(D),this.changed.dispatch(D,!0)),this}delete(D){const{values:q}=this;return q.delete(D)?(this.changed.dispatch(D,!1),!0):!1}has(D){return this.values.has(D)}get size(){return this.values.size}[Symbol.iterator](){return this.values[Symbol.iterator]()}clear(){const{values:D}=this;D.size>0&&(D.clear(),this.changed.dispatch(null,!1))}}function ke(z,...D){const q=D.map(Ae=>Ae.value),$=D.length;let _=new j.O8,Te=z(_,...q);const se=(0,me.A)(()=>{let Ae=!1;for(let Le=0;Le<$;++Le){const Ze=D[Le].value;q[Le]!==Ze&&(q[Le]=Ze,Ae=!0)}Ae&&(_.dispose(),_=new j.O8,Te=z(_,...q))},0),Xe=D.map(Ae=>Ae.changed.add(se));return{flush(){se.flush()},dispose(){se.cancel(),(0,j.$F)(Xe),_.dispose()},get value(){return se.flush(),Te}}}function U(z,...D){const q=D.map(Ae=>Ae.value),$=D.length;let _=new RefCounted,Te=z(_,...q);const se=()=>{let Ae=!1;for(let Le=0;Le<$;++Le){const Ze=D[Le].value;q[Le]!==Ze&&(q[Le]=Ze,Ae=!0)}Ae&&(_.dispose(),_=new RefCounted,Te=z(_,...q))},Xe=D.map(Ae=>Ae.changed.add(se));return{dispose(){invokeDisposers(Xe),_.dispose()},get value(){return Te}}}function W(z){return{changed:neverSignal,value:z}}function X(z,D){return z(D.value),D.changed.add(()=>z(D.value))}function O(z,D){return D.value=z.value,z.changed.add(()=>{D.value=z.value})}class F{constructor(D,q){this.outer=D,this.getInner=q,this.changed=new NullarySignal,this.update=()=>{const{disposer:$,outer:_}=this;$!==void 0&&$();const Te=this.inner=this.getInner(_.value);this.disposer=Te.changed.add(this.changed.dispatch),this.changed.dispatch()},D.changed.add(this.update),this.update()}dispose(){this.outer.changed.remove(this.update),this.disposer()}get value(){return this.inner.value}set value(D){this.inner.value=D}}class oe extends null{reset(){this.inner.reset()}restoreState(D){this.inner.restoreState(D)}toJSON(){return this.inner.toJSON()}}},4509:(te,Se,x)=>{x.d(Se,{Dq:()=>J,Qi:()=>ye,fx:()=>ae,gI:()=>Ee,wS:()=>j,y3:()=>Me});/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class me extends Error{constructor(){super(...arguments),this.name="CancellationError",this.message="CANCELED"}toString(){return"CANCELED"}}const j=new me;function J(re){if(re.isCanceled===!0)throw j}const be=()=>{},ae={isCanceled:!1,add:()=>be,remove:be};class ye{cancel(){const{handlers:ue}=this;if(ue!==null&&(this.handlers=null,ue!==void 0))for(const Q of ue)Q()}get isCanceled(){return this.handlers===null}add(ue){let{handlers:Q}=this;return Q===null?(ue(),be):(Q===void 0&&(Q=this.handlers=new Set),Q.add(ue),()=>{this.remove(ue)})}remove(ue){const{handlers:Q}=this;Q?.delete(ue)}}class Me extends ye{constructor(){super(...arguments),this.consumers=new Set}addConsumer(ue=ae){const{consumers:Q}=this;Q.has(ue)||ue.isCanceled||(Q.add(ue),ue.add(()=>{Q.delete(ue),Q.size===0&&this.cancel()}))}}function Ee(re,ue){return new Promise((Q,ze)=>{if(re===ae){ue(Q,ze,ae);return}const Ke=new ye,Je=re.add(()=>{Ke.cancel()});ue(et=>{Je(),Q(et)},et=>{Je(),ze(et)},Ke)})}},2596:(te,Se,x)=>{x.d(Se,{$F:()=>J,O8:()=>ae,fL:()=>ye});/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const me=!1;function j(Ee){typeof Ee=="object"?Ee.dispose():Ee()}function J(Ee){for(let re=Ee.length;re>0;--re)j(Ee[re-1])}function be(Ee,re,ue,Q){return Ee.addEventListener(re,ue,Q),()=>Ee.removeEventListener(re,ue,Q)}class ae{constructor(){this.refCount=1}addRef(){return++this.refCount,this}dispose(){me&&(this.disposedStacks=this.disposedStacks||[]).push(new Error().stack),--this.refCount===0&&this.refCountReachedZero()}refCountReachedZero(){this.disposed();const{disposers:re}=this;re!==void 0&&(J(re),this.disposers=void 0),this.wasDisposed=!0}disposed(){}registerDisposer(re){const{disposers:ue}=this;return ue==null?this.disposers=[re]:ue.push(re),re}unregisterDisposer(re){const{disposers:ue}=this;if(ue!=null){const Q=ue.indexOf(re);Q!==-1&&ue.splice(Q,1)}return re}registerEventListener(re,ue,Q,ze){this.registerDisposer(be(re,ue,Q,ze))}registerCancellable(re){return this.registerDisposer(()=>{re.cancel()}),re}}class ye extends ae{constructor(re){super(),this.value=re}}function Me(Ee){return()=>{if(Ee!==void 0){const re=Ee;Ee=void 0,j(re)}}}},3038:(te,Se,x)=>{x.d(Se,{I1:()=>Ae,Oi:()=>Q,T_:()=>$,WG:()=>ze,Yu:()=>be,_A:()=>D,_S:()=>q,eG:()=>F,eR:()=>j,ln:()=>J,nL:()=>De,pB:()=>me,qp:()=>_,sJ:()=>Le,uD:()=>O,vs:()=>X,w0:()=>ae,w8:()=>re,xK:()=>Je});var me=x(7684),j=x(329),J=x(4796),be=x(2221),ae=x(1409);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ye=me.create(),Me=null,Ee=[j.fromValues(1,0,0),j.fromValues(0,1,0),j.fromValues(0,0,1)],re=j.fromValues(0,0,0),ue=J.fromValues(0,0,0,0),Q=j.fromValues(1,1,1),ze=j.fromValues(1/0,1/0,1/0),Ke=be.create();function Je(P){return P[0]*P[1]*P[2]}function et(P){return P[0]*P[1]*P[2]*P[3]}function De(P){return`${P[0]},${P[1]},${P[2]}`}function ke(P,B){const ne=B[0],Z=B[1],ce=B[2],ie=B[3];P[0]=ie,P[1]=ce,P[2]=-Z,P[3]=-ne}function U(P,B){const ne=B[0],Z=B[1],ce=B[2],ie=B[3];P[0]=-ce,P[1]=ie,P[2]=ne,P[3]=-Z}function W(P,B){const ne=B[0],Z=B[1],ce=B[2],ie=B[3];P[0]=Z,P[1]=-ne,P[2]=ie,P[3]=-ce}function X(P,B,ne){const Z=B[0],ce=B[1],ie=B[2];return P[0]=ne[0]*Z+ne[4]*ce+ne[8]*ie,P[1]=ne[1]*Z+ne[5]*ce+ne[9]*ie,P[2]=ne[2]*Z+ne[6]*ce+ne[10]*ie,P}function O(P,B,ne){const Z=B[0],ce=B[1],ie=B[2];return P[0]=ne[0]*Z+ne[1]*ce+ne[2]*ie,P[1]=ne[4]*Z+ne[5]*ce+ne[6]*ie,P[2]=ne[8]*Z+ne[9]*ce+ne[10]*ie,P}function F(P,B,ne,Z,ce){const ie=P;return P[0]=Z[0],P[1]=Z[1],P[2]=Z[2]*ce,me.fromRotationTranslationScale(P,ne,B,ie)}function oe(P,B,ne){const Z=ne.length;let ce=0;for(let he=0;he<Z;++he)ce+=(P[he]-B[he])**2;let ie=0;for(let he=0;he<Z;++he){const Pe=P[he];ie-=(Pe-ne[he])*(B[he]-Pe)}return ie/Math.max(ce,1e-6)}function z(P,B,ne,Z){const ce=P.length;let ie=oe(B,ne,Z);ie=Math.max(0,Math.min(1,ie));for(let he=0;he<ce;++he){const Pe=B[he];P[he]=Pe+ie*(ne[he]-Pe)}return P}function D(P,B){const ne=B[0],Z=B[1],ce=B[2],ie=B[4],he=B[5],Pe=B[6],Oe=B[8],Ne=B[9],Ue=B[10];return P[0]=ne,P[1]=Z,P[2]=ce,P[3]=ie,P[4]=he,P[5]=Pe,P[6]=Oe,P[7]=Ne,P[8]=Ue,P}function q(P,B){const ne=B[0],Z=B[1],ce=B[2],ie=B[3],he=B[4],Pe=B[5],Oe=B[6],Ne=B[7],Ue=B[8],qe=B[9],bt=B[10],ot=B[11],ve=B[12],jt=B[13],Yt=B[14],at=B[15];P[0]=ie+ne,P[1]=Ne+he,P[2]=ot+Ue,P[3]=at+ve,P[4]=ie-ne,P[5]=Ne-he,P[6]=ot-Ue,P[7]=at-ve,P[8]=ie+Z,P[9]=Ne+Pe,P[10]=ot+qe,P[11]=at+jt,P[12]=ie-Z,P[13]=Ne-Pe,P[14]=ot-qe,P[15]=at-jt;const dt=ie+ce,ln=Ne+Oe,un=ot+bt,_e=at+Yt,g=ie-ce,M=Ne-Oe,G=ot-bt,K=at-Yt,de=Math.sqrt(dt**2+ln**2+un**2);P[16]=dt/de,P[17]=ln/de,P[18]=un/de,P[19]=_e/de;const fe=Math.sqrt(g**2+M**2+G**2);return P[20]=g/fe,P[21]=M/fe,P[22]=G/fe,P[23]=K/fe,P}function $(P,B,ne,Z,ce,ie,he){for(let Pe=0;Pe<6;++Pe){const Oe=he[Pe*4],Ne=he[Pe*4+1],Ue=he[Pe*4+2],qe=he[Pe*4+3];if(Math.max(Oe*P,Oe*Z)+Math.max(Ne*B,Ne*ce)+Math.max(Ue*ne,Ue*ie)+qe<0)return!1}return!0}function _(P,B,ne,Z,ce,ie,he){for(let Pe=0;Pe<4;++Pe){const Oe=he[Pe*4],Ne=he[Pe*4+1],Ue=he[Pe*4+2],qe=he[Pe*4+3];if(Math.max(Oe*P,Oe*Z)+Math.max(Ne*B,Ne*ce)+Math.max(Ue*ne,Ue*ie)+qe<0)return!1}{const Oe=he[20],Ne=he[5*4+1],Ue=he[5*4+2],qe=he[5*4+3],bt=Math.max(Oe*P,Oe*Z)+Math.max(Ne*B,Ne*ce)+Math.max(Ue*ne,Ue*ie),ot=Math.min(Oe*P,Oe*Z)+Math.min(Ne*B,Ne*ce)+Math.min(Ue*ne,Ue*ie),ve=Math.abs(qe)*1e-6;if(ot>-qe+ve||bt<-qe-ve)return!1}return!0}function Te(P,B,ne,Z=!1){const ce=ne.length,ie=[],he=Z?1:B+1,Pe=Z?B+1:1;for(let Oe=0;Oe<ce;++Oe){const Ne=ne[Oe];for(let Ue=0;Ue<B;++Ue)P[Ue*he+Ne*Pe]!==0&&(ie[Ue]=!0)}return findMatchingIndices(ie,!0)}function se(P,B,ne){for(let Z=0;Z<3;++Z){const ce=ne[Z];for(let ie=0;ie<3;++ie)P[ie+Z*3]=ce*B[ie+Z*3]}return P}function Xe(P,B,ne){for(let Z=0;Z<3;++Z){const ce=ne[Z];for(let ie=0;ie<3;++ie)P[Z+ie*3]=ce*B[Z+ie*3]}return P}function Ae(P){if(P[15]===1){const he=2/Math.abs(P[10]),Pe=2/Math.abs(P[0]),Oe=2/Math.abs(P[5]);return Pe*Oe*he}const B=P[10],Z=2*P[14]/(2*B-2),ce=(B-1)*Z/(B+1);return 4/(P[0]*P[5])/3*(Math.abs(ce)**3-Math.abs(Z)**3)}function Le(P){if(P[15]===1)return 2/Math.abs(P[10]);const B=P[10],Z=2*P[14]/(2*B-2),ce=(B-1)*Z/(B+1);return Math.abs(ce-Z)}function ut(P){return P[2]=0,P[6]=0,P[10]=0,P[14]=0,P}const Ze=j.create();function ds(P,B){B[0]=B[1]=B[2]=Number.POSITIVE_INFINITY,B[3]=B[4]=B[5]=Number.NEGATIVE_INFINITY;for(let ne=0;ne<8;++ne){Ze[0]=2*(ne&1)-1,Ze[1]=2*(ne>>>1&1)-1,Ze[2]=2*(ne>>>2&1)-1,vec3.transformMat4(Ze,Ze,P);for(let Z=0;Z<3;++Z){const ce=Ze[Z];B[Z]=Math.min(B[Z],ce),B[Z+3]=Math.max(B[Z+3],ce)}}}},9808:(te,Se,x)=>{x.d(Se,{Bk:()=>Q,Dl:()=>Je,El:()=>et,JD:()=>Ke,JZ:()=>Me,Rc:()=>re,cj:()=>ue,j$:()=>J});var me=x(4509),j=x(8796);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class J extends Error{constructor(ke,U,W,X){let O=`Fetching ${JSON.stringify(ke)} resulted in HTTP error ${U}`;W&&(O+=`: ${W}`),O+=".",super(O),this.name="HttpError",this.message=O,this.url=ke,this.status=U,this.statusText=W,X&&(this.response=X)}static fromResponse(ke){return new J(ke.url,ke.status,ke.statusText,ke)}static fromRequestError(ke,U){if(U instanceof TypeError){let W;return typeof ke=="string"?W=ke:W=ke.url,new J(W,0,"Network or CORS error")}return U}}const be=32,ae=500,ye=1e4;function Me(De){return Math.min(2**De*ae,ye/2)*(1+Math.random())}async function Ee(De,ke){for(let U=0;;){if(ke?.signal?.aborted)throw me.wS;let W;try{W=await fetch(De,ke)}catch(X){throw J.fromRequestError(De,X)}if(!W.ok){const{status:X}=W;if((X===429||X===503||X===504)&&++U!==be){await new Promise(O=>setTimeout(O,Me(U-1)));continue}throw J.fromResponse(W)}return W}}function re(De){return De.arrayBuffer()}function ue(De){return De.json()}async function Q(De,ke,U,W=me.fx){if(W===me.fx){const F=await Ee(De,ke);return await U(F)}const X=new AbortController,O=W.add(()=>X.abort());try{const F=await Ee(De,{...ke,signal:X.signal});return await U(F)}finally{O()}}const ze=new j.R;function Ke(De,ke){let U;return typeof ke=="number"?U=`${ke-1}`:(j.R.decrement(ze,ke),U=ze.toString()),{Range:`bytes=${De}-${U}`}}function Je(De){const ke=/^([^:/]+):\/\/([^/]+)((?:\/.*)?)$/,U=De.match(ke);if(U===null)throw new Error(`Invalid URL: ${JSON.stringify(De)}`);return{protocol:U[1],host:U[2],path:U[3]}}function et(De){return De instanceof J?De.status===0||De.status===403||De.status===404:!1}},7900:(te,Se,x)=>{x.d(Se,{$v:()=>se,HB:()=>_,J6:()=>Te,JB:()=>ue,MM:()=>he,Mo:()=>ae,Rf:()=>Ae,VH:()=>Yt,Vr:()=>Ee,Xu:()=>Xe,Zw:()=>be,_D:()=>j,aO:()=>dt,bX:()=>Le,cQ:()=>ie,si:()=>jt,sl:()=>qe,xU:()=>Oe,z$:()=>B,zo:()=>J,zr:()=>P});var me=x(3038);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function j(g){const M=typeof g;if(M==="number"||M==="string"){const G=parseFloat(""+g);if(!Number.isNaN(G))return G}throw new Error(`Expected floating-point number, but received: ${JSON.stringify(g)}.`)}function J(g){const M=j(g);if(Number.isFinite(M))return M;throw new Error(`Expected finite floating-point number, but received: ${M}.`)}function be(g){const M=j(g);if(Number.isFinite(M)&&M>=0)return M;throw new Error(`Expected finite non-negative floating-point number, but received: ${M}.`)}function ae(g){const M=J(g);if(M>0)return M;throw new Error(`Expected positive finite floating-point number, but received: ${M}.`)}function ye(g,M){return G=>{const K=j(G);if(K>=g&&K<=M)return K;throw new Error(`Expected floating-point number in range [${g}, ${M}], but received: ${K}.`)}}function Me(g,M,G=j){Ae(M),g[0]=g[1]=g[2]=0;for(const K of Object.keys(M))switch(K){case"x":g[0]=G(M[K]);break;case"y":g[1]=G(M[K]);break;case"z":g[2]=G(M[K]);break;default:throw new Error(`Expected object to have keys ['x', 'y', 'z'], but received: ${JSON.stringify(M)}.`)}return g}function Ee(g,M){const G=g.length;if(!Array.isArray(M)||M.length!==G)throw new Error("Incompatible sizes");for(let K=0;K<G;++K)if(!Number.isFinite(parseFloat(M[K])))throw new Error("Non-finite value.");for(let K=0;K<G;++K)g[K]=parseFloat(M[K]);return g}function re(g,M){const G=g.length;if(!Array.isArray(M)||M.length!==G)throw new Error("Incompatible sizes.");for(let K=0;K<G;++K){const de=parseInt(M[K],void 0);if(!Number.isInteger(de))throw new Error("Non-integer value.")}for(let K=0;K<G;++K)g[K]=parseInt(M[K],void 0);return g}function ue(g){if(typeof g=="object"){if(g===null)return"null";if(Array.isArray(g)){let fe="[";const Ve=g.length;let Ge=0;if(Ge<Ve)for(fe+=ue(g[Ge]);++Ge<Ve;)fe+=",",fe+=ue(g[Ge]);return fe+="]",fe}let M="{";const G=Object.keys(g).sort();let K=0;const de=G.length;if(K<de){let fe=G[K];for(M+=JSON.stringify(fe),M+=":",M+=ue(g[fe]);++K<de;)M+=",",fe=G[K],M+=JSON.stringify(fe),M+=":",M+=ue(g[fe])}return M+="}",M}return JSON.stringify(g)}function Q(g){return g.replace(/['"]/g,M=>M==='"'?"'":'"')}function ze(g){return Q(JSON.stringify(Q(g)))}const Ke="_";function Je(g){if(typeof g=="object"){if(g===null)return"null";const M=g.toJSON;if(typeof M=="function")return Je(M.call(g));if(Array.isArray(g)){let fe="[";const Ve=g.length;let Ge=0;if(Ge<Ve)for(fe+=Je(g[Ge]);++Ge<Ve;)fe+=Ke,fe+=Je(g[Ge]);return fe+="]",fe}let G="{";const K=Object.keys(g);let de=!0;for(const fe of K){const Ve=g[fe];if(Ve===void 0)continue;const Ge=Je(Ve);Ge&&(de?de=!1:G+=Ke,G+=ze(fe),G+=":",G+=Ge)}return G+="}",G}return typeof g=="string"?ze(g):JSON.stringify(g)}const et=/('(?:[^'\\]|(?:\\.))*')/,De=/("(?:[^"\\]|(?:\\.))*")/,ke=new RegExp(`${et.source}|${De.source}`),U=new RegExp(`${De.source}|${et.source}`),W=/^((?:[^"'\\]|(?:\\[^']))*)("|\\')/,X=/^((?:[^"'\\]|(?:\\.))*)'/;function O(g,M,G,K){if(g.length>=2&&g.charAt(0)===M&&g.charAt(g.length-1)===M){let de=g.substr(1,g.length-2),fe=G;for(;de.length>0;){const Ve=de.match(K);if(Ve===null){fe+=de;break}fe+=Ve[1],Ve[2]===G?(fe+="\\",fe+=G):fe+=M,de=de.substr(Ve.index+Ve[0].length)}return fe+=G,fe}return g}function F(g){return O(g,"'",'"',W)}function oe(g,M,G){const K=/[&_,]/g;let de,fe,Ve;G==='"'?(de="'",fe=W,Ve=ke):(de='"',fe=X,Ve=U);let Ge="";for(;g.length>0;){const Qe=g.match(Ve);let xt,Jt;if(Qe===null)xt=g,g="",Jt="";else{xt=g.substr(0,Qe.index),g=g.substr(Qe.index+Qe[0].length);const dn=Qe[1];dn!==void 0?Jt=O(dn,de,G,fe):Jt=Qe[2]}Ge+=xt.replace(K,M),Ge+=Jt}return Ge}function z(g){return oe(g,",",'"')}function D(g){return oe(g,"_","'")}function q(g){return JSON.parse(z(g))}function $(g){let M="";for(;g.length>0;){const G=g.match(ke);let K,de;if(G===null)K=g,g="",de="";else{K=g.substr(0,G.index),g=g.substr(G.index+G[0].length);const fe=G[1];fe!==void 0?de=F(fe):de=G[2]}M+=K.replace(/\(/g,"[").replace(/\)/g,"]").replace("True","true").replace("False","false").replace(/,\s*([}\]])/g,"$1"),M+=de}return M}function _(g){return JSON.parse($(g))}function Te(g,M){if(!Array.isArray(g))throw new Error(`Expected array, but received: ${JSON.stringify(g)}.`);if(M!==void 0&&g.length!==M)throw new Error(`Expected array of length ${M}, but received: ${JSON.stringify(g)}.`);return g}function se(g,M){if(!Array.isArray(g))throw new Error(`Expected array, but received: ${JSON.stringify(g)}.`);return g.map(M)}function Xe(g,M,G){const K=g.length;if(!Array.isArray(M)||M.length!==K)throw new Error(`Expected length ${K} array, but received: ${JSON.stringify(M)}.`);for(let de=0;de<K;++de)g[de]=G(M[de],de);return g}function Ae(g){if(typeof g!="object"||g==null||Array.isArray(g))throw new Error(`Expected JSON object, but received: ${JSON.stringify(g)}.`);return g}function Le(g){const M=parseInt(g,10);if(!Number.isInteger(M))throw new Error(`Expected integer, but received: ${JSON.stringify(g)}.`);return M}function ut(g){const M=Le(g);if(M<=0)throw new Error(`Expected positive integer, but received: ${M}.`);return M}function Ze(g){const M=Le(g);if(M<0)throw new Error(`Expected non-negative integer, but received: ${M}.`);return M}function ds(g,M){const G=M.get(g);if(G===void 0)throw new Error(`Expected one of ${JSON.stringify(Array.from(M.keys()))}, but received: ${JSON.stringify(g)}.`);return G}function P(g){if(typeof g!="string")throw new Error(`Expected string, but received: ${JSON.stringify(g)}.`);return g}function B(g){if(g!==void 0)return P(g)}function ne(g){if(g!==void 0)return Le(g)}function Z(g){if(g!==void 0){if(typeof g=="boolean")return g;if(g==="true")return!0;if(g==="false")return!1;throw new Error(`Expected string or boolean but received: ${JSON.stringify(g)}`)}}function ce(g,M){return g===void 0?M:g}function ie(g,M,G){const K=Object.prototype.hasOwnProperty.call(g,M)?g[M]:void 0;try{return G(K)}catch(de){throw new Error(`Error parsing ${JSON.stringify(M)} property: ${de.message}`)}}function he(g,M,G,K){return ie(g,M,de=>de===void 0?K:G(de))}function Pe(g,M){Ae(g);const G=new Map;for(const K of Object.keys(g))try{G.set(K,M(g[K]))}catch(de){throw new Error(`Error parsing value associated with key ${JSON.stringify(K)}: ${de.message}`)}return G}function Oe(g){if(typeof g!="number"||!Number.isFinite(g)||g<0||g>1)throw new Error(`Expected floating point number in [0,1], but received: ${JSON.stringify(g)}.`);return g}function Ne(g){if(g==="")return{};if(g.startsWith("{"))return q(g);const M={},G=g.split(/[&;]/);for(const K of G){const de=K.match(/^([^=&;]+)=([^&;]*)$/);if(de===null)throw new Error(`Invalid query string part: ${JSON.stringify(K)}.`);M[de[1]]=decodeURIComponent(de[2])}return M}function Ue(g){if(g===void 0)return"";const M=Object.keys(g);return M.length===0?"":M.some(G=>typeof g[G]!="string")?JSON.stringify(g):M.map(G=>`${encodeURIComponent(G)}=${encodeURIComponent(g[G])}`).join("&")}function qe(g,M,G=/^[a-zA-Z]/){if(typeof g=="string"&&g.match(G)!==null){const K=g.toUpperCase();if(Object.prototype.hasOwnProperty.call(M,K))return M[K]}throw new Error(`Invalid enum value: ${JSON.stringify(g)}.`)}function bt(g){return Xe(vec3.create(),g,J)}function ot(g){return Xe(vec3.create(),g,ae)}function ve(g){return Xe(vec3.create(),g,ut)}function jt(g){if(!Array.isArray(g))throw new Error(`Expected array, received: ${JSON.stringify(g)}.`);for(const M of g)if(typeof M!="string")throw new Error(`Expected string, received: ${JSON.stringify(M)}.`);return g}function Yt(g){if(!Array.isArray(g))throw new Error(`Expected array, received: ${JSON.stringify(g)}.`);for(const M of g)if(!Number.isInteger(M))throw new Error(`Expected integer, received: ${JSON.stringify(M)}.`);return g}function at(g){if(!Array.isArray(g))throw new Error(`Expected array, received: ${JSON.stringify(g)}.`);for(const M of g)j(M);return g}function dt(g){if(typeof g!="boolean")throw new Error(`Expected boolean, received: ${JSON.stringify(g)}`);return g}function ln(g){for(const M in g)return g}function un(g,M){if(g!==M)throw new Error(`Expected ${JSON.stringify(M)}, but received: ${JSON.stringify(g)}`);return M}function _e(g,M){if(g===void 0){const G=new Array(M);return G.fill(null),G}return Xe(new Array(M),g,G=>{if(G!==null&&typeof G!="string")throw new Error(`Expected string or null, but received: ${JSON.stringify(name)}`);return G})}},147:(te,Se,x)=>{x.d(Se,{DA:()=>J,DI:()=>Q});/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function me(U,W,X,O,F,oe,z,D,q){for(let $=0;$<z;++$)for(let _=0;_<q;++_){let Te=0;for(let se=0;se<D;++se)Te+=X[$+O*se]*F[se+oe*_];U[$+W*_]=Te}return U}function j(U,W,X){for(let O=0;O<X;++O){const F=W*O;U.fill(0,F,F+X),U[F+O]=1}return U}function J(U,W,X=W){return j(new U(W*X),W,Math.min(W,X))}function be(U,W,X=!0){const O=W.length,F=X?O+1:O,oe=new U(F*(O+1));X&&(oe[oe.length-1]=1);for(let z=0;z<O;++z)oe[(F+1)*z]=W[z];return oe}function ae(U,W,X=!0){const O=W.length,F=X?O+1:O,oe=J(U,F,O+1);for(let z=0;z<O;++z)oe[F*O+z]=W[z];return oe}function ye(U,W,X){for(let O=0;O<X;++O)for(let F=0;F<X;++F)if(U[O*W+F]!==(O===F?1:0))return!1;return!0}function Me(U,W,X,O,F,oe){for(let z=0;z<oe;++z){const D=z*O,q=z*W;for(let $=0;$<F;++$)U[q+$]=X[D+$]}return U}function Ee(U,W,X,O){Me(U,W+1,X,O+1,O,O);for(let F=0;F<O;++F)U[(W+1)*W+F]=X[(O+1)*O+F];U[U.length-1]=1;for(let F=O;F<W;++F)U[(W+1)*F+F]=1;return U}let re;function ue(U,W,X){let O=1;(re===void 0||re.length<X)&&(re=new Uint32Array(X));for(let F=0;F<X;++F)re[F]=F;for(let F=0;F<X;++F){const oe=W*F;let z=F;{let $=Math.abs(U[oe+F]);for(let _=F+1;_<X;++_){const Te=Math.abs(U[oe+_]);Te>$&&($=Te,z=_)}}if(F!==z){O*=-1;for(let $=0;$<X;++$){const _=W*$,Te=U[_+F];U[_+F]=U[_+z],U[_+z]=Te}{const $=re[F];re[F]=re[z],re[z]=$}}const D=U[oe+F],q=1/D;O*=D;for(let $=0;$<X;++$)U[W*$+F]*=q;U[oe+F]=q;for(let $=0;$<X;++$){if($===F)continue;const _=-U[W*F+$];for(let Te=0;Te<X;++Te){const se=W*Te;U[se+$]+=_*U[se+F]}U[W*F+$]=_*q}}for(let F=0;F<X;++F){let oe=re[F];for(;oe!==F;){const z=W*F,D=W*oe;for(let $=0;$<X;++$){const _=z+$,Te=D+$,se=U[_];U[_]=U[Te],U[Te]=se}const q=re[F]=re[oe];re[oe]=oe,oe=q}}return O}function Q(U,W,X,O,F){return Me(U,W,X,O,F,F),ue(U,W,F)}function ze(U,W,X,O,F,oe){for(let z=0;z<oe;++z){const D=W*z,q=O*z;for(let $=0;$<F;++$)if(U[D+$]!==X[q+$])return!1}return!0}function Ke(U,W,X,O,F,oe){for(let z=0;z<F;++z)for(let D=0;D<oe;++D)U[D+z*W]=X[z+D*O];return U}function Je(U,W,X,O,F){for(let oe=0;oe<F;++oe){let z=W[X*F+oe];for(let D=0;D<F;++D)z+=W[X*D+oe]*O[D];U[oe]=z}return U}function et(U,W,X,O,F){for(let oe=0;oe<F;++oe){let z=0;for(let D=0;D<F;++D)z+=W[X*D+oe]*O[D];U[oe]=z}return U}function De(U,W,X,O,F,oe){const z=F.length;for(let D=0;D<z;++D){const q=F[D];for(let $=0;$<oe;++$)U[$*W+D]=X[$*O+q]}return U}function ke(U,W,X,O,F,oe){const z=F.length;for(let D=0;D<z;++D){const q=F[D];for(let $=0;$<oe;++$)U[D*W+$]=X[q*O+$]}return U}},4038:(te,Se,x)=>{x.d(Se,{HN:()=>me,IY:()=>J});/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class me{constructor(){this.handlers=new Set,this.count=0;const ye=this;this.dispatch=function(){++ye.count,ye.handlers.forEach(Me=>{Me.apply(this,arguments)})}}add(ye){return this.handlers.add(ye),()=>this.remove(ye)}remove(ye){return this.handlers.delete(ye)}dispose(){this.handlers=void 0}}function j(ae,...ye){ae();for(let Me=0,Ee=ye.length;Me<Ee;++Me)ye[Me].add(ae);return()=>{for(let Me=0,Ee=ye.length;Me<Ee;++Me)ye[Me].remove(ae)}}class J extends me{}const be={count:0,add(ae){return()=>{}},remove(ae){return!1}}},8867:(te,Se,x)=>{te.exports=x.p+"neuroglancer_draco.ac67ec8d0d9050f8881d.wasm"},6499:(te,Se,x)=>{var me=x(3206),j=x(4509),J=x(2596);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const be=!(typeof Window<"u"&&self instanceof Window),ae=!1,ye=!1,Me="rpc.promise.response",Ee="rpc.promise.cancel",re="rpc.ready",ue=new Map;function Q(t,e){ue.set(t,e)}class ze extends Error{constructor(e,n){super(n),this.name=e,this.message=n}}function Ke(t,e){Q(t,function(n){const s=n.id,i=new j.Qi,r=e.call(this,n,i);this.set(s,{promise:r,cancellationToken:i}),r.then(({value:o,transfers:a})=>{this.delete(s),this.invoke(Me,{id:s,value:o},a)},o=>{this.delete(s),this.invoke(Me,{id:s,error:o.message,errorName:o.name})})})}Q(Ee,function(t){const e=t.id,n=this.get(e);if(n!==void 0){const{cancellationToken:s}=n;s.cancel()}}),Q(Me,function(t){const e=t.id,{resolve:n,reject:s}=this.get(e);this.delete(e),Object.prototype.hasOwnProperty.call(t,"value")?n(t.value):t.errorName===j.wS.name?s(j.wS):s(new ze(t.errorName,t.error))}),Q(re,function(t){this.onPeerReady()});const Je=be?-1:0;class et{constructor(e,n){this.target=e,this.objects=new Map,this.nextId=Je,n&&(this.queue=[]),e.onmessage=s=>{const i=s.data;ye&&console.log("Received message",i),ue.get(i.functionName).call(this,i)}}sendReady(){this.invoke(re,{})}onPeerReady(){const{queue:e}=this;if(e!==void 0){this.queue=void 0;for(const{data:n,transfers:s}of e)this.target.postMessage(n,s)}}get numObjects(){return this.objects.size}set(e,n){this.objects.set(e,n)}delete(e){this.objects.delete(e)}get(e){return this.objects.get(e)}getRef(e){const n=e.id,s=this.get(n);return s.referencedGeneration=e.gen,s.addRef(),s}getOptionalRef(e){if(e===void 0)return;const n=e.id,s=this.get(n);return s.referencedGeneration=e.gen,s.addRef(),s}invoke(e,n,s){n.functionName=e,ye&&console.trace("Sending message",n);const{queue:i}=this;if(i!==void 0){i.push({data:n,transfers:s});return}this.target.postMessage(n,s)}promiseInvoke(e,n,s=j.fx,i){return(0,j.gI)(s,(r,o,a)=>{const c=n.id=this.newId();this.set(c,{resolve:r,reject:o}),this.invoke(e,n,i),a.add(()=>{this.invoke(Ee,{id:c})})})}newId(){return be?this.nextId--:this.nextId++}}class De extends J.O8{constructor(){super(...arguments),this.rpc=null,this.rpcId=null}initializeSharedObject(e,n=e.newId()){this.rpc=e,this.rpcId=n,this.isOwner=!1,e.set(n,this)}initializeCounterpart(e,n={}){this.initializeSharedObject(e),this.unreferencedGeneration=0,this.referencedGeneration=0,this.isOwner=!0,n.id=this.rpcId,n.type=this.RPC_TYPE_ID,e.invoke("SharedObject.new",n)}dispose(){super.dispose()}addCounterpartRef(){return{id:this.rpcId,gen:++this.referencedGeneration}}refCountReachedZero(){this.isOwner===!0?this.referencedGeneration===this.unreferencedGeneration&&this.ownerDispose():this.isOwner===!1?this.rpc.invoke("SharedObject.refCountReachedZero",{id:this.rpcId,gen:this.referencedGeneration}):super.refCountReachedZero()}ownerDispose(){ae&&console.log(`[${be}] #rpc object = ${this.rpc.numObjects}`);const{rpc:e,rpcId:n}=this;super.refCountReachedZero(),e.delete(n),e.invoke("SharedObject.dispose",{id:n})}counterpartRefCountReachedZero(e){this.unreferencedGeneration=e,this.refCount===0&&e===this.referencedGeneration&&this.ownerDispose()}}function ke(t,e,n={}){e!=null&&t.initializeSharedObject(e,n.id)}class U extends De{constructor(e,n={}){super(),ke(this,e,n)}}Q("SharedObject.dispose",function(t){const e=this.get(t.id);if(e.refCount!==0)throw new Error("Attempted to dispose object with non-zero reference count.");ae&&console.log(`[${be}] #rpc objects: ${this.numObjects}`),e.disposed(),this.delete(e.rpcId),e.rpcId=null,e.rpc=null}),Q("SharedObject.refCountReachedZero",function(t){const e=this.get(t.id),n=t.gen;e.counterpartRefCountReachedZero(n)});const W=new Map;function X(t){return e=>{e.prototype.RPC_TYPE_ID=t}}function O(t){return e=>{if(t!==void 0)e.prototype.RPC_TYPE_ID=t;else if(t=e.prototype.RPC_TYPE_ID,t===void 0)throw new Error("RPC_TYPE_ID should have already been defined");W.set(t,e)}}Q("SharedObject.new",function(t){const e=this,n=t.type,s=W.get(n),i=new s(e,t);--i.refCount});var F=Object.defineProperty,oe=Object.getOwnPropertyDescriptor,z=(t,e,n,s)=>{for(var i=s>1?void 0:s?oe(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&F(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const D="SharedWatchableValue.changed";let q=class extends U{constructor(t,e={}){super(t,e),this.updatingValue_=!1,t!==void 0&&(this.base=new me.B0(e.value),this.setupChangedHandler())}initializeCounterpart(t,e={}){e.value=this.value,super.initializeCounterpart(t,e)}setupChangedHandler(){this.registerDisposer(this.base.changed.add(()=>{if(this.updatingValue_)this.updatingValue_=!1;else{const{rpc:t}=this;t!==null&&t.invoke(D,{id:this.rpcId,value:this.value})}}))}static makeFromExisting(t,e){const n=new q;return n.base=e,n.setupChangedHandler(),n.initializeCounterpart(t),n}static make(t,e){return q.makeFromExisting(t,new me.B0(e))}get value(){return this.base.value}set value(t){this.base.value=t}get changed(){return this.base.changed}};q=z([O("SharedWatchableValue")],q),Q(D,function(t){const e=this.get(t.id);e.updatingValue_=!0,e.base.value=t.value,e.updatingValue_=!1});var $=x(4022);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var _=(t=>(t[t.GPU_MEMORY=0]="GPU_MEMORY",t[t.SYSTEM_MEMORY=1]="SYSTEM_MEMORY",t[t.SYSTEM_MEMORY_WORKER=2]="SYSTEM_MEMORY_WORKER",t[t.DOWNLOADING=3]="DOWNLOADING",t[t.QUEUED=4]="QUEUED",t[t.NEW=5]="NEW",t[t.FAILED=6]="FAILED",t[t.EXPIRED=7]="EXPIRED",t))(_||{});const Te=8;var se=(t=>(t[t.FIRST_TIER=0]="FIRST_TIER",t[t.FIRST_ORDERED_TIER=0]="FIRST_ORDERED_TIER",t[t.VISIBLE=0]="VISIBLE",t[t.PREFETCH=1]="PREFETCH",t[t.LAST_ORDERED_TIER=1]="LAST_ORDERED_TIER",t[t.RECENT=2]="RECENT",t[t.LAST_TIER=2]="LAST_TIER",t))(se||{});const Xe=3;var Ae=(t=>(t[t.totalTime=0]="totalTime",t[t.totalChunks=1]="totalChunks",t))(Ae||{}),Le=(t=>(t[t.numChunks=0]="numChunks",t[t.systemMemoryBytes=1]="systemMemoryBytes",t[t.gpuMemoryBytes=2]="gpuMemoryBytes",t))(Le||{});const ut=3,ds=Te*Xe*ut+2;function P(t,e){return t*Xe+e}function B(t){return Te*Xe*ut+t}const ne=1e13,Z="ChunkQueueManager",ce="ChunkManager",ie="ChunkSource.invalidate",he="ChunkQueueManager.requestChunkStatistics",Pe="ChunkManager.chunkLayerStatistics";class Oe{constructor(){this.numVisibleChunksNeeded=0,this.numVisibleChunksAvailable=0,this.numPrefetchChunksNeeded=0,this.numPrefetchChunksAvailable=0}}var Ne=x(4472);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Ue=class{static insertAfter(t,e){const n=t.next1;e.next1=n,e.prev1=t,t.next1=e,n.prev1=e}static insertBefore(t,e){const n=t.prev1;e.prev1=n,e.next1=t,t.prev1=e,n.next1=e}static front(t){const e=t.next1;return e===t?null:e}static back(t){const e=t.prev1;return e===t?null:e}static pop(t){const e=t.next1,n=t.prev1;return e.prev1=n,n.next1=e,t.next1=null,t.prev1=null,t}static*iterator(t){for(let e=t.next1;e!==t;e=e.next1)yield e}static*reverseIterator(t){for(let e=t.prev1;e!==t;e=e.prev1)yield e}static initializeHead(t){t.next1=t.prev1=t}};var qe=x(4704);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class bt{constructor(e){this.compare=e}meld(e,n){if(n===null)return e;if(e===null)return n;const{compare:s}=this;if(s(n,e)){const r=e;e=n,n=r}const i=e.child0;return n.next0=i,n.prev0=e,i!==null&&(i.prev0=n),e.child0=n,e}combineChildren(e){let n=e.child0;if(n===null)return null;let s=null;for(;;){const r=n.next0;let o,a;if(r===null?(o=null,a=n):(o=r.next0,a=this.meld(n,r)),a.next0=s,s=a,o===null)break;n=o}let i=s;for(s=s.next0;s!==null;){const r=s.next0;i=this.meld(i,s),s=r}return i.prev0=null,i.next0=null,i}removeMin(e){const n=this.combineChildren(e);return e.next0=null,e.prev0=null,e.child0=null,n}remove(e,n){if(e===n)return this.removeMin(e);const s=n.prev0,i=n.next0;s.child0===n?s.child0=i:s.next0=i,i!==null&&(i.prev0=s);const r=this.meld(e,this.combineChildren(n));return n.next0=null,n.prev0=null,n.child0=null,r}*entries(e){if(e!==null){let n=e.child0;for(yield e;n!==null;){const s=n.next0;yield*this.entries(n),n=s}}}*removedEntries(e){if(e!==null){let n=e.child0;for(e.child0=null,e.next0=null,e.prev0=null,yield e;n!==null;){const s=n.next0;n.child0=null,n.next0=null,n.prev0=null,yield*this.entries(n),n=s}}}}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ot{constructor(e){this.compare=e}meld(e,n){if(n===null)return e;if(e===null)return n;const{compare:s}=this;if(s(n,e)){const r=e;e=n,n=r}const i=e.child1;return n.next1=i,n.prev1=e,i!==null&&(i.prev1=n),e.child1=n,e}combineChildren(e){let n=e.child1;if(n===null)return null;let s=null;for(;;){const r=n.next1;let o,a;if(r===null?(o=null,a=n):(o=r.next1,a=this.meld(n,r)),a.next1=s,s=a,o===null)break;n=o}let i=s;for(s=s.next1;s!==null;){const r=s.next1;i=this.meld(i,s),s=r}return i.prev1=null,i.next1=null,i}removeMin(e){const n=this.combineChildren(e);return e.next1=null,e.prev1=null,e.child1=null,n}remove(e,n){if(e===n)return this.removeMin(e);const s=n.prev1,i=n.next1;s.child1===n?s.child1=i:s.next1=i,i!==null&&(i.prev1=s);const r=this.meld(e,this.combineChildren(n));return n.next1=null,n.prev1=null,n.child1=null,r}*entries(e){if(e!==null){let n=e.child1;for(yield e;n!==null;){const s=n.next1;yield*this.entries(n),n=s}}}*removedEntries(e){if(e!==null){let n=e.child1;for(e.child1=null,e.next1=null,e.prev1=null,yield e;n!==null;){const s=n.next1;n.child1=null,n.next1=null,n.prev1=null,yield*this.entries(n),n=s}}}}var ve=x(4038),jt=Object.defineProperty,Yt=Object.getOwnPropertyDescriptor,at=(t,e,n,s)=>{for(var i=s>1?void 0:s?Yt(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&jt(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const dt=!1;let ln=0;function un(){return++ln}class _e{constructor(){this.child0=null,this.next0=null,this.prev0=null,this.child1=null,this.next1=null,this.prev1=null,this.source=null,this.key=null,this.state_=_.NEW,this.error=null,this.markGeneration=-1,this.priority=0,this.newPriority=0,this.priorityTier=se.RECENT,this.newPriorityTier=se.RECENT,this.systemMemoryBytes_=0,this.gpuMemoryBytes_=0,this.downloadSlots_=1,this.isComputational=!1,this.requestedState=_.NEW,this.newRequestedState=_.NEW,this.downloadCancellationToken=void 0}initialize(e){this.key=e,this.priority=Number.NEGATIVE_INFINITY,this.priorityTier=se.RECENT,this.newPriority=Number.NEGATIVE_INFINITY,this.newPriorityTier=se.RECENT,this.error=null,this.state=_.NEW,this.requestedState=_.NEW,this.newRequestedState=_.NEW}updatePriorityProperties(){this.priorityTier=this.newPriorityTier,this.priority=this.newPriority,this.newPriorityTier=se.RECENT,this.newPriority=Number.NEGATIVE_INFINITY,this.requestedState=this.newRequestedState,this.newRequestedState=_.NEW}dispose(){this.source=null,this.error=null}get chunkManager(){return this.source.chunkManager}get queueManager(){return this.source.chunkManager.queueManager}downloadFailed(e){this.error=e,this.queueManager.updateChunkState(this,_.FAILED)}downloadSucceeded(){this.requestedState===_.SYSTEM_MEMORY?(this.queueManager.moveChunkToFrontend(this),this.queueManager.updateChunkState(this,_.SYSTEM_MEMORY)):this.queueManager.updateChunkState(this,_.SYSTEM_MEMORY_WORKER)}freeSystemMemory(){}serialize(e,n){e.id=this.key,e.source=this.source.rpcId,e.new=!0}toString(){return this.key}set state(e){if(e===this.state_)return;const n=this.state_;this.state_=e,this.source.chunkStateChanged(this,n)}get state(){return this.state_}set systemMemoryBytes(e){G(this,-1),this.chunkManager.queueManager.adjustCapacitiesForChunk(this,!1),this.systemMemoryBytes_=e,this.chunkManager.queueManager.adjustCapacitiesForChunk(this,!0),G(this,1),this.chunkManager.queueManager.scheduleUpdate()}get systemMemoryBytes(){return this.systemMemoryBytes_}set gpuMemoryBytes(e){G(this,-1),this.chunkManager.queueManager.adjustCapacitiesForChunk(this,!1),this.gpuMemoryBytes_=e,this.chunkManager.queueManager.adjustCapacitiesForChunk(this,!0),G(this,1),this.chunkManager.queueManager.scheduleUpdate()}get gpuMemoryBytes(){return this.gpuMemoryBytes_}get downloadSlots(){return this.downloadSlots_}set downloadSlots(e){e!==this.downloadSlots_&&(G(this,-1),this.chunkManager.queueManager.adjustCapacitiesForChunk(this,!1),this.downloadSlots_=e,this.chunkManager.queueManager.adjustCapacitiesForChunk(this,!0),G(this,1),this.chunkManager.queueManager.scheduleUpdate())}registerListener(e){return this.source?this.source.registerChunkListener(this.key,e):!1}unregisterListener(e){return this.source?this.source.unregisterChunkListener(this.key,e):!1}static priorityLess(e,n){return e.priority<n.priority}static priorityGreater(e,n){return e.priority>n.priority}}const g=2;class M extends De{constructor(e){super(),this.chunkManager=e,this.listeners_=new Map,this.chunks=new Map,this.freeChunks=new Array,this.statistics=new Float64Array(ds),this.sourceQueueLevel=0,e.queueManager.sources.add(this)}disposed(){this.chunkManager.queueManager.sources.delete(this),super.disposed()}getNewChunk_(e){const n=this.freeChunks,s=n.length;if(s>0){const r=n[s-1];return n.length=s-1,r.source=this,r}const i=new e;return i.source=this,i}addChunk(e){const{chunks:n}=this;n.size===0&&this.addRef(),n.set(e.key,e),G(e,1)}removeChunk(e){const{chunks:n,freeChunks:s}=this;n.delete(e.key),e.dispose(),s[s.length]=e,n.size===0&&this.dispose()}registerChunkListener(e,n){return this.listeners_.has(e)?this.listeners_.get(e).push(n):this.listeners_.set(e,[n]),!0}unregisterChunkListener(e,n){if(!this.listeners_.has(e))return!1;const s=this.listeners_.get(e),i=s.indexOf(n);return i<0?!1:(s.splice(i,1),s.length===0&&this.listeners_.delete(e),!0)}chunkStateChanged(e,n){const{key:s}=e;if(s===null)return;const i=this.listeners_.get(s);if(i!==void 0)for(const r of i.slice())r(e,n)}}function G(t,e){const{statistics:n}=t.source,{systemMemoryBytes:s,gpuMemoryBytes:i}=t,r=P(t.state,t.priorityTier);n[r*ut+Le.numChunks]+=e,n[r*ut+Le.systemMemoryBytes]+=e*s,n[r*ut+Le.gpuMemoryBytes]+=e*i}class K extends M{constructor(e,n){const s=e.get(n.chunkManager);super(s),ke(this,e,n)}}function de(t){const e=t.downloadCancellationToken=new j.Qi,n=Date.now();t.source.download(t,e).then(()=>{if(t.downloadCancellationToken===e){t.downloadCancellationToken=void 0;const s=Date.now(),{statistics:i}=t.source;i[B(Ae.totalTime)]+=s-n,++i[B(Ae.totalChunks)],t.downloadSucceeded()}},s=>{t.downloadCancellationToken===e&&(t.downloadCancellationToken=void 0,t.downloadFailed(s),console.log(`Error retrieving chunk ${t}: ${s}`))})}function fe(t){const e=t.downloadCancellationToken;t.downloadCancellationToken=void 0,e.cancel()}class Ve{constructor(e,n){this.heapOperations=e,this.linkedListOperations=n,this.heapRoots=[null,null],this.recentHead=new _e,n.initializeHead(this.recentHead)}add(e){const n=e.priorityTier;if(n===se.RECENT)this.linkedListOperations.insertAfter(this.recentHead,e);else{const{heapRoots:s}=this;s[n]=this.heapOperations.meld(s[n],e)}}*candidates(){if(this.heapOperations.compare===_e.priorityLess){const{linkedListOperations:e,recentHead:n}=this;for(;;){const i=e.back(n);if(i==null)break;yield i}const{heapRoots:s}=this;for(let i=se.LAST_ORDERED_TIER;i>=se.FIRST_ORDERED_TIER;--i)for(;;){const r=s[i];if(r==null)break;yield r}}else{const e=this.heapRoots;for(let i=se.FIRST_ORDERED_TIER;i<=se.LAST_ORDERED_TIER;++i)for(;;){const r=e[i];if(r==null)break;yield r}const{linkedListOperations:n,recentHead:s}=this;for(;;){const i=n.front(s);if(i==null)break;yield i}}}delete(e){const n=e.priorityTier;if(n===se.RECENT)this.linkedListOperations.pop(e);else{const s=this.heapRoots;s[n]=this.heapOperations.remove(s[n],e)}}}function Ge(t){return new Ve(new bt(t),Ne.A)}function Qe(t){return new Ve(new ot(t),Ue)}function xt(t,e,n,s,i,r){for(;e.availableItems<1||e.availableSize<t;){const o=i.next().value;if(o===void 0)return!1;const a=o.priorityTier;if(a<n||a===n&&o.priority>=s)return!1;r(o)}return!0}class Jt extends J.O8{constructor(e,n){super(),this.itemLimit=e,this.sizeLimit=n,this.currentSize=0,this.currentItems=0,this.capacityChanged=new ve.IY,this.registerDisposer(e.changed.add(this.capacityChanged.dispatch)),this.registerDisposer(n.changed.add(this.capacityChanged.dispatch))}adjust(e,n){this.currentItems-=e,this.currentSize-=n}get availableSize(){return this.sizeLimit.value-this.currentSize}get availableItems(){return this.itemLimit.value-this.currentItems}toString(){return`bytes=${this.currentSize}/${this.sizeLimit.value},items=${this.currentItems}/${this.itemLimit.value}`}}let dn=class extends U{constructor(t,e){super(t,e),this.sources=new Set,this.queuedDownloadPromotionQueue=[Qe(_e.priorityGreater),Qe(_e.priorityGreater)],this.queuedComputePromotionQueue=Qe(_e.priorityGreater),this.downloadEvictionQueue=[Qe(_e.priorityLess),Qe(_e.priorityLess)],this.computeEvictionQueue=Qe(_e.priorityLess),this.systemMemoryEvictionQueue=Ge(_e.priorityLess),this.gpuMemoryPromotionQueue=Qe(_e.priorityGreater),this.gpuMemoryEvictionQueue=Qe(_e.priorityLess),this.updatePending=null,this.gpuMemoryChanged=new ve.IY,this.numQueued=0,this.numFailed=0,this.gpuMemoryGeneration=0;const n=s=>{const i=this.registerDisposer(new Jt(t.get(s.itemLimit),t.get(s.sizeLimit)));return i.capacityChanged.add(()=>this.scheduleUpdate()),i};this.gpuMemoryCapacity=n(e.gpuMemoryCapacity),this.systemMemoryCapacity=n(e.systemMemoryCapacity),this.enablePrefetch=t.get(e.enablePrefetch),this.downloadCapacity=[n(e.downloadCapacity),n(e.downloadCapacity)],this.computeCapacity=n(e.computeCapacity)}scheduleUpdate(){this.updatePending===null&&(this.updatePending=setTimeout(this.process.bind(this),0))}*chunkQueuesForChunk(t){switch(t.state){case _.QUEUED:t.isComputational?yield this.queuedComputePromotionQueue:yield this.queuedDownloadPromotionQueue[t.source.sourceQueueLevel];break;case _.DOWNLOADING:t.isComputational?yield this.computeEvictionQueue:(yield this.downloadEvictionQueue[t.source.sourceQueueLevel],yield this.systemMemoryEvictionQueue);break;case _.SYSTEM_MEMORY_WORKER:case _.SYSTEM_MEMORY:yield this.systemMemoryEvictionQueue,t.requestedState===_.GPU_MEMORY&&(yield this.gpuMemoryPromotionQueue);break;case _.GPU_MEMORY:yield this.systemMemoryEvictionQueue,yield this.gpuMemoryEvictionQueue;break}}adjustCapacitiesForChunk(t,e){const n=e?-1:1;switch(t.state){case _.FAILED:this.numFailed-=n;break;case _.QUEUED:this.numQueued-=n;break;case _.DOWNLOADING:(t.isComputational?this.computeCapacity:this.downloadCapacity[t.source.sourceQueueLevel]).adjust(n*t.downloadSlots,n*t.systemMemoryBytes),this.systemMemoryCapacity.adjust(n,n*t.systemMemoryBytes);break;case _.SYSTEM_MEMORY:case _.SYSTEM_MEMORY_WORKER:this.systemMemoryCapacity.adjust(n,n*t.systemMemoryBytes);break;case _.GPU_MEMORY:this.systemMemoryCapacity.adjust(n,n*t.systemMemoryBytes),this.gpuMemoryCapacity.adjust(n,n*t.gpuMemoryBytes);break}}removeChunkFromQueues_(t){G(t,-1);for(const e of this.chunkQueuesForChunk(t))e.delete(t)}addChunkToQueues_(t){if(t.state===_.QUEUED&&t.priorityTier===se.RECENT){const{source:e}=t;return e.removeChunk(t),this.adjustCapacitiesForChunk(t,!1),!1}G(t,1);for(const e of this.chunkQueuesForChunk(t))e.add(t);return!0}performChunkPriorityUpdate(t){if(t.priorityTier===t.newPriorityTier&&t.priority===t.newPriority){t.newPriorityTier=se.RECENT,t.newPriority=Number.NEGATIVE_INFINITY;return}dt&&console.log(`${t}: changed priority ${t.priorityTier}:${t.priority} -> ${t.newPriorityTier}:${t.newPriority}`),this.removeChunkFromQueues_(t),t.updatePriorityProperties(),t.state===_.NEW&&(t.state=_.QUEUED,this.adjustCapacitiesForChunk(t,!0)),this.addChunkToQueues_(t)}updateChunkState(t,e){e!==t.state&&(dt&&console.log(`${t}: changed state ${_[t.state]} -> ${_[e]}`),this.adjustCapacitiesForChunk(t,!1),this.removeChunkFromQueues_(t),t.state=e,this.adjustCapacitiesForChunk(t,!0),this.addChunkToQueues_(t),this.scheduleUpdate())}processGPUPromotions_(){const t=this;function e(r){t.freeChunkGPUMemory(r),r.source.chunkManager.queueManager.updateChunkState(r,_.SYSTEM_MEMORY)}const n=this.gpuMemoryPromotionQueue.candidates(),s=this.gpuMemoryEvictionQueue.candidates(),i=this.gpuMemoryCapacity;for(;;){const r=n.next().value;if(r===void 0)break;const o=r.priorityTier,a=r.priority;if(!xt(r.gpuMemoryBytes,i,o,a,s,e))break;this.copyChunkToGPU(r),this.updateChunkState(r,_.GPU_MEMORY)}}freeChunkGPUMemory(t){++this.gpuMemoryGeneration,this.rpc.invoke("Chunk.update",{id:t.key,state:_.SYSTEM_MEMORY,source:t.source.rpcId})}freeChunkSystemMemory(t){t.state===_.SYSTEM_MEMORY_WORKER?t.freeSystemMemory():this.rpc.invoke("Chunk.update",{id:t.key,state:_.EXPIRED,source:t.source.rpcId})}retrieveChunkData(t){return this.rpc.promiseInvoke("Chunk.retrieve",{key:t.key,source:t.source.rpcId})}copyChunkToGPU(t){++this.gpuMemoryGeneration;const e=this.rpc;if(t.state===_.SYSTEM_MEMORY)e.invoke("Chunk.update",{id:t.key,source:t.source.rpcId,state:_.GPU_MEMORY});else{const n={},s=[];t.serialize(n,s),n.state=_.GPU_MEMORY,e.invoke("Chunk.update",n,s)}}moveChunkToFrontend(t){const e=this.rpc,n={},s=[];t.serialize(n,s),n.state=_.SYSTEM_MEMORY,e.invoke("Chunk.update",n,s)}processQueuePromotions_(){const t=n=>{switch(n.state){case _.DOWNLOADING:fe(n);break;case _.GPU_MEMORY:this.freeChunkGPUMemory(n);case _.SYSTEM_MEMORY_WORKER:case _.SYSTEM_MEMORY:this.freeChunkSystemMemory(n);break}this.updateChunkState(n,_.QUEUED)},e=(n,s,i)=>{const r=this.systemMemoryEvictionQueue.candidates(),o=this.systemMemoryCapacity;for(;;){const a=n.next();if(a.done)return;const c=a.value,l=0,u=c.priorityTier,d=c.priority;if(!xt(l,i,u,d,s,t)||!xt(l,o,u,d,r,t))return;this.updateChunkState(c,_.DOWNLOADING),de(c)}};for(let n=0;n<g;++n)e(this.queuedDownloadPromotionQueue[n].candidates(),this.downloadEvictionQueue[n].candidates(),this.downloadCapacity[n]);e(this.queuedComputePromotionQueue.candidates(),this.computeEvictionQueue.candidates(),this.computeCapacity)}process(){if(!this.updatePending)return;this.updatePending=null;const t=this.gpuMemoryGeneration;this.processGPUPromotions_(),this.processQueuePromotions_(),this.logStatistics(),this.gpuMemoryGeneration!==t&&this.gpuMemoryChanged.dispatch()}logStatistics(){dt&&console.log(`[Chunk status] QUEUED: ${this.numQueued}, FAILED: ${this.numFailed}, DOWNLOAD: ${this.downloadCapacity}, MEM: ${this.systemMemoryCapacity}, GPU: ${this.gpuMemoryCapacity}`)}invalidateSourceCache(t){for(const e of t.chunks.values()){switch(e.state){case _.DOWNLOADING:fe(e);break;case _.SYSTEM_MEMORY_WORKER:e.freeSystemMemory();break}this.updateChunkState(e,_.QUEUED)}this.rpc.invoke("Chunk.update",{source:t.rpcId}),this.scheduleUpdate()}};dn=at([O(Z)],dn);class hs extends U{constructor(){super(...arguments),this.chunkManagerGeneration=-1,this.numVisibleChunksNeeded=0,this.numVisibleChunksAvailable=0,this.numPrefetchChunksNeeded=0,this.numPrefetchChunksAvailable=0}}const Ci=200;let Ei=class extends U{constructor(t,e){super(t,e),this.existingTierChunks=[],this.newTierChunks=[],this.updatePending=null,this.recomputeChunkPriorities=new ve.IY,this.recomputeChunkPrioritiesLate=new ve.IY,this.memoize=new qe.e,this.layers=[],this.sendLayerChunkStatistics=this.registerCancellable((0,$.A)(()=>{this.rpc.invoke(Pe,{id:this.rpcId,layers:this.layers.map(n=>({id:n.rpcId,numVisibleChunksAvailable:n.numVisibleChunksAvailable,numVisibleChunksNeeded:n.numVisibleChunksNeeded,numPrefetchChunksAvailable:n.numPrefetchChunksAvailable,numPrefetchChunksNeeded:n.numPrefetchChunksNeeded}))})},Ci)),this.queueManager=t.get(e.chunkQueueManager).addRef(),this.registerDisposer(this.queueManager.gpuMemoryChanged.add(this.registerCancellable((0,$.A)(()=>this.scheduleUpdateChunkPriorities(),Ci,{leading:!1,trailing:!0}))));for(let n=se.FIRST_TIER;n<=se.LAST_TIER;++n)n!==se.RECENT&&(this.existingTierChunks[n]=[])}scheduleUpdateChunkPriorities(){this.updatePending===null&&(this.updatePending=setTimeout(this.recomputeChunkPriorities_.bind(this),0))}registerLayer(t){const e=this.recomputeChunkPriorities.count;t.chunkManagerGeneration!==e&&(t.chunkManagerGeneration=e,this.layers.push(t),t.numVisibleChunksAvailable=0,t.numVisibleChunksNeeded=0,t.numPrefetchChunksAvailable=0,t.numPrefetchChunksNeeded=0)}recomputeChunkPriorities_(){this.updatePending=null,this.layers.length=0,this.recomputeChunkPriorities.dispatch(),this.recomputeChunkPrioritiesLate.dispatch(),this.updateQueueState([se.VISIBLE,se.PREFETCH]),this.sendLayerChunkStatistics()}requestChunk(t,e,n,s=_.GPU_MEMORY){if(Number.isNaN(n))return;if(e===se.RECENT)throw new Error("Not going to request a chunk with the RECENT tier");t.newRequestedState=Math.min(t.newRequestedState,s),t.newPriorityTier===se.RECENT&&this.newTierChunks.push(t);const i=t.newPriorityTier;(e<i||e===i&&n>t.newPriority)&&(t.newPriorityTier=e,t.newPriority=n)}updateQueueState(t){const e=this.existingTierChunks,n=this.queueManager;for(const i of t){const r=e[i];dt&&console.log(`existingTierChunks[${se[i]}].length=${r.length}`);for(const o of r)o.newPriorityTier===se.RECENT&&n.performChunkPriorityUpdate(o);r.length=0}const s=this.newTierChunks;for(const i of s)n.performChunkPriorityUpdate(i),e[i.priorityTier].push(i);dt&&console.log(`updateQueueState: newTierChunks.length = ${s.length}`),s.length=0,this.queueManager.scheduleUpdate()}};Ei=at([O(ce)],Ei);function je(t,e){let n=class extends t{constructor(...s){super(...s);const i=s[1];this.parameters=i.parameters}};return n=at([X(e.RPC_ID)],n),n}function It(t){return class extends t{constructor(...e){super(...e);const n=e[0],s=e[1];this.chunkManager=n.get(s.chunkManager)}}}Q(ie,function(t){const e=this.get(t.id);e.chunkManager.queueManager.invalidateSourceCache(e)}),Ke(he,function(t){const e=this.get(t.queue),n=new Map;for(const s of e.sources)n.set(s.rpcId,s.statistics);return Promise.resolve({value:n})});var Nn=x(3517),oc=Object.defineProperty,ac=Object.getOwnPropertyDescriptor,cc=(t,e,n,s)=>{for(var i=s>1?void 0:s?ac(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&oc(e,n,i),i};/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class lc extends J.O8{constructor(e){super(),this.view=e,this.state=void 0}}class xn extends hs{constructor(){super(...arguments),this.attachments=new Map}attach(e){}}Q(Nn.sC,function(t){const e=this.get(t.view),n=this.get(t.layer),s=new lc(e);n.attachments.set(e,s),n.attach(s)}),Q(Nn.lG,function(t){const e=this.get(t.view),n=this.get(t.layer),s=n.attachments.get(e);n.attachments.delete(e),s.dispose()});let ki=class extends U{constructor(t,e){super(t,e),this.changed=new ve.HN,this.value=e.value,this.oldValue=Object.assign({},this.value)}};ki=cc([O(Nn.Bh)],ki),Q(Nn.kg,function(t){const e=this.get(t.id),{value:n,oldValue:s}=e;Object.assign(s,n),Object.assign(n,t.value),e.changed.dispatch(s,n)});var w=x(3038),k=x(7900);/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const An=[{prefix:"Y",exponent:24,longPrefix:"yotta"},{prefix:"Z",exponent:21,longPrefix:"zetta"},{prefix:"E",exponent:18,longPrefix:"exa"},{prefix:"P",exponent:15,longPrefix:"peta"},{prefix:"T",exponent:12,longPrefix:"tera"},{prefix:"G",exponent:9,longPrefix:"giga"},{prefix:"M",exponent:6,longPrefix:"mega"},{prefix:"k",exponent:3,longPrefix:"kilo"},{prefix:"",exponent:0,longPrefix:""},{prefix:"m",exponent:-3,longPrefix:"milli"},{prefix:"\xB5",exponent:-6,longPrefix:"micro"},{prefix:"n",exponent:-9,longPrefix:"nano"},{prefix:"p",exponent:-12,longPrefix:"pico"},{prefix:"f",exponent:-15,longPrefix:"femto"},{prefix:"a",exponent:-18,longPrefix:"atto"},{prefix:"z",exponent:-21,longPrefix:"zepto"},{prefix:"y",exponent:-24,longPrefix:"yocto"}],Ti=[...An,{prefix:"h",exponent:2,longPrefix:"hecto"},{prefix:"da",exponent:1,longPrefix:"deca"},{prefix:"d",exponent:-1,longPrefix:"deci"},{prefix:"c",exponent:-2,longPrefix:"centi"}],uc=[{prefix:"u",exponent:-6},...Ti],hn=new Map;hn.set("",{unit:"",exponent:0});const dc=new Map;for(const{prefix:t,exponent:e}of uc){dc.set(e,t);for(const n of["m","s","Hz","rad/s"])hn.set(`${t}${n}`,{unit:n,exponent:e})}function hc(t){const e=Math.log10(t),n=An.length,s=binarySearchLowerBound(0,n,i=>An[i].exponent<=e);return An[Math.min(s,n-1)]}function fc(t,e,n={}){const{precision:s=6,elide1:i=!0}=n;let r=t,o="";if(e!==""){const c=hc(t);o=c.prefix,r=Di(t,-c.exponent)}if(i&&r===1)return{scale:"",unit:e,prefix:o};let a;if(s!==0){r<1||r>=1e3?a=r.toPrecision(s):a=r.toFixed(s);const c=a.indexOf("e");let l,u;c!==-1?(l=a.substring(0,c),u=a.substring(c)):(l=a,u="");const d=l.match(/.*\.(?:[0-9]*[1-9])?(0+)$/);d!==null&&(l=l.substring(0,l.length-d[1].length),l.endsWith(".")&&(l=l.substring(0,l.length-1)),a=l+u)}else a=r.toString();return{scale:a,unit:e,prefix:o}}function wp(t,e,n){const{scale:s,unit:i,prefix:r}=fc(t,e,n);return`${s}${r}${i}`}function Sp(t){if(t==="")return{scale:1,unit:""};const e=t.match(/^((?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)?([a-zA-Z]+)?$/);if(e===null)return;const n=e[1];let s=n===void 0?1:Number(n);if(Number.isNaN(s))return;let i="";if(e[2]!==void 0){const r=hn.get(e[2]);if(r===void 0)return;i=r.unit,r.exponent>0?s*=10**r.exponent:s/=10**-r.exponent}if(!(s<=0||!Number.isFinite(s)))return{scale:s,unit:i}}function bp(t){const e=hn.get(t);if(e===void 0)throw new Error(`Invalid unit: ${JSON.stringify(t)}`);return e}function Di(t,e){return e>=0?t*10**e:t/10**-e}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Ip(t,e){const n=t.length;for(let s=0;s<n;++s)if(t[s]!==e[s])return!1;return!0}function Pi(t,e,n){const s=t.length;for(let i=0;i<s;++i)t[i]=e[i]+n[i];return t}function fs(t,e,n){const s=t.length;for(let i=0;i<s;++i)t[i]=e[i]-n[i];return t}function pc(t,e,n){const s=t.length;for(let i=0;i<s;++i)t[i]=e[i]*n[i];return t}function Cp(t,e,n){const s=t.length;for(let i=0;i<s;++i)t[i]=e[i]/n[i];return t}function mc(t,e,n,s){const i=t.length;for(let r=0;r<i;++r)t[r]=e[r]+n[r]*s;return t}function Ep(t,e,n){const s=t.length;for(let i=0;i<s;++i)t[i]=e[i]*n;return t}function gc(t){let e=1;for(let n=0,s=t.length;n<s;++n)e*=t[n];return e}function yc(t,e,n){const s=t.length;for(let i=0;i<s;++i)t[i]=Math.min(e[i],n[i]);return t}function vc(t,e,n){const s=t.length;for(let i=0;i<s;++i)t[i]=Math.max(e[i],n[i]);return t}const ps=new Float32Array(0),Mi=new Float64Array(0),kp=Float64Array.of(1,1,1);/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let wc=0;function Ri(){return++wc}function Sc(t,e){return arraysEqual(t.lowerBounds,e.lowerBounds)&&arraysEqual(t.upperBounds,e.upperBounds)}function bc(t,e){return t===void 0?e===void 0:e===void 0?!1:t.explicit===e.explicit&&arraysEqual(t.coordinates,e.coordinates)&&arraysEqual(t.labels,e.labels)}function Ic(t,e){const n=new Map;for(let s=0,i=t.length;s<i;++s)n.set(t[s],e[s]);return t=Array.from(n.keys()),t.sort((s,i)=>s-i),e=Array.from(t,s=>n.get(s)),{coordinates:t,labels:e}}function _i(t){if(t.length===1)return t[0];const e=new Map;let n=!1;for(const r of t){r.explicit&&(n=!0);const{coordinates:o,labels:a}=r;for(let c=0,l=o.length;c<l;++c)e.set(o[c],a[c])}const s=Array.from(e.keys());s.sort((r,o)=>r-o);const i=Array.from(s,r=>e.get(r));return{explicit:n,coordinates:s,labels:i}}function Oi(t){if(t=t.filter(e=>e!==void 0),t.length!==0)return _i(t)}function Cc(t,e){return arraysEqual(t.transform,e.transform)&&Sc(t.box,e.box)}function Ln(t,e){return t.valid===e.valid&&t.rank===e.rank&&arraysEqual(t.names,e.names)&&arraysEqual(t.ids,e.ids)&&arraysEqual(t.timestamps,e.timestamps)&&arraysEqual(t.units,e.units)&&arraysEqual(t.scales,e.scales)&&arraysEqualWithPredicate(t.boundingBoxes,e.boundingBoxes,Cc)&&arraysEqualWithPredicate(t.coordinateArrays,e.coordinateArrays,bc)}function Tp(t,e,n){parseFixedLengthArray(t,n,(s,i)=>{const r=unitFromJson(s);return e[i]=r.exponent,r.unit})}function st(t){const{names:e,units:n,scales:s}=t,{valid:i=!0,rank:r=e.length,timestamps:o=e.map(()=>Number.NEGATIVE_INFINITY),ids:a=e.map((d,h)=>-h),boundingBoxes:c=[]}=t,{coordinateArrays:l=new Array(r)}=t,{bounds:u=Rc(c,r)}=t;return{valid:i,rank:r,names:e,timestamps:o,ids:a,units:n,scales:s,boundingBoxes:c,bounds:u,coordinateArrays:l}}const Ht=st({valid:!1,names:[],units:[],scales:Mi,boundingBoxes:[]}),Ec=st({valid:!0,names:[],units:[],scales:Mi,boundingBoxes:[]});function kc(t){const[e,n]=(0,k.J6)(t,2),s=(0,k.Mo)(e),i=(0,k.zr)(n),r=hn.get(i);if(r===void 0)throw new Error(`Invalid unit: ${JSON.stringify(i)}`);return{unit:r.unit,scale:Di(s,r.exponent)}}function ms(t,e=!1){if(t===void 0)return Ht;(0,k.Rf)(t);const n=Bi(Object.keys(t),e),s=n.length,i=new Array(s),r=new Float64Array(s),o=new Array(s);for(let a=0;a<s;++a)(0,k.cQ)(t,n[a],c=>{if(Array.isArray(c)){const{unit:l,scale:u}=kc(c);i[a]=l,r[a]=u}else{(0,k.Rf)(c);const l=(0,k.cQ)(c,"coordinates",k.VH),u=(0,k.cQ)(c,"labels",k.si),d=l.length;if(d!==u.length)throw new Error(`Length of coordinates array (${d}) does not match length of labels array (${u.length})`);i[a]="",r[a]=1,o[a]={explicit:!0,...Ic(l,u)}}});return st({valid:!1,names:n,units:i,scales:r,coordinateArrays:o})}function gs(t){const{rank:e}=t;if(e===0)return;const{names:n,units:s,scales:i,coordinateArrays:r}=t,o={};for(let a=0;a<e;++a){const c=n[a],l=r[a];l?.explicit?o[c]={coordinates:Array.from(l.coordinates),labels:l.labels}:o[c]=[i[a],s[a]]}return o}class Dp extends me.B0{constructor(){super(Ht)}toJSON(){return gs(this.value)}reset(){this.value=Ht}restoreState(e){this.value=ms(e)}}function Tc(t,e,n){return t.voxelCenterAtIntegerCoordinates[e]?n=Math.round(n):n=Math.floor(n)+.5,n}function Pp(t,e){let n=t.lowerBounds[e],s=t.upperBounds[e];return t.voxelCenterAtIntegerCoordinates[e]&&(n+=.5,s+=.5),[n,s]}function Dc(t,e,n){const s=t.upperBounds[e];Number.isFinite(s)&&(n=Math.min(n,s-1));const i=t.lowerBounds[e];return Number.isFinite(i)&&(n=Math.max(n,i)),n}function Ni(t,e,n){return n=Dc(t,e,n),Tc(t,e,n)}function xi(t,e){let n=(t+e)/2;return Number.isFinite(n)||(n=Math.min(Math.max(0,t),e)),n}function Pc(t,e){const{lowerBounds:n,upperBounds:s}=e,i=t.length;for(let r=0;r<i;++r)t[r]=xi(n[r],s[r]);return t}function Mp(t){const e=t.lowerBounds.length;return{box:t,transform:matrix.createIdentity(Float64Array,e,e+1)}}function Mc(t,e,n){const{box:{lowerBounds:s,upperBounds:i},transform:r}=t,o=s.length,a=n,c=r[a*o+e];let l=c,u=c,d=!1;for(let h=0;h<o;++h){const p=r[a*h+e];if(p===0)continue;const m=p*s[h],f=p*i[h];l+=Math.min(m,f),u+=Math.max(m,f),d=!0}if(d)return{lower:l,upper:u}}function Rc(t,e){const n=new Float64Array(e),s=new Float64Array(e);n.fill(Number.NEGATIVE_INFINITY),s.fill(Number.POSITIVE_INFINITY);const i=new Array(e);i.fill(0);const r=new Array(e);r.fill(0);for(const a of t)for(let c=0;c<e;++c){const l=Mc(a,c,e);if(l===void 0)continue;const{lower:u,upper:d}=l;if(Number.isFinite(u)&&Number.isFinite(d)){const h=Math.floor(u),p=Math.floor(d);h===u&&p===d?++r[c]:u-h===.5&&d-p===.5&&++i[c]}n[c]=n[c]===Number.NEGATIVE_INFINITY?u:Math.min(n[c],u),s[c]=s[c]===Number.POSITIVE_INFINITY?d:Math.max(s[c],d)}const o=r.map((a,c)=>i[c]>0&&a===0);return{lowerBounds:n,upperBounds:s,voxelCenterAtIntegerCoordinates:o}}function _c(t,e,n){const{transform:s,box:i}=t,r=n.length,o=i.lowerBounds.length,a=new Float64Array((o+1)*e);for(let c=0;c<r;++c){const l=n[c];if(l!==-1)for(let u=0;u<=o;++u)a[u*e+l]=s[u*r+c]}return{transform:a,box:i}}function Oc(t,e){const n={lowerBounds:Float64Array.of(0),upperBounds:Float64Array.of(1)},s=new Float64Array(2*t);return s[e]=1,{transform:s,box:n}}function Nc(t,e,n){if(e===n)return t;const{box:s}=t,i=s.lowerBounds.length,r=new Float64Array((i+1)*n);return matrix.copy(r,n,t.transform,e,e,i+1),{box:s,transform:r}}function Rp(t,e){const{rank:n,sourceRank:s}=t;if(n!==e.rank||s!==e.sourceRank)return!1;const{inputSpace:i}=t,{inputSpace:r}=e;return!arraysEqual(r.scales,i.scales)||!arraysEqual(r.units,i.units)||!arraysEqual(e.outputSpace.names,t.outputSpace.names)?!1:Ui(t.transform,n,t.outputSpace.scales,e.transform,n,e.outputSpace.scales)}function _p(t){return{rank:t.rank,sourceRank:t.rank,inputSpace:t,outputSpace:t,transform:matrix.createIdentity(Float64Array,t.rank+1)}}function xc(t,e,n,s){const{transform:i,box:r}=t,o=t.box.lowerBounds.length,a=s.length,c=new Float64Array((o+1)*a);for(let l=0;l<a;++l){const u=s[l];for(let h=0;h<o;++h){let p=0;for(let m=0;m<a;++m){const f=n[m];p+=e[(a+1)*m+l]*i[a*h+m]*(f/u)}c[a*h+l]=p}let d=e[(a+1)*a+l];for(let h=0;h<a;++h){const p=n[h];d+=e[(a+1)*h+l]*i[a*o+h]*(p/u)}c[o*a+l]=d}return{transform:c,box:r}}function Ai(t,e,n){return t.boundingBoxes.map(s=>xc(s,e,t.scales,n))}function ys(t,e,n){const s=st({valid:t.valid,rank:n.rank,ids:n.ids,names:n.names,timestamps:n.timestamps,scales:n.scales,units:n.units,boundingBoxes:Ai(t,e,n.scales),coordinateArrays:n.coordinateArrays});return Ln(s,n)?n:s}function vs(t,e=!1){if(e){const n=Number(t);if(Number.isInteger(n)&&n>=0)return!0}return t.match(/^[a-zA-Z][a-zA-Z_0-9]*['^]?$/)!==null}function Li(t,e=!1){const n=new Set;for(const s of t){if(!vs(s,e)||n.has(s))return!1;n.add(s)}return!0}function Ac(t){const e=t.length,n=new Array(e);n.fill(!0);for(let s=0;s<e;++s){const i=t[s];if(!vs(i)){n[s]=!1;continue}const r=t.indexOf(i,s+1);r!==-1&&(n[s]=!1,n[r]=!1)}return n}function Op(t){return t.endsWith("'")}function Lc(t){return t.endsWith("'")||t.endsWith("^")}function Np(t){return t.endsWith("^")}function xp(t){return!Lc(t)}function Uc(t,e,n){const s=new Float64Array(t),i=e.length,r=(i+1)*i;for(let o=0;o<i;++o)s[r+o]*=e[o]/n[o];return s}function Ui(t,e,n,s,i,r){if(!matrix.equal(t,e+1,s,i+1,e,e))return!1;for(let o=0;o<e;++o){const a=t[(e+1)*e+o],c=s[(i+1)*i+o];if(a*(n[o]/r[o])!==c)return!1}for(let o=e;o<i;++o)if(s[(i+1)*i+o]!==0)return!1;for(let o=e;o<i;++o){for(let a=0;a<e;++a)if(s[(i+1)*a+o]!==0)return!1;for(let a=0;a<i;++a){const c=s[(i+1)*o+a];if(o===a){if(c!==1)return!1}else if(c!==0)return!1}}return!0}function Vc(t,e){if(!e.includes(t))return t;const[,n,s]=t.match(/^([^']*)('?)$/);for(let i=0;;++i){const r=`${n}${i}${s}`;if(!e.includes(r))return r}}function Bc(t,e){const{inputSpace:n,transform:s}=t,{ids:i,rank:r}=n,{rank:o,names:a,units:c,scales:l}=e,u=new Array(r);u.fill(!0);const d=[],h=e.ids.map((Y,le)=>{const we=i.indexOf(Y);return we!==-1?u[we]=!1:d.push(le),we}),{outputSpace:p}=t,{names:m,units:f,scales:b,ids:I,timestamps:E,coordinateArrays:V}=p,R=u,C=[],S=[],T=new Float64Array(o),v=[],N=[],H=new Array(o);let y=0;const A=new Float64Array((o+1)**2);A[A.length-1]=1;for(let Y=0;Y<r;++Y)if(!R[Y]){C[y]=m[Y],v[y]=I[Y],S[y]=f[Y],T[y]=b[Y],N[y]=E[Y],H[y]=V[Y];for(let le=0;le<o;++le){const we=h[le];we!==-1&&(A[le*(o+1)+y]=s[we*(r+1)+Y])}A[o*(o+1)+y]=s[r*(r+1)+Y],++y}for(const Y of d)v[y]=Ri(),C[y]=Vc(a[Y],C),T[y]=l[Y],S[y]=c[Y],A[Y*(o+1)+y]=1,++y;const L=st({valid:e.valid,rank:o,names:C,ids:v,timestamps:N,units:S,scales:T,boundingBoxes:Ai(e,A,T),coordinateArrays:H});return{rank:o,sourceRank:t.sourceRank,inputSpace:e,outputSpace:L,transform:A}}function Vi(t){const e=ys(t.inputSpace,t.transform,t.outputSpace);return e===t.outputSpace?t:{rank:t.rank,sourceRank:t.sourceRank,inputSpace:t.inputSpace,transform:t.transform,outputSpace:e}}class Ap{constructor(e,n=!1){this.mutableSourceRank=n,this.value_=void 0,this.changed=new NullarySignal,this.inputSpaceChanged=new NullarySignal,this.defaultTransform=Vi(e);const s=this;this.outputSpace={changed:s.changed,get value(){return s.value.outputSpace},set value(i){const{value:r}=s;if(Ln(r.outputSpace,i)||r.rank!==i.rank)return;const o=Uc(r.transform,r.outputSpace.scales,i.scales);s.value_={sourceRank:r.sourceRank,rank:r.rank,inputSpace:r.inputSpace,outputSpace:ys(r.inputSpace,o,i),transform:o},s.changed.dispatch()}},this.inputSpace={changed:s.inputSpaceChanged,get value(){return s.value.inputSpace},set value(i){const{value:r}=s;Ln(r.inputSpace,i)||(s.value_=Bc(r,i),s.inputSpaceChanged.dispatch(),s.changed.dispatch())}}}set value(e){const n=this.value;e!==n&&(this.value_=Vi(e),e.inputSpace!==n.inputSpace&&this.inputSpaceChanged.dispatch(),this.changed.dispatch())}get value(){let{value_:e}=this;return e===void 0&&(e=this.value_=this.defaultTransform),e}reset(){this.value_!==this.defaultTransform&&(this.value_=this.defaultTransform,this.inputSpaceChanged.dispatch(),this.changed.dispatch())}get defaultInputSpace(){return this.defaultTransform.inputSpace}get spec(){const{value:e}=this,{rank:n,transform:s,inputSpace:i,outputSpace:r,sourceRank:o}=e,{defaultTransform:a,mutableSourceRank:c}=this,{inputSpace:l,rank:u,transform:d,outputSpace:h}=a,{units:p,scales:m}=i,f=o===n&&arraysEqual(m,c?r.scales:l.scales)&&arraysEqual(p,c?r.units:l.units),b=Ui(d,u,h.scales,s,n,r.scales),I=arraysEqual(h.names,r.names);if(!(b&&I&&f))return{sourceRank:o,transform:b?void 0:s,outputSpace:e.outputSpace,inputSpace:f?void 0:i}}set transform(e){const{value:n}=this,{inputSpace:s}=n;this.value_={rank:n.rank,sourceRank:n.sourceRank,inputSpace:s,transform:e,outputSpace:ys(s,e,n.outputSpace)},this.changed.dispatch()}set spec(e){if(e===void 0){this.reset();return}if(this.mutableSourceRank){const y=e.inputSpace||e.outputSpace,A=y.rank,L=st({rank:A,names:y.names.map((Y,le)=>`${le}`),units:y.units,scales:y.scales,coordinateArrays:y.coordinateArrays});this.value={rank:A,transform:e.transform||matrix.createIdentity(Float64Array,A+1),sourceRank:e.sourceRank,outputSpace:e.outputSpace,inputSpace:L};return}const{inputSpace:n,sourceRank:s,outputSpace:i,transform:r,rank:o}=this.defaultTransform,{inputSpace:a,sourceRank:c,outputSpace:l,transform:u}=e,d=e.outputSpace.rank,h=n.names,p=a!==void 0?a.names:h,m=new Array(s);for(let y=0;y<s;++y){let A=p.indexOf(h[y]);A>=c&&(A=-1),m[y]=A}const f=d-c+s;for(let y=c;y<d;++y)m[s+y-c]=y;const b=new Float64Array(f),I=new Array(f),E=[];for(let y=0;y<s;++y){const A=m[y];A===-1||a===void 0?(b[y]=n.scales[y],E[y]=n.units[y],I[y]=n.coordinateArrays[y]):(b[y]=a.scales[A],E[y]=a.units[A],I[y]=Oi([n.coordinateArrays[y],a.coordinateArrays[A]]))}const V=a||l,R=h.slice(0,s),C=i.names.slice(0,s),S=i.coordinateArrays.slice(0,s),T=new Float64Array(f),v=[];for(let y=0;y<f;++y){const A=m[y];A===-1?(T[y]=i.scales[y],v[y]=i.units[y],S[y]=i.coordinateArrays[y]):(C[y]=l.names[A],v[y]=l.units[A],T[y]=l.scales[A],S[y]=l.coordinateArrays[A])}if(!Li(C)){this.reset();return}for(let y=s;y<f;++y){const A=y-s+c;b[y]=V.scales[A],E[y]=V.units[A],R[y]=`${y}`}const N=new Float64Array((f+1)**2);N[N.length-1]=1;for(let y=0;y<f;++y){const A=m[y];let L;A===-1||u===void 0?y>=s?L=0:L=r[o*(o+1)+y]*(i.scales[y]/T[y]):L=u[d*(d+1)+A],N[f*(f+1)+y]=L;for(let Y=0;Y<f;++Y){const le=m[Y];let we;A===-1!=(le===-1)?we=0:A===-1||u===void 0?A>=s||le>=s?we=A===le?1:0:we=r[Y*(o+1)+y]:we=u[le*(d+1)+A],N[Y*(f+1)+y]=we}}const H=n.boundingBoxes.map(y=>Nc(y,o,f));for(let y=s;y<f;++y)H.push(Oc(f,y));for(let y=0;y<f;++y){if(N[f*(f+1)+y]!==0)continue;let L;for(let le=0;le<f;++le){const we=N[le*(f+1)+y];if(we!==0)if(we===1)if(L===void 0)L=le;else{L=null;break}else{L=null;break}}if(L==null)continue;let Y=I[L];Y!==void 0&&(Y.explicit&&(Y={...Y,explicit:!1}),S[y]=Oi([Y,S[y]]))}this.value={rank:f,transform:N,sourceRank:s,outputSpace:st({rank:f,names:C,scales:T,units:v,coordinateArrays:S}),inputSpace:st({rank:f,names:R,scales:b,units:E,coordinateArrays:I,boundingBoxes:H})}}toJSON(){return zc(this.spec)}restoreState(e){this.spec=$c(e)}}function Fc(t,e=!1){const n=(0,k.zr)(t);if(!vs(n,e))throw new Error(`Invalid dimension name: ${JSON.stringify(n)}`);return n}function Bi(t,e=!1){const n=(0,k.$v)(t,s=>Fc(s,e));if(!Li(n,e))throw new Error(`Invalid dimensions: ${JSON.stringify(n)}`);return n}class Lp{constructor(e,n){this.combined=e,this.bindings=new Set,this.retainCount=0,this.prevCombined=this.combined.value,this.dimensionRefCounts=new Map,this.handleCombinedChanged=()=>{this.combined.value!==this.prevCombined&&this.update()},this.includeDimensionPredicate_=n}getRenameValidity(e){const n=this.combined.value.names,s=Ac(e),i=e.length;for(let r=0;r<i;++r){if(!s[r])continue;const o=e[r];if(n.includes(o))continue;let a=!0;for(const c of this.bindings)if(c.space.value.names.includes(o)){a=!1;break}s[r]=a}return s}get includeDimensionPredicate(){return this.includeDimensionPredicate_}set includeDimensionPredicate(e){this.includeDimensionPredicate_=e,this.update()}update(){const{combined:e,bindings:n}=this,s=this.retainCount>0?1:0;if(n.size===0&&!s){e.value=Ht;return}const i=this.includeDimensionPredicate_,r=e.value;let o=Array.from(r.names),a=Array.from(r.units),c=Array.from(r.scales),l=Array.from(r.ids),u=Array.from(r.timestamps),d=r.names.map(()=>s?1:0);const h=[];let p=!1;for(const C of n){const{space:{value:S},prevValue:T,mappedDimensionIds:v}=C;p=p||S.valid;const{names:N,units:H,scales:y,ids:A,timestamps:L}=S,Y=[],le=[];h.push(le),C.mappedDimensionIds=Y,C.prevValue=S;const we=N.length;for(let pe=0;pe<we;++pe){const $e=N[pe];if(!i($e))continue;if(T!==void 0){const Pn=A[pe],an=T.ids.indexOf(Pn);if(an!==-1){const $t=v[an];if($t!==void 0){const rt=l.indexOf($t);if(rt!==-1){Y[pe]=$t,++d[rt],le[pe]=rt;const wt=L[pe];wt!==void 0&&!(wt<=u[rt])&&(o[rt]=$e,c[rt]=y[pe],a[rt]=H[pe],u[rt]=wt);continue}}}}let Fe=o.indexOf($e);if(Fe!==-1){Y[pe]=l[Fe],++d[Fe],le[pe]=Fe;continue}Fe=o.length,le[pe]=Fe,d[Fe]=1+s,o[Fe]=$e,a[Fe]=H[pe],c[Fe]=y[pe],u[Fe]=L[pe];const _t=Ri();l[Fe]=_t,Y[pe]=_t}}const{dimensionRefCounts:m}=this;m.clear();let f=0,b=o.length;for(const C of n){const{space:{value:S}}=C,T=h[f++],{rank:v}=S,N=Array.from(S.names),H=Array.from(S.timestamps),y=Float64Array.from(S.scales),A=Array.from(S.units);for(let L=0;L<v;++L){const Y=T[L];Y!==void 0&&(A[L]=a[Y],y[L]=c[Y],H[L]=u[Y],N[L]=o[Y])}for(const L of N){let Y=m.get(L);Y===void 0?Y=1:++Y,m.set(L,Y)}if(!arraysEqual(A,S.units)||!arraysEqual(y,S.scales)||!arraysEqual(N,S.names)||!arraysEqual(H,S.timestamps)){const L=st({valid:S.valid,ids:S.ids,scales:y,units:A,names:N,timestamps:H,boundingBoxes:S.boundingBoxes,coordinateArrays:S.coordinateArrays});C.prevValue=L,C.space.value=L}}{for(let S=0;S<b;++S)i(o[S])||(d[S]=0);const C=(S,T)=>d[T]!==0;o=o.filter(C),a=a.filter(C),c=c.filter(C),l=l.filter(C),u=u.filter(C),d=d.filter(C),b=o.length}const I=[],E=new Array(b);for(let C=0,S=r.rank;C<S;++C){const T=r.coordinateArrays[C];if(!T?.explicit)continue;const v=l.indexOf(r.ids[C]);v!==-1&&(E[v]=[T])}for(const C of n){const{space:{value:S}}=C,{rank:T,boundingBoxes:v,coordinateArrays:N}=S,H=S.names.map(y=>o.indexOf(y));for(const y of v)I.push(_c(y,b,H));for(let y=0;y<T;++y){const A=N[y];if(A===void 0)continue;const L=H[y],Y=E[L];Y===void 0?E[L]=[A]:Y.push(A)}}const V=new Array(b);for(let C=0;C<b;++C){const S=E[C];S!==void 0&&(V[C]=_i(S))}const R=st({valid:p,ids:l,names:o,units:a,scales:new Float64Array(c),boundingBoxes:I,coordinateArrays:V});if(s)for(let C=0;C<b;++C)--d[C];Ln(r,R)||(this.prevCombined=R,e.value=R)}retain(){return++this.retainCount,()=>{--this.retainCount===0&&this.update()}}bind(e){const n={space:e,mappedDimensionIds:[],prevValue:void 0},{bindings:s}=this;s.size===0&&this.combined.changed.add(this.handleCombinedChanged),s.add(n);const i=e.changed.add(()=>{e.value!==n.prevValue&&this.update()}),r=()=>{i();const{bindings:o}=this;o.delete(n),o.size===0&&this.combined.changed.remove(this.handleCombinedChanged),this.update()};return this.update(),r}}function Up(t,e,n,s,i){const r=i.length,o=new t((r+1)**2);o[o.length-1]=1;for(let a=0;a<r;++a){const c=s[a];o[(r+1)*r+a]=e[(n+1)*n+c];for(let l=0;l<r;++l){const u=i[l];o[(r+1)*l+a]=e[(n+1)*u+c]}}return o}function Vp(t){if(t===void 0)return;const e=new Float64Array(16);if(Array.isArray(t))if(t.length===16)for(let n=0;n<4;++n)for(let s=0;s<4;++s)e[n*4+s]=verifyFiniteFloat(t[s*4+n]);else{expectArray(t,4);for(let n=0;n<4;++n){const s=expectArray(t[n],4);for(let i=0;i<4;++i)e[i*4+n]=verifyFiniteFloat(s[i])}}else{verifyObject(t);const n=quat.create(),s=vec3.create(),i=vec3.fromValues(1,1,1);verifyOptionalObjectProperty(t,"rotation",o=>{parseFiniteVec(n,o),quat.normalize(n,n)}),verifyOptionalObjectProperty(t,"translation",o=>{parseFiniteVec(s,o)}),verifyOptionalObjectProperty(t,"scale",o=>{parseFiniteVec(i,o)});const r=mat4.create();mat4.fromRotationTranslationScale(r,n,s,i),e.set(r)}return{sourceRank:3,transform:e,outputSpace:st({valid:!0,names:["x","y","z"],units:["m","m","m"],scales:Float64Array.of(1e-9,1e-9,1e-9)}),inputSpace:void 0}}function $c(t){if(t===void 0)return;const e=verifyObject(t),n=verifyObjectProperty(e,"outputDimensions",ms),s=n.rank,i=verifyObjectProperty(e,"sourceRank",a=>{if(a===void 0)return s;if(!Number.isInteger(a)||a<0||a>s)throw new Error(`Expected integer in range [0, ${s}] but received: ${JSON.stringify(a)}`);return a}),r=verifyOptionalObjectProperty(e,"inputDimensions",a=>{const c=ms(a,!0);if(c.rank!==s)throw new Error(`Expected rank of ${s}, but received rank of: ${c.rank}`);return c});return{transform:verifyOptionalObjectProperty(e,"matrix",a=>{const c=new Float64Array((s+1)**2),l=expectArray(a,s);c[c.length-1]=1;for(let u=0;u<s;++u)try{const d=expectArray(l[u],s+1);for(let h=0;h<=s;++h)c[(s+1)*h+u]=verifyFiniteFloat(d[h])}catch(d){throw new Error(`Error in row ${u}: ${d.message}`)}return c}),outputSpace:n,inputSpace:r,sourceRank:i}}function zc(t){if(t===void 0)return;const{transform:e,outputSpace:n,inputSpace:s,sourceRank:i}=t;let r;const o=n.rank;if(e!==void 0){r=[];for(let a=0;a<o;++a){const c=[];r[a]=c;for(let l=0;l<=o;++l)c[l]=e[(o+1)*l+a]}}return{sourceRank:i===o?void 0:i,matrix:r,outputDimensions:gs(n),inputDimensions:s===void 0?void 0:gs(s)}}function Gc(t,e,n){const{box:s,transform:i}=t,r=t.box.lowerBounds.length,o=e.length,a=new Float64Array((r+1)*o);if(matrix.permuteRows(a,o,i,n,e,r+1),!a.every(c=>c===0))return{transform:a,box:s}}function jc(t,e){const{ids:n,names:s,scales:i,units:r,timestamps:o,coordinateArrays:a}=t;return st({rank:e.length,valid:t.valid,ids:e.map(c=>n[c]),names:e.map(c=>s[c]),timestamps:e.map(c=>o[c]),scales:Float64Array.from(e,c=>i[c]),units:e.map(c=>r[c]),coordinateArrays:e.map(c=>a[c]),boundingBoxes:t.boundingBoxes.map(c=>Gc(c,e,t.rank)).filter(c=>c!==void 0)})}function Bp(t,e,n){return e===n?t:jc(t,getInsertPermutation(t.rank,n,e))}function Fp(t,e){const{transform:n,rank:s}=t,i=getDependentTransformInputDimensions(n,s,[e]);if(i.length!==1)return;const[r]=i,o=Math.abs(n[(s+1)*r+e]),{inputSpace:a}=t;return{scale:a.scales[r]*o,unit:a.units[r]}}function $p(t,e){const{scales:n,units:s}=t.defaultInputSpace;return e<n.length?{scale:n[e],unit:s[e]}:void 0}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function zp(t,e,n,s){for(;e<n;){const i=t[e];if(s(i)){++e;continue}--n,t[e]=t[n],t[n]=i}return n}function Gp(t,e){const n=t.length;let s=0;for(let i=0;i<n;++i)e(t[i],i,t)&&(t[s]=t[i],++s);t.length=s}function jp(t,e){if(t.length===e)return t;const n=new t.constructor(e);return n.set(t),n}function Yp(t,e=1){const n=t.length,s=new Array(n);let i=s[0]=e;for(let r=1;r<n;++r)i*=t[r-1],s[r]=i;return s}function Yc(t,e,n){const s=new t.constructor(t.length);for(let i=0;i<e*n;i+=n)for(let r=0;r<n;r++){const o=i/n;s[r*e+o]=t[i+r]}return s}function Jp(t,e,n,s){const i=t.length/e,r=t.length*n*s,o=new t.constructor(r),a=t.length*s,c=e,l=e*s;for(let u=0;u<i;++u)for(let d=0;d<e;++d){const h=t[u*e+d],p=u*l+d;for(let m=0;m<n;++m)for(let f=0;f<s;++f)o[m*a+f*c+p]=h}return o}function Hp(t,e,n,s=0,i=t.length){for(;s<i;){const r=s+i-1>>1,o=n(e,t[r]);if(o>0)s=r+1;else if(o<0)i=r;else return r}return~s}function Wp(t,e,n,s=0,i=t.length){let r=-1,o=1/0;for(;s<i;){const a=s+i-1>>1,c=n(e,t[a]);if(c>0)s=a+1;else if(c<0)i=a;else return a;const l=Math.abs(c);l<o&&(o=l,r=a)}return r}function Kp(t,e,n){let s=e-t;for(;s>0;){const i=Math.floor(s/2),r=t+i;n(r)?s=i:(t=r+1,s-=i+1)}return t}function Jc(t,e){const n=[];for(let s=0,i=t.length;s<i;++s)t[s]===e&&n.push(s);return n}function qp(t,e){const n=[];n.length=e;for(const s of t)n[s]=!0;return Jc(n,void 0)}function kt(t,e){const n=t.length;if(e.length!==n)return!1;for(let s=0;s<n;++s)if(t[s]!==e[s])return!1;return!0}function Qp(t,e,n=(s,i)=>s===i){const s=t.length;if(e.length!==s)return!1;for(let i=0;i<s;++i)if(!n(t[i],e[i]))return!1;return!0}function Xp(t,e,n){const s=[];if(n===e){for(let i=0;i<t;++i)s[i]=i;return s}s[n]=e;for(let i=0,r=0;i<t;){if(i===e){++i;continue}r===n&&++r,s[r++]=i++}return s}function Zp(t,e,n){for(let s=0,i=n.length;s<i;++s){const r=n[s];r!==-1&&(t[r]=e[s])}return t}function em(t,e,n){for(let s=0,i=n.length;s<i;++s){const r=n[s];r!==-1&&(t[s]=e[r])}return t}function tm(t){const e=[];for(let n=0,s=t.length;n<s;++n){const i=t[n];for(let r=0,o=i.length;r<o;++r){let a=e[r];a===void 0&&(a=e[r]=[]),a.push(i[r])}}return e}function nm(t,e){const n=[];let s=0;for(let r=0,o=e.length;r<o;++r){const{retainCount:a,deleteCount:c,insertCount:l}=e[r];a!==0&&(n.push(t.slice(s,s+a)),s+=a),s+=c,l!==0&&n.push(new Array(l))}const i=t.length;return s!==i&&n.push(t.slice(s)),new Array(0).concat(...n)}function sm(t,e,n){const s=[];let i=0,r=0;const o=t.length,a=e.length;for(;i<o&&r<a;){let c;const l=t[i],u=e[r];if(c=n(l,u),c===0){let d=1;for(++i,++r;i<o&&r<a&&(c=n(t[i],e[r]))===0;)++d,++i,++r;s.push({retainCount:d,deleteCount:0,insertCount:0});continue}if(c<0){let d=1;for(;++i<o&&(c=n(t[i],u))<0;)++d;s.push({retainCount:0,deleteCount:d,insertCount:0});continue}if(c>0){let d=1;for(;++r<a&&(c=n(l,e[r]))>0;)++d;s.push({retainCount:0,deleteCount:0,insertCount:d})}}return(i<o||r<a)&&s.push({retainCount:0,deleteCount:o-i,insertCount:a-r}),s}function im(t,e,n){const s=[];let i=0,r=0;const o=t.length,a=e.length;for(;i<o;){let c=0;for(;i<o&&r<a&&n(t[i],e[r]);)++c,++i,++r;c!==0&&s.push({retainCount:c,deleteCount:0,insertCount:0});let l=0;for(;i<o&&(r===a||!n(t[i],e[r]));)++l,++i;l!==0&&s.push({retainCount:0,deleteCount:l,insertCount:0})}return r!==a&&s.push({retainCount:0,deleteCount:0,insertCount:a-r}),s}function rm(t,e,n,s,i,r){let o=0,a=0;if(t!==0&&e!==0)for(;;){const c=n(o,a);if(c<0){if(s(o),++o===t)break}else if(c>0){if(i(a),++a===e)break}else if(r(o,a),++o,++a,o===t||a===e)break}for(;o<t;)s(o),++o;for(;a<e;)i(a),++a}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Hc(t,e,n){(0,k.MM)(t,e,s=>n.restoreState(s))}class Fi extends J.O8{constructor(){super(...arguments),this.children=new Map,this.changed=new ve.IY}add(e,n){const{children:s}=this;if(s.has(e))throw new Error(`Key ${JSON.stringify(e)} already registered.`);return this.children.set(e,n),n.changed.add(this.changed.dispatch),this.changed.dispatch(),()=>{this.remove(e)}}remove(e){const{children:n}=this;if(n.has(e))throw new Error(`Key ${JSON.stringify(e)} not registered.`);const s=n.get(e);this.children.delete(e),s.changed.remove(this.changed.dispatch),this.changed.dispatch()}disposed(){const{changed:e}=this;for(const n of this.children.values())n.changed.remove(e.dispatch);this.children=void 0,super.disposed()}toJSON(){const e=this.baseJSON();for(const[n,s]of this.children)e[n]=s.toJSON();return e}baseJSON(){return{}}reset(){for(const e of this.children.values())e.reset()}restoreState(e){(0,k.Rf)(e);for(const[n,s]of this.children)try{if(Object.prototype.hasOwnProperty.call(e,n)){const i=e[n];if(i===void 0)continue;s.restoreState(i)}}catch(i){throw new Error(`Error restoring property ${JSON.stringify(n)}: ${i.message}`)}}}class om extends Fi{constructor(){super(...arguments),this.lastState={}}restoreState(e){(0,k.Rf)(e),this.lastState=e,super.restoreState(e)}reset(){this.lastState={},super.reset()}baseJSON(){const e=Object.assign(super.baseJSON(),this.lastState);for(const n of this.children.keys())delete e[n];return e}toJSON(){const e=super.toJSON();return this.lastState=e,e}add(e,n){const s=super.add(e,n),i=this.lastState[e];return i!==void 0&&(n.reset(),n.restoreState(i)),s}}const $i=new WeakMap;function Wc(t){let e=$i.get(t);const n=t.changed.count;if(e!==void 0&&e.generation===n)return e;let s;if(t instanceof Fi){s=t.baseJSON();for(const[i,r]of t.children)s[i]=Wc(r).value}else s=t.toJSON();return e===void 0?(e={generation:n,value:s},$i.set(t,e)):(e.generation=n,e.value=s),e}var zi=x(6703);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var Gi=(t=>(t[t.LINKED=0]="LINKED",t[t.RELATIVE=1]="RELATIVE",t[t.UNLINKED=2]="UNLINKED",t))(Gi||{}),ji=(t=>(t[t.LINKED=0]="LINKED",t[t.UNLINKED=2]="UNLINKED",t))(ji||{});class Kc extends zi.F{constructor(e=0){super(Gi,e)}}class am extends zi.F{constructor(e=0){super(ji,e)}}const Un=w.eR.create(),Yi=w.Yu.create();function fn(t,e,n,s){let i=!1;const r=!1;let o;t.registerDisposer(e);const a=()=>{if(!r){switch(i=!0,n.value){case 2:if(s.isValid(t))break;case 0:s.assign(t,e);break;case 1:s.add(t,e,o);break}i=!1}},c=()=>{if(!i)switch(n.value){case 2:break;case 0:s.assign(e,t);break;case 1:s.subtract(e,t,o);break}};let l=2;const u=()=>{const d=n.value;if(d!==l)switch(d){case 2:o=void 0;break;case 0:o=void 0,s.assign(t,e);break;case 1:o=s.difference(t,e);break}l=d,t.changed.dispatch()};return t.registerDisposer(t.changed.add(c)),t.registerDisposer(e.changed.add(a)),t.registerDisposer(n.changed.add(u)),u(),t}function Ji(t,e,n,s){return fn(t,e,n,s)}class Vn extends J.O8{constructor(e){super(),this.coordinateSpace=e,this.coordinates_=ps,this.changed=new ve.IY,this.registerDisposer(e.changed.add(()=>{this.handleCoordinateSpaceChanged()}))}get valid(){return this.coordinateSpace.value.valid}get value(){return this.handleCoordinateSpaceChanged(),this.coordinates_}reset(){this.curCoordinateSpace=void 0,this.coordinates_=ps,this.changed.dispatch()}set value(e){const{curCoordinateSpace:n}=this;if(n===void 0||!n.valid||n.rank!==e.length)return;const{coordinates_:s}=this;s.set(e),this.changed.dispatch()}handleCoordinateSpaceChanged(){const e=this.coordinateSpace.value,n=this.curCoordinateSpace;if(e===n)return;this.curCoordinateSpace=e;const{rank:s}=e;if(!e.valid)return;if(n===void 0||!n.valid){let{coordinates_:u}=this;if(!(u!==void 0&&u.length===s)){u=this.coordinates_=new Float32Array(s),Pc(u,e.bounds);const{voxelCenterAtIntegerCoordinates:d}=e.bounds;for(let h=0;h<s;++h)d[h]?u[h]=Math.round(u[h]):u[h]=Math.floor(u[h])+.5}this.changed.dispatch();return}const i=new Float32Array(s),r=this.coordinates_,{ids:o,scales:a}=e,{ids:c,scales:l}=n;for(let u=0;u<s;++u){const d=o[u],h=c.indexOf(d);h===-1?i[u]=xi(e.bounds.lowerBounds[u],e.bounds.upperBounds[u]):i[u]=r[h]*(l[h]/a[u])}this.coordinates_=i,this.changed.dispatch()}toJSON(){if(!this.valid&&this.coordinates_.length===0)return;this.handleCoordinateSpaceChanged();const{value:e}=this;if(e.length!==0)return Array.from(e)}restoreState(e){if(e===void 0){this.reset();return}this.curCoordinateSpace=void 0,this.coordinates_=Float32Array.from((0,k.$v)(e,k.zo)),this.handleCoordinateSpaceChanged(),this.changed.dispatch()}snapToVoxel(){this.handleCoordinateSpaceChanged();const{bounds:{voxelCenterAtIntegerCoordinates:e}}=this.coordinateSpace.value,{coordinates_:n}=this,s=n.length;for(let i=0;i<s;++i)e[i]?n[i]=Math.round(n[i]):n[i]=Math.floor(n[i])+.5;this.changed.dispatch()}assign(e){e.handleCoordinateSpaceChanged();const{curCoordinateSpace:n,coordinates_:s}=e;this.curCoordinateSpace=n,this.coordinates_=Float32Array.from(s),this.changed.dispatch()}static getOffset(e,n){const s=e.coordinates_,i=n.coordinates_;if(s.length===i.length)return fs(new Float32Array(s.length),s,i)}static addOffset(e,n,s,i=1){e.handleCoordinateSpaceChanged();const{value:r}=n;s!==void 0&&r.length===s.length&&(mc(e.value,r,s,i),e.changed.dispatch())}get legacyJsonView(){const e=this;return{changed:e.changed,toJSON(){return e.toJSON()},reset(){e.reset()},restoreState(n){if(n===void 0||Array.isArray(n)){e.restoreState(n);return}(0,k.Rf)(n),Hc(n,"voxelCoordinates",e)}}}}var ws=(t=>(t[t.STOP=0]="STOP",t[t.LOOP=1]="LOOP",t[t.REVERSE=2]="REVERSE",t))(ws||{});const Hi=10;class Ss{constructor(){this.velocity=Hi,this.atBoundary=2,this.paused=!0}}function qc(t,e){return t.velocity===e.velocity&&t.atBoundary===e.atBoundary&&t.paused===e.paused}function Qc(t){return(0,k.Rf)(t),{velocity:(0,k.MM)(t,"velocity",k.zo,Hi),atBoundary:(0,k.MM)(t,"atBoundary",e=>(0,k.sl)(e,ws),0),paused:(0,k.MM)(t,"paused",k.aO,!0)}}function Xc(t){const{velocity:e,atBoundary:n,paused:s}=t;return{velocity:e,atBoundary:n===0?void 0:ws[n].toLowerCase(),paused:s?void 0:!1}}class Zc extends J.O8{constructor(e){super(),this.coordinateSpace=e,this.changed=new ve.IY,this.registerDisposer(e.changed.add(()=>{this.handleCoordinateSpaceChanged()})),this.curCoordinateSpace=e.value,this.velocities_=new Array(this.curCoordinateSpace?.rank??0)}get valid(){return this.coordinateSpace.value.valid}get value(){return this.handleCoordinateSpaceChanged(),this.velocities_}set value(e){const{curCoordinateSpace:n}=this;n===void 0||n.rank!==e.length||(this.velocities_=e,this.changed.dispatch())}get(e){const n=this.coordinateSpace.value?.ids;if(n===void 0)return;const s=n.indexOf(e);return s===-1?void 0:this.value[s]}dimensionVelocity(e,n){const s=new ve.IY;let i=-1;const r=()=>{const l=this.coordinateSpace.value?.ids;l===void 0?i=-1:(i===-1||l[i]!==n)&&(i=l.indexOf(n))},o=()=>{if(r(),i!==-1)return this.value[i]},a=l=>{if(r(),i===-1)return;const u=this.value;u[i]!==l&&(u[i]=l,this.changed.dispatch())},c=o();return e.registerDisposer(this.changed.add(()=>{o()!==c&&s.dispatch()})),{get value(){return o()},set value(l){a(l)},changed:s}}modifyDimension(e,n){const s=this.coordinateSpace.value?.ids;if(s===void 0)return;const i=s.indexOf(e);if(i===-1)return;const r=this.value,o=r[i],a=n(o);o!==a&&(r[i]=a,this.changed.dispatch())}togglePlayback(e,n=void 0){this.modifyDimension(e,(s=new Ss)=>({...s,paused:n??!s.paused}))}playbackEnabled(e){const n=this;return{changed:this.changed,get value(){return n.get(e)!==void 0},set value(s){n.modifyDimension(e,i=>s?i??new Ss:void 0)}}}multiplyVelocity(e,n){this.modifyDimension(e,(s=new Ss)=>{let i=Math.round(s.velocity*n);return i===0&&(i=Math.sign(s.velocity)||1),{...s,velocity:i}})}handleCoordinateSpaceChanged(){const e=this.coordinateSpace.value,n=this.curCoordinateSpace;if(e===n)return;this.curCoordinateSpace=e;const{rank:s}=e;if(!e.valid)return;if(n===void 0){let{velocities_:c}=this;c.length===s||(c=new Array(s)),this.changed.dispatch();return}const i=new Array(s),r=this.velocities_,{ids:o}=e,{ids:a}=n;for(let c=0;c<s;++c){const l=o[c],u=a.indexOf(l);u!==-1&&(i[c]=r[u])}this.velocities_=i,this.changed.dispatch()}toJSON(){this.handleCoordinateSpaceChanged();const{velocities_:e,curCoordinateSpace:n}=this;if(!n?.valid||!e.some(o=>o!==void 0))return;const s={},{names:i,rank:r}=n;for(let o=0;o<r;++o){const a=e[o];a!==void 0&&(s[i[o]]=Xc(a))}return s}reset(){this.handleCoordinateSpaceChanged(),this.velocities_=new Array(this.curCoordinateSpace?.rank??0)}restoreState(e){if(e===void 0){this.reset();return}(0,k.Rf)(e);const n=this.curCoordinateSpace=this.coordinateSpace.value;if(this.velocities_=new Array(n?.rank??0),n===void 0)throw new Error("Must specify dimensions in order to specify velocities");const s=this.velocities_=new Array(n?.rank??0),{names:i}=n;for(const r of Object.keys(e)){const o=i.indexOf(r);if(o===-1)throw new Error(`Invalid dimension name: ${JSON.stringify(r)}`);s[o]=(0,k.cQ)(e,r,Qc)}this.changed.dispatch()}assign(e){const n=e.value,s=this.value,i=s.length;let r=!1;for(let o=0;o<i;++o){const a=n[o],c=s[o];a!==c&&((c===void 0||a===void 0||!qc(c,a))&&(r=!0),s[o]=a)}r&&this.changed.dispatch()}}class cm extends J.O8{constructor(e,n){super(),this.peer=e,this.positionLink=n,this.changed=new ve.IY,this.velocity=this.registerDisposer(new Zc(this.peer.coordinateSpace)),this.registerDisposer(e),this.velocity.changed.add(()=>{this.positionLink.value===2?this.changed.dispatch():this.peer.assign(this.velocity)});const s=()=>{this.positionLink.value!==2&&this.velocity.assign(this.peer)};this.registerDisposer(e.changed.add(s)),s()}toJSON(){if(this.positionLink.value===2)return this.velocity.toJSON()}reset(){this.positionLink.value===2&&this.velocity.reset()}restoreState(e){this.positionLink.value===2&&this.velocity.restoreState(e)}copyToPeer(){this.positionLink.value===2&&this.peer.assign(this.velocity)}}class lm extends J.O8{constructor(e,n,s){super(),this.display=e,this.position=n,this.velocity=s,this.dimensionStates=new Map,this.lastUpdateGeneration=0,this.handleVelocityChanged(),this.registerDisposer(s.changed.add(()=>this.handleVelocityChanged()))}disposed(){this.unregisterUpdateStartedCallback?.(),super.disposed()}handleVelocityChanged(){const{dimensionStates:e}=this,n=this.position.coordinateSpace.value?.ids??[],s=n.length,i=this.velocity.value,r=++this.lastUpdateGeneration,o=this.position.value,a=Date.now();for(let c=0;c<s;++c){const l=i[c];if(l===void 0||l.velocity===0||l.paused)continue;const u=n[c],d=e.get(u);d===void 0?e.set(u,{prevTime:a,dimensionIndex:c,prevCoordinate:o[c],generation:r}):(d.generation=r,d.dimensionIndex=c)}for(const[c,l]of e)l.generation!==r&&e.delete(c);if(e.size===0){const{unregisterUpdateStartedCallback:c}=this;c!==void 0&&(c(),this.unregisterUpdateStartedCallback=void 0)}else this.unregisterUpdateStartedCallback===void 0&&(this.unregisterUpdateStartedCallback=this.display.updateStarted.add(()=>this.updateStarted()),this.display.scheduleRedraw())}updateStarted(){const e=this.position.coordinateSpace.value;if(e===void 0)return;const n=e.ids,s=this.position.value;let i=!1,r=!1;const o=Date.now(),a=this.velocity.value,{bounds:{lowerBounds:c,upperBounds:l}}=e;for(const[u,d]of this.dimensionStates){const{dimensionIndex:h}=d;if(n[h]!==u)continue;const p=a[h];if(Math.floor(s[h])!==Math.floor(d.prevCoordinate)){p?.paused===!1&&(a[h]={...p,paused:!0},r=!0);continue}const m=o-d.prevTime,f=p?.velocity??0,b=m*f/1e3;if(b===0)continue;let I=s[h]+b;const E=c[h],V=Math.ceil(l[h]-1),R=b>0?V:E,C=b>0?E:V,S=Math.sign(b);if(Number.isFinite(R)&&I*S>=R*S)switch(p.atBoundary){case 1:if(Number.isFinite(C)){I=C;break}case 0:a[h]={...p,paused:!0},r=!0,I=R;break;case 2:a[h]={...p,velocity:-f},r=!0,I=R;break}s[h]=I,d.prevCoordinate=s[h],d.prevTime=o,i=!0}i&&this.position.changed.dispatch(),r&&this.velocity.changed.dispatch(),this.display.scheduleRedraw()}}function Wi(t,e,n){if(n===void 0||Object.keys(n).length===0){t.value=0;return}(0,k.Rf)(n),t.value=2,(0,k.cQ)(n,"value",s=>{s!==void 0&&e.restoreState(s)}),(0,k.cQ)(n,"link",s=>t.restoreState(s))}class pn{constructor(e,n=new Kc){this.peer=e,this.link=n}get changed(){return this.value.changed}toJSON(){const{link:e}=this;if(e.value!==0)return{link:e.toJSON(),value:this.getValueJson()}}getValueJson(){return this.value.toJSON()}reset(){this.link.value=0}restoreState(e){Wi(this.link,this.value,e)}copyToPeer(){this.link.value!==0&&(this.link.value=2,this.peer.assign(this.value),this.link.value=0)}}class Ki extends pn{}class um extends pn{constructor(){super(...arguments),this.value=fn(new Vn(this.peer.coordinateSpace),this.peer,this.link,{assign:(e,n)=>e.assign(n),isValid:e=>e.valid,difference:Vn.getOffset,add:Vn.addOffset,subtract:(e,n,s)=>{Vn.addOffset(e,n,s,-1)}})}}function el(t){return t[0]===0&&t[1]===0&&t[2]===0&&t[3]===1}class bs extends J.O8{constructor(e){super(),this.changed=new ve.IY,e==null&&(e=w.Yu.create()),this.orientation=e}toJSON(){const{orientation:e}=this;if(w.Yu.normalize(this.orientation,this.orientation),!el(e))return Array.prototype.slice.call(this.orientation)}restoreState(e){try{(0,k.Vr)(this.orientation,e),w.Yu.normalize(this.orientation,this.orientation)}catch{w.Yu.identity(this.orientation)}this.changed.dispatch()}reset(){w.Yu.identity(this.orientation),this.changed.dispatch()}snap(){const e=w.w0.create();w.w0.fromQuat(e,this.orientation);const n=[!1,!1,!1];for(let s=0;s<3;++s){let i=0,r=0;for(let o=0;o<3;++o){const a=e[s*3+o];e[s*3+o]=0,!n[o]&&Math.abs(a)>Math.abs(i)&&(i=a,r=o)}e[s*3+r]=Math.sign(i),n[r]=!0}w.Yu.fromMat3(this.orientation,e),this.changed.dispatch()}static makeRelative(e,n){const s=new bs(w.Yu.multiply(w.Yu.create(),e.orientation,n));let i=!1;s.registerDisposer(e.changed.add(()=>{i||(r=!0,w.Yu.multiply(s.orientation,e.orientation,n),s.changed.dispatch(),r=!1)}));let r=!1;const o=w.Yu.invert(w.Yu.create(),n);return s.registerDisposer(s.changed.add(()=>{r||(i=!0,w.Yu.multiply(e.orientation,s.orientation,o),e.changed.dispatch(),i=!1)})),s}assign(e){w.Yu.copy(this.orientation,e.orientation),this.changed.dispatch()}}class dm extends pn{constructor(){super(...arguments),this.value=fn(new bs,this.peer,this.link,{assign:(e,n)=>e.assign(n),isValid:()=>!0,difference:(e,n)=>{const s=w.Yu.create();return w.Yu.multiply(s,w.Yu.invert(s,n.orientation),e.orientation)},add:(e,n,s)=>{w.Yu.multiply(e.orientation,n.orientation,s),e.changed.dispatch()},subtract:(e,n,s)=>{w.Yu.multiply(e.orientation,n.orientation,w.Yu.invert(Yi,s)),e.changed.dispatch()}})}}class tl extends J.O8{constructor(e){super(),this.coordinateSpace=e,this.changed=new ve.IY,this.curCoordinateSpace=Ht,this.value_={factors:new Float64Array(0)},this.registerDisposer(e.changed.add(()=>this.update())),this.update()}get value(){return this.update()}reset(){this.value_={factors:new Float64Array(0)},this.curCoordinateSpace=Ht,this.changed.dispatch()}toJSON(){const e={};let n=!1;const{value:s}=this,{factors:i}=s,{names:r,rank:o}=this.curCoordinateSpace;for(let a=0;a<o;++a){const c=i[a];c!==1&&(e[r[a]]=c,n=!0)}if(n)return e}restoreState(e){const{coordinateSpace:{value:n}}=this,{names:s,rank:i}=n,r=new Float64Array(i);if(r.fill(-1),e!==void 0){const o=(0,k.Rf)(e);for(let a=0;a<i;++a)r[a]=(0,k.cQ)(o,s[a],c=>c===void 0?1:(0,k.Mo)(c))}this.value_={factors:r},this.curCoordinateSpace=n,this.changed.dispatch()}setFactors(e){const{coordinateSpace:{value:n}}=this;e.length===n.rank&&(this.value_={factors:e},this.curCoordinateSpace=n,this.changed.dispatch())}update(){const{coordinateSpace:{value:e}}=this;let n=this.value_;const{curCoordinateSpace:s}=this;if(s===e)return n;const{ids:i}=s,{ids:r,rank:o}=e,a=n.factors,c=new Float64Array(o);c.fill(1);for(let l=0;l<o;++l){const u=r[l],d=i.indexOf(u);d!==-1&&(c[l]=a[d])}return kt(c,a)||(n=this.value_={factors:c},this.curCoordinateSpace=e,this.changed.dispatch()),n}assign(e){this.setFactors(e.value.factors)}}function qi(t,e,n,s,i){if(n===s)return e;const{ids:r}=n,{rank:o,ids:a}=s,c=new t(o);for(let l=0;l<o;++l){const u=a[l],d=r.indexOf(u);c[l]=d===-1?i(l):e[d]}return c}class hm extends pn{constructor(){super(...arguments),this.value=fn(new tl(this.peer.coordinateSpace),this.peer,this.link,{assign:(e,n)=>e.assign(n),difference:(e,n)=>{const{factors:s}=e.value,i=e.coordinateSpace.value,r=n.value.factors;return{coordinateSpace:i,offsets:fs(new Float64Array(s.length),s,r)}},add:(e,n,s)=>{const i=qi(Float64Array,s.offsets,s.coordinateSpace,e.coordinateSpace.value,()=>0);e.setFactors(Pi(new Float64Array(i.length),i,n.value.factors))},subtract:(e,n,s)=>{const i=qi(Float64Array,s.offsets,s.coordinateSpace,e.coordinateSpace.value,()=>0);e.setFactors(fs(new Float64Array(i.length),n.value.factors,i))},isValid:()=>!0})}}function Qi(t,e,n){const{rank:s,names:i,units:r}=t,{displayRank:o,displayDimensionIndices:a}=e,c=new Float64Array(3),l=new Float64Array(3);let u;const{factors:d}=n,h=new Array(3),p=new Float64Array(3);if(c.fill(1),l.fill(1),p.fill(1),h.fill(""),o===0)u=1;else{u=Number.POSITIVE_INFINITY;const{scales:m}=t;for(let f=0;f<o;++f){const b=a[f],I=l[f]=d[b]*m[b];u=Math.min(u,I),h[f]=r[b],p[f]=m[b]}for(let f=0;f<o;++f)c[f]=l[f]/u}return{globalRank:s,globalDimensionNames:i,displayRank:o,displayDimensionIndices:a,displayDimensionUnits:h,displayDimensionScales:p,canonicalVoxelFactors:c,voxelPhysicalScales:l,canonicalVoxelPhysicalSize:u}}function Xi(t,e){return kt(t.globalDimensionNames,e.globalDimensionNames)&&kt(t.displayDimensionIndices,e.displayDimensionIndices)&&kt(t.canonicalVoxelFactors,e.canonicalVoxelFactors)&&kt(t.voxelPhysicalScales,e.voxelPhysicalScales)&&t.canonicalVoxelPhysicalSize===e.canonicalVoxelPhysicalSize&&kt(t.displayDimensionUnits,e.displayDimensionUnits)&&kt(t.displayDimensionScales,e.displayDimensionScales)}function Is(t,e){const n=t.displayDimensionRenderInfo;return n===e?!0:Xi(n,e)?(t.displayDimensionRenderInfo=e,!0):!1}class fm extends J.O8{constructor(e,n){super(),this.relativeDisplayScales=e,this.displayDimensions=n,this.changed=new ve.IY,this.curRelativeDisplayScales=this.relativeDisplayScales.value,this.curDisplayDimensions=this.displayDimensions.value,this.curCoordinateSpace=this.relativeDisplayScales.coordinateSpace.value,this.value_=Qi(this.curCoordinateSpace,this.curDisplayDimensions,this.curRelativeDisplayScales),this.registerDisposer(e),this.registerDisposer(n);const s=()=>{this.value};this.registerDisposer(e.changed.add(s)),this.registerDisposer(n.changed.add(s))}get value(){const{relativeDisplayScales:{value:e,coordinateSpace:{value:n}},displayDimensions:{value:s},curRelativeDisplayScales:i,curDisplayDimensions:r,curCoordinateSpace:o}=this;let a=this.value_;if(i!==e||r!==s||o!==n){this.curRelativeDisplayScales=e,this.curDisplayDimensions=s,this.curCoordinateSpace=n;const c=Qi(n,s,e);Xi(a,c)||(this.value_=a=c,this.changed.dispatch())}return a}}class nl extends J.O8{constructor(e){super(),this.coordinateSpace=e,this.changed=new ve.IY,this.default_=!0,this.value_=void 0,this.registerDisposer(this.coordinateSpace.changed.add(this.changed.dispatch)),this.update()}get value(){return this.update(),this.value_}update(){const{coordinateSpace:{value:e}}=this,n=this.value_;if(n!==void 0&&n.coordinateSpace===e)return;if(n===void 0||this.default_){this.setToDefault(e);return}const s=new Int32Array(3),{ids:i}=n.coordinateSpace,{ids:r}=e,o=n.displayDimensionIndices,a=n.displayRank;let c=0;for(let l=0;l<a;++l){const u=r.indexOf(i[o[l]]);u!==-1&&(s[c]=u,++c)}if(s.fill(-1,c),c===0){this.default_=!0,this.setToDefault(e);return}this.assignValue(e,c,s),this.changed.dispatch()}setToDefault(e){const n=Math.min(e.rank,3),s=new Int32Array(3);s.fill(-1);for(let i=0;i<n;++i)s[i]=i;this.assignValue(e,n,s)}assignValue(e,n,s){this.value_={coordinateSpace:e,displayRank:n,displayDimensionIndices:s},this.changed.dispatch()}reset(){this.default_=!0,this.value_=void 0,this.changed.dispatch()}restoreState(e){if(e===void 0){this.reset();return}const n=Bi(e);if(n.length>3)throw new Error("Number of spatial dimensions must be <= 3");const{coordinateSpace:{value:s}}=this,i=new Int32Array(3);i.fill(-1);const{names:r}=s;let o=0;for(const a of n){const c=r.indexOf(a);c!==-1&&(i[o++]=c)}if(o===0){this.reset();return}this.default_=!1,this.assignValue(s,o,i)}get default(){return this.update(),this.default_}set default(e){this.default_!==e&&(e?(this.default_=!0,this.setToDefault(this.coordinateSpace.value)):(this.default_=!1,this.changed.dispatch()))}setDimensionIndices(e,n){this.default_=!1,this.assignValue(this.coordinateSpace.value,e,n)}toJSON(){if(this.default_)return;const{value:e}=this,n=[],{displayRank:s,displayDimensionIndices:i,coordinateSpace:{names:r}}=e;if(s!==0){for(let o=0;o<s;++o)n[o]=r[i[o]];return n}}assign(e){if(e.default)this.default=!0;else{const{displayRank:n,displayDimensionIndices:s}=e.value;this.setDimensionIndices(n,s)}}}class pm extends Ki{constructor(){super(...arguments),this.value=Ji(new nl(this.peer.coordinateSpace),this.peer,this.link,{assign:(e,n)=>e.assign(n),isValid:()=>!0})}}class mm extends J.O8{constructor(e,n,s){super(),this.position=e,this.displayDimensionRenderInfo=n,this.orientation=s,this.changed=new ve.IY,this.registerDisposer(e),this.registerDisposer(s),this.registerDisposer(n),this.registerDisposer(e.changed.add(this.changed.dispatch)),this.registerDisposer(s.changed.add(this.changed.dispatch)),this.registerDisposer(n.changed.add(this.changed.dispatch))}get displayDimensions(){return this.displayDimensionRenderInfo.displayDimensions}get relativeDisplayScales(){return this.displayDimensionRenderInfo.relativeDisplayScales}get valid(){return this.position.valid}reset(){this.position.reset(),this.orientation.reset(),this.displayDimensions.reset()}updateDisplayPosition(e,n=Un){const{coordinateSpace:{value:s},value:i}=this.position,{displayDimensionIndices:r,displayRank:o}=this.displayDimensions.value;if(s===void 0)return!1;n.fill(0);for(let a=0;a<o;++a){const c=r[a];n[a]=i[c]}if(e(n)!==!1){for(let a=0;a<o;++a){const c=r[a];i[c]=n[a]}return this.position.changed.dispatch(),!0}return!1}toMat4(e,n){w.pB.fromQuat(e,this.orientation.orientation);const{value:s}=this.position,{canonicalVoxelFactors:i,displayDimensionIndices:r}=this.displayDimensionRenderInfo.value;for(let o=0;o<3;++o){const a=r[o],c=n/i[o];e[o]*=c,e[4+o]*=c,e[8+o]*=c,e[12+o]=s[a]||0}}toMat3(e,n){w.w0.fromQuat(e,this.orientation.orientation);const{canonicalVoxelFactors:s,displayRank:i}=this.displayDimensionRenderInfo.value;for(let r=0;r<i;++r){const o=n/s[r];e[r]*=o,e[3+r]*=o,e[6+r]*=o}}snap(){this.orientation.snap(),this.position.snapToVoxel(),this.changed.dispatch()}translateDimensionRelative(e,n){if(!this.valid)return;const{position:s}=this,{value:i}=s,{bounds:r}=s.coordinateSpace.value;i[e]=Ni(r,e,i[e]+n),s.changed.dispatch()}translateVoxelsRelative(e){if(!this.valid)return;const n=w.eR.transformQuat(Un,e,this.orientation.orientation),{position:s}=this,{value:i}=s,{displayDimensionIndices:r,displayRank:o}=this.displayDimensions.value,{bounds:a}=s.coordinateSpace.value;for(let c=0;c<o;++c){const l=r[c],u=n[c];u!==0&&(i[l]=Ni(a,l,i[l]+u))}this.position.changed.dispatch()}rotateRelative(e,n){const s=w.Yu.create();w.Yu.setAxisAngle(s,e,n);const i=this.orientation.orientation;w.Yu.multiply(i,i,s),this.orientation.changed.dispatch()}rotateAbsolute(e,n,s){const{coordinateSpace:{value:i},value:r}=this.position;if(i===void 0)return;const{relativeDisplayScales:{value:{factors:o}},displayDimensions:{value:{displayDimensionIndices:a,displayRank:c}}}=this,{scales:l}=i,u=w.Yu.create();w.Yu.setAxisAngle(u,e,n);const d=this.orientation.orientation,h=Un;Un.fill(0);for(let m=0;m<c;++m){const f=a[m],b=s[f]-r[f];h[m]=b*l[f]*o[f]}const p=w.Yu.invert(Yi,d);w.eR.transformQuat(h,h,p),w.Yu.multiply(d,u,d),w.eR.transformQuat(h,h,d);for(let m=0;m<c;++m){const f=a[m];r[f]=s[f]-h[m]/(l[f]*o[f])}this.position.changed.dispatch(),this.orientation.changed.dispatch()}translateNonDisplayDimension(e,n){if(!this.valid)return;const{displayDimensionIndices:s}=this.displayDimensions.value,{position:i}=this,r=i.coordinateSpace.value.rank;for(let o=0;o<r;++o)if(s.indexOf(o)===-1&&e--===0){this.translateDimensionRelative(o,n);return}}}class gm extends pn{constructor(e,n){super(e),this.value=(()=>{const s=new e.constructor(n),i=(l,u)=>{l.assign(u)},r=(l,u)=>l.value/u.value*(l.canonicalVoxelPhysicalSize/u.canonicalVoxelPhysicalSize),o=(l,u,d)=>{l.setPhysicalScale(u.value*d,u.canonicalVoxelPhysicalSize)},a=(l,u,d)=>{l.setPhysicalScale(u.value/d,u.canonicalVoxelPhysicalSize)},c=l=>l.coordinateSpaceValue.valid&&l.canonicalVoxelPhysicalSize!==0;return fn(s,this.peer,this.link,{assign:i,isValid:c,difference:r,add:o,subtract:a}),s})()}}function ym(t){return{changed:t.changed,toJSON(){return t.toJSON()},restoreState(e){Wi(t.link,t.value.legacyJsonView,e)},reset(){t.reset()}}}class vm extends J.O8{constructor(e){super(),this.displayDimensionRenderInfo=e,this.changed=new ve.IY,this.curCanonicalVoxelPhysicalSize=0,this.value_=Number.NaN,this.legacyValue_=Number.NaN,this.registerDisposer(e),this.registerDisposer(e.changed.add(()=>this.handleCoordinateSpaceChanged())),this.registerDisposer(e.relativeDisplayScales.coordinateSpace.changed.add(()=>this.handleCoordinateSpaceChanged())),this.handleCoordinateSpaceChanged()}get value(){return this.handleCoordinateSpaceChanged(),this.value_}set value(e){const{canonicalVoxelPhysicalSize:n}=this;Object.is(e,this.value_)&&n===this.curCanonicalVoxelPhysicalSize||(this.curCanonicalVoxelPhysicalSize=n,this.legacyValue_=Number.NaN,this.value_=e,this.changed.dispatch())}get canonicalVoxelPhysicalSize(){return this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize}get coordinateSpaceValue(){return this.displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace.value}set legacyValue(e){Object.is(e,this.legacyValue_)||(this.value_=Number.NaN,this.legacyValue_=e,this.curCanonicalVoxelPhysicalSize=0,this.changed.dispatch())}get legacyValue(){return this.legacyValue_}handleCoordinateSpaceChanged(){const{value_:e}=this,{displayDimensionRenderInfo:{value:{canonicalVoxelPhysicalSize:n},relativeDisplayScales:{coordinateSpace:{value:s}}}}=this,{curCanonicalVoxelPhysicalSize:i}=this;if(!(!Number.isNaN(e)&&n===i)){if(!Number.isNaN(e)){i!==0&&(this.value_=e*(i/n),this.curCanonicalVoxelPhysicalSize=n,this.changed.dispatch());return}!s.valid||n===0||(this.curCanonicalVoxelPhysicalSize=n,this.value_=this.getDefaultValue(),this.changed.dispatch())}}toJSON(){const{value:e}=this;return Number.isNaN(e)?void 0:e}restoreState(e){this.curCanonicalVoxelPhysicalSize=0,this.legacyValue_=Number.NaN,e===void 0?this.value_=Number.NaN:this.value_=(0,k.Mo)(e),this.changed.dispatch()}reset(){this.curCanonicalVoxelPhysicalSize=0,this.value_=Number.NaN,this.legacyValue_=Number.NaN,this.changed.dispatch()}get legacyJsonView(){const e=this;return{changed:e.changed,toJSON(){return e.toJSON()},reset(){return e.reset()},restoreState(n){e.legacyValue=(0,k.Mo)(n)}}}setPhysicalScale(e,n){const s=this.curCanonicalVoxelPhysicalSize=this.canonicalVoxelPhysicalSize;this.value=e*(n/s)}assign(e){const{legacyValue:n}=e;Number.isNaN(n)?this.setPhysicalScale(e.value,e.canonicalVoxelPhysicalSize):this.legacyValue=n}}class wm extends null{getDefaultValue(){const{legacyValue_:e}=this;if(Number.isNaN(e))return 1;const{canonicalVoxelPhysicalSize:n}=this;return this.legacyValue_*1e-9/n}}class Sm extends null{getDefaultValue(){const{legacyValue_:e}=this;if(!Number.isNaN(e)){this.legacyValue_=Number.NaN;const{canonicalVoxelPhysicalSize:a}=this;return 200*Math.tan(Math.PI/8)*1e-9*e/a}const{coordinateSpaceValue:{bounds:{lowerBounds:n,upperBounds:s}}}=this,{canonicalVoxelFactors:i,displayDimensionIndices:r}=this.displayDimensionRenderInfo.value;let o=i.reduce((a,c,l)=>{const u=r[l],d=(s[u]-n[u])*c;return Math.max(a,d)},0);return Number.isFinite(o)?o=2**Math.ceil(Math.log2(o)):o=1024,o}}class sl extends J.O8{constructor(e,n){super(),this.defaultValue=e,this.displayDimensionRenderInfo=n,this.changed=new ve.IY,this.value_=e,this.canonicalVoxelPhysicalSize=n.value.canonicalVoxelPhysicalSize,this.registerDisposer(n.changed.add(()=>{this.value}))}get value(){let{value_:e}=this;if(e>0){const{canonicalVoxelPhysicalSize:n}=this.displayDimensionRenderInfo.value,s=this.canonicalVoxelPhysicalSize;n!==s&&(this.canonicalVoxelPhysicalSize=n,e=this.value_=e=s/n,this.changed.dispatch())}return e}set value(e){if(e===this.value)return;this.value_=e;const{canonicalVoxelPhysicalSize:n}=this.displayDimensionRenderInfo.value;this.canonicalVoxelPhysicalSize=n,this.changed.dispatch()}toJSON(){const{value:e}=this;if(e!==this.defaultValue)return e}reset(){this.value=this.defaultValue}restoreState(e){typeof e!="number"||!Number.isFinite(e)||e===0?this.value=this.defaultValue:this.value=e}setValueAbsolute(e,n){if(e>0){const{canonicalVoxelPhysicalSize:s}=this.displayDimensionRenderInfo.value;e=e*(n/s)}this.value=e}assign(e){this.setValueAbsolute(e.value,e.canonicalVoxelPhysicalSize)}}class bm extends Ki{constructor(e,n){super(e),this.value=Ji(new sl(e.defaultValue,n),this.peer,this.link,{assign:(s,i)=>s.assign(i),isValid:()=>!0})}}class Im extends J.O8{constructor(e,n,s){super(),this.pose=e,this.zoomFactor=n,this.depthRange=s,this.changed=new ve.IY,this.registerDisposer(e),this.registerDisposer(n),this.registerDisposer(s),this.registerDisposer(this.pose.changed.add(this.changed.dispatch)),this.registerDisposer(this.zoomFactor.changed.add(this.changed.dispatch)),this.registerDisposer(this.depthRange.changed.add(this.changed.dispatch))}get coordinateSpace(){return this.pose.position.coordinateSpace}reset(){this.pose.reset(),this.zoomFactor.reset()}get position(){return this.pose.position}get displayDimensions(){return this.pose.displayDimensions}get relativeDisplayScales(){return this.pose.relativeDisplayScales}get displayDimensionRenderInfo(){return this.pose.displayDimensionRenderInfo}toMat4(e){this.pose.toMat4(e,this.zoomFactor.value)}toMat3(e){this.pose.toMat3(e,this.zoomFactor.value)}get relativeDepthRange(){let e=this.depthRange.value;return e>0?e/=this.zoomFactor.value:e*=-1,e}get valid(){return this.pose.valid&&!Number.isNaN(this.zoomFactor.value)}zoomBy(e){this.zoomFactor.value*=e}}var Zi=x(5716),il=x(4104);/**
 * @license
 * Copyright 2024 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var rl=(t=>(t[t.MEDIAN=0]="MEDIAN",t[t.MEAN=1]="MEAN",t[t.MAX=2]="MAX",t))(rl||{});class ol{constructor(e=10,n=10){if(this.numStoredTimes=e,this.queryPoolSize=n,this.timeElapsedQueries=[],this.warnedAboutMissingExtension=!1,this.storedTimeDeltas=[],this.queryPoolSize<1)throw new Error(`Query pool size must be at least 1, but got ${n}.`)}getTimingExtension(e){const n=e.getExtension("EXT_disjoint_timer_query_webgl2");return n===null&&!this.warnedAboutMissingExtension&&(console.log("EXT_disjoint_timer_query_webgl2 extension not available. Cannot measure frame time."),this.warnedAboutMissingExtension=!0),n}startFrameTimeQuery(e,n){if(n===null)return null;const s=e.createQuery();return s!==null&&e.beginQuery(n.TIME_ELAPSED_EXT,s),s}endFrameTimeQuery(e,n,s){if(n!==null&&s!==null&&e.endQuery(n.TIME_ELAPSED_EXT),this.timeElapsedQueries.length>=this.queryPoolSize){const i=this.timeElapsedQueries.shift();i!=null&&e.deleteQuery(i)}this.timeElapsedQueries.push(s)}grabAnyFinishedQueryResults(e){const n=[];for(let s=0;s<this.timeElapsedQueries.length;s++){const i=this.timeElapsedQueries[s];if(i!==null&&e.getQueryParameter(i,e.QUERY_RESULT_AVAILABLE)){const o=e.getQueryParameter(i,e.QUERY_RESULT)/1e6;this.storedTimeDeltas.push(o),e.deleteQuery(i),n.push(s)}}for(let s=n.length-1;s>=0;s--)this.timeElapsedQueries.splice(s,1);this.storedTimeDeltas.length>this.numStoredTimes&&(this.storedTimeDeltas=this.storedTimeDeltas.slice(-this.numStoredTimes))}getLastFrameTimesInMs(e=10){return this.storedTimeDeltas.slice(-e)}getQueries(){return this.timeElapsedQueries}}class Cm{constructor(e=10,n=8,s=16.666666666666668,i=15){this.numberOfStoredFrameDeltas=e,this.maxDownsamplingFactor=n,this.desiredFrameTimingMs=s,this.downsamplingPersistenceDurationInFrames=i,this.lastFrameTime=null,this.frameDeltas=[],this.downsamplingRates=new Map,this.frameCount=0,this.validateConstructorArguments();for(let r=1;r<=this.maxDownsamplingFactor;r*=2)this.downsamplingRates.set(r,-1/0)}validateConstructorArguments(){this.numberOfStoredFrameDeltas=Math.max(1,Math.round(this.numberOfStoredFrameDeltas)),this.maxDownsamplingFactor=Math.max(2,Math.round(this.maxDownsamplingFactor))}storeFrameDelta(e){this.frameDeltas.push(e),this.frameDeltas.length>this.numberOfStoredFrameDeltas&&this.frameDeltas.shift()}calculateMeanFrameTime(){return this.frameDeltas.reduce((e,n)=>e+n,0)/this.frameDeltas.length}calculateMedianFrameTime(){const e=this.frameDeltas.slice().sort((s,i)=>s-i),n=Math.floor(e.length/2);return e.length%2===1?e[n]:(e[n-1]+e[n])/2}calculateMaxFrameTime(){return Math.max(...this.frameDeltas)}updateMaxTrackedDownsamplingRate(e){this.downsamplingRates.set(e,this.frameCount);let n=1;for(const[s,i]of this.downsamplingRates)this.frameCount-i<=this.downsamplingPersistenceDurationInFrames&&(n=s);return n}resetForNewFrameSet(){this.lastFrameTime=null,this.frameCount=0,this.downsamplingRates.forEach((e,n)=>{this.downsamplingRates.set(n,-1/0)})}addFrame(e=Date.now()){if(this.lastFrameTime!==null){const n=e-this.lastFrameTime;n>0&&this.storeFrameDelta(n)}this.lastFrameTime=e,this.frameCount++}calculateFrameTimeInMs(e=2){if(this.frameDeltas.length===0)return 0;switch(e){case 0:return this.calculateMedianFrameTime();case 1:return this.calculateMeanFrameTime();case 2:return this.calculateMaxFrameTime()}}calculateDownsamplingRate(e=1){const n=this.calculateFrameTimeInMs(e);if(n===0)return Math.min(4,this.maxDownsamplingFactor);let s=Math.max(n/this.desiredFrameTimingMs,1);return s=Math.min(Math.pow(2,Math.round(Math.log2(s))),this.maxDownsamplingFactor),this.updateMaxTrackedDownsamplingRate(s)}getFrameDeltas(){return this.frameDeltas}getFrameCount(){return this.frameCount}getDownsamplingRates(){return this.downsamplingRates}setFrameDeltas(e,n=!0){this.frameDeltas=e.slice(-this.numberOfStoredFrameDeltas),n&&this.frameCount++}}var al=x(310);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const cl=300;class er{constructor(){this.width=0,this.height=0,this.logicalWidth=0,this.logicalHeight=0,this.visibleLeftFraction=0,this.visibleTopFraction=0,this.visibleWidthFraction=0,this.visibleHeightFraction=0}}function Em(t,e){const n=1/t.visibleWidthFraction,s=1/t.visibleHeightFraction,i=-1-(-1+2*t.visibleLeftFraction)*n;let r=-1-(-1+2*t.visibleTopFraction)*s;r=-r,e[0]=e[0]*n+e[3]*i,e[4]=e[4]*n+e[7]*i,e[8]=e[8]*n+e[11]*i,e[12]=e[12]*n+e[15]*i,e[1]=e[1]*s+e[3]*r,e[5]=e[5]*s+e[7]*r,e[9]=e[9]*s+e[11]*r,e[13]=e[13]*s+e[15]*r}function km(t,e){return t.width===e.width&&t.height===e.height&&t.logicalWidth===e.logicalWidth&&t.logicalHeight===e.logicalHeight&&t.visibleLeftFraction===e.visibleLeftFraction&&t.visibleTopFraction===e.visibleTopFraction}class ll extends J.O8{constructor(e,n,s){super(),this.context=e,this.element=n,this.visibility=s,this.boundsGeneration=-1,this.canvasRelativeClippedLeft=0,this.canvasRelativeClippedTop=0,this.canvasRelativeLogicalLeft=0,this.canvasRelativeLogicalTop=0,this.renderViewport=new er,this.monitorState={},this.gl=e.gl,e.addPanel(this)}scheduleRedraw(){this.visible&&this.context.scheduleRedraw()}ensureBoundsUpdated(){const{context:e}=this;e.ensureBoundsUpdated();const{boundsGeneration:n}=e;if(n===this.boundsGeneration)return;this.boundsGeneration=n;const{element:s}=this,i=s.getBoundingClientRect();e.ensureMonitorPanel(s,this.monitorState,i);const r=e.container,o=e.canvasRect,{canvas:a}=e,{width:c,height:l}=a,u=c/o.width,d=l/o.height,h=o.left,p=o.top,m=this.canvasRelativeLogicalLeft=Math.round((i.left-h)*u+s.clientLeft),f=this.canvasRelativeLogicalTop=Math.round((i.top-p)*d+s.clientTop),b=s.clientWidth,I=s.clientHeight,E=m+b,V=f+I;let R=f,C=m,S=E,T=V;for(let y=s.parentElement;y!==null&&y!==r;y=y.parentElement){const A=y.getBoundingClientRect();A.x===0&&A.y===0&&A.width===0&&A.height===0||(C=Math.max(C,(A.left-h)*u),R=Math.max(R,(A.top-p)*d),S=Math.min(S,(A.right-h)*u),T=Math.min(T,(A.bottom-p)*d))}R=this.canvasRelativeClippedTop=Math.round(Math.max(R,0)),C=this.canvasRelativeClippedLeft=Math.round(Math.max(C,0)),S=Math.round(Math.min(S,c)),T=Math.round(Math.min(T,l));const v=this.renderViewport,N=v.width=Math.max(0,S-C),H=v.height=Math.max(0,T-R);v.logicalWidth=b,v.logicalHeight=I,v.visibleLeftFraction=(C-m)/b,v.visibleTopFraction=(R-f)/I,v.visibleWidthFraction=N/b,v.visibleHeightFraction=H/I}setGLClippedViewport(){const{gl:e,canvasRelativeClippedTop:n,canvasRelativeClippedLeft:s,renderViewport:{width:i,height:r}}=this,o=n+r;e.enable(WebGL2RenderingContext.SCISSOR_TEST);const a=this.context.canvas.height-o;e.viewport(s,a,i,r),e.scissor(s,a,i,r)}setGLLogicalViewport(){const{gl:e,renderViewport:{width:n,height:s,logicalWidth:i,logicalHeight:r}}=this,o=this.context.canvas.height;e.enable(WebGL2RenderingContext.SCISSOR_TEST),e.viewport(this.canvasRelativeLogicalLeft,o-(this.canvasRelativeLogicalTop+r),i,r),e.scissor(this.canvasRelativeClippedLeft,o-(this.canvasRelativeClippedTop+s),n,s)}disposed(){this.context.unmonitorPanel(this.element,this.monitorState),this.context.removePanel(this),super.disposed()}get visible(){return this.visibility.visible}getDepthArray(){}get shouldDraw(){if(!this.visible)return!1;const{element:e}=this;return!(e.clientWidth===0||e.clientHeight===0||e.offsetWidth===0||e.offsetHeight===0)}get drawOrder(){return 0}}class Tm extends ll{constructor(e,n,s){super(e,n,s),this.canvas=document.createElement("canvas"),this.canvasRenderingContext=this.canvas.getContext("2d");const{canvas:i}=this;n.appendChild(i),n.style.position="relative",i.style.position="absolute",i.style.left="0",i.style.right="0",i.style.top="0",i.style.bottom="0"}draw(){this.drawIndirect();const{renderViewport:e,canvas:n}=this,{logicalWidth:s,logicalHeight:i}=e;n.width=s,n.height=i;const{canvasRenderingContext:r}=this;r?.drawImage(this.context.canvas,this.canvasRelativeLogicalLeft,this.canvasRelativeLogicalTop,s,i,0,0,s,i)}}class Dm extends me.DN{constructor(){super(Float64Array.of(0,0,1,1),e=>(0,k.Xu)(new Float64Array(4),e,k.xU))}toJSON(){const{value:e}=this,[n,s,i,r]=e;if(!(n===0&&s===0&&i===1&&r===1))return Array.from(e)}}class Pm extends J.O8{constructor(e){super(),this.container=e,this.canvas=document.createElement("canvas"),this.updateStarted=new ve.IY,this.updateFinished=new ve.IY,this.continuousCameraMotionStarted=new ve.IY,this.continuousCameraMotionFinished=new ve.IY,this.changed=this.updateFinished,this.panels=new Set,this.resizeGeneration=0,this.boundsGeneration=-1,this.framerateMonitor=new ol,this.continuousCameraMotionInProgress=!1,this.orderedPanels=[],this.frameNumber=0,this.resizeCallback=()=>{++this.resizeGeneration,this.scheduleRedraw()},this.resizeObserver=new ResizeObserver(this.resizeCallback),this.debouncedEndContinuousCameraMotion=this.registerCancellable((0,Zi.A)(()=>{this.continuousCameraMotionInProgress=!1,this.continuousCameraMotionFinished.dispatch()},cl)),this.scheduleRedraw=this.registerCancellable((0,il.t)(()=>this.draw()));const{canvas:n,resizeObserver:s}=this;e.style.position="relative",n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.style.width="100%",n.style.height="100%",n.style.zIndex="0",s.observe(n),e.appendChild(n),this.registerEventListener(n,"webglcontextlost",i=>{console.log(`Lost WebGL context: ${i.statusMessage}`),i.preventDefault()}),this.registerEventListener(n,"webglcontextrestored",()=>{console.log("WebGL context restored"),window.location.reload()}),this.gl=(0,al.y)(n)}ensureMonitorPanel(e,n,s){n.addedToResizeObserver||(this.resizeObserver.observe(e),n.addedToResizeObserver=!0);const i=this.rootRect,r=i.top-s.top,o=i.left-s.left,a=s.right-i.right,c=s.bottom-i.bottom,l=`${r}px ${a}px ${c}px ${o}px`;n.intersectionObserverMargin!==l&&(n.intersectionObserverMargin=l,n.intersectionObserver?.disconnect(),(n.intersectionObserver=new IntersectionObserver(this.resizeCallback,{root:this.container,rootMargin:l,threshold:[.93,.94,.95,.96,.97,.98,.99,1]})).observe(e))}unmonitorPanel(e,n){n.addedToResizeObserver&&this.resizeObserver.unobserve(e),n.intersectionObserver?.disconnect()}flagContinuousCameraMotion(){this.continuousCameraMotionInProgress||this.continuousCameraMotionStarted.dispatch(),this.continuousCameraMotionInProgress=!0,this.debouncedEndContinuousCameraMotion()}get isContinuousCameraMotionInProgress(){return this.continuousCameraMotionInProgress}applyWindowedViewportToElement(e,n){const[s,i,r,o]=n,a=1/r,c=1/o;e.style.position="absolute",e.style.top=`${-c*i*100}%`,e.style.left=`${-a*s*100}%`,e.style.width=`${a*100}%`,e.style.height=`${c*100}%`,++this.resizeGeneration,this.scheduleRedraw()}isReady(){for(const e of this.panels)if(e.visible&&!e.isReady())return!1;return!0}makeCanvasOverlayElement(){const e=document.createElement("div");return e.style.position="absolute",e.style.top="0px",e.style.left="0px",e.style.width="100%",e.style.height="100%",e.style.zIndex="2",this.container.appendChild(e),e}disposed(){this.orderedPanels.length=0,this.resizeObserver.disconnect()}addPanel(e){this.panels.add(e),this.orderedPanels.length=0,++this.resizeGeneration,this.scheduleRedraw()}removePanel(e){this.panels.delete(e),this.orderedPanels.length=0,++this.resizeGeneration,this.scheduleRedraw()}ensureBoundsUpdated(){const{resizeGeneration:e}=this;if(this.boundsGeneration===e)return;const{canvas:n}=this;n.width=n.offsetWidth,n.height=n.offsetHeight,this.canvasRect=n.getBoundingClientRect(),this.rootRect=this.container.getBoundingClientRect(),this.boundsGeneration=e}draw(){++this.frameNumber,this.updateStarted.dispatch();const e=this.gl,n=this.framerateMonitor.getTimingExtension(e),s=this.framerateMonitor.startFrameTimeQuery(e,n);this.ensureBoundsUpdated(),this.gl.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);const{orderedPanels:i,panels:r}=this;i.length!==r.size&&(i.push(...r),i.sort((o,a)=>o.drawOrder-a.drawOrder));for(const o of i){if(!o.shouldDraw)continue;o.ensureBoundsUpdated();const{renderViewport:a}=o;a.width===0||a.height===0||o.draw()}e.disable(e.SCISSOR_TEST),this.gl.clearColor(1,1,1,1),this.gl.colorMask(!1,!1,!1,!0),e.clear(e.COLOR_BUFFER_BIT),this.gl.colorMask(!0,!0,!0,!0),this.updateFinished.dispatch(),this.framerateMonitor.endFrameTimeQuery(e,n,s),this.framerateMonitor.grabAnyFinishedQueryResults(e)}getDepthArray(){const{width:e,height:n}=this.canvas,s=new Float32Array(e*n);for(const i of this.panels){if(!i.shouldDraw)continue;const r=i.getDepthArray();if(r===void 0)continue;const{canvasRelativeClippedTop:o,canvasRelativeClippedLeft:a,renderViewport:{width:c,height:l}}=i;for(let u=0;u<l;++u){const d=(l-1-u)*c;s.set(r.subarray(d,d+c),(o+u)*c+a)}}return s}getLastFrameTimesInMs(e=10){return this.framerateMonitor.getLastFrameTimesInMs(e)}}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ul extends er{constructor(){super(...arguments),this.globalPosition=ps,this.projectionMat=w.pB.create(),this.viewMatrix=w.pB.create(),this.invViewMatrix=w.pB.create(),this.viewProjectionMat=w.pB.create(),this.invViewProjectionMat=w.pB.create()}}function Mm(t,e){return t.displayDimensionRenderInfo===e.displayDimensionRenderInfo&&renderViewportsEqual(t,e)&&arraysEqual(t.globalPosition,e.globalPosition)&&arraysEqual(t.projectionMat,e.projectionMat)&&arraysEqual(t.viewMatrix,e.viewMatrix)}function Rm(t){const{viewMatrix:e,viewProjectionMat:n}=t;mat4.invert(e,t.invViewMatrix),mat4.multiply(n,t.projectionMat,e),mat4.invert(t.invViewProjectionMat,n)}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _m={channelCoordinateSpace:Ec,shape:new Uint32Array(0),numChannels:1,coordinates:new Uint32Array(0)};function Om(t){const{rank:e}=t,{bounds:{lowerBounds:n,upperBounds:s}}=t;if(n.some(a=>a!==0))throw new Error("Lower bounds of channel coordinate space must all be 0");if(s.some(a=>!Number.isInteger(a)||a<=0||a>=4294967296))throw new Error("Upper bounds of channel coordinate space must all be positive integers");const i=new Uint32Array(s),r=prod(i),o=new Uint32Array(r*e);for(let a=0;a<r;++a){let c=a;for(let l=0;l<e;++l){const u=c%i[l];c=(c-u)/i[l],o[a*e+l]=u}}return{channelCoordinateSpace:t,shape:i,numChannels:r,coordinates:o}}function Cs(t,e,n,s,i,r){const{scales:o}=n,{scales:a,rank:c}=i,l=e+1;for(let u=0;u<c;++u){const d=r[u];if(d===-1)continue;const h=a[u];for(let p=0;p<e;++p){const m=s[p],f=o[m];t[l*p+d]*=f/h}}}function dl(t,e,n,s,i=emptyValidCoordinateSpace){const{inputSpace:r,rank:o,sourceRank:a,outputSpace:c,transform:l}=n,{names:u}=r,{names:d}=c;let h;if(s!==void 0)h=Array.from(s.modelSubspaceDimensionIndices);else{h=[];for(let L=0;L<a;++L)h[L]=L}const p=h.length;for(let L=a;L<o;++L)h.push(L);const m=getDependentTransformInputDimensions(n.transform,o,h,!0),f=h.length,b=h.map(L=>u[L]||`${L}`),I=m.map(L=>d[L]);if(f!==m.length)return{error:"Rank mismatch between model subspace dimensions ("+b.join(", ")+") and corresponding layer/global dimensions ("+I.join(", ")+")"};let E=homogeneousTransformSubmatrix(Float32Array,l,o,m,h);const V=m.map(L=>d[L]),R=e.names.map(L=>V.indexOf(L)),C=t.names.map(L=>V.indexOf(L));Cs(E,f,r,h,t,C),Cs(E,f,r,h,e,R);const S=i.names.map(L=>V.indexOf(L));Cs(E,f,r,h,i,S);const T=[],v=i.rank;if(s!==void 0){let{subsourceToModelSubspaceTransform:L}=s;p!==f&&(L=matrix.extendHomogeneousTransform(new Float32Array((f+1)**2),f,L,p)),E=matrix.multiply(new Float32Array((f+1)**2),f+1,E,f+1,L,f+1,f+1,f+1,f+1)}const N=new Uint32Array(v),{lowerBounds:H,upperBounds:y,voxelCenterAtIntegerCoordinates:A}=i.bounds;for(let L=0;L<v;++L){let Y=H[L],le=y[L];if(A[L]&&(Y+=.5,le+=.5),Y!==0||!Number.isInteger(le)||le<=0||le>=4294967296)return{error:`Channel dimension ${i.names[L]} must have lower bound of 0 and positive integer upper bound; current bounds are [${Y}, ${le}]`};N[L]=le;const we=S[L];let pe=-1;if(we!==-1)for(let $e=0;$e<f;++$e){const Fe=E[we+$e*(f+1)];if(Fe!==0){if(Fe!==1||pe!==-1)return{error:`Channel dimension ${I[we]} must map to a single source dimension`};pe=$e}}T[L]=pe}return{rank:f,unpaddedRank:p,modelDimensionNames:b,layerDimensionNames:I,localToRenderLayerDimensions:R,globalToRenderLayerDimensions:C,channelToRenderLayerDimensions:S,modelToRenderLayerTransform:E,channelToModelDimensions:T,channelSpaceShape:N}}function hl(t,e){return t===e?!0:t.error!==void 0||e.error!==void 0?!1:arraysEqual(t.modelDimensionNames,e.modelDimensionNames)&&arraysEqual(t.layerDimensionNames,e.layerDimensionNames)&&arraysEqual(t.globalToRenderLayerDimensions,e.globalToRenderLayerDimensions)&&arraysEqual(t.localToRenderLayerDimensions,e.localToRenderLayerDimensions)&&arraysEqual(t.channelToRenderLayerDimensions,e.channelToRenderLayerDimensions)&&arraysEqual(t.modelToRenderLayerTransform,e.modelToRenderLayerTransform)&&arraysEqual(t.channelSpaceShape,e.channelSpaceShape)}function Nm(t,e,n,s,i){return makeCachedDerivedWatchableValue((r,o,a,c)=>dl(r,o,a,s,c),[t,e,n,i===void 0?constantWatchableValue(void 0):i],hl)}function xm(t,e,n,s){const{globalToRenderLayerDimensions:i}=n;for(let r=0;r<3;++r){let o=0;const a=s[r];if(a!==-1){const c=i[a];c!==-1&&(o=e[c])}t[r]=o}}function Am(t,e,n,s){const{globalToRenderLayerDimensions:i}=n;for(let r=0;r<3;++r){const o=s[r];if(o!==-1){const a=i[o];a!==-1&&(t[a]=e[r])}}}function Lm(t,e,n,s){const{globalToRenderLayerDimensions:i}=n.modelTransform,{layerRank:r,chunkToLayerTransform:o}=n,a=r+1;for(let c=0;c<3;++c){let l=0;const u=s[c];if(u!==-1){const d=i[u];if(d!==-1){l=o[a*r+d];for(let h=0;h<r;++h)l+=o[a*h+d]*e[h]}}t[c]=l}return t}function Um(t,e){const n=t.rank,s=t.unpaddedRank;let i;s!==n&&e!==void 0&&(e=matrix.extendHomogeneousTransform(new Float32Array((n+1)**2),n,e,s)),e!==void 0?(i=new Float32Array((n+1)*(n+1)),matrix.multiply(i,n+1,t.modelToRenderLayerTransform,n+1,e,n+1,n+1,n+1,n+1)):i=t.modelToRenderLayerTransform;const r=new Float32Array((n+1)*(n+1)),o=matrix.inverse(r,n+1,i,n+1,n+1);if(o===0)throw new Error("Transform is singular");const{globalToRenderLayerDimensions:a,localToRenderLayerDimensions:c,channelToRenderLayerDimensions:l}=t,u=a.length,d=c.length,h=u+d,p=new Float32Array((h+1)*n);for(let C=0;C<n;++C){for(let S=0;S<u;++S){const T=a[S];T!==-1&&(p[C+S*n]=r[C+T*(n+1)])}for(let S=0;S<d;++S){const T=c[S];T!==-1&&(p[C+(u+S)*n]=r[C+T*(n+1)])}p[C+h*n]=r[C+n*(n+1)]}const m=l.length,f=new Array(m),b=[];for(let C=0;C<m;++C){const S=l[C];let T=-1;if(S!==-1){for(let v=0;v<n;++v){const N=i[S+v*(n+1)];if(N!==0){if(N!==1||T!==-1)throw new Error(`Channel dimension ${t.layerDimensionNames[S]} must map with stride 1 to a single data chunk dimensions`);T=v}}if(T!==-1){const v=i[S+n*(n+1)];if(v!==0&&v!==-.5)throw new Error(`Channel dimension ${t.layerDimensionNames[S]} must have an offset of 0 in the chunk coordinate space; current offset is ${v}`);b.push(T)}}f[C]=T}const{channelSpaceShape:I}=t,E=vector.prod(I),V=b.length,R=new Uint32Array(E*V);for(let C=0;C<E;++C){let S=C,T=0;for(let v=0;v<m;++v){const N=S%I[v];S=(S-N)/I[v],f[v]!==-1&&(R[C*V+T]=N,++T)}}return{layerRank:n,modelTransform:t,chunkToLayerTransform:i,layerToChunkTransform:r,chunkToLayerTransformDet:o,combinedGlobalLocalRank:h,combinedGlobalLocalToChunkTransform:p,channelToChunkDimensionIndices:f,chunkChannelDimensionIndices:b,numChannels:E,chunkChannelCoordinates:R,channelSpaceShape:I}}function Vm(t,e){const{globalToRenderLayerDimensions:n}=t,s=[],i=[];for(let r=0;r<3;++r){const o=e[r];if(o===-1)continue;const a=n[o];i.push(a),a!==-1&&s.push(a)}for(let r=i.length;r<3;++r)i[r]=-1;return{layerDisplayDimensionIndices:s,displayToLayerDimensionIndices:i}}function Bm(t,e){const{chunkToLayerTransform:n,modelTransform:s}=t,i=s.rank,{layerDisplayDimensionIndices:r,displayToLayerDimensionIndices:o}=e,a=r.length,c=getDependentTransformInputDimensions(n,i,r);if(c.length!==a){const{modelDimensionNames:d,layerDimensionNames:h}=s;throw new Error(`Rank mismatch between displayed layer dimensions (${Array.from(r,p=>h[p]).join(",\xA0")}) and corresponding chunk dimensions (${Array.from(c,p=>d[p]).join(",\xA0")})`)}const l=mat4.create();for(let d=0;d<3;++d){const h=o[d];if(h!==-1){for(let p=0;p<a;++p){const m=c[p];l[p*4+d]=n[m*(i+1)+h]}l[12+d]=n[i*(i+1)+h]}}const u=mat4.create();mat4.invert(u,l);for(let d=c.length;d<3;++d)c[d]=-1;return{modelTransform:t.modelTransform,chunkTransform:t,displaySubspaceModelMatrix:l,displaySubspaceInvModelMatrix:u,chunkDisplayDimensionIndices:c,numChunkDisplayDims:a}}function fl(t,e,n,s,i){const r=e.length,o=n.length,a=t.length;let c=!0;for(let l=0;l<s;++l){let u=l,d=0;for(let h=0;h<r;++h)d+=i[u+h*s]*e[h];u+=r*s;for(let h=0;h<o;++h)d+=i[u+h*s]*n[h];d+=i[u+o*s],l<a?t[l]=d:(d<0||d>=1)&&(c=!1)}return c}function Fm(t,e,n,s){return scatterUpdate(t,e,s.globalToRenderLayerDimensions),scatterUpdate(t,n,s.localToRenderLayerDimensions),t}function pl(t,e,n){t.fill(0),t[15]=1;let s=!0;const{displayDimensionIndices:i}=e,{globalToRenderLayerDimensions:r,modelToRenderLayerTransform:o}=n,a=n.rank;for(let c=0;c<3;++c){const l=i[c];if(l===-1){s=!1;continue}const u=r[l];if(u===-1){s=!1;continue}t[c+12]=o[u+a*(a+1)];for(let d=0;d<3;++d)t[c+4*d]=o[u+(a+1)*d]}if(!s){const{globalDimensionNames:c}=e,l=Array.from(i.filter(u=>u!==-1),u=>c[u]).join(",\xA0");throw new Error(`Transform from model dimensions (${n.modelDimensionNames.join(",\xA0")}) to display dimensions (${l}) does not have full rank`)}}var tr=x(9459);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var ge=(t=>(t[t.UINT8=0]="UINT8",t[t.INT8=1]="INT8",t[t.UINT16=2]="UINT16",t[t.INT16=3]="INT16",t[t.UINT32=4]="UINT32",t[t.INT32=5]="INT32",t[t.UINT64=6]="UINT64",t[t.FLOAT32=7]="FLOAT32",t))(ge||{});const $m={0:!1,1:!0,2:!1,3:!0,4:!1,5:!0,6:!1,7:void 0},Wt={0:1,1:1,2:2,3:2,4:4,5:4,6:8,7:4},nr={0:Uint8Array,1:Int8Array,2:Uint16Array,3:Int16Array,4:Uint32Array,5:Int32Array,6:Uint32Array,7:Float32Array},sr={0:1,1:1,2:1,3:1,4:1,5:1,6:2,7:1};function ir(t,e,n=0,s=e.byteLength){const i=Wt[t],r=sr[t];return new nr[t](e,n,s/i*r)}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Bn=!1,ml=!1,gl=w.pB.create();function yl(t,e){let n=0,s=Math.abs(t.detTransform);const{transform:i,size:r}=t;for(let o=0;o<3;++o){let a=0;for(let l=0;l<3;++l)a+=e[l*4+2]*i[4*o+l];const c=r[o];n+=Math.abs(a)*c,s*=c}return s/n}function rr(t,e,n){const{curPositionInChunks:s,fixedPositionWithinChunk:i}=t,{nonDisplayLowerClipBound:r,nonDisplayUpperClipBound:o}=t,{rank:a,chunkDataSize:c}=t.source.spec;if(!fl(s,e,n,t.layerRank,t.fixedLayerToChunkTransform))return!1;for(let l=0;l<a;++l){const u=s[l];if(u<r[l]||u>=o[l])return Bn&&console.log("excluding source",t,`because of chunkDim=${l}, sum=${u}`,r,o,t.fixedLayerToChunkTransform),!1;const d=c[l],h=s[l]=Math.floor(u/d);i[l]=u-h*d}return!0}function vl(t,e){const n=e.length;let s=0;if(Bn&&console.log(e),n>1){let i=0;for(let r=0;r<n;++r){const o=e[r],{chunkLayout:a}=o,c=yl(a,t);Bn&&console.log(`chunksize = ${a.size}, sliceArea = ${c}`),c>i&&(i=c,s=r)}}return s}const Kt=new tr.i(w.eR.create(),w.pB.create(),0);class zm extends ul{constructor(){super(...arguments),this.viewportNormalInGlobalCoordinates=w.eR.create(),this.viewportNormalInCanonicalCoordinates=w.eR.create(),this.centerDataPosition=w.eR.create(),this.pixelSize=0}}function wl(t,e){if(t.displayDimensionRenderInfo!==e.displayDimensionRenderInfo||t.pixelSize!==e.pixelSize)return!0;const{viewMatrix:n}=t,{viewMatrix:s}=e;for(let i=0;i<12;++i)if(n[i]!==s[i])return!0;return!1}class Sl extends De{constructor(e){super(),this.projectionParameters=e,this.visibleLayers=new Map,this.visibleSourcesStale=!0,this.registerDisposer(e.changed.add((n,s)=>{wl(n,s)&&this.invalidateVisibleSources(),this.invalidateVisibleChunks()}))}invalidateVisibleSources(){this.visibleSourcesStale=!0}invalidateVisibleChunks(){}updateVisibleSources(){if(!this.visibleSourcesStale)return;this.visibleSourcesStale=!1;const e=this.projectionParameters.value.displayDimensionRenderInfo,{visibleLayers:n}=this;for(const[s,i]of n){const{allSources:r,visibleSources:o}=i;if(o.length=0,r.length===0||!Is(i,e))continue;const a=vl(this.projectionParameters.value.viewMatrix,r.map(l=>l[0])),c=r[a];for(const l of s.filterVisibleSources(this,c))o.push(l);o.reverse(),Bn&&console.log("visible sources chosen",o)}}}const bl=18;function Es(t){let{rank:e,upperVoxelBound:n,maxVoxelsPerChunkLog2:s=bl,chunkToViewTransform:i,displayRank:r,minBlockSize:o,maxBlockSize:a}=t;const{lowerVoxelBound:c=new Uint32Array(e)}=t,l=new Float32Array(e);for(let p=0;p<e;++p){let m=0;for(let f=0;f<r;++f){const b=i[p*r+f];m+=b*b}l[p]=Math.sqrt(m)}const u=new Uint32Array(e);o!==void 0?u.set(o):u.fill(1);const d=new Array(e);for(let p=0;p<e;++p){let m=Number.POSITIVE_INFINITY;l[p]===0?m=u[p]:(n!==void 0&&(m=2**Math.floor(Math.log2(n[p]-c[p]))),a!==void 0&&(m=Math.min(m,a[p]))),d[p]=m}function h(){let p=1/0,m=-1;for(let f=0;f<e;++f){if(u[f]>=d[f])continue;const b=u[f]*l[f];b<p&&(p=b,m=f)}return m}s-=Math.log2(vector.prod(u));for(let p=0;p<s;++p){const m=h();if(m===-1)break;u[m]*=2}return u}function Il(t){const e=[],{displayRank:n,chunkToViewTransform:s,rank:i}=t;if(n>3)throw new Error("Unsupported view transform");if(n<3)return[Es(t)];for(let r=0;r<3;++r){const o=(r+2)%3,a=new Float32Array(s);for(let c=0;c<i;++c)a[c*n+o]=0;e[r]=Es({...t,chunkToViewTransform:a})}return e}var Cl=(t=>(t[t.ISOTROPIC=0]="ISOTROPIC",t[t.FLAT=1]="FLAT",t))(Cl||{});function Gm(t,e,n){return n===void 0?e:matrix.multiply(new Float32Array((t+1)*(t+1)),t+1,e,t+1,n,t+1,t+1,t+1,t+1)}function jm(t){if(t.chunkDataSizes!==void 0)return t.chunkDataSizes;const{chunkLayoutPreference:e=0}=t;switch(e){case 0:return[Es(t)];case 1:return Il(t)}}function Ym(t){const{rank:e,chunkDataSize:n,upperVoxelBound:s}=t,{lowerVoxelBound:i=new Float32Array(e)}=t,r=new Float32Array(e),o=new Float32Array(e);for(let a=0;a<e;++a)r[a]=Math.floor(i[a]/n[a]),o[a]=Math.floor((s[a]-1)/n[a]+1);return{rank:e,chunkDataSize:n,lowerChunkBound:r,upperChunkBound:o,lowerVoxelBound:i,upperVoxelBound:s}}function*El(t,e,n){const s=t.projectionParameters.value.pixelSize*1.1,i=n[0].effectiveVoxelSize,r=e.renderScaleTarget.value,o=u=>{const d=s*r;for(let h=0;h<3;++h){const p=u[h];if(p>d&&p>1.01*i[h])return!0}return!1},a=(u,d)=>{const h=s*r;for(let p=0;p<3;++p){const m=u[p],f=d[p];if(Math.abs(h-m)<Math.abs(h-f)&&m<1.01*f)return!0}return!1};let c=n.length-1,l;for(;;){const u=n[c];if(l!==void 0&&!a(u.effectiveVoxelSize,l)||(yield u,c===0||!o(u.effectiveVoxelSize)))break;l=u.effectiveVoxelSize,--c}}const kl="SliceView",Tl="sliceview/RenderLayer",Dl="SliceView.addVisibleLayer",Pl="SliceView.removeVisibleLayer",Ml="ChunkManager.requestChunk",ks=new Float32Array(3),Ts=new Float32Array(3),or=w.pB.create(),ar=new Float32Array(24);function cr(t,e,n,s){const i=ks,r=Ts,{lowerChunkDisplayBound:o,upperChunkDisplayBound:a}=e;for(let d=0;d<3;++d)i[d]=Math.max(i[d],o[d]),r[d]=Math.min(r[d],a[d]);const{curPositionInChunks:c,chunkDisplayDimensionIndices:l}=e;function u(){if(!s(i[0],i[1],i[2],r[0],r[1],r[2],t))return;let d=0,h=Math.max(0,r[0]-i[0]),p=h;for(let I=1;I<3;++I){const E=Math.max(0,r[I]-i[I]);p*=E,E>h&&(h=E,d=I)}if(p===0)return;if(p===1){c[l[0]]=i[0],c[l[1]]=i[1],c[l[2]]=i[2],n(i,t);return}const m=i[d],f=r[d],b=Math.floor(.5*(m+f));r[d]=b,u(),r[d]=f,i[d]=b,u(),i[d]=m}u()}function lr(t,e,n,s){if(!rr(n,t.globalPosition,e))return;const{size:i}=n.chunkLayout,r=w.pB.multiply(or,t.viewProjectionMat,n.chunkLayout.transform);for(let l=0;l<3;++l){const u=i[l];for(let d=0;d<4;++d)r[4*l+d]*=u}const o=ar;(0,w._S)(o,r);const a=ks,c=Ts;a.fill(Number.NEGATIVE_INFINITY),c.fill(Number.POSITIVE_INFINITY),cr(o,n,s,w.T_)}function ur(t,e,n,s,i){if(!rr(n,t.globalPosition,e))return;const{size:r}=s,o=w.pB.multiply(or,t.viewProjectionMat,s.transform);for(let h=0;h<3;++h){const p=r[h];for(let m=0;m<4;++m)o[4*h+m]*=p}const a=gl;w.pB.invert(a,o);const c=ks,l=Ts,u=.001;for(let h=0;h<3;++h){const p=a[12+h]+u/r[h],m=Math.abs(a[h]),f=Math.abs(a[4+h]);c[h]=Math.floor(p-m-f),l[h]=Math.floor(p+m+f+1)}const d=ar;for(let h=0;h<3;++h){const p=o[4*h],m=o[4*h+1],f=o[4*h+2];d[h]=p,d[4+h]=-p,d[8+h]=+m,d[12+h]=-m,d[16+h]=+f,d[20+h]=-f}{const p=o[12],m=o[4*3+1],f=o[4*3+2];d[3]=1+p,d[7]=1-p,d[11]=1+m,d[15]=1-m,d[19]=f,d[23]=-f}ml&&(console.log("clippingPlanes",d),console.log("modelViewProjection",o.join(",")),console.log(`lower=${c.join(",")}, upper=${l.join(",")}`)),cr(d,n,i,w.qp)}function dr(t,e){const{finiteRank:n}=e;if(n===3)return e;Kt.finiteRank=n,w.eR.copy(Kt.size,e.size);const s=w.pB.copy(Kt.transform,e.transform),i=w.pB.copy(Kt.invTransform,e.invTransform);Kt.detTransform=e.detTransform;const{invViewMatrix:r,width:o,height:a}=t,c=(0,w.sJ)(t.projectionMat);for(let l=n;l<3;++l){const u=r[12+l];let d=u,h=u;const p=Math.abs(r[l]*o);d-=p,h+=p;const m=Math.abs(r[l+4]*a);d-=m,h+=m;const f=Math.abs(r[l+8]*c);d-=f,h+=f;const b=Math.max(1,h-d);s[12+l]=d,s[5*l]=b}return w.pB.invert(i,s),Kt}/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Rl(t){const e=.254829592,n=-.284496736,s=1.421413741,i=-1.453152027,r=1.061405429,a=1/(1+.3275911*Math.abs(t)),c=1-((((r*a+i)*a+s)*a+n)*a+e)*a*Math.exp(-t*t);return Math.sign(t)*c}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _l=50,Ol=1e3;class Nl{constructor(e=_l,n=Ol){this.velocityHalfLifeMilliseconds=e,this.modelHalfLifeMilliseconds=n,this.lastTime=Number.NEGATIVE_INFINITY,this.rank=0,this.numSamples=0,this.prevPosition=new Float32Array,this.velocity=new Float32Array,this.mean=new Float32Array,this.variance=new Float32Array}reset(e){this.lastTime=Number.NEGATIVE_INFINITY,this.rank=e,this.numSamples=0,this.velocity=new Float32Array(e),this.prevPosition=new Float32Array(e),this.mean=new Float32Array(e),this.variance=new Float32Array(e)}addSample(e,n=Date.now()){const s=e.length;s!==this.rank&&this.reset(s);const i=this.numSamples;if(++this.numSamples,this.numSamples===0){this.prevPosition.set(e),this.lastTime=n;return}const r=n-this.lastTime;this.lastTime=n;const o=1-2**-(r/this.velocityHalfLifeMilliseconds),a=1-2**-(r/this.modelHalfLifeMilliseconds),{velocity:c,prevPosition:l,mean:u,variance:d}=this;for(let h=0;h<s;++h){const p=(e[h]-l[h])/Math.max(r,1);l[h]=e[h];const m=c[h],f=c[h]=m+o*(p-m);if(i===1)u[h]=f;else{const b=u[h],I=d[h],E=f-b;u[h]=b+a*E,d[h]=(1-a)*(I+a*E*E)}}}}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function At(t){return class extends t{constructor(...e){super(...e);const n=e[0],s=e[1];this.visibility=n.get(s.visibility),this.registerDisposer(this.visibility.changed.add(()=>this.chunkManager.scheduleUpdateChunkPriorities()))}}}function ht(t){return t===Number.POSITIVE_INFINITY?se.VISIBLE:se.PREFETCH}function ft(t){return t===Number.POSITIVE_INFINITY?0:t*ne}var xl=Object.defineProperty,Al=Object.getOwnPropertyDescriptor,hr=(t,e,n,s)=>{for(var i=s>1?void 0:s?Al(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&xl(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const fr=-1e12,Ds=1e9,pr=w.eR.create(),Ll=w.eR.create(),Ul=w.eR.create();class Vl extends Sl{constructor(e,n){super(e.get(n.projectionParameters)),this.initializeSharedObject(e,n.id)}}function mr(t){for(const e of t)for(const n of e)n.source.dispose()}const Bl=At(It(Vl));let gr=class extends Bl{constructor(t,e){super(t,e),this.velocityEstimator=new Nl,this.handleLayerChanged=()=>{this.chunkManager.scheduleUpdateChunkPriorities()},this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(()=>{this.updateVisibleChunks()})),this.registerDisposer(this.projectionParameters.changed.add(()=>{this.velocityEstimator.addSample(this.projectionParameters.value.globalPosition)}))}invalidateVisibleChunks(){super.invalidateVisibleChunks(),this.chunkManager.scheduleUpdateChunkPriorities()}updateVisibleChunks(){const t=this.projectionParameters.value,e=this.chunkManager,n=this.visibility.value;if(n===Number.NEGATIVE_INFINITY)return;this.updateVisibleSources();const{centerDataPosition:s}=t,i=ht(n);let r=ft(n);r+=fr;const o=Ll,a=Ul,c=[];this.velocityEstimator.addSample(this.projectionParameters.value.globalPosition);for(const[l,u]of this.visibleLayers){e.registerLayer(l);const{visibleSources:d}=u;for(let h=0,p=d.length;h<p;++h){const m=d[h],f=e.queueManager.enablePrefetch.value?$l(this.velocityEstimator,m):[],{chunkLayout:b}=m;b.globalToLocalSpatial(o,s);const{size:I,finiteRank:E}=b;w.eR.copy(a,I);for(let S=E;S<3;++S)a[S]=0,o[S]=0;const R=r+Ds*h;c.length=0;const C=un();if(ur(t,m.renderLayer.localPosition.value,m,dr(t,m.chunkLayout),S=>{w.eR.multiply(pr,S,a);const T=-w.eR.distance(o,pr),{curPositionInChunks:v}=m,N=m.source.getChunk(v);e.requestChunk(N,i,R+T),++l.numVisibleChunksNeeded,N.state===_.GPU_MEMORY&&++l.numVisibleChunksAvailable,c.push(N),N.markGeneration=C}),f.length!==0){const{curPositionInChunks:S}=m;for(const T of c){S.set(T.chunkGridPosition);for(let v=0,N=f.length;v<N;){const H=f[v],y=f[v+2],A=f[v+3],L=f[v+4],Y=f[v+5],le=S[H],we=le+f[v+1];if(we<y||we>A){v=Y;continue}S[H]=we;const pe=m.source.getChunk(S);if(S[H]=le,pe.markGeneration===C){v=Y;continue}e.requestChunk(pe,se.PREFETCH,R+L),++l.numPrefetchChunksNeeded,pe.state===_.GPU_MEMORY&&++l.numPrefetchChunksAvailable,v+=mn}}}}}}removeVisibleLayer(t){const{visibleLayers:e}=this,n=e.get(t);e.delete(t),mr(n.allSources),t.renderScaleTarget.changed.remove(this.invalidateVisibleSources),t.localPosition.changed.remove(this.handleLayerChanged),this.invalidateVisibleSources()}addVisibleLayer(t,e,n){let s=this.visibleLayers.get(t);s===void 0?(s={allSources:e,visibleSources:[],displayDimensionRenderInfo:n},this.visibleLayers.set(t,s),t.renderScaleTarget.changed.add(()=>this.invalidateVisibleSources()),t.localPosition.changed.add(this.handleLayerChanged)):(mr(s.allSources),s.allSources=e,s.visibleSources.length=0,s.displayDimensionRenderInfo=n),this.invalidateVisibleSources()}disposed(){for(const t of this.visibleLayers.keys())this.removeVisibleLayer(t);super.disposed()}invalidateVisibleSources(){super.invalidateVisibleSources(),this.chunkManager.scheduleUpdateChunkPriorities()}};gr=hr([O(kl)],gr);function Fn(t,e,n){return e.map(i=>i.map(r=>{const o=t.getRef(r.source),a=r.chunkLayout,{rank:c}=o.spec;return{renderLayer:n,source:o,chunkLayout:tr.i.fromObject(a),layerRank:r.layerRank,nonDisplayLowerClipBound:r.nonDisplayLowerClipBound,nonDisplayUpperClipBound:r.nonDisplayUpperClipBound,lowerClipBound:r.lowerClipBound,upperClipBound:r.upperClipBound,lowerClipDisplayBound:r.lowerClipDisplayBound,upperClipDisplayBound:r.upperClipDisplayBound,lowerChunkDisplayBound:r.lowerChunkDisplayBound,upperChunkDisplayBound:r.upperChunkDisplayBound,effectiveVoxelSize:r.effectiveVoxelSize,chunkDisplayDimensionIndices:r.chunkDisplayDimensionIndices,fixedLayerToChunkTransform:r.fixedLayerToChunkTransform,combinedGlobalLocalToChunkTransform:r.combinedGlobalLocalToChunkTransform,curPositionInChunks:new Float32Array(c),fixedPositionWithinChunk:new Uint32Array(c)}}))}Q(Dl,function(t){const e=this.get(t.id),n=this.get(t.layerId),s=Fn(this,t.sources,n);e.addVisibleLayer(n,s,t.displayDimensionRenderInfo)}),Q(Pl,function(t){const e=this.get(t.id),n=this.get(t.layerId);e.removeVisibleLayer(n)});class yr extends _e{constructor(){super(...arguments),this.source=null}initializeVolumeChunk(e,n){super.initialize(e),this.chunkGridPosition=Float32Array.from(n)}serialize(e,n){super.serialize(e,n),e.chunkGridPosition=this.chunkGridPosition}downloadSucceeded(){super.downloadSucceeded()}freeSystemMemory(){}toString(){return this.source.toString()+":"+(0,w.nL)(this.chunkGridPosition)}}class vr extends K{constructor(e,n){super(e,n),this.spec=n.spec}getChunk(e){const n=e.join();let s=this.chunks.get(n);return s===void 0&&(s=this.getNewChunk_(this.chunkConstructor),s.initializeVolumeChunk(n,e),this.addChunk(s)),s}}let wr=class extends U{constructor(t,e){super(t,e),this.renderScaleTarget=t.get(e.renderScaleTarget),this.localPosition=t.get(e.localPosition),this.numVisibleChunksNeeded=0,this.numVisibleChunksAvailable=0,this.numPrefetchChunksAvailable=0,this.numPrefetchChunksNeeded=0,this.chunkManagerGeneration=-1}filterVisibleSources(t,e){return El(t,this,e)}};wr=hr([O(Tl)],wr);const Sr=2e3,Fl=.1,br=32,Ir=.05,mn=6;function $l(t,e){const n=[],s=t.rank,{combinedGlobalLocalToChunkTransform:i,layerRank:r}=e,{rank:o,chunkDataSize:a}=e.source.spec,{mean:c,variance:l}=t;for(let u=0;u<o;++u){const d=e.chunkDisplayDimensionIndices.includes(u);let h=0,p=0;for(let v=0;v<s;++v){const N=c[v],H=l[v],y=i[v*r+u];h+=y*N,p+=y*y*H}if(h>Fl)continue;const m=a[u],f=d?0:e.fixedPositionWithinChunk[u]/m,b=h/m*Sr;let I=Math.sqrt(2*p)/m*Sr;if(Math.abs(b)<.001&&I<.001)continue;I=Math.max(1e-6,I);const E=v=>.5*(1+Rl((v-b)/I)),V=e.curPositionInChunks[u],R=Math.floor(e.lowerClipBound[u]/m),C=Math.ceil(e.upperClipBound[u]/m)-1;let S=n.length;for(let v=1;v<=br&&!(!d&&V+v>C);++v){const N=1-E(v-f);if(N<Ir)break;n.push(u,v,R,C,N,0)}let T=n.length;for(let v=S,N=n.length;v<N;v+=mn)n[v+mn-1]=T;S=T;for(let v=1;v<=br&&!(!d&&V-v<R);++v){const N=E(-v+1-f);if(N<Ir)break;n.push(u,-v,R,C,N,0)}T=n.length;for(let v=S,N=n.length;v<N;v+=mn)n[v+mn-1]=T}return n}Ke(Ml,async function(t,e){const n=this.get(t.source),{chunkManager:s}=n,i=n.getChunk(t.chunkGridPosition),r=i.key;if(i.state<=_.SYSTEM_MEMORY)return{value:void 0};const o=s.recomputeChunkPriorities.add(()=>{s.requestChunk(i,se.VISIBLE,Number.POSITIVE_INFINITY,_.SYSTEM_MEMORY)});s.scheduleUpdateChunkPriorities();let a;const c=new Promise((u,d)=>{a=h=>{if(h.state===_.FAILED){d(h.error);return}h.state<=_.SYSTEM_MEMORY&&u()}});n.registerChunkListener(r,a);const l=new Promise((u,d)=>{e.add(()=>{d(j.wS)})});try{return await Promise.race([c,l]),{value:void 0}}finally{n.unregisterChunkListener(r,a),o(),s.scheduleUpdateChunkPriorities()}});var zl=x(4373),Gl=Object.defineProperty,jl=Object.getOwnPropertyDescriptor,Yl=(t,e,n,s)=>{for(var i=s>1?void 0:s?jl(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&Gl(e,n,i),i};/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let Cr=class extends U{constructor(...t){super(...t);const e=t[0],n=t[1];this.visibility=e.get(n.visibility),this.projectionParameters=e.get(n.projectionParameters)}};Cr=Yl([O(zl.l)],Cr);class Er extends xn{}/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Jl="volume_rendering/VolumeRenderingRenderLayer",Hl="volume_rendering/VolumeRenderingRenderLayer/update",Wl=!1,Kl=w.w0.create();function Jm(t,e,n){let s=0,i=0;for(let l=0;l<3;++l){const u=t[16+l],d=u*e[l],h=u*n[l];s+=Math.min(d,h),i+=Math.max(d,h)}const r=-t[19],o=Math.max(r,s),a=t[23],c=Math.min(a,i);return{near:r,far:a,adjustedNear:o,adjustedFar:c}}function ql(t,e,n,s,i,r){if(s.length===0)return;const{viewMatrix:o,projectionMat:a,displayDimensionRenderInfo:c}=t,{voxelPhysicalScales:l}=c,u=(0,w.xK)(l),d=(0,w.sJ)(a),p=(d/n)**3,m=w.w0.determinant((0,w._A)(Kl,o)),f={spatialScales:new Map,activeIndex:-1},b=T=>{const v=s[T];return Math.abs(v.chunkLayout.detTransform*m)};let I=s.length-1,E=b(I);for(let T=I;T>=0;--T){const v=b(T),N=Math.cbrt(v*u/m),H=d/Math.cbrt(v);f.spatialScales.set(N,H),v-p>=0&&(E=v,I=T),f.activeIndex=I}if(Wl){console.log(s);for(let T=0;T<s.length;++T){const v=b(T),N=d/Math.cbrt(v);console.log(`scaleIndex=${T} viewVolume=${v} bestScaleIndex=${I} actualViewVolume=${p}, desiredSamples=${N}, difference=${v-p}`)}}const V=Math.cbrt(E*u/m),R=d/Math.cbrt(E);let C=!0;const S=s[I];lr(t,e,S,(T,v)=>{C&&(i(S,I,V,R,v,f),C=!1),r(S,I,T)})}var Ql=Object.defineProperty,Xl=Object.getOwnPropertyDescriptor,Zl=(t,e,n,s)=>{for(var i=s>1?void 0:s?Xl(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&Ql(e,n,i),i};/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const kr=w.eR.create(),eu=w.eR.create(),tu=w.eR.create(),nu=w.eR.create();let Ps=class extends It(xn){constructor(t,e){super(t,e),this.renderScaleTarget=t.get(e.renderScaleTarget),this.localPosition=t.get(e.localPosition);const n=()=>this.chunkManager.scheduleUpdateChunkPriorities();this.registerDisposer(this.localPosition.changed.add(n)),this.registerDisposer(this.renderScaleTarget.changed.add(n)),this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(()=>this.recomputeChunkPriorities()))}attach(t){const e=()=>this.chunkManager.scheduleUpdateChunkPriorities(),{view:n}=t;t.registerDisposer(e),t.registerDisposer(n.projectionParameters.changed.add(e)),t.registerDisposer(n.visibility.changed.add(e)),t.state={displayDimensionRenderInfo:n.projectionParameters.value.displayDimensionRenderInfo,transformedSources:[]}}recomputeChunkPriorities(){for(const t of this.attachments.values()){const{view:e}=t,n=e.visibility.value;if(n===Number.NEGATIVE_INFINITY)continue;const s=t.state,{transformedSources:i}=s;if(i.length===0||!Is(s,e.projectionParameters.value.displayDimensionRenderInfo))continue;const r=e.projectionParameters.value,o=ht(n);let a=ft(n);a+=fr;const c=eu,l=tu,u=nu,{globalPosition:d,displayDimensionRenderInfo:{displayDimensionIndices:h}}=r;for(let f=0;f<3;++f){const b=h[f];u[f]=b===-1?0:d[b]}let p;const{chunkManager:m}=this;m.registerLayer(this),ql(r,this.localPosition.value,this.renderScaleTarget.value,i[0],(f,b)=>{const{chunkLayout:I}=f;I.globalToLocalSpatial(c,u);const{size:E,finiteRank:V}=I;w.eR.copy(l,E);for(let C=V;C<3;++C)l[C]=0,c[C]=0;const R=i[0].length-1-b;p=a+Ds*R},(f,b,I)=>{w.eR.multiply(kr,I,l);const E=-w.eR.distance(c,kr),V=f.source.getChunk(f.curPositionInChunks);++this.numVisibleChunksNeeded,m.requestChunk(V,o,p+E),V.state===_.GPU_MEMORY&&++this.numVisibleChunksAvailable})}}};Ps=Zl([O(Jl)],Ps),Q(Hl,function(t){const e=this.get(t.view),n=this.get(t.layer),s=n.attachments.get(e);s.state.transformedSources=Fn(this,t.sources,n),s.state.displayDimensionRenderInfo=t.displayDimensionRenderInfo,n.chunkManager.scheduleUpdateChunkPriorities()});/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const su="annotation.MetadataChunkSource",Hm="annotation.GeometryChunkSource",iu="annotation.SubsetGeometryChunkSource",ru="annotation.reference.add",ou="annotation.reference.delete",au="annotation.commit",Tr="annotation.commit",cu="annotation/SpatiallyIndexedRenderLayer",lu="annotation/PerspectiveRenderLayer:updateSources",uu="annotation/RenderLayer",du="annotation/RenderLayer.updateSegmentation",hu=w.w0.create();function fu(t,e,n,s,i,r){const{displayDimensionRenderInfo:o,viewMatrix:a,projectionMat:c,width:l,height:u}=t,{voxelPhysicalScales:d}=o,h=Math.abs(w.w0.determinant((0,w._A)(hu,a))),p=(0,w.xK)(d),m=(0,w.I1)(c)/h*p;if(s.length===0)return;const f=s[0];let b=Math.abs(f.chunkLayout.detTransform)*p;const{lowerClipDisplayBound:I,upperClipDisplayBound:E}=f;for(let v=0;v<3;++v)b*=E[v]-I[v];const V=Math.min(b,m),R=l*u,S=R/n**2/V;let T=0;for(let v=s.length-1;v>=0&&T<S;--v){const N=s[v],H=N.source.spec,{chunkLayout:y}=N,A=(0,w.xK)(y.size)*Math.abs(y.detTransform)*p,{limit:L,rank:Y}=H,{nonDisplayLowerClipBound:le,nonDisplayUpperClipBound:we}=N;let pe=1;for(let wt=0;wt<Y;++wt){const Mn=we[wt]-le[wt];Number.isFinite(Mn)&&(pe/=Mn)}const $e=L*pe/A;let Fe=!0;const _t=T+$e,Pn=(1/_t)**(1/3),an=Math.sqrt(R/(_t*V)),$t=(S-T)*A/pe,rt=Math.min(1,$t/H.limit);lr(t,e,N,()=>{Fe&&(i(N,v),Fe=!1),r(N,v,rt,Pn,an)}),T=_t}}var pu=x(8103);/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Dr(t){return("0"+t.toString(16)).slice(-2)}function Wm(t){return Array.prototype.map.call(t,Dr).join("")}function Km(t){if(!/^(?:[0-9a-fA-F]{2})*$/.test(t))throw new Error("Invalid hex-encoded string");const e=t.length/2,n=new Uint8Array(e);for(let s=0;s<e;++s)n[s]=parseInt(t.substr(s*2,2),16);return n}/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function mu(t){const e=/^rgba\(([0-9]+), ([0-9]+), ([0-9]+), (0(?:\.[0-9]+)?)\)$/;{const s=t.match(e);if(s!==null)return[parseInt(s[1],10),parseInt(s[2],10),parseInt(s[3],10),parseFloat(s[4])]}const n=/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/;{const s=t.match(n);if(s!==null)return[parseInt(s[1],16),parseInt(s[2],16),parseInt(s[3],16),1]}throw new Error(`Invalid serialized color: ${JSON.stringify(t)}.`)}function Pr(t){try{if(typeof t!="string")throw new Error(`Expected string, but received ${JSON.stringify(t)}.`);const e=document.createElement("canvas").getContext("2d");e.fillStyle=t;const n=mu(e.fillStyle);return w.ln.fromValues(n[0]/255,n[1]/255,n[2]/255,n[3])}catch(e){throw new Error(`Failed to parse color specification: ${e.message}`)}}function Ms(t){return Pr(t).subarray(0,3)}function Mr(t){const e=t[3]===void 0?3:4;let n=0;for(let s=0;s<e;s++)n=(n<<8>>>0)+Math.min(255,Math.max(0,Math.round(t[e-1-s]*255)));return n}function gu(t){return w.eR.fromValues((t>>>0&255)/255,(t>>>8&255)/255,(t>>>16&255)/255)}function yu(t){return w.ln.fromValues((t>>>0&255)/255,(t>>>8&255)/255,(t>>>16&255)/255,(t>>>24&255)/255)}function gn(t){if(t[3]===void 0||t[3]===1){let n="#";for(let s=0;s<3;++s)n+=Dr(Math.min(255,Math.max(0,Math.round(t[s]*255))));return n}let e="rgba(";for(let n=0;n<3;++n)n!==0&&(e+=", "),e+=Math.min(255,Math.max(0,Math.round(t[n]*255)));return e+=`, ${(0,pu.K)(t[3])})`,e}function Rs(t){return t<=.03928?t/12.92:((t+.055)/1.055)**2.4}function vu(t){const[e,n,s]=t;return .2126*Rs(e)+.7152*Rs(n)+.0722*Rs(s)}function qm(t){return vu(t)<=.179}class Qm extends me.B0{constructor(e){super(w.eR.clone(e)),this.defaultValue=e}toString(){return gn(this.value)}toJSON(){if(!w.eR.equals(this.value,this.defaultValue))return gn(this.value)}reset(){this.value=w.eR.clone(this.defaultValue)}restoreState(e){if(e===void 0){this.reset();return}const{value:n}=this,s=Ms(e);w.eR.equals(n,s)||(this.value=s)}}class Xm extends me.B0{constructor(){super(void 0)}toJSON(){const{value:e}=this;if(e!==void 0)return gn(e)}reset(){this.value=void 0}restoreState(e){if(e===void 0){this.reset();return}const{value:n}=this,s=Ms(e);(n===void 0||!w.eR.equals(n,s))&&(this.value=s)}}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var xe=(t=>(t[t.LITTLE=0]="LITTLE",t[t.BIG=1]="BIG",t))(xe||{});function wu(){const t=Uint16Array.of(4386);return new Uint8Array(t.buffer)[0]===17?1:0}const qt=wu();function Rr(t){const e=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);for(let n=0,s=e.length;n<s;n+=2){const i=e[n];e[n]=e[n+1],e[n+1]=i}}function _r(t){const e=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);for(let n=0,s=e.length;n<s;n+=4){let i=e[n];e[n]=e[n+3],e[n+3]=i,i=e[n+1],e[n+1]=e[n+2],e[n+2]=i}}function Or(t){const e=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);for(let n=0,s=e.length;n<s;n+=8){let i=e[n];e[n]=e[n+7],e[n+7]=i,i=e[n+1],e[n+1]=e[n+6],e[n+6]=i,i=e[n+2],e[n+2]=e[n+5],e[n+5]=i,i=e[n+3],e[n+3]=e[n+4],e[n+4]=i}}function Su(t,e,n=qt){e!==n&&Rr(t)}function pt(t,e,n=qt){e!==n&&_r(t)}function Zm(t,e,n=qt){e!==n&&Or(t)}function _s(t,e,n,s=qt){if(!(e===s||n===1))switch(n){case 2:Rr(t);break;case 4:_r(t);break;case 8:Or(t);break}}/**
 * @license
 * Copyright 2021 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Nr=null,Os=new Float64Array(1),Tt=new Uint32Array(Os.buffer);function eg(t,e){if(Number.isNaN(t)||Number.isNaN(e))return NaN;if(t===e)return e;if(t===0)return e<0?-Nr:Nr;Os[0]=t;const n=ENDIANNESS===Endianness.LITTLE?0:1,s=1-n;return e>t==t>0?Tt[n]===4294967295?(Tt[n]=0,Tt[s]+=1):Tt[n]+=1:Tt[n]===0?(Tt[n]=4294967295,Tt[s]-=1):Tt[n]-=1,Os[0]}var ee=x(8796);/**
 * @license
 * Copyright 2021 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Qt={[ge.UINT8]:[0,255],[ge.INT8]:[-128,127],[ge.UINT16]:[0,65535],[ge.INT16]:[-32768,32767],[ge.UINT32]:[0,4294967295],[ge.INT32]:[-2147483648,2147483647],[ge.UINT64]:[ee.R.ZERO,new ee.R(4294967295,4294967295)],[ge.FLOAT32]:[0,1]};function tg(t,e){if(typeof e=="number"){const o=t[0],a=t[1];return(e-o)/(a-o)}const n=t[0],s=t[1];let i;Uint64.compare(e,n)<0?i=-Uint64.subtract(tt,n,e).toNumber():i=Uint64.subtract(tt,e,n).toNumber();let r=Uint64.absDifference(tt,s,n).toNumber();return Uint64.compare(n,s)>0&&(r*=-1),i/r}function ng(t,e,n){if(typeof t[0]=="number"){const a=t[0],c=t[1];let l=a*(1-n)+c*n;if(e!==DataType.FLOAT32){const u=Qt[e];l=Math.round(l),l=Math.max(u[0],l),l=Math.min(u[1],l)}return l}let s=t[0],i=t[1];Uint64.compare(s,i)>0&&([s,i]=[i,s],n=1-n);const r=Uint64.subtract(tt,i,s).toNumber(),o=new Uint64;return n<=0?(tt.setFromNumber(r*-n),Uint64.subtract(o,s,Uint64.min(tt,s))):n>=1?(tt.setFromNumber(r*(n-1)),Uint64.add(o,i,tt),Uint64.less(o,i)&&(o.low=o.high=4294967295)):(tt.setFromNumber(r*n),Uint64.add(o,s,tt),Uint64.less(o,s)&&(o.low=o.high=4294967295)),o}function xr(t,e){return typeof e=="number"?Math.min(Math.max(t[0],e),t[1]):Uint64.min(Uint64.max(t[0],e),t[1])}function sg(t,e){return[xr(t,e[0]),xr(t,e[1])]}function ig(t){if(Ar(t[0],t[1])<=0)return t;throw new Error(`Invalid interval: [${t[0]}, ${t[1]}]`)}function rg(t){return Ar(t[0],t[1])<=0?t:[t[1],t[0]]}function Ar(t,e){return typeof t=="number"?t-e:Uint64.compare(t,e)}const tt=new ee.R,bu=new ee.R;function og(t,e){return typeof e=="number"?Math.abs(e-t[0])<Math.abs(e-t[1])?0:1:Uint64.less(Uint64.absDifference(tt,t[0],e),Uint64.absDifference(bu,t[1],e))?0:1}function Iu(t,e){let n;switch(typeof e!="string"?n=""+e:n=e,t){case DataType.UINT64:return Uint64.parseString(n);case DataType.FLOAT32:{const s=parseFloat(n);if(!Number.isFinite(s))throw new Error(`Invalid float32 value: ${JSON.stringify(n)}`);return s}default:{const s=parseInt(n),i=Qt[t];if(!Number.isInteger(s)||s<i[0]||s>i[1])throw new Error(`Invalid ${DataType[t].toLowerCase()} value: ${JSON.stringify(n)}`);return s}}}function Cu(t){if(typeof t=="number")return t;if(typeof t=="string"){const e=new Uint64,n=Number(t);if(e.tryParseString(t))return n.toString()===e.toString()?n:e;if(!Number.isFinite(n))throw new Error(`Invalid value: ${JSON.stringify(t)}`);return n}throw new Error(`Invalid value: ${JSON.stringify(t)}`)}function ag(t,e){return parseFixedLengthArray(new Array(2),t,n=>Iu(e,n))}function cg(t){return parseFixedLengthArray(new Array(2),t,e=>Cu(e))}function Eu(t,e,n){return t===DataType.UINT64?Uint64.equal(e[0],n[0])&&Uint64.equal(e[1],n[1]):e[0]===n[0]&&e[1]===n[1]}function lg(t,e,n=Qt[e]){if(!Eu(e,t,n))return e===DataType.UINT64?[t[0].toString(),t[1].toString()]:t}function ug(t,e,n){switch(t){case DataType.FLOAT32:return nextAfterFloat64(e,n*(1/0));case DataType.UINT64:{const s=e;return n===-1?s.low===0&&s.high===0?s:Uint64.decrement(new Uint64,s):s.low===4294967295&&s.high===4294967295?s:Uint64.increment(new Uint64,s)}default:{const s=Qt[t];return Math.max(s[0],Math.min(s[1],e+n))}}}function dg(t,e){switch(t){case DataType.FLOAT32:return 0;case DataType.UINT64:return .5/Uint64.absDifference(tt,e[0],e[1]).toNumber();default:return .5/Math.abs(e[0]-e[1])}}function hg(t,e){switch(t){case DataType.FLOAT32:return 1;case DataType.UINT64:{const n=Uint64.absDifference(tt,e[0],e[1]).toNumber();return n/(n+1)}default:{const n=Math.abs(e[0]-e[1]);return n/(n+1)}}}function fg(t,e){if(t===void 0)return Qt[e];let[n,s]=t;if(e===DataType.UINT64)return typeof n=="number"&&(n=Uint64.fromNumber(n)),typeof s=="number"&&(s=Uint64.fromNumber(s)),[n,s];if(typeof n!="number"&&(n=n.toNumber()),typeof s!="number"&&(s=s.toNumber()),e!==DataType.FLOAT32){n=Math.round(n),s=Math.round(s);const i=Qt[e];Number.isFinite(n)?n=Math.min(Math.max(i[0],n),i[1]):n=i[0],Number.isFinite(s)?s=Math.min(Math.max(i[0],s),i[1]):s=i[1]}return[n,s]}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Ns(t=128){const e=Math.ceil(t/32),n=new Uint32Array(e);crypto.getRandomValues(n);let s="";for(let i=0;i<e;++i)s+=("00000000"+n[i].toString(16)).slice(-8);return s}function ku(t){const e=new Uint8Array(t.buffer,t.byteOffset,t.byteLength),n=65536;for(let s=0,i=e.length;s<i;s+=n)crypto.getRandomValues(e.subarray(s,Math.min(i,s+n)));return t}function pg(){const t=new Uint32Array(1);return crypto.getRandomValues(t),t[0]}/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Tu extends J.O8{constructor(e){super(),this.id=e,this.changed=new ve.IY}}var ct=(t=>(t[t.POINT=0]="POINT",t[t.LINE=1]="LINE",t[t.AXIS_ALIGNED_BOUNDING_BOX=2]="AXIS_ALIGNED_BOUNDING_BOX",t[t.ELLIPSOID=3]="ELLIPSOID",t))(ct||{});const Xt=[0,1,2,3],mg={float32:ge.FLOAT32,uint32:ge.UINT32,int32:ge.INT32,uint16:ge.UINT16,int16:ge.INT16,uint8:ge.UINT8,int8:ge.INT8,rgb:void 0,rgba:void 0};function Du(t){return t.type!=="rgb"&&t.type!=="rgba"}function Pu(t){return t.type==="uint8"&&t.tag!==void 0}const Dt={rgb:{serializedBytes(){return 3},alignment(){return 1},serializeCode(t,e){return`dv.setUint16(${e}, ${t}, true);dv.setUint8(${e} + 2, ${t} >>> 16);`},deserializeCode(t,e){return`${t} = dv.getUint16(${e}, true) | (dv.getUint8(${e} + 2) << 16);`},deserializeJson(t){return Mr(Ms(t))},serializeJson(t){return gn(gu(t))}},rgba:{serializedBytes(){return 4},alignment(){return 1},serializeCode(t,e){return`dv.setUint32(${e}, ${t}, true);`},deserializeCode(t,e){return`${t} = dv.getUint32(${e}, true);`},deserializeJson(t){return Mr(Pr(t))},serializeJson(t){return gn(yu(t))}},float32:{serializedBytes(){return 4},alignment(){return 4},serializeCode(t,e){return`dv.setFloat32(${e}, ${t}, isLittleEndian);`},deserializeCode(t,e){return`${t} = dv.getFloat32(${e}, isLittleEndian);`},deserializeJson(t){return(0,k._D)(t)},serializeJson(t){return t}},uint32:{serializedBytes(){return 4},alignment(){return 4},serializeCode(t,e){return`dv.setUint32(${e}, ${t}, isLittleEndian);`},deserializeCode(t,e){return`${t} = dv.getUint32(${e}, isLittleEndian);`},deserializeJson(t){return(0,k.bX)(t)},serializeJson(t){return t}},int32:{serializedBytes(){return 4},alignment(){return 4},serializeCode(t,e){return`dv.setInt32(${e}, ${t}, isLittleEndian);`},deserializeCode(t,e){return`${t} = dv.getInt32(${e}, isLittleEndian);`},deserializeJson(t){return(0,k.bX)(t)},serializeJson(t){return t}},uint16:{serializedBytes(){return 2},alignment(){return 2},serializeCode(t,e){return`dv.setUint16(${e}, ${t}, isLittleEndian);`},deserializeCode(t,e){return`${t} = dv.getUint16(${e}, isLittleEndian);`},deserializeJson(t){return(0,k.bX)(t)},serializeJson(t){return t}},int16:{serializedBytes(){return 2},alignment(){return 2},serializeCode(t,e){return`dv.setInt16(${e}, ${t}, isLittleEndian);`},deserializeCode(t,e){return`${t} = dv.getInt16(${e}, isLittleEndian);`},deserializeJson(t){return(0,k.bX)(t)},serializeJson(t){return t}},uint8:{serializedBytes(){return 1},alignment(){return 1},serializeCode(t,e){return`dv.setUint8(${e}, ${t});`},deserializeCode(t,e){return`${t} = dv.getUint8(${e});`},deserializeJson(t){return(0,k.bX)(t)},serializeJson(t){return t}},int8:{serializedBytes(){return 2},alignment(){return 1},serializeCode(t,e){return`dv.setInt8(${e}, ${t});`},deserializeCode(t,e){return`${t} = dv.getInt8(${e});`},deserializeJson(t){return(0,k.bX)(t)},serializeJson(t){return t}}},Mu=255;function Ru(t,e,n){let s=0;const i=n.length,r=new Array(i),o=[];for(let h=0;h<i;++h)r[h]=h;const a=h=>Dt[n[h].type].alignment(t);r.sort((h,p)=>a(p)-a(h));let c=0;const l=new Array(i);let u=e;const d=()=>{u+=(4-u%4)%4,s+=u,o[c]=u,u=0,++c};for(let h=0;h<i;++h){const p=r[h],m=n[p],f=Dt[m.type],b=f.serializedBytes(t),I=f.alignment(t),E=(I-u%I)%I,R=u+E+b;R+(4-R%4)%4<=Mu?u+=E:d(),l[p]={offset:u,group:c},u+=b}return d(),{serializedBytes:s,offsets:l,propertyGroupBytes:o}}class Lr{constructor(e,n,s){if(this.rank=e,this.firstGroupInitialOffset=n,this.propertySpecs=s,s.length===0){this.serializedBytes=n,this.serialize=this.deserialize=()=>{},this.propertyGroupBytes=[n];return}const{serializedBytes:i,offsets:r,propertyGroupBytes:o}=Ru(e,n,s);this.propertyGroupBytes=o;let a="let groupOffset0 = offset;";for(let d=1;d<o.length;++d)a+=`let groupOffset${d} = groupOffset${d-1} + ${o[d-1]}*annotationCount;`;for(let d=0;d<o.length;++d)a+=`groupOffset${d} += ${o[d]}*annotationIndex;`;let c=a,l=a;const u=s.length;for(let d=0;d<u;++d){const{group:h,offset:p}=r[d],m=s[d],f=Dt[m.type],b=`properties[${d}]`,I=`groupOffset${h} + ${p}`;c+=f.serializeCode(b,I,e),l+=f.deserializeCode(b,I,e)}this.serializedBytes=i,this.serialize=new Function("dv","offset","annotationIndex","annotationCount","isLittleEndian","properties",c),this.deserialize=new Function("dv","offset","annotationIndex","annotationCount","isLittleEndian","properties",l)}}function xs(t,e){const n=[];for(const s of Xt){const i=Zt[s];n[s]=new Lr(t,i.serializedBytes(t),e)}return n}function _u(t,e){const n=t.type==="float32"?e.toPrecision(6):e.toString(),{enumValues:s,enumLabels:i}=t;if(s!==void 0){const r=s.indexOf(e);if(r!==-1)return`${i[r]} (${n})`}return n}function gg(t,e){switch(t.type){case"rgb":return serializeColor(unpackRGB(e));case"rgba":return serializeColor(unpackRGBA(e));default:return _u(t,e)}}function Ou(t){const e=verifyString(t);if(e.match(/^[a-z][a-zA-Z0-9_]*$/)===null)throw new Error(`Invalid property identifier: ${JSON.stringify(t)}`);return e}function Nu(t){if(verifyString(t),!Object.prototype.hasOwnProperty.call(Dt,t))throw new Error("Unsupported property type: $JSON.stringify(obj)}");return t}function xu(t){const e=new Set;for(const n of t){if(e.has(n.identifier))throw new Error(`Duplicate property identifier: ${n.identifier}`);e.add(n.identifier)}}function Au(t){verifyObject(t);const e=verifyObjectProperty(t,"id",Ou),n=verifyObjectProperty(t,"type",Nu),s=verifyOptionalObjectProperty(t,"description",verifyString),i=verifyOptionalObjectProperty(t,"default",c=>Dt[n].deserializeJson(c),0);let r,o,a;switch(n){case"rgb":case"rgba":break;default:{const c=DataType[n.toUpperCase()];r=verifyOptionalObjectProperty(t,"enum_values",l=>parseArray(l,u=>parseDataTypeValue(c,u))),r!==void 0&&(o=verifyObjectProperty(t,"enum_labels",l=>parseFixedLengthArray(new Array(r.length),l,verifyString))),a=verifyOptionalObjectProperty(t,"tag",verifyString)}}return{type:n,identifier:e,description:s,default:i,enumValues:r,enumLabels:o,tag:a}}function Lu(t){const e=t.default,n=Du(t),s=n?t.tag:void 0,i=n?t.enumValues:void 0,r=n?t.enumLabels:void 0;return{id:t.identifier,description:t.description,type:t.type,tag:s,enum_values:i,enum_labels:r,default:e===0?void 0:Dt[t.type].serializeJson(e)}}function yg(t){if(!(t===void 0||t.length===0))return t.map(Lu)}function vg(t){if(t===void 0)return[];const e=parseArray(t,Au);return xu(e),e}function As(t,e,n,s,i){for(let r=0;r<s;++r)t.setFloat32(e,i[r],n),e+=4;return e}function Ls(t,e,n,s,i,r){return e=As(t,e,n,s,i),e=As(t,e,n,s,r),e}function Us(t,e,n,s,i){for(let r=0;r<s;++r)i[r]=t.getFloat32(e,n),e+=4;return e}function Vs(t,e,n,s,i,r){return e=Us(t,e,n,s,i),e=Us(t,e,n,s,r),e}const Zt={1:{icon:"\uA579",description:"Line",toJSON(t){return{pointA:Array.from(t.pointA),pointB:Array.from(t.pointB)}},restoreState(t,e,n){t.pointA=(0,k.cQ)(e,"pointA",s=>(0,k.Xu)(new Float32Array(n),s,k.zo)),t.pointB=(0,k.cQ)(e,"pointB",s=>(0,k.Xu)(new Float32Array(n),s,k.zo))},serializedBytes(t){return 2*4*t},serialize(t,e,n,s,i){Ls(t,e,n,s,i.pointA,i.pointB)},deserialize:(t,e,n,s,i)=>{const r=new Float32Array(s),o=new Float32Array(s);return Vs(t,e,n,s,r,o),{type:1,pointA:r,pointB:o,id:i,properties:[]}},visitGeometry(t,e){e(t.pointA,!1),e(t.pointB,!1)}},0:{icon:"\u26AC",description:"Point",toJSON:t=>({point:Array.from(t.point)}),restoreState:(t,e,n)=>{t.point=(0,k.cQ)(e,"point",s=>(0,k.Xu)(new Float32Array(n),s,k.zo))},serializedBytes:t=>t*4,serialize:(t,e,n,s,i)=>{As(t,e,n,s,i.point)},deserialize:(t,e,n,s,i)=>{const r=new Float32Array(s);return Us(t,e,n,s,r),{type:0,point:r,id:i,properties:[]}},visitGeometry(t,e){e(t.point,!1)}},2:{icon:"\u2751",description:"Bounding Box",toJSON:t=>({pointA:Array.from(t.pointA),pointB:Array.from(t.pointB)}),restoreState:(t,e,n)=>{t.pointA=(0,k.cQ)(e,"pointA",s=>(0,k.Xu)(new Float32Array(n),s,k.zo)),t.pointB=(0,k.cQ)(e,"pointB",s=>(0,k.Xu)(new Float32Array(n),s,k.zo))},serializedBytes:t=>2*4*t,serialize(t,e,n,s,i){Ls(t,e,n,s,i.pointA,i.pointB)},deserialize:(t,e,n,s,i)=>{const r=new Float32Array(s),o=new Float32Array(s);return Vs(t,e,n,s,r,o),{type:2,pointA:r,pointB:o,id:i,properties:[]}},visitGeometry(t,e){e(t.pointA,!1),e(t.pointB,!1)}},3:{icon:"\u25CE",description:"Ellipsoid",toJSON:t=>({center:Array.from(t.center),radii:Array.from(t.radii)}),restoreState:(t,e,n)=>{t.center=(0,k.cQ)(e,"center",s=>(0,k.Xu)(new Float32Array(n),s,k.zo)),t.radii=(0,k.cQ)(e,"radii",s=>(0,k.Xu)(new Float32Array(n),s,k.Zw))},serializedBytes:t=>2*4*t,serialize(t,e,n,s,i){Ls(t,e,n,s,i.center,i.radii)},deserialize:(t,e,n,s,i)=>{const r=new Float32Array(s),o=new Float32Array(s);return Vs(t,e,n,s,r,o),{type:3,center:r,radii:o,id:i,properties:[]}},visitGeometry(t,e){e(t.center,!1),e(t.radii,!0)}}};function Uu(t,e){const n=Zt[t.type].toJSON(t,e.rank);n.type=ct[t.type].toLowerCase(),n.id=t.id,n.description=t.description||void 0;const{relatedSegments:s}=t;s?.some(r=>r.length!==0)&&(n.segments=s.map(r=>r.map(o=>o.toString())));const i=e.properties.value;return i.length!==0&&(n.props=t.properties.map((r,o)=>Dt[i[o].type].serializeJson(r))),n}function Vu(t,e,n=!1){(0,k.Rf)(t);const s=(0,k.cQ)(t,"type",c=>(0,k.sl)(c,ct)),i=(0,k.cQ)(t,"id",n?k.z$:k.zr)||Vr(),r=(0,k.cQ)(t,"segments",c=>{if(c===void 0)return e.relationships.map(()=>[]);const l=(0,k.J6)(c);return l.length===0?e.relationships.map(()=>[]):e.relationships.length===1&&!Array.isArray(l[0])?[(0,k.$v)(l,u=>ee.R.parseString(u))]:(0,k.$v)((0,k.J6)(c,e.relationships.length),u=>(0,k.$v)(u,d=>ee.R.parseString(d)))}),o=(0,k.cQ)(t,"props",c=>{const l=e.properties.value;return c===void 0?l.map(u=>u.default):(0,k.$v)((0,k.J6)(c,l.length),(u,d)=>Dt[l[d].type].deserializeJson(u))}),a={id:i,description:(0,k.cQ)(t,"description",k.z$),relatedSegments:r,properties:o,type:s};return Zt[s].restoreState(a,t,e.rank),a}class Ur extends J.O8{constructor(e,n=[],s=new me.B0([])){super(),this.relationships=n,this.properties=s,this.annotationMap=new Map,this.changed=new ve.IY,this.readonly=!1,this.childAdded=new ve.HN,this.childUpdated=new ve.HN,this.childCommitted=new ve.HN,this.childDeleted=new ve.HN,this.pending=new Set,this.references=new Map,this.rank_=e,this.annotationPropertySerializers=xs(e,s.value)}get rank(){return this.rank_}hasNonSerializedProperties(){return!0}add(e,n=!0){if(this.ensureUpdated(),!e.id)e.id=Vr();else if(this.annotationMap.has(e.id))throw new Error(`Annotation id already exists: ${JSON.stringify(e.id)}.`);return this.annotationMap.set(e.id,e),n||this.pending.add(e.id),this.changed.dispatch(),this.childAdded.dispatch(e),n&&this.childCommitted.dispatch(e.id),this.getReference(e.id)}commit(e){this.ensureUpdated();const n=e.id;this.pending.delete(n),this.changed.dispatch(),this.childCommitted.dispatch(n)}update(e,n){if(this.ensureUpdated(),e.value===null)throw new Error("Annotation already deleted.");e.value=n,this.annotationMap.set(n.id,n),e.changed.dispatch(),this.changed.dispatch(),this.childUpdated.dispatch(n)}[Symbol.iterator](){return this.ensureUpdated(),this.annotationMap.values()}get(e){return this.ensureUpdated(),this.annotationMap.get(e)}delete(e){e.value!==null&&(e.value=null,this.annotationMap.delete(e.id),this.pending.delete(e.id),e.changed.dispatch(),this.changed.dispatch(),this.childDeleted.dispatch(e.id))}getReference(e){let n=this.references.get(e);return n!==void 0?n.addRef():(n=new Tu(e),n.value=this.annotationMap.get(e)||null,this.references.set(e,n),n.registerDisposer(()=>{this.references.delete(e)}),n)}ensureUpdated(){}toJSON(){this.ensureUpdated();const e=[],{pending:n}=this;for(const s of this)n.has(s.id)||e.push(Uu(s,this));return e}clear(){this.annotationMap.clear(),this.pending.clear(),this.changed.dispatch()}restoreState(e){this.ensureUpdated();const{annotationMap:n}=this;n.clear(),this.pending.clear(),e!==void 0&&(0,k.$v)(e,s=>{const i=Vu(s,this);n.set(i.id,i)});for(const s of this.references.values()){const{id:i}=s,r=n.get(i);s.value=r||null,s.changed.dispatch()}this.changed.dispatch()}reset(){this.clear()}}class wg extends Ur{constructor(e,n=new me.B0([]),s){super(e.value.sourceRank,s,n),this.watchableTransform=e,this.properties=n,this.getTagProperties=()=>{const{properties:i}=this;return i.value.filter(Pu)},this.curCoordinateTransform=e.value,this.registerDisposer(e.changed.add(()=>this.ensureUpdated())),this.registerDisposer(n.changed.add(()=>{this.updateAnnotationPropertySerializers(),this.changed.dispatch()}))}get rank(){return this.ensureUpdated(),this.rank_}updateAnnotationPropertySerializers(){this.annotationPropertySerializers=xs(this.rank_,this.properties.value)}addProperty(e){this.properties.value.push(e);for(const n of this)n.properties.push(e.default);this.properties.changed.dispatch()}removeProperty(e){const n=this.properties.value.findIndex(s=>s.identifier===e);this.properties.value.splice(n,1);for(const s of this)s.properties.splice(n,1);this.properties.changed.dispatch()}ensureUpdated(){const e=this.watchableTransform.value,{curCoordinateTransform:n}=this;if(e===n)return;this.curCoordinateTransform=e;const s=e.sourceRank,i=n.sourceRank;if(i===s&&(n.inputSpace===e.inputSpace||kt(n.inputSpace.ids.slice(0,s),e.inputSpace.ids.slice(0,s))))return;const{ids:r}=e.inputSpace,o=n.inputSpace.ids,a=[];for(let l=0;l<s;++l){let u=o.indexOf(r[l]);u>=i&&(u=-1),a.push(u)}const c=l=>{const u=new Float32Array(s);for(let d=0;d<s;++d){const h=a[d];u[d]=h===-1?0:l[d]}return u};for(const l of this.annotationMap.values())switch(l.type){case 0:l.point=c(l.point);break;case 1:case 2:l.pointA=c(l.pointA),l.pointB=c(l.pointB);break;case 3:l.center=c(l.center),l.radii=c(l.radii);break}this.rank_!==s&&(this.rank_=s,this.updateAnnotationPropertySerializers()),this.changed.dispatch()}}const Bu="Data Bounds";function Vr(){return Ns(160)}function Fu(t){return{type:2,id:"data-bounds",description:Bu,pointA:new Float32Array(t.lowerBounds),pointB:new Float32Array(t.upperBounds),properties:[]}}function Sg(t){const e=new Ur(t.lowerBounds.length);return e.readonly=!0,e.add(Fu(t)),e}function $u(t,e){let n=0;const s=[];for(const l of Xt){const d=e[l].serializedBytes;s[l]=n;const p=t[l].length;n+=d*p}const i=[],r=[],o=new ArrayBuffer(n),a=new DataView(o),c=qt===xe.LITTLE;for(const l of Xt){const u=e[l],{rank:d}=u,h=u.serialize,p=t[l];i[l]=p.map(E=>E.id),r[l]=new Map(p.map((E,V)=>[E.id,V]));const f=Zt[l].serialize,b=s[l],I=u.propertyGroupBytes[0];for(let E=0,V=p.length;E<V;++E){const R=p[E];f(a,b+E*I,c,d,R),h(a,b,E,V,c,R.properties)}}return{data:new Uint8Array(o),typeToIds:i,typeToOffset:s,typeToIdMaps:r}}class zu{constructor(e){this.propertySerializers=e,this.annotations=[[],[],[],[]]}add(e){this.annotations[e.type].push(e)}serialize(){return $u(this.annotations,this.propertySerializers)}}function Gu(t){if(t==null)return t;const{relatedSegments:e}=t;if(e!==void 0)for(let n=0,s=e.length;n<s;++n){const i=e[n];i!==void 0&&(e[n]=i.map(r=>new ee.R(r.low,r.high)))}return t}var ju=x(9100),Yu=Object.defineProperty,Ju=Object.getOwnPropertyDescriptor,Hu=(t,e,n,s)=>{for(var i=s>1?void 0:s?Ju(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&Yu(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Wu="DisjointUint64Sets",Br="DisjointUint64Sets.add",Fr="DisjointUint64Sets.clear",$r="DisjointUint64Sets.highBitRepresentativeChanged",zr="DisjointUint64Sets.deleteSet";let $n=class extends U{constructor(){super(...arguments),this.disjointSets=new ju.I,this.changed=new ve.IY}get value(){return this}static makeWithCounterpart(t,e){const n=new $n;return n.disjointSets.visibleSegmentEquivalencePolicy=e,n.registerDisposer(e.changed.add(()=>{Gr(n)})),n.initializeCounterpart(t),e.value&&Gr(n),n}disposed(){this.disjointSets=void 0,this.changed=void 0,super.disposed()}link(t,e){if(this.disjointSets.link(t,e)){const{rpc:n}=this;return n&&n.invoke(Br,{id:this.rpcId,al:t.low,ah:t.high,bl:e.low,bh:e.high}),this.changed.dispatch(),!0}return!1}linkAll(t){for(let e=1,n=t.length;e<n;++e)this.link(t[0],t[e])}has(t){return this.disjointSets.has(t)}get(t){return this.disjointSets.get(t)}clear(){if(this.disjointSets.clear()){const{rpc:t}=this;t&&t.invoke(Fr,{id:this.rpcId}),this.changed.dispatch()}}setElements(t){return this.disjointSets.setElements(t)}deleteSet(t){if(this.disjointSets.deleteSet(t)){const{rpc:e}=this;e&&e.invoke(zr,{id:this.rpcId,l:t.low,h:t.high}),this.changed.dispatch()}}get size(){return this.disjointSets.size}toJSON(){return this.disjointSets.toJSON()}restoreState(t){if(t!==void 0){const e=[new ee.R,new ee.R];(0,k.$v)(t,n=>{(0,k.$v)(n,(s,i)=>{e[i%2].parseString(String(s),10),i!==0&&this.link(e[0],e[1])})})}}assignFrom(t){this.clear(),t instanceof $n&&(t=t.disjointSets);for(const[e,n]of t)this.link(e,n)}};$n=Hu([O(Wu)],$n);const en=new ee.R,Bs=new ee.R;Q(Br,function(t){const e=this.get(t.id);en.low=t.al,en.high=t.ah,Bs.low=t.bl,Bs.high=t.bh,e.disjointSets.link(en,Bs)&&e.changed.dispatch()}),Q(Fr,function(t){const e=this.get(t.id);e.disjointSets.clear()&&e.changed.dispatch()});function Gr(t){t.rpc.invoke($r,{id:t.rpcId,value:t.disjointSets.visibleSegmentEquivalencePolicy.value})}Q($r,function(t){const e=this.get(t.id);e.disjointSets.visibleSegmentEquivalencePolicy.value=t.value}),Q(zr,function(t){const e=this.get(t.id);en.low=t.l,en.high=t.h,e.disjointSets.deleteSet(en)&&e.changed.dispatch()});var zn=x(9254);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const jr=3,Ku=.8,Pt=!1;let mt=0,gt=0,Yr=0,Jr=0;class yn{constructor(e=yn.generateHashSeeds(jr)){this.hashSeeds=e,this.loadFactor=Ku,this.size=0,this.emptyLow=4294967295,this.emptyHigh=4294967295,this.maxRehashAttempts=5,this.maxAttempts=5,this.generation=0,this.mungedEmptyKey=-1;let n=8;for(;n<2*e.length;)n*=2;this.allocate(n)}updateHashFunctions(e){this.hashSeeds=yn.generateHashSeeds(e),this.mungedEmptyKey=-1}tableWithMungedEmptyKey(e){const n=this.hashSeeds.length,s=new Array(n);for(let c=0;c<n;++c)s[c]=this.getHash(c,this.emptyLow,this.emptyHigh);let{mungedEmptyKey:i}=this;if(i===-1)e:for(;;){i=Math.random()*16777216>>>0;for(let c=0;c<n;++c){const l=this.getHash(c,i,i);for(let u=0;u<n;++u)if(s[u]===l)continue e}this.mungedEmptyKey=i;break}const{table:r,emptyLow:o,emptyHigh:a}=this;for(let c=0;c<n;++c){const l=s[c];r[l]===o&&r[l+1]===a&&(r[l]=i,r[l+1]=i)}try{e(r)}finally{for(let c=0;c<n;++c){const l=s[c];r[l]===i&&r[l+1]===i&&(r[l]=o,r[l+1]=a)}}}static generateHashSeeds(e=jr){return ku(new Uint32Array(e))}getHash(e,n,s){let i=this.hashSeeds[e];return i=(0,zn._)(i,n),i=(0,zn._)(i,s),this.entryStride*(i&this.tableSize-1)}*keys(){const{emptyLow:e,emptyHigh:n,entryStride:s}=this,{table:i}=this;for(let r=0,o=i.length;r<o;r+=s){const a=i[r],c=i[r+1];(a!==e||c!==n)&&(yield new ee.R(a,c))}}*unsafeKeys(e=new ee.R){const{emptyLow:n,emptyHigh:s,entryStride:i}=this,{table:r}=this;for(let o=0,a=r.length;o<a;o+=i){const c=r[o],l=r[o+1];(c!==n||l!==s)&&(e.low=c,e.high=l,yield e)}}indexOfPair(e,n){const{table:s,emptyLow:i,emptyHigh:r}=this;if(e===i&&n===r)return-1;for(let o=0,a=this.hashSeeds.length;o<a;++o){const c=this.getHash(o,e,n);if(s[c]===e&&s[c+1]===n)return c}return-1}indexOf(e){return this.indexOfPair(e.low,e.high)}chooseAnotherEmptyKey(){const{emptyLow:e,emptyHigh:n,table:s,entryStride:i}=this;let r,o;for(;r=Math.random()*4294967296>>>0,o=Math.random()*4294967296>>>0,!(!(r===e&&o===n)&&!this.hasPair(r,o)););this.emptyLow=r,this.emptyHigh=o;for(let a=0,c=s.length;a<c;a+=i)s[a]===e&&s[a+1]===n&&(s[a]=r,s[a+1]=o)}has(e){return this.indexOf(e)!==-1}hasPair(e,n){return this.indexOfPair(e,n)!==-1}delete(e){const n=this.indexOf(e);if(n!==-1){const{table:s}=this;return s[n]=this.emptyLow,s[n+1]=this.emptyHigh,++this.generation,this.size--,!0}return!1}clearTable(){const{table:e,entryStride:n,emptyLow:s,emptyHigh:i}=this,r=e.length;for(let o=0;o<r;o+=n)e[o]=s,e[o+1]=i}clear(){return this.size===0?!1:(this.size=0,++this.generation,this.clearTable(),!0)}reserve(e){return e>this.capacity?(this.backupPending(),this.grow(e),this.restorePending(),!0):!1}swapPending(e,n){const s=mt,i=gt;this.storePending(e,n),e[n]=s,e[n+1]=i}storePending(e,n){mt=e[n],gt=e[n+1]}backupPending(){Yr=mt,Jr=gt}restorePending(){mt=Yr,gt=Jr}tryToInsert(){Pt&&console.log(`tryToInsert: ${mt}, ${gt}`);let e=0;const{emptyLow:n,emptyHigh:s,maxAttempts:i,table:r}=this,o=this.hashSeeds.length;let a=Math.floor(Math.random()*o);for(;;){const c=this.getHash(a,mt,gt);if(this.swapPending(r,c),mt===n&&gt===s)return!0;if(++e===i)break;a=(a+Math.floor(Math.random()*(o-1))+1)%o}return!1}allocate(e){this.tableSize=e;const{entryStride:n}=this;this.table=new Uint32Array(e*n),this.maxAttempts=e,this.clearTable(),this.capacity=e*this.loadFactor,this.mungedEmptyKey=-1}rehash(e,n){Pt&&console.log("rehash begin"),this.allocate(n),this.updateHashFunctions(this.hashSeeds.length);const{emptyLow:s,emptyHigh:i,entryStride:r}=this;for(let o=0,a=e.length;o<a;o+=r){const c=e[o],l=e[o+1];if((c!==s||l!==i)&&(this.storePending(e,o),!this.tryToInsert()))return Pt&&console.log("rehash failed"),!1}return Pt&&console.log("rehash end"),!0}grow(e){Pt&&console.log(`grow: ${e}`);const n=this.table;let{tableSize:s}=this;for(;s<e;)s*=2;for(;;){for(let i=0;i<this.maxRehashAttempts;++i)if(this.rehash(n,s)){Pt&&console.log("grow end");return}s*=2}}insertInternal(){for(++this.generation,mt===this.emptyLow&&gt===this.emptyHigh&&this.chooseAnotherEmptyKey(),++this.size>this.capacity&&(this.backupPending(),this.grow(this.tableSize*2),this.restorePending());!this.tryToInsert();)this.backupPending(),this.grow(this.tableSize),this.restorePending()}}class Hr extends yn{add(e){const{low:n,high:s}=e;return this.hasPair(n,s)?!1:(Pt&&console.log(`add: ${n},${s}`),mt=n,gt=s,this.insertInternal(),!0)}[Symbol.iterator](){return this.unsafeKeys()}}Hr.prototype.entryStride=2;let vn=0,wn=0,Wr=0,Kr=0;class qr extends yn{set(e,n){const{low:s,high:i}=e;return this.hasPair(s,i)?!1:(Pt&&console.log(`add: ${s},${i} -> ${n.low},${n.high}`),mt=s,gt=i,vn=n.low,wn=n.high,this.insertInternal(),!0)}get(e,n){const s=this.indexOf(e);if(s===-1)return!1;const{table:i}=this;return n.low=i[s+2],n.high=i[s+3],!0}swapPending(e,n){const s=vn,i=wn;super.swapPending(e,n),e[n+2]=s,e[n+3]=i}storePending(e,n){super.storePending(e,n),vn=e[n+2],wn=e[n+3]}backupPending(){super.backupPending(),Wr=vn,Kr=wn}restorePending(){super.restorePending(),vn=Wr,wn=Kr}[Symbol.iterator](){return this.unsafeEntries()}*entries(){const{emptyLow:e,emptyHigh:n,entryStride:s}=this,{table:i}=this;for(let r=0,o=i.length;r<o;r+=s){const a=i[r],c=i[r+1];if(a!==e||c!==n){const l=new ee.R(a,c),u=new ee.R(i[r+2],i[r+3]);yield[l,u]}}}*unsafeEntries(e=[new ee.R,new ee.R]){const{emptyLow:n,emptyHigh:s,entryStride:i}=this,{table:r}=this,[o,a]=e;for(let c=0,l=r.length;c<l;c+=i){const u=r[c],d=r[c+1];(u!==n||d!==s)&&(o.low=u,o.high=d,a.low=r[c+2],a.high=r[c+3],yield e)}}}qr.prototype.entryStride=4;var qu=Object.defineProperty,Qu=Object.getOwnPropertyDescriptor,Xu=(t,e,n,s)=>{for(var i=s>1?void 0:s?Qu(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&qu(e,n,i),i};/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let Fs=class extends U{constructor(){super(...arguments),this.hashTable=new qr,this.changed=new ve.HN}get value(){return this}static makeWithCounterpart(t){const e=new Fs;return e.initializeCounterpart(t),e}set_(t,e){return this.hashTable.set(t,e)}set(t,e){if(this.set_(t,e)){const{rpc:n}=this;n&&n.invoke("Uint64Map.set",{id:this.rpcId,key:t,value:e}),this.changed.dispatch(t,!0)}}has(t){return this.hashTable.has(t)}get(t,e){return this.hashTable.get(t,e)}[Symbol.iterator](){return this.hashTable.entries()}unsafeEntries(){return this.hashTable.unsafeEntries()}delete_(t){return this.hashTable.delete(t)}delete(t){if(this.delete_(t)){const{rpc:e}=this;e&&e.invoke("Uint64Map.delete",{id:this.rpcId,key:t}),this.changed.dispatch(t,!1)}}get size(){return this.hashTable.size}assignFrom(t){this.clear();for(const[e,n]of t.unsafeEntries())this.set(e,n)}clear(){if(this.hashTable.clear()){const{rpc:t}=this;t&&t.invoke("Uint64Map.clear",{id:this.rpcId}),this.changed.dispatch(null,!1)}}toJSON(){const t={};for(const[e,n]of this.hashTable.unsafeEntries())t[e.toString()]=n.toString();return t}};Fs=Xu([O("Uint64Map")],Fs),Q("Uint64Map.set",function(t){const e=this.get(t.id);e.set_(t.key,t.value)&&e.changed.dispatch()}),Q("Uint64Map.delete",function(t){const e=this.get(t.id);e.delete_(t.key)&&e.changed.dispatch()}),Q("Uint64Map.clear",function(t){const e=this.get(t.id);e.hashTable.clear()&&e.changed.dispatch()});var Zu=Object.defineProperty,ed=Object.getOwnPropertyDescriptor,td=(t,e,n,s)=>{for(var i=s>1?void 0:s?ed(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&Zu(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let Sn=class extends U{constructor(){super(...arguments),this.hashTable=new Hr,this.changed=new ve.HN}get value(){return this}static makeWithCounterpart(t){const e=new Sn;return e.initializeCounterpart(t),e}set(t,e){e?this.add(t):this.delete(t)}reserve_(t){return this.hashTable.reserve(t)}reserve(t){if(this.reserve_(t)){const{rpc:e}=this;e&&e.invoke("Uint64Set.reserve",{id:this.rpcId,value:t})}}add_(t){let e=!1;for(const n of t)e=this.hashTable.add(n)||e;return e}add(t){const e=Array().concat(t);if(this.add_(e)){const{rpc:n}=this;n&&n.invoke("Uint64Set.add",{id:this.rpcId,value:e}),this.changed.dispatch(t,!0)}}has(t){return this.hashTable.has(t)}[Symbol.iterator](){return this.hashTable.keys()}unsafeKeys(){return this.hashTable.unsafeKeys()}delete_(t){let e=!1;for(const n of t)e=this.hashTable.delete(n)||e;return e}delete(t){const e=Array().concat(t);if(this.delete_(Array().concat(t))){const{rpc:n}=this;n&&n.invoke("Uint64Set.delete",{id:this.rpcId,value:e}),this.changed.dispatch(t,!1)}}get size(){return this.hashTable.size}clear(){if(this.hashTable.clear()){const{rpc:t}=this;t&&t.invoke("Uint64Set.clear",{id:this.rpcId}),this.changed.dispatch(null,!1)}}toJSON(){const t=new Array;for(const e of this.unsafeKeys())t.push(e.toString());return t.sort(),t}assignFrom(t){this.clear();for(const e of t.unsafeKeys())this.add(e)}};Sn=td([O("Uint64Set")],Sn),Q("Uint64Set.reserve",function(t){const e=this.get(t.id);e.reserve_(t.value)&&e.changed.dispatch()}),Q("Uint64Set.add",function(t){const e=this.get(t.id);e.add_(t.value)&&e.changed.dispatch()}),Q("Uint64Set.delete",function(t){const e=this.get(t.id);e.delete_(t.value)&&e.changed.dispatch()}),Q("Uint64Set.clear",function(t){const e=this.get(t.id);e.hashTable.clear()&&e.changed.dispatch()});var $s=x(4242);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const nd=["visibleSegments","segmentEquivalences","temporaryVisibleSegments","temporarySegmentEquivalences","useTemporaryVisibleSegments","useTemporarySegmentEquivalences"];function Qr(t,e,n){t.registerDisposer(e.visibleSegments.changed.add(n)),t.registerDisposer(e.segmentEquivalences.changed.add(n))}function Xr(t,e,n){t.registerDisposer(e.temporaryVisibleSegments.changed.add(n)),t.registerDisposer(e.temporarySegmentEquivalences.changed.add(n)),t.registerDisposer(e.useTemporaryVisibleSegments.changed.add(n)),t.registerDisposer(e.useTemporarySegmentEquivalences.changed.add(n))}function Gn(t){return`${t.low},${t.high}`}function sd(t){return!!(t.high>>>31)}function id(t){return t.useTemporaryVisibleSegments.value?t.temporaryVisibleSegments:t.visibleSegments}function rd(t){return t.useTemporarySegmentEquivalences.value?t.temporarySegmentEquivalences:t.segmentEquivalences}function bn(t,e){const n=id(t),s=rd(t),i=s.disjointSets.visibleSegmentEquivalencePolicy.value;for(const r of n.unsafeKeys())if(i&$s.y6.NONREPRESENTATIVE_EXCLUDED){const o=s.get(r);e(r,o)}else{if(!s.disjointSets.isMinElement(r))continue;for(const o of s.setElements(r))i&$s.y6.REPRESENTATIVE_EXCLUDED&&i&$s.y6.MAX_REPRESENTATIVE&&sd(o)||e(o,r)}}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Zr(t,e,n={}){for(const s of nd)n[s]=t.get(e[s]);return n}const jn=t=>class extends t{constructor(...n){const[s,i]=n;super(s,i),Zr(s,i,this),this.transform=s.get(i.transform),this.renderScaleTarget=s.get(i.renderScaleTarget);const r=()=>{this.chunkManager.scheduleUpdateChunkPriorities()};Xr(this,this,r),Qr(this,this,r),this.registerDisposer(this.transform.changed.add(r)),this.registerDisposer(this.renderScaleTarget.changed.add(r))}};class od extends K{constructor(e,n){super(e,n),this.properties=n.properties}}var ad=Object.defineProperty,cd=Object.getOwnPropertyDescriptor,Yn=(t,e,n,s)=>{for(var i=s>1?void 0:s?cd(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&ad(e,n,i),i};/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ld=200,ud=60;class dd extends _e{freeSystemMemory(){this.annotation=void 0}serialize(e,n){super.serialize(e,n),e.annotation=this.annotation}downloadSucceeded(){this.systemMemoryBytes=this.gpuMemoryBytes=0,super.downloadSucceeded()}}class eo{serialize(e,n){e.data=this.data,e.typeToOffset=this.typeToOffset,e.typeToIds=this.typeToIds,e.typeToIdMaps=this.typeToIdMaps,n.push(this.data.buffer)}get numBytes(){return this.data.byteLength}}function to(t){class e extends t{serialize(s,i){super.serialize(s,i);const{data:r}=this;r!==void 0&&(r.serialize(s,i),this.data=void 0)}downloadSucceeded(){const{data:s}=this;this.systemMemoryBytes=this.gpuMemoryBytes=s===void 0?0:s.numBytes,super.downloadSucceeded()}freeSystemMemory(){this.data=void 0}}return e}class hd extends to(yr){}class fd extends to(_e){}let no=class extends K{constructor(){super(...arguments),this.parent=void 0}getChunk(t){const{chunks:e}=this;let n=e.get(t);return n===void 0&&(n=this.getNewChunk_(dd),n.initialize(t),this.addChunk(n)),n}download(t,e){return this.parent.downloadMetadata(t,e)}};no=Yn([O(su)],no);class zs extends vr{constructor(e,n){super(e,n),this.parent=e.get(n.parent)}}zs.prototype.chunkConstructor=hd;let so=class extends K{constructor(){super(...arguments),this.parent=void 0}getChunk(t){const e=Gn(t),{chunks:n}=this;let s=n.get(e);return s===void 0&&(s=this.getNewChunk_(fd),s.initialize(e),s.objectId=t.clone(),this.addChunk(s)),s}download(t,e){return this.parent.downloadSegmentFilteredGeometry(t,this.relationshipIndex,e)}};so=Yn([O(iu)],so);class io extends U{constructor(e,n){super(e,n),this.references=new Set;const s=this.chunkManager=e.get(n.chunkManager),i=this.metadataChunkSource=this.registerDisposer(e.getRef(n.metadataChunkSource));this.segmentFilteredSources=n.segmentFilteredSource.map((r,o)=>{const a=this.registerDisposer(e.getRef(r));return a.parent=this,a.relationshipIndex=o,a}),i.parent=this,this.registerDisposer(s.recomputeChunkPriorities.add(()=>this.recomputeChunkPriorities()))}recomputeChunkPriorities(){const{chunkManager:e,metadataChunkSource:n}=this;for(const s of this.references)e.requestChunk(n.getChunk(s),se.VISIBLE,ld)}add(e){throw new Error("Not implemented")}delete(e){throw new Error("Not implemented")}update(e,n){throw new Error("Not implemented")}}Q(ru,function(t){const e=this.get(t.id);e.references.add(t.annotation),e.chunkManager.scheduleUpdateChunkPriorities()}),Q(ou,function(t){const e=this.get(t.id);e.references.delete(t.annotation),e.chunkManager.scheduleUpdateChunkPriorities()}),Q(au,function(t){const e=this.get(t.id),n=t.annotationId,s=Gu(t.newAnnotation);let i;n===void 0?i=e.add(s).then(r=>({...s,id:r})):s===null?i=e.delete(n).then(()=>null):i=e.update(n,s).then(()=>s),i.then(r=>{e.wasDisposed||this.invoke(Tr,{id:e.rpcId,annotationId:n||s.id,newAnnotation:r})},r=>{e.wasDisposed||this.invoke(Tr,{id:e.rpcId,annotationId:n||s?.id,error:r.message})})});let Gs=class extends It(xn){constructor(t,e){super(t,e),this.renderScaleTarget=t.get(e.renderScaleTarget),this.localPosition=t.get(e.localPosition);const n=()=>this.chunkManager.scheduleUpdateChunkPriorities();this.registerDisposer(this.localPosition.changed.add(n)),this.registerDisposer(this.renderScaleTarget.changed.add(n)),this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(()=>this.recomputeChunkPriorities()))}attach(t){const e=()=>this.chunkManager.scheduleUpdateChunkPriorities(),{view:n}=t;t.registerDisposer(e),t.registerDisposer(n.projectionParameters.changed.add(e)),t.registerDisposer(n.visibility.changed.add(e)),t.state={displayDimensionRenderInfo:n.projectionParameters.value.displayDimensionRenderInfo,transformedSources:[]}}recomputeChunkPriorities(){this.chunkManager.registerLayer(this);for(const t of this.attachments.values()){const{view:e}=t,n=e.visibility.value;if(n===Number.NEGATIVE_INFINITY)continue;const s=t.state,{transformedSources:i}=s;if(i.length===0||!Is(s,e.projectionParameters.value.displayDimensionRenderInfo))continue;const r=ht(n),o=ft(n),a=e.projectionParameters.value,{chunkManager:c}=this;fu(a,this.localPosition.value,this.renderScaleTarget.value,i[0],()=>{},(l,u)=>{const d=l.source.getChunk(l.curPositionInChunks);++this.numVisibleChunksNeeded,d.state===_.GPU_MEMORY&&++this.numVisibleChunksAvailable,c.requestChunk(d,r,o+0+Ds*u)})}}};Gs=Yn([O(cu)],Gs),Q(lu,function(t){const e=this.get(t.view),n=this.get(t.layer),s=n.attachments.get(e);s.state.transformedSources=Fn(this,t.sources,n),s.state.displayDimensionRenderInfo=t.displayDimensionRenderInfo,n.chunkManager.scheduleUpdateChunkPriorities()});let js=class extends At(It(hs)){constructor(t,e){super(t,e),this.source=t.get(e.source),this.segmentationStates=new me.B0(this.getSegmentationState(e.segmentationStates));const n=()=>this.chunkManager.scheduleUpdateChunkPriorities();this.registerDisposer((0,me.no)((s,i)=>{if(i!==void 0){for(const r of i)r!=null&&(Qr(s,r,n),Xr(s,r,n));n()}},this.segmentationStates)),this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(()=>this.recomputeChunkPriorities()))}recomputeChunkPriorities(){const t=this.visibility.value;if(t===Number.NEGATIVE_INFINITY)return;const{segmentationStates:{value:e},source:{segmentFilteredSources:n}}=this;if(e===void 0)return;const{chunkManager:s}=this;s.registerLayer(this);const i=e.length;for(let r=0;r<i;++r){const o=e[r];if(o==null)continue;const a=ht(t),c=ft(t),l=n[r];bn(o,u=>{const d=l.getChunk(u);++this.numVisibleChunksNeeded,d.state===_.GPU_MEMORY&&++this.numVisibleChunksAvailable,s.requestChunk(d,a,c+ud)})}}getSegmentationState(t){if(t!==void 0)return t.map(e=>e==null?e:Zr(this.rpc,e))}};js=Yn([O(uu)],js),Q(du,function(t){const e=this.get(t.id);e.segmentationStates.value=e.getSegmentationState(t.segmentationStates)});/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class pd extends J.O8{constructor(){super(...arguments),this.errorHandler=async(e,n)=>{const{status:s}=e;if(s===401||s===403&&!n.accessToken)return"refresh";throw e instanceof Error&&n.email!==void 0&&(e.message+=`  (Using credentials for ${JSON.stringify(n.email)})`),e}}}function Ys(t){let e,n,s;return(i,r)=>n!==void 0&&(e===void 0||i===void 0||e.generation!==i.generation)?(e===void 0&&s.addConsumer(r),n):(e=void 0,s=new j.y3,n=t(i,s).then(o=>(e=o,s=void 0,o),o=>{throw s.isCanceled&&(s=void 0,n=void 0),o}),n)}function bg(t){let e=0;return Ys((n,s)=>t(s).then(i=>({generation:++e,credentials:i})))}class md{constructor(){this.providers=new Map,this.topLevelManager=this}register(e,n){this.providers.set(e,n)}getCredentialsProvider(e,n){const s=this.providers.get(e);if(s===void 0)throw new Error(`No registered credentials provider: ${JSON.stringify(e)}`);return s(n,this.topLevelManager)}}class gd extends J.O8{constructor(e){super(),this.base=e,this.memoize=new qe.e}getCredentialsProvider(e,n){return this.memoize.get({key:e,parameters:n},()=>this.registerDisposer(this.base.getCredentialsProvider(e,n).addRef()))}}class Ig extends gd{constructor(){super(new md),this.base.topLevelManager=this}register(e,n){this.base.register(e,n)}}class Cg extends pd{constructor(e,n){super(),this.baseProvider=e,this.anonymousCredentials=n,this.anonymous=!0,this.get=Ys(s=>this.anonymous&&s===void 0?Promise.resolve({generation:-10,credentials:this.anonymousCredentials}):(this.anonymous=!1,this.baseProvider.get(s)))}}var ro=x(957),yd=Object.defineProperty,vd=Object.getOwnPropertyDescriptor,wd=(t,e,n,s)=>{for(var i=s>1?void 0:s?vd(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&yd(e,n,i),i};/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let oo=class extends U{constructor(){super(...arguments),this.get=Ys((t,e)=>this.rpc.promiseInvoke(ro.y,{providerId:this.rpcId,invalidCredentials:t},e))}};oo=wd([O(ro.P)],oo);function Ye(){return t=>class extends t{constructor(...e){super(...e);const n=e[1];this.credentialsProvider=this.rpc.getOptionalRef(n.credentialsProvider)}}}var ao=x(2366),Ie=x(9808);/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Eg="boss";function Sd(t,e,n,s,i=j.fx){return(0,Ie.Bk)(e,n,s,i).catch(r=>{if(r.status!==500&&r.status!==401&&r.status!==403&&r.status!==504)throw r;return(0,ao.R)(t,e,n,s,o=>{const a=new Headers(n.headers);return a.set("Authorization",`Bearer ${o}`),{...n,headers:a}},o=>{const{status:a}=o;if(a===403||a===401)return"refresh";throw o},i)})}var co=x(6650),Mt=x(3708);/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Jn=!1;function lo(t,e,n,s,i,r,o){const{octree:a,lodScales:c,chunkGridSpatialOrigin:l,chunkShape:u}=t,d=c.length-1,h=e[0],p=e[4],m=e[8],f=e[1],b=e[5],I=e[9],E=e[3],V=e[7],R=e[11],C=e[15],S=E>0?0:1,T=V>0?0:1,v=R>0?0:1,N=n[4*4],H=n[4*4+1],y=n[4*4+2],A=n[4*4+3];function L(St,zt,Ot){return E*St+V*zt+R*Ot+C}function Y(St,zt,Ot,Nt,Gt,Si){return L(St+S*(Nt-St),zt+T*(Gt-zt),Ot+v*(Si-Ot))}const le=L(-A*N,-A*H,-A*y),we=t.clipLowerBound[0],pe=t.clipLowerBound[1],$e=t.clipLowerBound[2],Fe=t.clipUpperBound[0],_t=t.clipUpperBound[1],Pn=t.clipUpperBound[2],an=Math.sqrt((h*i)**2+(f*r)**2),$t=Math.sqrt((p*i)**2+(b*r)**2),rt=Math.sqrt((m*i)**2+(I*r)**2),wt=Math.max(an,$t,rt);function Mn(St,zt,Ot){const Nt=1<<St,Gt=zt*5,Si=a[Gt],pp=a[Gt+1],mp=a[Gt+2],gp=a[Gt+3],sc=a[Gt+4];let Rn=Si*Nt*u[0]+l[0],_n=pp*Nt*u[1]+l[1],On=mp*Nt*u[2]+l[2],cs=Rn+Nt*u[0],ls=_n+Nt*u[1],us=On+Nt*u[2];if(Rn=Math.max(Rn,we),_n=Math.max(_n,pe),On=Math.max(On,$e),cs=Math.min(cs,Fe),ls=Math.min(ls,_t),us=Math.min(us,Pn),(0,w.T_)(Rn,_n,On,cs,ls,us,n)){const bi=Math.max(le,Y(Rn,_n,On,cs,ls,us))/wt;if(Ot===0||bi*s<Ot){const cn=c[St];if(cn!==0&&o(St,zt,cn/bi,sc>>>31),St>0&&(cn===0||bi*s<cn)){const yp=cn===0?Ot:cn,vp=(sc&2147483647)>>>0;for(let Ii=gp;Ii<vp;++Ii)Mn(St-1,Ii,yp)}}}}Mn(d,a.length/5-1,0)}function kg(t,e,n,s,i,r,o,a){const{lodScales:c}=t;let l=0;for(;l+1<c.length&&c[l+1]!==0;)++l;const u=3,d=[];let h=0,p=0;function m(I,E){for(Jn&&console.log(`emitChunksUpTo: stackDepth=${h}, targetStackIndex=${I}, subChunkIndex=${E}, priorSubChunkIndex=${p}`);;){if(h===0)return;const V=h-1,R=l-V,C=d[V*u],S=R===0?1:8,T=d[V*u+1],v=d[V*u+2];if(I===h){const N=E&S-1;p!==N&&C!==-1&&(Jn&&console.log(`  drawing chunk because priorSubChunkIndex (${p}) != endSubChunk (${N})`),a(R,C,p,N,v)),p=N+1;return}p!==S&&C!==-1&&a(R,C,p,S,v),p=T+1,--h}}let f=0;Jn&&(console.log(""),console.log("Starting to draw"));const{octree:b}=t;lo(t,e,n,s,i,r,(I,E,V,R)=>{if(!R&&!o(I,E,V)){f=Math.max(I,f);return}if(I<f)return;f=0;const C=E*5,S=b[C],T=b[C+1],v=b[C+2],N=getOctreeChildIndex(S,T,v),H=l-I;m(H,N);const y=H*u;d[y]=R?-1:E,d[y+1]=N,d[y+2]=V,Jn&&console.log(`Adding to stack: lod=${I}, row=${d[y]}, subChunkIndex=${N}`),p=0,h=H+1}),m(0,0)}function Tg(t){if(t.length%5!==0)throw new Error("Invalid length");const e=t.length/5,n=new Set;function s(i){if(n.has(i))throw new Error("Previously seen node");if(n.add(i),i<0||i>=e)throw new Error("Invalid node reference");const r=t[i*5],o=t[i*5+1],a=t[i*5+2],c=t[i*5+3],l=t[i*5+4];if(c<0||l<0||l<c||l>e||c+8<l)throw new Error("Invalid child references");for(let u=c;u<l;++u){const d=t[u*5],h=t[u*5+1],p=t[u*5+2];if(d>>>1!==r||h>>>1!==o||p>>>1!==a)throw new Error("invalid child");s(u)}}if(e!==0&&(s(e-1),n.size!==e))throw new Error("Orphan nodes in octree")}function Dg(t,e,n){return`${t}/${e}:${n}`}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Hn=!1;function bd(t){let e=0;for(let n=0,s=t.length;n<s;n+=3){let i=t[n],r=t[n+1],o=t[n+2],a;i>r&&(a=i,i=r,r=a),r>o&&(a=r,r=o,o=a),i>r&&(a=i,i=r,r=a),t[n]=i,t[n+1]=r,t[n+2]=o,o>e&&(e=o)}return e}let Js=0;function Id(t,e,n,s,i,r){const o=e-1>>>0;let a=(i&o)>>>0;for(let c=0;;++c){const l=t[a];if(l===s)return t[a]=n,n;if(r(l))return l;++Js,a=(a+c+1&o)>>>0}}function Cd(t,e){return(0,zn._)((0,zn._)(0,t),e)}const Ed=1053042;function kd(t){return Ed>>>t*3&7}function Wn(t){return(t>>>2)*3}function Kn(t){return t&3}function Hs(t){return t>>>1}function Ws(t){return 1+(t+1>>>1)}function uo(t){return 2-t}function Td(t){return 2**Math.ceil(Math.log2(t))*4}function Dd(t,e,n){const s=e.length/3,i=n.length,r=4294967295;t.fill(r),n.fill(r);for(let o=0;o<s;++o){const a=o*3;for(let c=0;c<3;++c){const l=e[a+Hs(c)],u=e[a+Ws(c)],d=o<<2|c,h=Id(n,i,d,r,Cd(l,u),p=>{const m=Wn(p),f=Kn(p),b=e[m+Hs(f)],I=e[m+Ws(f)];return l===b&&u===I});if(h!==d){const p=Wn(h),m=Kn(h);t[p+m]=d,t[a+c]=h}}}return t}function Pd(t,e,n,s){const i=-1>>>32-8*n.BYTES_PER_ELEMENT,o=t.length/3,a=4294967295;e:for(let c=0;c<o;++c){let l=c*3;if(t[l]!==i){for(let u=0;u<3;++u){let d=e[l+u];if(d===a)continue;let h=Wn(d);if(t[h]===i)continue;const p=Kn(d);n[s++]=t[l+uo(u)],n[s++]=t[l+Hs(u)],n[s++]=t[l+Ws(u)];let m=p;for(;;){if(t[l]=i,l=h,n[s++]=t[l+uo(m&3)],m=kd(m),d=e[l+(m&3)],d===a||t[h=Wn(d)]===i){n[s++]=i,t[l]=i;continue e}m=Kn(d)|m&4}}n[s++]=t[l],n[s++]=t[l+1],n[s++]=t[l+2],t[l]=i,n[s++]=i}}return s}function Md(t,e){if(t.length===0)return t;Js=0,e===void 0&&(e=Uint32Array.of(0,t.length));let n=0,s=0,i=0,r=0,o=0;const a=bd(t),c=t.length/3*4,l=a>=65535?new Uint32Array(c):new Uint16Array(c);let u=0,d=0;const h=e.length-1;for(let I=0;I<h;++I)d=Math.max(d,e[I+1]-e[I]);const p=new Uint32Array(d),m=new Uint32Array(Td(d));let f=e[0];for(let I=0;I<h;++I){e[I]=u;const E=e[I+1],V=t.subarray(f,E);Hn&&(i=Date.now()),Dd(p,V,m),Hn&&(r=Date.now()),u=Pd(V,p,l,u),Hn&&(o=Date.now(),n+=r-i,s+=o-r),f=E}--u,e[h]=u;const b=new l.constructor(u);return b.set(l.subarray(0,u)),Hn&&console.log(`reduced from ${t.byteLength}(${t.BYTES_PER_ELEMENT}) -> ${b.byteLength}(${b.BYTES_PER_ELEMENT}): adj=${n}, emit=${s}, ${Js}/${t.length} collisions`),b}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Rd(t,e,n){return t&1|e<<1&2|n<<2&4}function _d(t,e,n,s){const i=Math.max(e,n,s);let r=0,o=t.low,a=0,c=0,l=0;for(let u=0;u<i;++u){if(u<e){const d=o>>>r&1;a|=d<<u,r===31?(r=0,o=t.high):++r}if(u<n){const d=o>>>r&1;c|=d<<u,r===31?(r=0,o=t.high):++r}if(u<s){const d=o>>>r&1;l|=d<<u,r===31?(r=0,o=t.high):++r}}return Uint32Array.of(a,c,l)}function ho(t,e,n,s,i,r,o){const a=Math.max(e,n,s);let c=0,l=0,u=!1;function d(h){l|=(h&1)<<c,++c===32&&(t.low=l>>>0,l=0,c=0,u=!0)}for(let h=0;h<a;++h)h<e&&d(i>>h&1),h<n&&d(r>>h&1),h<s&&d(o>>h&1);return u?t.high=l>>>0:(t.high=0,t.low=l>>>0),t}function Od(t,e,n){let s=0;const i=e.length;let r=0,o=!1;function a(c){r|=(c&1)<<s,++s===32&&(t.low=r>>>0,r=0,s=0,o=!0)}for(let c=0;c<32;++c)for(let l=0;l<i;++l)n[l]-1>>>c&&a(e[l]>>>c);return o?t.high=r>>>0:(t.high=0,t.low=r>>>0),t}function fo(t,e){return t<e&&t<(t^e)}function Ks(t,e,n,s,i,r){let o=n,a=r;return fo(o^a,e^i)&&(o=e,a=i),fo(o^a,t^s)&&(o=t,a=s),o<a}var Nd=Object.defineProperty,xd=Object.getOwnPropertyDescriptor,qn=(t,e,n,s)=>{for(var i=s>1?void 0:s?xd(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&Nd(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const po=100,mo=50,Ad=!1;class Ld extends _e{constructor(){super(...arguments),this.objectId=new ee.R}initializeManifestChunk(e,n){super.initialize(e),this.objectId.assign(n)}freeSystemMemory(){this.fragmentIds=null}serialize(e,n){super.serialize(e,n),e.fragmentIds=this.fragmentIds}downloadSucceeded(){this.systemMemoryBytes=100,this.gpuMemoryBytes=0,super.downloadSucceeded(),this.priorityTier<se.RECENT&&this.source.chunkManager.scheduleUpdateChunkPriorities()}toString(){return this.objectId.toString()}}function go(t,e,n){const{vertexPositions:s,indices:i,vertexNormals:r,strips:o}=t;e.vertexPositions=s,e.indices=i,e.strips=o,e.vertexNormals=r;const a=s.buffer;n.push(a);const c=i.buffer;c!==a&&n.push(c),n.push(r.buffer)}function yo(t){const{vertexPositions:e,indices:n,vertexNormals:s}=t;return e.byteLength+n.byteLength+s.byteLength}class Ud extends _e{constructor(){super(...arguments),this.manifestChunk=null,this.fragmentId=null,this.meshData=null}initializeFragmentChunk(e,n,s){super.initialize(e),this.manifestChunk=n,this.fragmentId=s}freeSystemMemory(){this.manifestChunk=null,this.meshData=null,this.fragmentId=null}serialize(e,n){super.serialize(e,n),go(this.meshData,e,n),this.meshData=null}downloadSucceeded(){this.systemMemoryBytes=this.gpuMemoryBytes=yo(this.meshData),super.downloadSucceeded()}}function vo(t,e,n){(0,k.Rf)(e),t.fragmentIds=(0,k.cQ)(e,n,k.si)}function wo(t,e){const n=w.eR.create(),s=w.eR.create(),i=w.eR.create(),r=new Float32Array(t.length),o=e.length;for(let c=0;c<o;c+=3){const l=e[c]*3,u=e[c+1]*3,d=e[c+2]*3;for(let h=0;h<3;++h)s[h]=t[u+h]-t[l+h],i[h]=t[d+h]-t[u+h];w.eR.cross(n,s,i),w.eR.normalize(n,n);for(let h=0;h<3;++h){const m=e[c+h]*3;for(let f=0;f<3;++f)r[m+f]+=n[f]}}const a=r.length;for(let c=0;c<a;c+=3){const l=r.subarray(c,c+3);w.eR.normalize(l,l)}return r}function Qn(t){return Math.min(Math.max(-127,t*127+.5),127)>>>0}function So(t){return t<0?-1:1}function Vd(t,e){const n=e.length;let s=0;for(let i=0;i<n;i+=3){const r=e[i],o=e[i+1],a=e[i+2],c=1/(Math.abs(r)+Math.abs(o)+Math.abs(a));a<0?(t[s]=Qn((1-Math.abs(o*c))*So(r)),t[s+1]=Qn((1-Math.abs(r*c))*So(o))):(t[s]=Qn(r*c),t[s+1]=Qn(o*c)),s+=2}}function bo(t,e,n,s,i,r,o){const a=new Float32Array(e,s,i*3);pt(a,n),r===void 0&&(r=s+12*i);let c;o!==void 0&&(c=o*t);const l=c===void 0?new Uint32Array(e,r):new Uint32Array(e,r,c);if(l.length%t!==0)throw new Error(`Number of indices is not a multiple of ${t}: ${l.length}.`);return pt(l,n),{vertexPositions:a,indices:l}}function qs(t,e,n,s,i,r){return bo(3,t,e,n,s,i,r)}class In extends K{constructor(e,n){super(e,n);const s=this.fragmentSource=this.registerDisposer(e.getRef(n.fragmentSource));s.meshSource=this}getChunk(e){const n=Gn(e);let s=this.chunks.get(n);return s===void 0&&(s=this.getNewChunk_(Ld),s.initializeManifestChunk(n,e),this.addChunk(s)),s}getFragmentKey(e,n){return{key:`${e}/${n}`,fragmentId:n}}getFragmentChunk(e,n){const s=this.fragmentSource,{key:i,fragmentId:r}=this.getFragmentKey(e.key,n);let o=s.chunks.get(i);return o===void 0&&(o=s.getNewChunk_(Ud),o.initializeFragmentChunk(i,e,r),s.addChunk(o)),o}}let Io=class extends K{constructor(){super(...arguments),this.meshSource=null}download(t,e){return this.meshSource.downloadFragment(t,e)}};Io=qn([O(Mt.dI)],Io);let Co=class extends jn(At(It(Er))){constructor(t,e){super(t,e),this.source=this.registerDisposer(t.getRef(e.source)),this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(()=>{this.updateChunkPriorities()}))}attach(t){const e=()=>{this.chunkManager.scheduleUpdateChunkPriorities()},{view:n}=t;t.registerDisposer(n.visibility.changed.add(e)),t.registerDisposer(e),e()}updateChunkPriorities(){const t=this.visibility.value;if(t===Number.NEGATIVE_INFINITY)return;this.chunkManager.registerLayer(this);const e=ht(t),n=ft(t),{source:s,chunkManager:i}=this;bn(this,r=>{const o=s.getChunk(r);++this.numVisibleChunksNeeded,i.requestChunk(o,e,n+po);const a=o.state;if(a===_.SYSTEM_MEMORY_WORKER||a===_.SYSTEM_MEMORY||a===_.GPU_MEMORY){++this.numVisibleChunksAvailable;for(const c of o.fragmentIds){const l=s.getFragmentChunk(o,c);++this.numVisibleChunksNeeded,i.requestChunk(l,e,n+mo),l.state===_.GPU_MEMORY&&++this.numVisibleChunksAvailable}}})}};Co=qn([O(Mt.Of)],Co);class Bd extends _e{constructor(){super(...arguments),this.objectId=new ee.R}initializeManifestChunk(e,n){super.initialize(e),this.objectId.assign(n)}freeSystemMemory(){this.manifest=void 0}serialize(e,n){super.serialize(e,n),e.manifest=this.manifest}downloadSucceeded(){this.systemMemoryBytes=this.manifest.octree.byteLength,this.gpuMemoryBytes=0,super.downloadSucceeded(),this.priorityTier<se.RECENT&&this.source.chunkManager.scheduleUpdateChunkPriorities()}toString(){return this.objectId.toString()}}class Fd extends _e{constructor(){super(...arguments),this.subChunkOffsets=null,this.meshData=null,this.lod=0,this.chunkIndex=0,this.manifestChunk=null}freeSystemMemory(){this.meshData=this.subChunkOffsets=null}serialize(e,n){super.serialize(e,n),go(this.meshData,e,n);const{subChunkOffsets:s}=this;e.subChunkOffsets=s,n.push(s.buffer),this.meshData=this.subChunkOffsets=null}downloadSucceeded(){const{subChunkOffsets:e}=this;this.systemMemoryBytes=this.gpuMemoryBytes=yo(this.meshData),this.systemMemoryBytes+=e.byteLength,super.downloadSucceeded()}}class Eo extends K{constructor(e,n){super(e,n);const s=this.fragmentSource=this.registerDisposer(e.getRef(n.fragmentSource));this.format=n.format,s.meshSource=this}getChunk(e){const n=Gn(e);let s=this.chunks.get(n);return s===void 0&&(s=this.getNewChunk_(Bd),s.initializeManifestChunk(n,e),this.addChunk(s)),s}getFragmentChunk(e,n,s){const i=`${e.key}/${n}:${s}`,r=this.fragmentSource;let o=r.chunks.get(i);return o===void 0&&(o=r.getNewChunk_(Fd),o.initialize(i),o.lod=n,o.chunkIndex=s,o.manifestChunk=e,r.addChunk(o)),o}}let ko=class extends K{constructor(){super(...arguments),this.meshSource=null}download(t,e){return this.meshSource.downloadFragment(t,e)}};ko=qn([O(Mt.pi)],ko);const $d=w.pB.create();let To=class extends jn(At(It(Er))){constructor(t,e){super(t,e),this.source=this.registerDisposer(t.getRef(e.source)),this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(()=>{this.updateChunkPriorities()}))}attach(t){const e=()=>this.chunkManager.scheduleUpdateChunkPriorities(),{view:n}=t;t.registerDisposer(n.projectionParameters.changed.add(e)),t.registerDisposer(n.visibility.changed.add(e)),t.registerDisposer(e),e()}updateChunkPriorities(){const t=this.visibility.value;if(t===Number.NEGATIVE_INFINITY)return;const{transform:{value:e}}=this;if(e.error!==void 0)return;const n=new Array;this.chunkManager.registerLayer(this);{const r=ht(t),o=ft(t),{source:a,chunkManager:c}=this;bn(this,l=>{const u=a.getChunk(l);++this.numVisibleChunksNeeded,c.requestChunk(u,r,o+po);const d=u.state;(d===_.SYSTEM_MEMORY_WORKER||d===_.SYSTEM_MEMORY||d===_.GPU_MEMORY)&&(n.push(u),++this.numVisibleChunksAvailable)})}if(n.length===0)return;const{source:s,chunkManager:i}=this;for(const{view:r}of this.attachments.values()){const o=r.visibility.value;if(o===Number.NEGATIVE_INFINITY)continue;const a=ht(o),c=ft(o),l=r.projectionParameters.value,u=$d;try{pl(u,l.displayDimensionRenderInfo,e)}catch{continue}w.pB.multiply(u,l.viewProjectionMat,u);const d=(0,w._S)(new Float32Array(24),u),h=this.renderScaleTarget.value;for(const p of n){const m=p.manifest.lodScales.length-1;lo(p.manifest,u,d,h,l.width,l.height,(f,b,I,E)=>{if(E)return;const V=s.getFragmentChunk(p,f,b);++this.numVisibleChunksNeeded,i.requestChunk(V,a,c+mo-m+f),V.state===_.GPU_MEMORY&&++this.numVisibleChunksAvailable})}}}};To=qn([O(Mt.Yo)],To);function Do(t,e){const n=wo(t.vertexPositions,t.indices),s=new Uint8Array(n.length/3*2);Vd(s,n);let i,r;Ad?(i=Md(t.indices,t.subChunkOffsets),r=!0):(t.indices.BYTES_PER_ELEMENT===4&&t.vertexPositions.length/3<65535?(i=new Uint16Array(t.indices.length),i.set(t.indices)):i=t.indices,r=!1);let o;if(e===Mt.Pc.uint10){const a=t.vertexPositions,c=a.length/3;o=new Uint32Array(c);for(let l=0,u=0;u<c;l+=3,++u)o[u]=a[l]&1023|(a[l+1]&1023)<<10|(a[l+2]&1023)<<20}else if(e===Mt.Pc.uint16){const a=t.vertexPositions;a.BYTES_PER_ELEMENT===2?o=a:(o=new Uint16Array(a.length),o.set(a))}else o=t.vertexPositions;return{vertexPositions:o,vertexNormals:s,indices:i,strips:r}}function Cn(t,e,n=Mt.Pc.float32){t.meshData=Do(e,n)}function Po(t,e,n){t.meshData=Do(e,n),t.subChunkOffsets=e.subChunkOffsets}function Mo(t,e,n){let s=n;for(let i=0;i<3;++i)t[s*5+i]=t[e*5+i]>>>1;t[s*5+3]=e;for(let i=e+1;i<n;++i){const r=t[i*5]>>>1,o=t[i*5+1]>>>1,a=t[i*5+2]>>>1;(r!==t[s*5]||o!==t[s*5+1]||a!==t[s*5+2])&&(t[s*5+4]=i,++s,t[s*5]=r,t[s*5+1]=o,t[s*5+2]=a,t[s*5+3]=i)}return t[s*5+4]=n,++s,s}function zd(t,e,n,s){let i=e;for(let r=n;r<s;++r){const o=t[r*5],a=t[r*5+1],c=t[r*5+2];for(;i<n;){const l=t[i*5]>>>1,u=t[i*5+1]>>>1,d=t[i*5+2]>>>1;if(!Ks(l,u,d,o,a,c))break;++i}for(t[r*5+3]=i;i<n;){const l=t[i*5]>>>1,u=t[i*5+1]>>>1,d=t[i*5+2]>>>1;if(l!==o||u!==a||d!==c)break;++i}t[r*5+4]+=i}}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function yt(t){return{id:t}}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const tn=yt("decodeGzip");/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let Qs=0;const Xs=[],Xn=new Map,En=new Map,Gd=typeof navigator.hardwareConcurrency>"u"?4:Math.min(12,navigator.hardwareConcurrency);let jd=0;function Ro(t){for(const[e,n]of Xn){Xn.delete(e),t.postMessage(n.msg,n.transfer);return}Xs.push(t)}function Yd(){++Qs;const t=new Worker(new URL(x.p+x.u(491),x.b),{type:"module"});let e=!1;t.onmessage=n=>{if(!e){e=!0,Ro(t);return}const{id:s,value:i,error:r}=n.data;Ro(t);const o=En.get(s);En.delete(s),o!==void 0&&(o.cleanup(),r!==void 0?o.reject(new Error(r)):o.resolve(i))}}function Be(t,e,n,...s){if(e.isCanceled)return Promise.reject(j.wS);const i=jd++,r={t:t.id,id:i,args:s},o=e.add(()=>{Xn.delete(i),En.delete(i)}),a=new Promise((c,l)=>{En.set(i,{resolve:c,reject:l,cleanup:o})});return Xs.length!==0?Xs.pop().postMessage(r,n):(Xn.set(i,{msg:r,transfer:n}),En.size>Qs&&Qs<Gd&&Yd()),a}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Jd=yt("encodeCompressedSegmentationUint32"),Hd=yt("encodeCompressedSegmentationUint64");/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function kn(t,e,n){const{spec:s}=t.source;if(s.compressedSegmentationBlockSize!==void 0){const{dataType:i}=s,r=t.chunkDataSize,o=[r[0],r[1],r[2],r[3]||1];switch(i){case ge.UINT32:t.data=await Be(Jd,e,[n.buffer],n,o,s.compressedSegmentationBlockSize);break;case ge.UINT64:t.data=await Be(Hd,e,[n.buffer],n,o,s.compressedSegmentationBlockSize);break;default:throw new Error(`Unsupported data type for compressed segmentation: ${ge[i]}`)}}else t.data=n}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Ct=new Map;Ct.set("|u1",{endianness:xe.LITTLE,dataType:ge.UINT8}),Ct.set("|i1",{endianness:xe.LITTLE,dataType:ge.INT8});for(const[t,e]of[["<",xe.LITTLE],[">",xe.BIG]]){for(const n of["u","i"])Ct.set(`${t}${n}8`,{endianness:e,dataType:ge.UINT64});Ct.set(`${t}u2`,{endianness:e,dataType:ge.UINT16}),Ct.set(`${t}i2`,{endianness:e,dataType:ge.INT16}),Ct.set(`${t}u4`,{endianness:e,dataType:ge.UINT32}),Ct.set(`${t}i4`,{endianness:e,dataType:ge.INT32}),Ct.set(`${t}f4`,{endianness:e,dataType:ge.FLOAT32})}function Wd(t){const e=Ct.get(t);if(e===void 0)throw new Error(`Unsupported numpy data type: ${JSON.stringify(t)}`);return e}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Kd{constructor(e,n,s,i){this.data=e,this.shape=n,this.dataType=s,this.fortranOrder=i}}function qd(t){if(t[0]!==147||t[1]!==78||t[2]!==85||t[3]!==77||t[4]!==80||t[5]!==89)throw new Error("Data does not match npy format.");const e=t[6],n=t[7];if(e!==1||n!==0)throw new Error(`Unsupported npy version ${e}.${n}`);const i=new DataView(t.buffer,t.byteOffset,t.byteLength).getUint16(8,!0),r=new TextDecoder("utf-8").decode(t.subarray(10,i+10));let o;const a=i+10;try{o=(0,k.HB)(r)}catch(E){throw new Error(`Failed to parse npy header: ${E}`)}const c=o.descr,l=o.shape;let u=1;if(!Array.isArray(l))throw new Error("Invalid shape ${JSON.stringify(shape)}");for(const E of l){if(typeof E!="number")throw new Error("Invalid shape ${JSON.stringify(shape)}");u*=E}const{dataType:d,endianness:h}=Wd(c),p=Wt[d],m=sr[d],f=nr[d],b=m*u;if(p*u+a!==t.byteLength)throw new Error("Expected length does not match length of data");const I=new f(t.buffer,t.byteOffset+a,b);return _s(I,h,p),new Kd(I,l,d,o.fortran_order===!0)}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Qd(t,e,n){const s=qd(await Be(tn,e,[n],new Uint8Array(n))),i=t.chunkDataSize,r=t.source,{shape:o}=s;if(o.length!==3||o[0]!==i[2]||o[1]!==i[1]||o[2]!==i[0])throw new Error(`Shape ${JSON.stringify(o)} does not match chunkDataSize ${(0,w.nL)(i)}`);const a=s.dataType,{spec:c}=r;if(a!==c.dataType)throw new Error(`Data type ${ge[a]} does not match expected data type ${ge[c.dataType]}`);await kn(t,e,s.data)}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Zs=yt("decodeJpeg");/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Zn(t,e,n){const s=t.chunkDataSize,{uint8Array:i}=await Be(Zs,e,[n],new Uint8Array(n),s[0],s[1]*s[2],s[3]||1,!1);await kn(t,e,i)}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Xd extends yr{constructor(){super(...arguments),this.source=null}initializeVolumeChunk(e,n){super.initializeVolumeChunk(e,n),this.chunkDataSize=null,this.data=null}serialize(e,n){super.serialize(e,n);const s=this.chunkDataSize;s!==this.source.spec.chunkDataSize&&(e.chunkDataSize=s);const i=e.data=this.data;i!==null&&n.push(i.buffer),this.data=null}downloadSucceeded(){this.systemMemoryBytes=this.gpuMemoryBytes=this.data?.byteLength??0,super.downloadSucceeded()}freeSystemMemory(){this.data=null}}function _o(t,e){const{spec:n,tempChunkDataSize:s,tempChunkPosition:i}=t,{upperVoxelBound:r,rank:o,baseVoxelOffset:a}=n,c=n.chunkDataSize,l=s,u=pc(i,e.chunkGridPosition,c);let d=!1;for(let h=0;h<o;++h){const p=Math.min(r[h],u[h]+c[h]);(l[h]=p-u[h])!==c[h]&&(d=!0)}return Pi(u,u,a),d?e.chunkDataSize=Uint32Array.from(l):e.chunkDataSize=c,u}class vt extends vr{constructor(e,n){super(e,n);const s=this.spec.rank;this.tempChunkDataSize=new Uint32Array(s),this.tempChunkPosition=new Float32Array(s)}computeChunkBounds(e){return _o(this,e)}}vt.prototype.chunkConstructor=Xd;var Zd=Object.defineProperty,eh=Object.getOwnPropertyDescriptor,Oo=(t,e,n,s)=>{for(var i=s>1?void 0:s?eh(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&Zd(e,n,i),i};/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ei=new Map;ei.set("npz",Qd),ei.set("jpeg",Zn);const ti=new Map;ti.set("npz","application/npygz"),ti.set("jpeg","image/jpeg");function No(t,e){return je(Ye()(t),e)}let xo=class extends No(vt,co.jj){constructor(){super(...arguments),this.chunkDecoder=ei.get(this.parameters.encoding)}async download(t,e){const{parameters:n}=this;let s=`${n.baseUrl}/latest/cutout/${n.collection}/${n.experiment}/${n.channel}/${n.resolution}`;{const r=this.computeChunkBounds(t),o=t.chunkDataSize;for(let a=0;a<3;++a)s+=`/${r[a]}:${r[a]+o[a]}`}s+="/",n.window!==void 0&&(s+=`?window=${n.window[0]},${n.window[1]}`);const i=await Sd(this.credentialsProvider,s,{headers:{Accept:ti.get(n.encoding)}},Ie.Rc,e);await this.chunkDecoder(t,e,i)}};xo=Oo([O()],xo);function th(t,e){return vo(t,e,"fragments")}function nh(t,e){const s=new DataView(e).getUint32(0,!0);Cn(t,qs(e,xe.LITTLE,4,s))}let Ao=class extends No(In,co.Ve){download(t,e){const{parameters:n}=this;return(0,Ie.Bk)(`${n.baseUrl}${t.objectId}`,{},Ie.Rc,e).then(s=>th(t,s))}downloadFragment(t,e){const{parameters:n}=this;return(0,Ie.Bk)(`${n.baseUrl}${t.fragmentId}`,{},Ie.Rc,e).then(s=>nh(t,s))}};Ao=Oo([O()],Ao);var es=x(3551);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Pg="google-brainmaps";function lt(t,e,n,s=j.fx){return(0,es.Y)(e,`${t.serverUrl}${n.path}`,{method:n.method,body:n.payload},n.responseType==="json"?Ie.cj:Ie.Rc,s)}var it=x(2020),sh=x(3786),ih=Object.defineProperty,rh=Object.getOwnPropertyDescriptor,oh=(t,e,n,s)=>{for(var i=s>1?void 0:s?rh(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&ih(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ah=60;class ch extends _e{constructor(){super(...arguments),this.objectId=new ee.R,this.vertexPositions=null,this.vertexAttributes=null,this.indices=null}initializeSkeletonChunk(e,n){super.initialize(e),this.objectId.assign(n)}freeSystemMemory(){this.vertexPositions=this.indices=null}getVertexAttributeBytes(){let e=this.vertexPositions.byteLength;const{vertexAttributes:n}=this;return n?.forEach(s=>{e+=s.byteLength}),e}serialize(e,n){super.serialize(e,n);const s=this.vertexPositions,i=this.indices;e.numVertices=s.length/3,e.indices=i,n.push(i.buffer);const{vertexAttributes:r}=this;if(r!=null&&r.length>0){const o=new Uint8Array(this.getVertexAttributeBytes());o.set(new Uint8Array(s.buffer,s.byteOffset,s.byteLength));const a=e.vertexAttributeOffsets=new Uint32Array(r.length+1);a[0]=0;let c=s.byteLength;r.forEach((l,u)=>{a[u+1]=c,o.set(new Uint8Array(l.buffer,l.byteOffset,l.byteLength),c),c+=l.byteLength}),n.push(o.buffer),e.vertexAttributes=o}else e.vertexAttributes=new Uint8Array(s.buffer,s.byteOffset,s.byteLength),e.vertexAttributeOffsets=Uint32Array.of(0),s.buffer!==n[0]&&n.push(s.buffer);this.vertexPositions=this.indices=this.vertexAttributes=null}downloadSucceeded(){this.systemMemoryBytes=this.gpuMemoryBytes=this.indices.byteLength+this.getVertexAttributeBytes(),super.downloadSucceeded()}}class ni extends K{getChunk(e){const n=Gn(e);let s=this.chunks.get(n);return s===void 0&&(s=this.getNewChunk_(ch),s.initializeSkeletonChunk(n,e),this.addChunk(s)),s}}let Lo=class extends jn(At(It(hs))){constructor(t,e){super(t,e),this.source=this.registerDisposer(t.getRef(e.source)),this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(()=>{this.updateChunkPriorities()}))}updateChunkPriorities(){const t=this.visibility.value;if(t===Number.NEGATIVE_INFINITY)return;this.chunkManager.registerLayer(this);const e=ht(t),n=ft(t),{source:s,chunkManager:i}=this;bn(this,r=>{const o=s.getChunk(r);++this.numVisibleChunksNeeded,o.state===_.GPU_MEMORY&&++this.numVisibleChunksAvailable,i.requestChunk(o,e,n+ah)})}};Lo=oh([O(sh.k)],Lo);function Uo(t,e,n,s,i,r,o){const a=bo(2,e,n,s,i,r,o);t.vertexPositions=a.vertexPositions,t.indices=a.indices}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function si(t,e,n){t.data=new Uint32Array(n)}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Lt(t,e,n,s=qt,i=0,r=n.byteLength){const{spec:o}=t.source,{dataType:a}=o,c=gc(t.chunkDataSize),l=Wt[a],u=c*l;if(u!==r)throw new Error(`Raw-format chunk is ${r} bytes, but ${c} * ${l} = ${u} bytes are expected.`);const d=ir(a,n,i,r);_s(d,s,l),await kn(t,e,d)}var lh=x(8795),uh=Object.defineProperty,dh=Object.getOwnPropertyDescriptor,nn=(t,e,n,s)=>{for(var i=s>1?void 0:s?dh(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&uh(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const hh=new Map([[it.r7.RAW,Lt],[it.r7.JPEG,Zn],[it.r7.COMPRESSED_SEGMENTATION,si]]);function Vo(t,e){t&&(e.change_spec={change_stack_id:t.changeStackId},t.timeStamp&&(e.change_spec.time_stamp=t.timeStamp),t.skipEquivalences&&(e.change_spec.skip_equivalences=t.skipEquivalences))}function sn(t,e){return je(Ye()(t),e)}const fh=new ee.R;let Bo=class extends sn(vt,it.CR){constructor(){super(...arguments),this.chunkDecoder=hh.get(this.parameters.encoding)}applyEncodingParams(t){const{encoding:e}=this.parameters;switch(e){case it.r7.RAW:t.subvolume_format="RAW";break;case it.r7.JPEG:t.subvolume_format="SINGLE_IMAGE",t.image_format_options={image_format:"JPEG",jpeg_quality:this.parameters.jpegQuality};return;case it.r7.COMPRESSED_SEGMENTATION:t.subvolume_format="RAW",t.image_format_options={compressed_segmentation_block_size:(0,w.nL)(this.spec.compressedSegmentationBlockSize)};break;default:throw new Error(`Invalid encoding: ${e}`)}}async download(t,e){const{parameters:n}=this,s=this.computeChunkBounds(t),i=t.chunkDataSize,r=`/v1/volumes/${n.volumeId}/subvolume:binary`,o={geometry:{corner:(0,w.nL)(s),size:(0,w.nL)(i),scale:n.scaleIndex}};this.applyEncodingParams(o),Vo(n.changeSpec,o);const a=await lt(n.instance,this.credentialsProvider,{method:"POST",payload:JSON.stringify(o),path:r,responseType:"arraybuffer"},e);await this.chunkDecoder(t,e,a)}};Bo=nn([O()],Bo);function ph(t,e,n,s){const i=new ee.R;if(!i.tryParseString(t,16))throw new Error(`Couldn't parse fragmentId ${t} as hex-encoded Uint64`);return _d(i,e,n,s)}function mh(t,e){(0,k.Rf)(e);const n=t.source,s=(0,k.cQ)(e,"fragmentKey",k.si),i=(0,k.cQ)(e,"supervoxelId",k.si),r=s.length;if(r!==i.length)throw new Error("Expected fragmentKey and supervoxelId arrays to have the same length.");const o=new Map;s.forEach((R,C)=>{let S=o.get(R);S===void 0&&(S=[],o.set(R,S)),S.push(i[C])});const{chunkShape:a}=n.parameters.info,c=n.parameters.info.lods[0].gridShape,l=Math.ceil(Math.log2(c[0])),u=Math.ceil(Math.log2(c[1])),d=Math.ceil(Math.log2(c[2])),h=Array.from(o.entries()).map(([R,C])=>({fragmentId:R,corner:ph(R,l,u,d),supervoxelIds:C}));h.sort((R,C)=>Ks(R.corner[0],R.corner[1],R.corner[2],C.corner[0],C.corner[1],C.corner[2])?-1:1);let p,m,f=0,b;if(r===0)p=m=w.w8,b=Uint32Array.of(0,0,0,0,2147483648);else{const R=w.eR.clone(w.WG),C=w.eR.clone(w.w8);for(h.forEach(S=>{const{corner:T}=S;for(let v=0;v<3;++v)R[v]=Math.min(R[v],T[v]),C[v]=Math.max(C[v],T[v])}),f=1;C[0]>>>f-1!==R[0]>>>f-1||C[1]>>>f-1!==R[1]>>>f-1||C[2]>>>f-1!==R[2]>>>f-1;)++f;p=w.eR.multiply(R,R,a),m=w.eR.add(C,w.eR.multiply(C,C,a),a)}const{lods:I}=n.parameters.info,E=new Float32Array(Math.max(I.length,f));for(let R=0;R<I.length;++R)E[R]=I[R].scale;if(r!==0){const R=new Uint32Array(h.length*E.length*5);h.forEach((T,v)=>{R.set(T.corner,v*5),R[v*5]=T.corner[0]});let C=0,S=h.length;for(let T=1;T<E.length;++T){const v=Mo(R,C,S);C=S,S=v}b=R.slice(0,S*5)}const V={chunkShape:a,chunkGridSpatialOrigin:w.w8,clipLowerBound:p,clipUpperBound:m,octree:b,lodScales:E,vertexOffsets:new Float32Array(E.length*3)};t.manifest=V,t.fragmentSupervoxelIds=h}const ii=255;function Fo(t,e){const n=t.byteLength;let s=0;const i=new DataView(t),r=32;for(;s<n;){if(s+r>n)throw new Error("Invalid batch mesh fragment response.");const o=i.getUint32(s,!0),a=i.getUint32(s+4,!0),l=new ee.R(o,a).toString()+"\0";s+=8;const u=i.getUint32(s,!0),d=i.getUint32(s+4,!0);if(s+=8,d!==0)throw new Error("Invalid batch mesh fragment response.");if(s+u+8+8>n)throw new Error("Invalid batch mesh fragment response.");const h=new TextDecoder().decode(new Uint8Array(t,s,u)),p=l+h;s+=u;const m=i.getUint32(s,!0),f=i.getUint32(s+4,!0);s+=8;const b=i.getUint32(s,!0),I=i.getUint32(s+4,!0);if(s+=8,f!==0||I!==0)throw new Error("Invalid batch mesh fragment response.");const E=s+b*12+m*12;if(E>n)throw new Error("Invalid batch mesh fragment response.");e({fullKey:p,buffer:t,verticesOffset:s,numVertices:m,indicesOffset:s+12*m,numIndices:b*3}),s=E}}function $o(t){let e=0,n=0;for(const a of t)e+=a.numVertices,n+=a.numIndices;const s=new Float32Array(e*3),i=new Uint32Array(n);let r=0,o=0;for(const a of t){s.set(new Float32Array(a.buffer,a.verticesOffset,a.numVertices*3),r*3);const{numIndices:c}=a,l=new Uint32Array(a.buffer,a.indicesOffset,c);pt(l,xe.LITTLE);for(let u=0;u<c;++u)i[o++]=l[u]+r;r+=a.numVertices}return pt(s,xe.LITTLE),{vertexPositions:s,indices:i}}async function zo(t,e,n,s){const i="/v1/objects/meshes:batch",r=[];let o,a=0;const c=new Map;for(const[u,d]of n){c.set(u,d),n.delete(u);const h=u.indexOf("\0"),p=u.substring(0,h),m=u.substring(h+1);if(p!==o&&r.push({object_id:p,fragment_keys:[]}),r[r.length-1].fragment_keys.push(m),++a===ii)break}const l={volume_id:e.volumeId,mesh_name:e.meshName,batches:r};try{return await lt(e.instance,t,{method:"POST",path:i,payload:JSON.stringify(l),responseType:"arraybuffer"},s)}finally{for(const[u,d]of c)n.set(u,d)}}let Go=class extends sn(Eo,it.Ip){constructor(){super(...arguments),this.listFragmentsParams=(()=>{const{parameters:t}=this,{changeSpec:e}=t;return e!==void 0?`&header.changeStackId=${e.changeStackId}`:""})()}download(t,e){const{parameters:n}=this,s=`/v1/objects/${n.volumeId}/meshes/${n.info.lods[0].info.name}:listfragments?object_id=${t.objectId}&return_supervoxel_ids=true`+this.listFragmentsParams;return lt(n.instance,this.credentialsProvider,{method:"GET",path:s,responseType:"json"},e).then(i=>mh(t,i))}async downloadFragment(t,e){const{parameters:n}=this,s=t.manifestChunk,{fragmentSupervoxelIds:i}=s,r=s.manifest,{lod:o}=t,{octree:a}=r,c=i.length,l=t.chunkIndex;let u=l;for(;u>=c;)u=a[u*5+3];let d=l+1;for(;d>c;)d=a[d*5-1]&2147483647;const{relativeBlockShape:h,gridShape:p}=n.info.lods[o],m=Math.ceil(Math.log2(p[0])),f=Math.ceil(Math.log2(p[1])),b=Math.ceil(Math.log2(p[2]));let I=new Map;for(let y=u;y<d;++y){const A=Math.floor(a[y*5]/h[0]),L=Math.floor(a[y*5+1]/h[1]),Y=Math.floor(a[y*5+2]/h[2]),le=ho(fh,m,f,b,A,L,Y).toString(16).padStart(16,"0"),we=i[y];for(const pe of we.supervoxelIds)I.set(pe+"\0"+le,y)}const E=Math.max(0,o-1),V=[],R=Array.from(I);R.sort((y,A)=>(0,lh.e)(y[0],A[0])),I=new Map(R);const C=n.info.lods[o].info.name,S=!0;await new Promise((y,A)=>{let L=0,Y=!1;const le=()=>{if(!Y){for(;I.size!==0&&(++L,zo(this.credentialsProvider,{instance:n.instance,volumeId:n.volumeId,meshName:C},I,e).then(we=>{--L,Fo(we,pe=>{const $e=I.get(pe.fullKey);if(!I.delete(pe.fullKey))throw new Error(`Received unexpected fragment key: ${JSON.stringify(pe.fullKey)}.`);pe.chunkIndex=$e,V.push(pe)}),le()}).catch(we=>{Y=!0,A(we)}),!!S););if(t.downloadSlots=Math.max(1,L),L===0){y(void 0);return}}};le()}),V.sort((y,A)=>y.chunkIndex-A.chunkIndex);let T=0;const v=1<<3*(o-E),N=new Uint32Array(v+1);let H=0;for(const y of V){const A=y.chunkIndex,L=Rd(a[A*5]>>>E,a[A*5+1]>>>E,a[A*5+2]>>>E)&v-1;N.fill(T,H+1,L+1),H=L,T+=y.numIndices}N.fill(T,H+1,v+1),Po(t,{...$o(V),subChunkOffsets:N},Mt.Pc.float32)}};Go=nn([O()],Go);function gh(t){const e=[];let n=0;const s=t.length;for(;n<s;)e.push(JSON.stringify(t.slice(n,n+ii))),n+=ii;return e}function yh(t,e){(0,k.Rf)(e);const n=(0,k.cQ)(e,"fragmentKey",k.si),s=(0,k.cQ)(e,"supervoxelId",k.si);if(n.length!==s.length)throw new Error("Expected fragmentKey and supervoxelId arrays to have the same length.");const r=s.map((o,a)=>o+"\0"+n[a]);t.fragmentIds=gh(r)}let jo=class extends sn(In,it.Ve){constructor(){super(...arguments),this.listFragmentsParams=(()=>{const{parameters:t}=this,{changeSpec:e}=t;return e!==void 0?`&header.changeStackId=${e.changeStackId}`:""})()}download(t,e){const{parameters:n}=this,s=`/v1/objects/${n.volumeId}/meshes/${n.meshName}:listfragments?object_id=${t.objectId}&return_supervoxel_ids=true`+this.listFragmentsParams;return lt(n.instance,this.credentialsProvider,{method:"GET",path:s,responseType:"json"},e).then(i=>yh(t,i))}async downloadFragment(t,e){const{parameters:n}=this,s=new Map;for(const o of JSON.parse(t.fragmentId))s.set(o,null);const i=[],{credentialsProvider:r}=this;for(;s.size!==0;){const o=await zo(r,n,s,e);Fo(o,a=>{if(!s.delete(a.fullKey))throw new Error(`Received unexpected fragment key: ${JSON.stringify(a.fullKey)}.`);i.push(a)})}Cn(t,$o(i))}};jo=nn([O()],jo);function vh(t,e){const n=new DataView(e),s=n.getUint32(0,!0);if(n.getUint32(4,!0)!==0)throw new Error("The number of vertices should not exceed 2^32-1.");const r=n.getUint32(8,!0);if(n.getUint32(12,!0)!==0)throw new Error("The number of edges should not exceed 2^32-1.");Uo(t,e,xe.LITTLE,16,s,void 0,r)}let Yo=class extends sn(ni,it.NV){download(t,e){const{parameters:n}=this,s={object_id:`${t.objectId}`},i=`/v1/objects/${n.volumeId}/meshes/${n.meshName}/skeleton:binary`;return Vo(n.changeSpec,s),lt(n.instance,this.credentialsProvider,{method:"POST",path:i,payload:JSON.stringify(s),responseType:"arraybuffer"},e).then(r=>vh(t,r))}};Yo=nn([O()],Yo);const ri=["LOCATION","LINE","VOLUME"];function Jo(t){const e=/(-?[0-9]+),(-?[0-9]+),(-?[0-9]+)/,n=t.match(e);if(n===null)throw new Error(`Error parsing number triplet: ${JSON.stringify(t)}.`);return w.eR.fromValues(parseFloat(n[1]),parseFloat(n[2]),parseFloat(n[3]))}function oi(t){return t.volumeId+":"+t.changestack+":"}function Ho(t,e){if(!e.startsWith(t))throw new Error(`Received annotation id ${JSON.stringify(e)} does not have expected prefix of ${JSON.stringify(t)}.`);return e.substring(t.length)}function wh(t){if(t!=null)return[(0,k.$v)(t,e=>ee.R.parseString(""+e,10))]}function Wo(t,e,n){const s=(0,k.cQ)(t,"corner",u=>Jo((0,k.zr)(u))),i=(0,k.cQ)(t,"size",u=>Jo((0,k.zr)(u))),r=(0,k.cQ)(t,"payload",k.z$),o=(0,k.cQ)(t,"type",k.zr),a=(0,k.cQ)(t,"id",k.zr),c=Ho(e,a),l=(0,k.cQ)(t,"objectLabels",wh);if(n!==void 0&&c!==n)throw new Error(`Received annotation has unexpected id ${JSON.stringify(a)}.`);switch(o){case"LOCATION":{if(w.eR.equals(i,w.w8))return{type:ct.POINT,id:c,point:s,description:r,relatedSegments:l,properties:[]};const u=w.eR.scale(w.eR.create(),i,.5),d=w.eR.add(w.eR.create(),s,u);return{type:ct.ELLIPSOID,id:c,center:d,radii:u,description:r,relatedSegments:l,properties:[]}}case"LINE":return{type:ct.LINE,id:c,pointA:s,pointB:w.eR.add(w.eR.create(),s,i),description:r,relatedSegments:l,properties:[]};case"VOLUME":return{type:ct.AXIS_ALIGNED_BOUNDING_BOX,id:c,pointA:s,pointB:w.eR.add(w.eR.create(),s,i),description:r,relatedSegments:l,properties:[]};default:throw new Error(`Unknown spatial annotation type: ${JSON.stringify(o)}.`)}}function Sh(t,e,n){(0,k.Rf)(t);const s=(0,k.cQ)(t,"annotations",i=>(0,k.Xu)([void 0],i,k.Rf))[0];return Wo(s,e,n)}const bh=xs(3,[]);function Ko(t,e){const n=new zu(bh),s=t.source.parent,i=oi(s.parameters);e.forEach((r,o)=>{try{(0,k.Rf)(r);const a=(0,k.cQ)(r,"annotations",c=>c===void 0?[]:c);if(!Array.isArray(a))throw new Error(`Expected array, but received ${JSON.stringify(typeof a)}.`);for(const c of a)try{n.add(Wo(c,i))}catch(l){throw new Error(`Error parsing annotation: ${l.message}`)}}catch(a){throw new Error(`Error parsing ${ri[o]} annotations: ${a.message}`)}}),t.data=Object.assign(new eo,n.serialize())}function qo(t){const e=t.indexOf(".");return t.substring(0,e)}function Ut(t){return`${Math.round(t[0])},${Math.round(t[1])},${Math.round(t[2])}`}function ai(t,e){return`${t.volumeId}:${t.changestack}:${e}`}function Qo(t){const e=t.description||"",n=t.relatedSegments===void 0?void 0:t.relatedSegments[0].map(s=>s.toString());switch(t.type){case ct.LINE:{const{pointA:s,pointB:i}=t,r=w.eR.subtract(w.eR.create(),i,s);return{type:"LINE",corner:Ut(s),size:Ut(r),object_labels:n,payload:e}}case ct.AXIS_ALIGNED_BOUNDING_BOX:{const{pointA:s,pointB:i}=t,r=yc(w.eR.create(),s,i),o=vc(w.eR.create(),s,i),a=w.eR.subtract(o,o,r);return{type:"VOLUME",corner:Ut(r),size:Ut(a),object_labels:n,payload:e}}case ct.POINT:return{type:"LOCATION",corner:Ut(t.point),size:"0,0,0",object_labels:n,payload:e};case ct.ELLIPSOID:{const s=w.eR.subtract(w.eR.create(),t.center,t.radii),i=w.eR.scale(w.eR.create(),t.radii,2);return{type:"LOCATION",corner:Ut(s),size:Ut(i),object_labels:n,payload:e}}}}let Xo=class extends sn(zs,it.Rw){async download(t,e){const{parameters:n}=this;return Promise.all(ri.map(s=>lt(n.instance,this.credentialsProvider,{method:"POST",path:`/v1/changes/${n.volumeId}/${n.changestack}/spatials:get`,payload:JSON.stringify({type:s,ignore_payload:!0}),responseType:"json"},e))).then(s=>{Ko(t,s)})}};Xo=nn([O()],Xo);let Zo=class extends sn(io,it.rl){downloadSegmentFilteredGeometry(t,e,n){const{parameters:s}=this;return Promise.all(ri.map(i=>lt(s.instance,this.credentialsProvider,{method:"POST",path:`/v1/changes/${s.volumeId}/${s.changestack}/spatials:get`,payload:JSON.stringify({type:i,object_labels:[t.objectId.toString()],ignore_payload:!0}),responseType:"json"},n))).then(i=>{Ko(t,i)})}downloadMetadata(t,e){const{parameters:n}=this,s=t.key;return lt(n.instance,this.credentialsProvider,{method:"POST",path:`/v1/changes/${n.volumeId}/${n.changestack}/spatials:get`,payload:JSON.stringify({type:qo(s),id:ai(n,s)}),responseType:"json"},e).then(i=>{t.annotation=Sh(i,oi(n),s)},()=>{t.annotation=null})}add(t){const{parameters:e}=this,n=Qo(t);return lt(e.instance,this.credentialsProvider,{method:"POST",path:`/v1/changes/${e.volumeId}/${e.changestack}/spatials:push`,payload:JSON.stringify({annotations:[n]}),responseType:"json"}).then(s=>{(0,k.Rf)(s);const i=(0,k.cQ)(s,"ids",k.si);if(i.length!==1)throw new Error(`Expected list of 1 id, but received ${JSON.stringify(i)}.`);const r=oi(this.parameters);return Ho(r,i[0])})}update(t,e){const{parameters:n}=this,s=Qo(e);return s.id=ai(n,t),lt(n.instance,this.credentialsProvider,{method:"POST",path:`/v1/changes/${n.volumeId}/${n.changestack}/spatials:push`,payload:JSON.stringify({annotations:[s]}),responseType:"json"})}delete(t){const{parameters:e}=this;return lt(e.instance,this.credentialsProvider,{method:"POST",path:`/v1/changes/${e.volumeId}/${e.changestack}/spatials:delete`,payload:JSON.stringify({type:qo(t),ids:[ai(e,t)]}),responseType:"json"})}};Zo=nn([O()],Zo);/**
 * @license
 * Copyright 2022 William Silversmith
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ea=yt("decodePng");var ts=x(5990);/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Ih(t,e,n,s,i){const r=await fetchWithOAuth2Credentials(t,`${e}?prefix=${encodeURIComponent(n)}&delimiter=${encodeURIComponent(s)}`,{},u=>u.text(),i),o=new DOMParser().parseFromString(r,"application/xml"),a=o.evaluate('//*[name()="CommonPrefixes"]/*[name()="Prefix"]',o,null,XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,null),c=[];for(let u=0,d=a.snapshotLength;u<d;++u)c.push(a.snapshotItem(u).textContent||"");const l=o.evaluate('//*[name()="Contents"]/*[name()="Key"]',o,null,XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,null);for(let u=0,d=l.snapshotLength;u<d;++u)c.push(l.snapshotItem(u).textContent||"");return c}async function Mg(t,e,n,s,i){if(!s.startsWith("/"))throw null;const o=await Ih(t,n,s.substring(1),"/",i),a=s.lastIndexOf("/");return{offset:a+e.length+1,completions:o.map(c=>({value:c.substring(a)}))}}/**
 * @license
 * Copyright 2021 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Ch(t,e,n,s,i=j.fx){return await(0,Ie.Bk)(`https://${t}.s3.amazonaws.com${e}`,n,s,i)}async function Rg(t,e,n){return await getS3CompatiblePathCompletions(void 0,`s3://${t}`,`https://${t}.s3.amazonaws.com`,e,n)}/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Eh(t,e){return t.getCredentialsProvider("middleauthapp",new URL(e).origin)}function ns(t,e,n){const s=/^\/([^/]+)/,i=n.match(s);if(i!==null)return pythonIntegration?t.getCredentialsProvider("gcs",{bucket:i[1]}):t.getCredentialsProvider("ngauth_gcs",{authServer:e,bucket:i[1]})}function _g(t,e){const n=parseUrl(t);switch(n.protocol){case"gs":case"gs+xml":return{credentialsProvider:pythonIntegration?e.getCredentialsProvider("gcs",{bucket:n.host}):void 0,url:t};case"gs+ngauth+http":return{credentialsProvider:ns(e,`http://${n.host}`,n.path),url:"gs:/"+n.path};case"gs+ngauth+https":return{credentialsProvider:ns(e,`https://${n.host}`,n.path),url:"gs:/"+n.path};case"gs+xml+ngauth+http":return{credentialsProvider:ns(e,`http://${n.host}`,n.path),url:"gs+xml:/"+n.path};case"gs+xml+ngauth+https":return{credentialsProvider:ns(e,`https://${n.host}`,n.path),url:"gs+xml:/"+n.path};case"middleauth+https":return t=t.substr(11),{credentialsProvider:Eh(e,t),url:t};case"s3":return{credentialsProvider:void 0,url:t};default:return{credentialsProvider:void 0,url:t}}}async function He(t,e,n,s,i=j.fx){const r=(0,Ie.Dl)(e);switch(r.protocol){case"gs":return(0,es.Y)(t,`https://www.googleapis.com/storage/v1/b/${r.host}/o/${encodeURIComponent(r.path.substring(1))}?alt=media&neuroglancer=${Ns()}`,n,s,i);case"gs+xml":return(0,es.Y)(t,`https://storage.googleapis.com/${r.host}${r.path}?neuroglancer=${Ns()}`,n,s,i);case"s3":return Ch(r.host,r.path,n,s,i);default:return(0,es.Y)(t,e,n,s,i)}}var kh=Object.defineProperty,Th=Object.getOwnPropertyDescriptor,Dh=(t,e,n,s)=>{for(var i=s>1?void 0:s?Th(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&kh(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc., 2023 Gergely Csucs
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let ta=class extends je(Ye()(vt),ts.D){constructor(){super(...arguments),this.gridShape=(()=>{const t=new Uint32Array(2),{upperVoxelBound:e,chunkDataSize:n}=this.spec;for(let s=0;s<2;++s)t[s]=Math.ceil(e[s]/n[s]);return t})()}async download(t,e){const{parameters:n}=this,{tilesize:s,overlap:i,encoding:r}=n,[o,a]=t.chunkGridPosition,c=o===0?0:i,l=a===0?0:i,u=`${n.url}/${o}_${a}.${n.format}`;try{const d=await He(this.credentialsProvider,u,{},Ie.Rc,e);let h=0,p=0,m;switch(r){case ts.j.PNG:{const f=await Be(ea,e,[d],new Uint8Array(d),void 0,void 0,3,1,!1);({width:h,height:p}=f),m=Yc(f.uint8Array,h*p,3);break}case ts.j.JPG:case ts.j.JPEG:{({uint8Array:m,width:h,height:p}=await Be(Zs,e,[d],new Uint8Array(d),void 0,void 0,3,!1));break}}if(m!==void 0){const f=s*s,b=h*p,I=t.data=new Uint8Array(f*3);for(let E=0;E<3;E++)for(let V=0;V<p;V++)for(let R=0;R<h;R++)I[R+V*s+E*f]=m[R+c+(V+l)*h+E*b]}}catch(d){if(!(0,Ie.El)(d))throw d}}};ta=Dh([O()],ta);/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Og="DVID";class Ph{constructor(e,n){this.baseUrl=e,this.nodeKey=n}getNodeApiUrl(e=""){return`${this.baseUrl}/api/node/${this.nodeKey}${e}`}getRepoInfoUrl(){return`${this.baseUrl}/api/repos/info`}getKeyValueUrl(e,n){return`${this.getNodeApiUrl()}/${e}/key/${n}`}getKeyValueRangeUrl(e,n,s){return`${this.getNodeApiUrl()}/${e}/keyrange/${n}/${s}`}getKeyValuesUrl(e){return`${this.getNodeApiUrl()}/${e}/keyvalues?jsontar=false`}}function ci(t,e){return t.includes("?")?t+="&":t+="?",t+="app=Neuroglancer",e&&(t+=`&u=${e}`),t}function na(t){return t.text()}function Ng(t,e=uncancelableToken){const n=`${t.url}`,s={method:t.method,body:t.payload};return t.responseType===""?cancellableFetchOk(n,s,na,e):cancellableFetchOk(n,s,responseJson,e)}function li(t,e,n=j.fx){return Mh(t,e.url,{method:e.method,body:e.payload},e.responseType===""?na:e.responseType==="json"?Ie.cj:Ie.Rc,n)}function Mh(t,e,n,s,i=j.fx){return(0,ao.R)(t,e,n,s,(r,o)=>{const a={...o};return r.token&&(a.headers={...a.headers,Authorization:`Bearer ${r}`}),a},r=>{const{status:o}=r;if(o===403||o===401)return"refresh";throw r},i)}var Et=x(8820);/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2020 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Rh(t,e){const n=_h(e);if(n.length<1)throw new Error("ERROR parsing swc data");const s=new Uint32Array(n.length);let i=0,r=0;n.forEach((u,d)=>{u&&(s[d]=i++,u.parent>=0&&++r)});const o=new Float32Array(3*i),a=new Uint32Array(2*r);let c=0,l=0;n.forEach(u=>{u&&(o[3*c]=u.x,o[3*c+1]=u.y,o[3*c+2]=u.z,u.parent>=0&&(a[2*l]=c,a[2*l+1]=s[u.parent],++l),++c)}),t.indices=a,t.vertexPositions=o}function _h(t){const e=t.split(`
`),n=[],s="-?\\d*(?:\\.\\d+)?",i=new RegExp("^[ \\t]*("+["\\d+","\\d+",s,s,s,s,"-1|\\d+"].join(")[ \\t]+(")+")[ \\t]*$");return e.forEach(r=>{const o=r.match(i);if(o){const a=n[parseInt(o[1],10)]=new Oh;a.type=parseInt(o[2],10),a.x=parseFloat(o[3]),a.y=parseFloat(o[4]),a.z=parseFloat(o[5]),a.radius=parseFloat(o[6]),a.parent=parseInt(o[7],10)}}),n}class Oh{}var Nh=Object.defineProperty,xh=Object.getOwnPropertyDescriptor,ui=(t,e,n,s)=>{for(var i=s>1?void 0:s?xh(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&Nh(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function di(t,e){return je(Ye()(t),e)}let sa=class extends di(ni,Et.NV){download(t,e){const{parameters:n}=this,s=`${t.objectId}`,i=`${n.baseUrl}/api/node/${n.nodeKey}/${n.dataInstanceKey}/key/`+s+"_swc";return li(this.credentialsProvider,{method:"GET",url:ci(i,n.user),responseType:"arraybuffer"},e).then(r=>{const o=new TextDecoder("utf-8");Rh(t,o.decode(r))})}};sa=ui([O()],sa);function Ah(t,e){const s=new DataView(e).getUint32(0,!0);Cn(t,qs(e,xe.LITTLE,4,s))}let ia=class extends di(In,Et.Ve){download(t){return t.fragmentIds=[`${t.objectId}`],Promise.resolve(void 0)}downloadFragment(t,e){const{parameters:n}=this,i=new Ph(n.baseUrl,n.nodeKey).getKeyValueUrl(n.dataInstanceKey,`${t.fragmentId}.ngmesh`);return li(this.credentialsProvider,{method:"GET",url:ci(i,n.user),responseType:"arraybuffer"},e).then(r=>Ah(t,r))}};ia=ui([O()],ia);let ra=class extends di(vt,Et.jj){async download(t,e){const n=this.parameters;let s;{const o=this.computeChunkBounds(t),a=t.chunkDataSize;s=this.getPath(o,a)}const i=this.getDecoder(n),r=await li(this.credentialsProvider,{method:"GET",url:ci(`${n.baseUrl}${s}`,n.user),responseType:"arraybuffer"},e);await i(t,e,n.encoding===Et.r7.JPEG?r.slice(16):r)}getPath(t,e){const n=this.parameters;return n.encoding===Et.r7.JPEG?`/api/node/${n.nodeKey}/${n.dataInstanceKey}/subvolblocks/${e[0]}_${e[1]}_${e[2]}/${t[0]}_${t[1]}_${t[2]}`:n.encoding===Et.r7.RAW?`/api/node/${n.nodeKey}/${n.dataInstanceKey}/raw/0_1_2/${e[0]}_${e[1]}_${e[2]}/${t[0]}_${t[1]}_${t[2]}/jpeg`:n.encoding===Et.r7.COMPRESSED_SEGMENTATIONARRAY?`/api/node/${n.nodeKey}/${n.dataInstanceKey}/raw/0_1_2/${e[0]}_${e[1]}_${e[2]}/${t[0]}_${t[1]}_${t[2]}?compression=googlegzip&scale=${n.dataScale}`:`/api/node/${n.nodeKey}/${n.dataInstanceKey}/raw/0_1_2/${e[0]}_${e[1]}_${e[2]}/${t[0]}_${t[1]}_${t[2]}?compression=googlegzip`}getDecoder(t){return t.encoding===Et.r7.JPEG||t.encoding===Et.r7.RAW?Zn:si}};ra=ui([O()],ra);/**
 * @license
 * Copyright 2019 The Neuroglancer Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const xg=1,Lh="GrapheneMeshSource:NewSegment";var Uh=(t=>(t[t.RAW=0]="RAW",t[t.JPEG=1]="JPEG",t[t.COMPRESSED_SEGMENTATION=2]="COMPRESSED_SEGMENTATION",t))(Uh||{});class Vh{}Vh.RPC_ID="graphene/VolumeChunkSource";class oa{}oa.RPC_ID="graphene/ChunkedGraphSource";class aa{}aa.RPC_ID="graphene/MeshSource";class Ag{}const Bh=async t=>t;function ca(t,e){const n=ee.R.rshift(new ee.R,t,64-e);return ee.R.equal(n,ee.R.ONE)}function Fh(t){if(t.charAt(0)==="~"){const n=t.substring(1).split(/:(.+)/);return{key:n[0],fragmentId:n[1]}}return{key:t,fragmentId:t}}const $h="ChunkedGraphLayer",zh="ChunkedGraphLayer:updateSources",Gh=5;function Lg(t){const{rank:e,dataType:n}=t,{baseVoxelOffset:s=new Float32Array(e)}=t;return{...makeSliceViewChunkSpecification(t),baseVoxelOffset:s,dataType:n}}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const la=Symbol("objectId");let jh=0;function ua(t){if(t instanceof Object){let e=t[la];return e===void 0&&(e=t[la]=jh++),`o${e}`}return""+JSON.stringify(t)}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Yh extends _e{initialize(e){super.initialize(e),this.requesters=new Set}downloadSucceeded(){super.downloadSucceeded();const{requesters:e,data:n}=this;this.requesters=void 0;for(const s of e)s.resolve(n)}downloadFailed(e){super.downloadFailed(e);const{requesters:n}=this;this.requesters=void 0;for(const s of n)s.reject(e)}freeSystemMemory(){this.data=void 0}}class Rt extends M{constructor(e,n){super(e),this.registerDisposer(e);const{encodeKey:s=k.JB}=n;this.downloadFunction=n.download,this.encodeKeyFunction=s;const{sourceQueueLevel:i=0}=n;this.sourceQueueLevel=i,this.registerDisposer(this.chunkManager.recomputeChunkPrioritiesLate.add(()=>{this.updateChunkPriorities()}))}updateChunkPriorities(){const{chunkManager:e}=this;for(const n of this.chunks.values()){const{requesters:s}=n;if(s!==void 0)for(const i of s){const{priorityTier:r,priority:o}=i.getPriority();r!==se.RECENT&&e.requestChunk(n,r,o,_.SYSTEM_MEMORY_WORKER)}}}async download(e,n){const{size:s,data:i}=await this.downloadFunction(e.decodedKey,n);e.systemMemoryBytes=s,e.data=i}getData(e,n,s){const i=this.encodeKeyFunction(e);let r=this.chunks.get(i);return r===void 0&&(r=this.getNewChunk_(Yh),r.decodedKey=e,r.initialize(i),this.addChunk(r)),(0,j.gI)(s,(o,a,c)=>{switch(r.state){case _.FAILED:a(r.error);return;case _.SYSTEM_MEMORY_WORKER:o(r.data);return}const l={resolve:o,reject:a,getPriority:n};r.requesters.add(l),c.add(()=>{const{requesters:u}=r;u!==void 0&&(u.delete(l),this.chunkManager.scheduleUpdateChunkPriorities()),a(j.wS)}),this.chunkManager.scheduleUpdateChunkPriorities()})}static get(e,n,s){return e.memoize.get(`getFileSource:${n}`,()=>new Rt(e.addRef(),s))}static getData(e,n,s,i,r,o){const a=Rt.get(e,n,s),c=a.getData(i,r,o);return a.dispose(),c}static getUrl(e,n,s,i,r,o){return Rt.getData(e,`${ua(s)}`,{download:(a,c)=>He(n,a,{},Ie.Rc,c).then(l=>s(l,c))},i,r,o)}}class Jh extends _e{initialize(e){super.initialize(e)}freeSystemMemory(){this.promise=void 0,this.cancellationSource=void 0}}class da extends M{constructor(e,n){super(e),this.registerDisposer(e),this.downloadFunction=n.get,this.encodeKeyFunction=n.encodeKey??k.JB}get(e,n){const s=this.encodeKeyFunction(e);let i=this.chunks.get(s);if(i===void 0&&(i=this.getNewChunk_(Jh),i.initialize(s),this.addChunk(i)),i.promise===void 0){let r=!1;const o=i.cancellationSource=new j.y3;o.add(()=>{r||(i.promise=void 0)}),i.promise=(async()=>{try{const{data:a,size:c}=await this.downloadFunction(e,o);return i.systemMemoryBytes=c,i.queueManager.updateChunkState(i,_.SYSTEM_MEMORY),a}catch(a){throw i.queueManager.updateChunkState(i,_.FAILED),a}finally{r=!0}})()}return i.cancellationSource.addConsumer(n),i.promise}}function Ug(t,e,n){return t.memoize.get(`simpleAsyncCache:${e}`,()=>new da(t.addRef(),n))}var We=x(3819);/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let Tn,ha=0,fa;const pa={emscripten_notify_memory_growth:t=>{},neuroglancer_draco_receive_decoded_mesh:(t,e,n,s,i)=>{const r=t*3,o=fa.exports.memory,a=new Uint32Array(o.buffer,n,r).slice(),c=new Uint32Array(o.buffer,s,3*e).slice(),l=new Uint32Array(o.buffer,i,ha+1).slice();Tn={indices:a,vertexPositions:c,subChunkOffsets:l}},proc_exit:t=>{throw`proc exit: ${t}`}};let hi;function ma(){return hi==null&&(hi=(async()=>{const t=fa=(await WebAssembly.instantiateStreaming(fetch(new URL(x(8867),x.b)),{env:pa,wasi_snapshot_preview1:pa})).instance;return t.exports._initialize(),t})()),hi}async function Hh(t,e,n){const s=await ma(),i=s.exports.malloc(t.byteLength);new Uint8Array(s.exports.memory.buffer).set(t,i),ha=n?8:1;const o=s.exports.neuroglancer_draco_decode(i,t.byteLength,n,e,!0);if(o===0){const a=Tn;if(Tn=void 0,a instanceof Error)throw a;return a}throw new Error(`Failed to decode draco mesh: ${o}`)}async function Wh(t){const e=await ma(),n=e.exports.malloc(t.byteLength);new Uint8Array(e.exports.memory.buffer).set(t,n);const i=e.exports.neuroglancer_draco_decode(n,t.byteLength,!1,0,!1);if(i===0){const r=Tn;if(Tn=void 0,r instanceof Error)throw r;return r.vertexPositions=new Float32Array(r.vertexPositions.buffer),r}throw new Error(`Failed to decode draco mesh: ${i}`)}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Kh(t,e,n){const s=new DataView(e),i=s.getUint32(0,!0),r=s.getUint32(4,!0),o=8;let a=8+i*4*3;Uo(t,e,xe.LITTLE,o,i,a,r),a+=r*4*2;const c=[];for(const l of n.values()){const u=Wt[l.dataType]*l.numComponents,d=u*i,h=new Uint8Array(e,a,d);switch(u){case 2:Su(h,xe.LITTLE);break;case 4:case 8:pt(h,xe.LITTLE);break}c.push(h),a+=d}t.vertexAttributes=c}/**
 * @license
 * Copyright 2021 William Silversmith
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const qh=yt("decodeCompresso");/**
 * @license
 * Copyright 2021 William Silvermsith.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Qh(t,e,n){const s=await Be(qh,e,[n],new Uint8Array(n));await Lt(t,e,s.buffer)}/**
 * @license
 * Copyright 2022 William Silvermsith.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Xh(t,e,n){const s=t.chunkDataSize,i=t.source.spec.dataType,{uint8Array:r}=await Be(ea,e,[n],new Uint8Array(n),s[0],s[1]*s[2],s[3]||1,Wt[i],!1);await Lt(t,e,r.buffer)}/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Zh=navigator.userAgent.indexOf("Chrome")!==-1?"no-store":"default";function Dn(t,e,n,s,i){return He(t,e,{headers:(0,Ie.JD)(n,s),cache:Zh},Ie.Rc,i)}/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Vg(t){let e=0;const n=t.length;for(let s=0;s<n;++s)e=e*31+t.charCodeAt(s)|0;return e}function ga(t,e){return e=Math.imul(e,3432918353)>>>0,e=(e<<15|e>>>17)>>>0,e=Math.imul(e,461845907)>>>0,t^=e,t=(t<<13|t>>>19)>>>0,t=Math.imul(t,5)+3864292196>>>0,t}function ef(t,e){return t^=e,t^=t>>>16,t=Math.imul(t,2246822507)>>>0,t^=t>>>13,t*=3266489909,t^=t>>>16,t>>>0}function Bg(t,e,n){let s=t;return s=ga(s,e),s=ga(s,n),ef(s,8)}function ss(t){return t^=t>>>16,t=Math.imul(t,2246822507),t^=t>>>13,t=Math.imul(t,3266489909),t^=t>>>16,t}function ya(t,e){return t<<e|t>>>32-e}function tf(t,e,n,s){let i=e,r=e,o=e,a=e;const c=597399067,l=2869860233,u=951274213;let d=Math.imul(s,l);d=ya(d,16),d=Math.imul(d,u),r^=d;let h=Math.imul(n,c);h=ya(h,15),h=Math.imul(h,l),i^=h;const p=8;return i^=p,r^=p,o^=p,a^=p,i=i+r>>>0,i=i+o>>>0,i=i+a>>>0,r=r+i>>>0,o=o+i>>>0,a=a+i>>>0,i=ss(i),r=ss(r),o=ss(o),a=ss(a),i=i+r>>>0,i=i+o>>>0,i=i+a>>>0,r=r+i>>>0,t.low=i,t.high=r,t}var nf=Object.defineProperty,sf=Object.getOwnPropertyDescriptor,Vt=(t,e,n,s)=>{for(var i=s>1?void 0:s?sf(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&nf(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const rf=!1,of=new Map([[We.TV.MURMURHASH3_X86_128,t=>{tf(t,0,t.low,t.high)}],[We.TV.IDENTITY,t=>{}]]);function Bt(t,e,n){const{url:s,sharding:i}=n;if(i===void 0)return;const r=Rt.get(t,(0,k.JB)({type:"precomputed:shardedDataSource",url:s,sharding:i,credentialsProvider:ua(e)}),{download:async(o,a)=>{const c=ee.R.lowMask(new ee.R,i.minishardBits);ee.R.and(c,c,o);const l=ee.R.lowMask(new ee.R,i.shardBits),u=new ee.R;ee.R.rshift(u,o,i.minishardBits),ee.R.and(l,l,u);const d=`${s}/${l.toString(16).padStart(Math.ceil(i.shardBits/4),"0")}.shard`,h=new ee.R(16);ee.R.lshift(h,h,i.minishardBits);const p=ee.R.lshift(new ee.R,c,4),m=ee.R.addUint32(new ee.R,p,16);let f;try{f=await Dn(e,d,p,m,a)}catch(H){if((0,Ie.El)(H))return{data:void 0,size:0};throw H}if(f.byteLength!==16)throw new Error("Failed to retrieve minishard offset");const b=new DataView(f),I=new ee.R(b.getUint32(0,!0),b.getUint32(4,!0)),E=new ee.R(b.getUint32(8,!0),b.getUint32(12,!0));if(ee.R.equal(I,E))return{data:void 0,size:0};ee.R.add(I,I,h),ee.R.add(E,E,h);let V=await Dn(e,d,I,E,a);if(i.minishardIndexEncoding===We.Y1.GZIP&&(V=(await Be(tn,a,[V],new Uint8Array(V))).buffer),V.byteLength%24!==0)throw new Error(`Invalid minishard index length: ${V.byteLength}`);const R=new Uint32Array(V);pt(R,xe.LITTLE);const C=R.byteLength/24;let S=0,T=0,v=h.low,N=h.high;for(let H=0;H<C;++H){let y=S+R[H*2],A=T+R[H*2+1];y>=4294967296&&(y-=4294967296,A+=1),S=R[H*2]=y,T=R[H*2+1]=A;let L=v+R[(C+H)*2],Y=N+R[(C+H)*2+1];L>=4294967296&&(L-=4294967296,Y+=1),R[(C+H)*2]=L,R[(C+H)*2+1]=Y;const le=R[(2*C+H)*2],we=R[(2*C+H)*2+1];let pe=L+le,$e=Y+we;pe>=4294967296&&(pe-=4294967296,$e+=1),v=pe,N=$e,R[(2*C+H)*2]=pe,R[(2*C+H)*2+1]=$e}return{data:{data:R,shardUrl:d},size:R.byteLength}},encodeKey:o=>o.toString(),sourceQueueLevel:1});return r.sharding=i,r.credentialsProvider=e,r}function af(t,e){const n=t.data,s=n.length/6,i=e.low,r=e.high;for(let o=0;o<s;++o){if(n[o*2]!==i||n[o*2+1]!==r)continue;const a=new ee.R(n[(s+o)*2],n[(s+o)*2+1]),c=new ee.R(n[(2*s+o)*2],n[(2*s+o)*2+1]);return{startOffset:a,endOffset:c}}}async function is(t,e,n,s){const{sharding:i}=t,r=of.get(i.hash),o=ee.R.rshift(new ee.R,n,i.preshiftBits);r(o);const a=ee.R.lowMask(new ee.R,i.minishardBits+i.shardBits);ee.R.and(a,a,o);const c=()=>({priorityTier:e.priorityTier,priority:e.priority}),l=await t.getData(a,c,s);if(l===void 0)return;const u=af(l,n);if(u===void 0)return;const{startOffset:d,endOffset:h}=u;let p=await Dn(t.credentialsProvider,l.shardUrl,d,h,s);return t.sharding.dataEncoding===We.Y1.GZIP&&(p=(await Be(tn,s,[p],new Uint8Array(p))).buffer),{data:p,shardInfo:{shardUrl:l.shardUrl,offset:d}}}function va(t){if(t===void 0)throw new Error("not found");return t}const rn=new Map;rn.set(We.r7.RAW,Lt),rn.set(We.r7.JPEG,Zn),rn.set(We.r7.COMPRESSED_SEGMENTATION,si),rn.set(We.r7.COMPRESSO,Qh),rn.set(We.r7.PNG,Xh);let wa=class extends je(Ye()(vt),We.jj){constructor(){super(...arguments),this.chunkDecoder=rn.get(this.parameters.encoding),this.minishardIndexSource=Bt(this.chunkManager,this.credentialsProvider,this.parameters),this.gridShape=(()=>{const t=new Uint32Array(3),{upperVoxelBound:e,chunkDataSize:n}=this.spec;for(let s=0;s<3;++s)t[s]=Math.ceil(e[s]/n[s]);return t})()}async download(t,e){const{parameters:n}=this,{minishardIndexSource:s}=this;let i;if(s===void 0){let r;{const o=this.computeChunkBounds(t),a=t.chunkDataSize;r=`${n.url}/${o[0]}-${o[0]+a[0]}_${o[1]}-${o[1]+a[1]}_${o[2]}-${o[2]+a[2]}`}try{i=await He(this.credentialsProvider,r,{},Ie.Rc,e)}catch(o){if((0,Ie.El)(o))i=void 0;else throw o}}else{this.computeChunkBounds(t);const{gridShape:r}=this,{chunkGridPosition:o}=t,a=Math.ceil(Math.log2(r[0])),c=Math.ceil(Math.log2(r[1])),l=Math.ceil(Math.log2(r[2])),u=ho(new ee.R,a,c,l,o[0],o[1],o[2]);i=(await is(s,t,u,e))?.data}i!==void 0&&await this.chunkDecoder(t,e,i)}};wa=Vt([O()],wa);function fi(t,e){return vo(t,e,"fragments")}function cf(t,e){const s=new DataView(e).getUint32(0,!0);Cn(t,qs(e,xe.LITTLE,4,s))}let Sa=class extends je(Ye()(In),We.Ve){async download(t,e){const{parameters:n}=this,s=await He(this.credentialsProvider,`${n.url}/${t.objectId}:${n.lod}`,{},Ie.cj,e);fi(t,s)}async downloadFragment(t,e){const{parameters:n}=this,s=await He(this.credentialsProvider,`${n.url}/${t.fragmentId}`,{},Ie.Rc,e);cf(t,s)}};Sa=Vt([O()],Sa);function lf(t,e){if(e.byteLength<28||e.byteLength%4!==0)throw new Error(`Invalid index file size: ${e.byteLength}`);const n=new DataView(e);let s=0;const i=w.eR.fromValues(n.getFloat32(s,!0),n.getFloat32(s+4,!0),n.getFloat32(s+8,!0));s+=12;const r=w.eR.fromValues(n.getFloat32(s,!0),n.getFloat32(s+4,!0),n.getFloat32(s+8,!0));s+=12;const o=n.getUint32(s,!0);if(s+=4,e.byteLength<s+20*o)throw new Error(`Invalid index file size for ${o} lods: ${e.byteLength}`);const a=new Float32Array(e,s,o);s+=4*o,pt(a,xe.LITTLE);const c=new Float32Array(e,s,o*3);pt(c,xe.LITTLE),s+=12*o;const l=new Uint32Array(e,s,o);s+=4*o,pt(l,xe.LITTLE);const u=l.reduce((S,T)=>S+T);if(e.byteLength!==s+16*u)throw new Error(`Invalid index file size for ${o} lods and ${u} total fragments: ${e.byteLength}`);const d=new Uint32Array(e,s);pt(d,xe.LITTLE);const h=w.eR.fromValues(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),p=w.eR.fromValues(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);let m=Math.max(1,a.length);{let S=0;for(let T=0;T<o;++T){const v=l[T];if(rf)for(let N=1;N<v;++N){const H=d[S+v*0+(N-1)],y=d[S+v*1+(N-1)],A=d[S+v*2+(N-1)],L=d[S+v*0+N],Y=d[S+v*1+N],le=d[S+v*2+N];Ks(H,y,A,L,Y,le)||console.log(`Fragment index violates zorder constraint: lod=${T}, chunk ${N-1} = [${H},${y},${A}], chunk ${N} = [${L},${Y},${le}]`)}for(let N=0;N<3;++N){let H=Number.NEGATIVE_INFINITY,y=Number.POSITIVE_INFINITY;const A=S+v*N;for(let L=0;L<v;++L){const Y=d[A+L];H=Math.max(H,Y),y=Math.min(y,Y)}if(v!==0){for(;H>>>m-T-1!==y>>>m-T-1;)++m;T===0&&(h[N]=Math.min(h[N],(1<<T)*y),p[N]=Math.max(p[N],(1<<T)*(H+1)))}}S+=v*4}}let f=0;{let S=0,T=0;for(let v=0;v<o;++v){const N=l[v];f+=S*(v-T),T=v,S=N,f+=N}f+=(m-1-T)*S}const b=new Uint32Array(5*f),I=new Float64Array(f+1);let E;{let S=0,T=0,v=0,N=0;for(let H=0;H<o;++H){const y=l[H];for(let A=0;A<y;++A){for(let Y=0;Y<3;++Y)b[5*(T+A)+Y]=d[N+A+Y*y];const L=d[N+A+3*y];v+=L,I[T+A+1]=v,L===0&&(b[5*(T+A)+4]=2147483648)}for(N+=4*y,H!==0&&zd(b,S,T,T+y),S=T,T+=y;H+1<m&&(H+1>=a.length||a[H+1]===0);){const A=Mo(b,S,T);I.fill(v,T+1,A+1),S=T,T=A,++H}}E=b.slice(0,5*T),t.offsets=I.slice(0,T+1)}const V=t.source,{lodScaleMultiplier:R}=V.parameters.metadata,C=new Float32Array(m);C.set(a,0);for(let S=0;S<a.length;++S)C[S]*=R;t.manifest={chunkShape:i,chunkGridSpatialOrigin:r,clipLowerBound:w.eR.add(h,r,w.eR.multiply(h,h,i)),clipUpperBound:w.eR.add(p,r,w.eR.multiply(p,p,i)),octree:E,lodScales:C,vertexOffsets:c}}async function uf(t,e){const{lod:n}=t,s=t.manifestChunk.source,i=await Hh(new Uint8Array(e),s.parameters.metadata.vertexQuantizationBits,n!==0);Po(t,i,s.format.vertexPositionFormat)}let ba=class extends je(Ye()(Eo),We.Ip){constructor(){super(...arguments),this.minishardIndexSource=Bt(this.chunkManager,this.credentialsProvider,{url:this.parameters.url,sharding:this.parameters.metadata.sharding})}async download(t,e){const{parameters:n,minishardIndexSource:s}=this;let i;s===void 0?i=await He(this.credentialsProvider,`${n.url}/${t.objectId}.index`,{},Ie.Rc,e):{data:i,shardInfo:t.shardInfo}=va(await is(s,t,t.objectId,e)),lf(t,i)}async downloadFragment(t,e){const{parameters:n}=this,s=t.manifestChunk,i=t.chunkIndex,{shardInfo:r,offsets:o}=s,a=o[i],c=o[i+1];let l,u,d;if(r!==void 0){l=r.shardUrl;const p=o[o.length-1];let m=r.offset.low-p+a,f=r.offset.high,b=m+c-a,I=f;for(;m<0;)m+=4294967296,f-=1;for(;b<0;)b+=4294967296,I-=1;for(;b>4294967296;)b-=4294967296,I+=1;u=new ee.R(m,f),d=new ee.R(b,I)}else l=`${n.url}/${s.objectId}`,u=a,d=c;const h=await Dn(this.credentialsProvider,l,u,d,e);await uf(t,h)}};ba=Vt([O()],ba);async function pi(t,e,n,s,i,r){if(s===void 0)try{return await He(t,`${e}/${i}`,{},Ie.Rc,r)}catch(a){if((0,Ie.El)(a))return;throw a}const o=await is(s,n,i,r);if(o!==void 0)return o.data}let Ia=class extends je(Ye()(ni),We.NV){constructor(){super(...arguments),this.minishardIndexSource=Bt(this.chunkManager,this.credentialsProvider,{url:this.parameters.url,sharding:this.parameters.metadata.sharding})}async download(t,e){const{parameters:n}=this,s=va(await pi(this.credentialsProvider,n.url,t,this.minishardIndexSource,t.objectId,e));Kh(t,s,n.metadata.vertexAttributes)}};Ia=Vt([O()],Ia);function Ca(t,e,n){const s=new DataView(t);if(t.byteLength<=8)throw new Error("Expected at least 8 bytes");const i=s.getUint32(0,!0);if(s.getUint32(4,!0)!==0)throw new Error("Annotation count too high");const o=n.serializedBytes,a=8+(o+8)*i;if(t.byteLength!==a)throw new Error(`Expected ${a} bytes, but received: ${t.byteLength} bytes`);const c=8+o*i,l=new ee.R,u=new Array(i);for(let E=0;E<i;++E)l.low=s.getUint32(c+E*8,!0),l.high=s.getUint32(c+E*8+4,!0),u[E]=l.toString();const d=new eo,h=new Uint8Array(t,8,o*i);let p;const{propertyGroupBytes:m}=n;if(m.length>1){p=new Uint8Array(h.length);let E=0,V=0;for(let R=0;R<m.length;++R){const C=m[R];for(let S=0;S<i;++S){const T=E+S*o,v=V+S*C;for(let N=0;N<C;++N)p[v+N]=h[T+N]}E+=C,V+=C*i}}else p=h;d.data=p;const f=d.typeToOffset=new Array(Xt.length);f.fill(0),f[e.type]=0;const b=d.typeToIds=new Array(Xt.length),I=d.typeToIdMaps=new Array(Xt.length);return b.fill([]),b[e.type]=u,I.fill(new Map),I[e.type]=new Map(u.map((E,V)=>[E,V])),d}function df(t,e,n,s){const i=Zt[e.type],r=n.serializedBytes,o=e.relationships.length,a=r+4*o;if(t.byteLength<a)throw new Error(`Expected at least ${a} bytes, but received: ${t.byteLength}`);const c=new DataView(t),l=i.deserialize(c,0,!0,e.rank,s);n.deserialize(c,0,0,1,!0,l.properties=new Array(e.properties.length));let u=r;const d=l.relatedSegments=[];d.length=o;for(let h=0;h<o;++h){const p=c.getUint32(u,!0);if(t.byteLength<a+p*8)throw new Error(`Expected at least ${a} bytes, but received: ${t.byteLength}`);u+=4;const m=d[h]=[];for(let f=0;f<p;++f)m[f]=new ee.R(c.getUint32(u,!0),c.getUint32(u+4,!0)),u+=8}if(u!==t.byteLength)throw new Error(`Expected ${u} bytes, but received: ${t.byteLength}`);return l}let Ea=class extends je(Ye()(zs),We.Rw){constructor(){super(...arguments),this.minishardIndexSource=Bt(this.chunkManager,this.credentialsProvider,this.parameters)}async download(t,e){const{parameters:n}=this,{minishardIndexSource:s}=this,{parent:i}=this;let r;const{chunkGridPosition:o}=t;if(s===void 0){const a=`${n.url}/${o.join("_")}`;try{r=await He(this.credentialsProvider,a,{},Ie.Rc,e)}catch(c){if(!(0,Ie.El)(c))throw c}}else{const{upperChunkBound:a}=this.spec,{chunkGridPosition:c}=t,l=Od(new ee.R,c,a),u=await is(s,t,l,e);u!==void 0&&(r=u.data)}r!==void 0&&(t.data=Ca(r,i.parameters,i.annotationPropertySerializer))}};Ea=Vt([O()],Ea);let ka=class extends je(Ye()(io),We.rl){constructor(){super(...arguments),this.byIdMinishardIndexSource=Bt(this.chunkManager,this.credentialsProvider,this.parameters.byId),this.relationshipIndexSource=this.parameters.relationships.map(t=>Bt(this.chunkManager,this.credentialsProvider,t)),this.annotationPropertySerializer=new Lr(this.parameters.rank,Zt[this.parameters.type].serializedBytes(this.parameters.rank),this.parameters.properties)}async downloadSegmentFilteredGeometry(t,e,n){const{parameters:s}=this,i=await pi(this.credentialsProvider,s.relationships[e].url,t,this.relationshipIndexSource[e],t.objectId,n);i!==void 0&&(t.data=Ca(i,this.parameters,this.annotationPropertySerializer))}async downloadMetadata(t,e){const{parameters:n}=this,s=ee.R.parseString(t.key),i=await pi(this.credentialsProvider,n.byId.url,t,this.byIdMinishardIndexSource,s,e);i===void 0?t.annotation=null:t.annotation=df(i,this.parameters,this.annotationPropertySerializer,t.key)}};ka=Vt([O()],ka);let Ta=class extends je(Ye()(od),We.vq){constructor(){super(...arguments),this.minishardIndexSource=Bt(this.chunkManager,this.credentialsProvider,this.parameters)}};Ta=Vt([O()],Ta);var hf=Object.defineProperty,ff=Object.getOwnPropertyDescriptor,mi=(t,e,n,s)=>{for(var i=s>1?void 0:s?ff(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&hf(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function pf(t,e,n,s){if(e.fragmentId&&e.fragmentId.charAt(0)==="~"){const i=e.fragmentId.substr(1).split(":"),r=Number(i[1]),o=r+Number(i[2]);return Dn(t,`${n.fragmentUrl}/initial/${i[0]}`,r,o,s)}return He(t,`${n.fragmentUrl}/dynamic/${e.fragmentId}`,{},Ie.Rc,s)}function mf(t,e,n,s){let i;return n.sharding?i=pf(t,e,n,s):i=He(t,`${n.fragmentUrl}/${e.fragmentId}`,{},Ie.Rc,s),i}async function gf(t,e){const n=await Wh(new Uint8Array(e));Cn(t,n)}let Da=class extends je(Ye()(In),aa){constructor(){super(...arguments),this.manifestRequestCount=new Map,this.newSegments=new Sn}addNewSegment(t){const{newSegments:e}=this;e.add(t);const n=1e3*60*10;setTimeout(()=>{e.delete(t)},n)}async download(t,e){const{parameters:n,newSegments:s,manifestRequestCount:i}=this;if(ca(t.objectId,n.nBitsForLayerId))return fi(t,{fragments:[]});const o=`${`${n.manifestUrl}/manifest`}/${t.objectId}:${n.lod}?verify=1&prepend_seg_ids=1`;await He(this.credentialsProvider,o,{},Ie.cj,e).then(a=>{const c=o;if(s.has(t.objectId)){const l=(i.get(c)||0)+1;i.set(c,l),setTimeout(()=>{this.chunkManager.queueManager.updateChunkState(t,_.QUEUED)},2**l*1e3)}else i.delete(c);return fi(t,a)})}async downloadFragment(t,e){const{parameters:n}=this,s=await mf(void 0,t,n,e);await gf(t,s)}getFragmentKey(t,e){return Fh(e)}};Da=mi([O()],Da);class yf extends _e{constructor(){super(...arguments),this.source=null,this.leaves=[]}initializeVolumeChunk(e,n){super.initialize(e),this.chunkGridPosition=Float32Array.from(n)}initializeChunkedGraphChunk(e,n,s){this.initializeVolumeChunk(e,n),this.chunkDataSize=null,this.systemMemoryBytes=16,this.gpuMemoryBytes=0,this.segment=s}downloadSucceeded(){this.systemMemoryBytes=16,this.systemMemoryBytes+=16*this.leaves.length,this.queueManager.updateChunkState(this,_.SYSTEM_MEMORY_WORKER),this.priorityTier<se.RECENT&&this.source.chunkManager.scheduleUpdateChunkPriorities(),super.downloadSucceeded()}freeSystemMemory(){this.leaves=[]}}function vf(t){const e=new Array(t.length);for(let n=0;n<e.length;++n)e[n]=ee.R.parseString(t[n]);return e}let Pa=class extends je(Ye()(K),oa){constructor(t,e){super(t,e),this.spec=e.spec;const n=this.spec.rank;this.tempChunkDataSize=new Uint32Array(n),this.tempChunkPosition=new Float32Array(n)}async download(t,e){const{parameters:n}=this,s=this.computeChunkBounds(t),i=t.chunkDataSize,r=`${s[0]}-${s[0]+i[0]}_${s[1]}-${s[1]+i[1]}_${s[2]}-${s[2]+i[2]}`,o=He(this.credentialsProvider,`${n.url}/${t.segment}/leaves?int64_as_str=1&bounds=${r}`,{},Bh,e);await this.withErrorMessage(o,`Fetching leaves of segment ${t.segment} in region ${r}: `).then(a=>a.json()).then(a=>{t.leaves=vf(a.leaf_ids)}).catch(a=>console.error(a))}getChunk(t,e){const n=`${(0,w.nL)(t)}-${e}`;let s=this.chunks.get(n);return s===void 0&&(s=this.getNewChunk_(yf),s.initializeChunkedGraphChunk(n,t,e),this.addChunk(s)),s}computeChunkBounds(t){return _o(this,t)}async withErrorMessage(t,e){const n=await t;if(n.ok)return n;let s;try{s=(await n.json()).message}catch{s=await n.text()}throw new Error(`[${n.status}] ${e}${s}`)}};Pa=mi([O()],Pa);const Ma=w.eR.create(),wf=w.eR.create(),Sf=w.eR.create();let Ra=class extends jn(At(It(xn))){constructor(t,e){super(t,e),this.debouncedupdateDisplayState=(0,Zi.A)(()=>{this.updateDisplayState()},100),this.source=this.registerDisposer(t.getRef(e.source)),this.localPosition=t.get(e.localPosition),this.leafRequestsActive=t.get(e.leafRequestsActive),this.nBitsForLayerId=t.get(e.nBitsForLayerId),this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(()=>{this.updateChunkPriorities(),this.debouncedupdateDisplayState()}))}attach(t){const e=()=>this.chunkManager.scheduleUpdateChunkPriorities(),{view:n}=t;t.registerDisposer(e),t.registerDisposer(n.projectionParameters.changed.add(e)),t.registerDisposer(n.visibility.changed.add(e)),t.state={displayDimensionRenderInfo:n.projectionParameters.value.displayDimensionRenderInfo}}get renderRatioLimit(){return Gh}updateChunkPriorities(){const{source:t,chunkManager:e}=this;e.registerLayer(this);for(const n of this.attachments.values()){const{view:s}=n,i=s.visibility.value;if(i===Number.NEGATIVE_INFINITY)continue;const r=n.state,{transformedSource:o}=r,a=s.projectionParameters.value;if(!o)continue;const c=a.pixelSize*1.1,l=o.effectiveVoxelSize;if(this.leafRequestsActive.value=this.renderRatioLimit>=c/Math.min(...l),!this.leafRequestsActive.value)continue;const u=ht(i),d=ft(i),{chunkLayout:h}=o,{size:p,finiteRank:m}=h,f=Sf,b=wf;w.eR.copy(f,p);for(let E=m;E<3;++E)f[E]=0,b[E]=0;const{centerDataPosition:I}=a;h.globalToLocalSpatial(b,I),ur(a,this.localPosition.value,o,dr(a,h),E=>{w.eR.multiply(Ma,E,f);const V=-w.eR.distance(b,Ma),{curPositionInChunks:R}=o;bn(this,(C,S)=>{if(ca(C,this.nBitsForLayerId.value))return;const T=t.getChunk(R,C.clone());e.requestChunk(T,u,d+V,_.SYSTEM_MEMORY_WORKER),++this.numVisibleChunksNeeded,T.state===_.GPU_MEMORY&&++this.numVisibleChunksAvailable})})}}forEachSelectedRootWithLeaves(t){const{source:e}=this;for(const n of e.chunks.values())n.state===_.SYSTEM_MEMORY_WORKER&&n.priorityTier<se.RECENT&&this.visibleSegments.has(n.segment)&&n.leaves.length&&t(n.segment.toString(),n.leaves)}updateDisplayState(){const t=new Map,e=new Map;this.forEachSelectedRootWithLeaves((n,s)=>{e.has(n)?e.set(n,e.get(n)+s.length):e.set(n,s.length)}),this.forEachSelectedRootWithLeaves((n,s)=>{t.has(n)||(t.set(n,new Sn),t.get(n).reserve(e.get(n)),t.get(n).add(ee.R.parseString(n))),t.get(n).add(s)});for(const[n,s]of t){const i=[...s].filter(o=>!this.segmentEquivalences.has(o)),r=ee.R.parseString(n);for(const o of i)this.segmentEquivalences.link(r,o)}}};Ra=mi([O($h)],Ra),Q(zh,function(t){const e=this.get(t.view),n=this.get(t.layer),s=n.attachments.get(e);s.state.transformedSource=Fn(this,t.sources,n)[0][0],s.state.displayDimensionRenderInfo=t.displayDimensionRenderInfo,n.chunkManager.scheduleUpdateChunkPriorities()}),Q(Lh,function(t){this.get(t.rpcId).addNewSegment(ee.R.parseString(t.segment))});/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _a=yt("decodeBlosc");/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Oa=yt("decodeZstd");var rs=x(5926),bf=Object.defineProperty,If=Object.getOwnPropertyDescriptor,Cf=(t,e,n,s)=>{for(var i=s>1?void 0:s?If(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&bf(e,n,i),i};/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Ef(t,e,n,s){const i=new DataView(n),r=i.getUint16(0,!1);if(r!==0)throw new Error(`Unsupported mode: ${r}.`);const o=i.getUint16(2,!1);if(o!==t.source.spec.rank)throw new Error("Number of dimensions must be 3.");let a=4;const c=new Uint32Array(o);for(let u=0;u<o;++u)c[u]=i.getUint32(a,!1),a+=4;t.chunkDataSize=c;let l=new Uint8Array(n,a);switch(s){case rs.r.GZIP:l=await Be(tn,e,[l.buffer],l);break;case rs.r.BLOSC:l=await Be(_a,e,[l.buffer],l);break;case rs.r.ZSTD:l=await Be(Oa,e,[l.buffer],l);break}await Lt(t,e,l.buffer,xe.BIG,l.byteOffset,l.byteLength)}let Na=class extends je(Ye()(vt),rs.j){async download(t,e){const{parameters:n}=this,{chunkGridPosition:s}=t;let i=n.url;const r=this.spec.rank;for(let o=0;o<r;++o)i+=`/${s[o]}`;try{const o=await He(this.credentialsProvider,i,{},Ie.Rc,e);await Ef(t,e,o,n.encoding)}catch(o){if(!(0,Ie.El)(o))throw o}}};Na=Cf([O()],Na);var nt=x(8053),xa=x(6435);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var kf=(t=>(t[t.UNKNOWN=0]="UNKNOWN",t[t.IMAGE=1]="IMAGE",t[t.SEGMENTATION=2]="SEGMENTATION",t))(kf||{});const Fg=18;function Aa(t){const{rank:e,dataType:n,fillValue:s=n===DataType.UINT64?Uint64.ZERO:0,compressedSegmentationBlockSize:i}=t,{baseVoxelOffset:r=new Float32Array(e)}=t;return{...makeSliceViewChunkSpecification(t),compressedSegmentationBlockSize:i,baseVoxelOffset:r,dataType:n,fillValue:s}}function Tf(t){if(t.compressedSegmentationBlockSize!==void 0||t.volumeType!==2&&!t.volumeSourceOptions.discreteValues)return!1;switch(t.dataType){case DataType.UINT32:case DataType.UINT64:break;default:return!1}switch(t.rank){case 3:return!0;case 4:{const{chunkDataSize:e}=t;return e[3]===1}default:return!1}}function Df(t){const{rank:e,lowerVoxelBound:n,upperVoxelBound:s}=t;if(!Tf(t))return Aa(t);let{volumeSourceOptions:{displayRank:i,multiscaleToViewTransform:r},chunkToMultiscaleTransform:o,chunkToViewTransform:a}=t;a===void 0&&(a=matrix.multiply(new Float32Array(e*i),i,r,i,o,e+1,i,e,e));const{maxCompressedSegmentationBlockSize:c,chunkDataSize:l}=t;return Aa({...t,compressedSegmentationBlockSize:Float32Array.from(getNearIsotropicBlockSize({rank:e,chunkToViewTransform:a,displayRank:i,lowerVoxelBound:n,upperVoxelBound:s,maxVoxelsPerChunkLog2:9,maxBlockSize:c===void 0?l:vector.min(new Uint32Array(e),l,c)}))})}function $g(t){const{rank:e}=t,{volumeSourceOptions:{displayRank:n,multiscaleToViewTransform:s,modelChannelDimensionIndices:i},chunkToMultiscaleTransform:r}=t,o=matrix.multiply(new Float32Array(n*e),n,s,n,r,e+1,n,e,e);let{minBlockSize:a}=t;a===void 0?(a=new Uint32Array(e),a.fill(1)):a=new Uint32Array(a);const{lowerVoxelBound:c,upperVoxelBound:l}=t;if(i.length!==0)for(const d of getDependentTransformInputDimensions(r,e,i)){let h=l[d];c!==void 0&&(h-=c[d]),a[d]=h}const{chunkDataSizes:u=getChunkDataSizes({...t,minBlockSize:a,chunkToViewTransform:o,displayRank:n})}=t;return u.map(d=>Df({...t,chunkDataSize:d,chunkToViewTransform:o}))}const zg="volume";var Pf=x(147),Mf=Object.defineProperty,Rf=Object.getOwnPropertyDescriptor,_f=(t,e,n,s)=>{for(var i=s>1?void 0:s?Rf(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&Mf(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Of{}async function Nf(t,e){(0,nt.isCompressed)(t)&&(t=(await Be(tn,e,[t],new Uint8Array(t))).buffer);const n=new Of;n.uncompressedData=t;const s=(0,nt.readHeader)(t);if(s===null)throw new Error("Failed to parse NIFTI header.");return n.header=s,{data:n,size:t.byteLength}}function La(t,e,n,s,i){return Rt.getUrl(t,e,Nf,n,s,i)}const xf=1e3;async function Af(t,e,n,s){return(await La(t,e,n,()=>({priorityTier:se.VISIBLE,priority:xf}),s)).header}function Lf(t){return w.pB.fromValues(t[0][0],t[1][0],t[2][0],t[3][0],t[0][1],t[1][1],t[2][1],t[3][1],t[0][2],t[1][2],t[2][2],t[3][2],t[0][3],t[1][3],t[2][3],t[3][3])}var Ua=(t=>(t[t.NONE=0]="NONE",t[t.BINARY=1]="BINARY",t[t.UINT8=2]="UINT8",t[t.INT16=4]="INT16",t[t.INT32=8]="INT32",t[t.FLOAT32=16]="FLOAT32",t[t.COMPLEX64=32]="COMPLEX64",t[t.FLOAT64=64]="FLOAT64",t[t.RGB24=128]="RGB24",t[t.INT8=256]="INT8",t[t.UINT16=512]="UINT16",t[t.UINT32=768]="UINT32",t[t.INT64=1024]="INT64",t[t.UINT64=1280]="UINT64",t[t.FLOAT128=1536]="FLOAT128",t[t.COMPLEX128=1792]="COMPLEX128",t[t.COMPLEX256=2048]="COMPLEX256",t))(Ua||{});const Uf=new Map([[256,{dataType:ge.INT8}],[2,{dataType:ge.UINT8}],[4,{dataType:ge.INT16}],[512,{dataType:ge.UINT16}],[8,{dataType:ge.INT32}],[768,{dataType:ge.UINT32}],[1024,{dataType:ge.UINT64}],[1280,{dataType:ge.UINT64}],[16,{dataType:ge.FLOAT32}]]);Ke(xa.Y,async function(t,e){const n=this.getRef(t.chunkManager),s=this.getOptionalRef(t.credentialsProvider);try{const i=await Af(n,s,t.url,e),r=Uf.get(i.datatypeCode);if(r===void 0)throw new Error(`Unsupported data type: ${Ua[i.datatypeCode]||i.datatypeCode}.`);let o=1,a="";switch(i.xyzt_units&nt.NIFTI1.SPATIAL_UNITS_MASK){case nt.NIFTI1.UNITS_METER:o=1,a="m";break;case nt.NIFTI1.UNITS_MM:o=1e3,a="m";break;case nt.NIFTI1.UNITS_MICRON:o=1e6,a="m";break}let c="",l=1;switch(i.xyzt_units&nt.NIFTI1.TEMPORAL_UNITS_MASK){case nt.NIFTI1.UNITS_SEC:c="s",l=1;break;case nt.NIFTI1.UNITS_MSEC:c="s",l=1e3;break;case nt.NIFTI1.UNITS_USEC:c="s",l=1e6;break;case nt.NIFTI1.UNITS_HZ:c="Hz",l=1;break;case nt.NIFTI1.UNITS_RADS:c="rad/s",l=1;break}let u=[a,a,a,c,"","",""],d=Float64Array.of(i.pixDims[1]/o,i.pixDims[2]/o,i.pixDims[3]/o,i.pixDims[4]/l,i.pixDims[5],i.pixDims[6],i.pixDims[7]),h=Float64Array.of(1/o,1/o,1/o,1/l,1,1,1),p=["i","j","k","m","c^","c1^","c2^"],m=["x","y","z","t","c^","c1^","c2^"];const f=i.dims[0];p=p.slice(0,f),m=m.slice(0,f),u=u.slice(0,f),d=d.slice(0,f),h=h.slice(0,f);const{quatern_b:b,quatern_c:I,quatern_d:E}=i,V=Math.sqrt(1-b*b-I*I-E*E),R=i.pixDims[0]===-1?-1:1,C=w.eR.fromValues(i.qoffset_x,i.qoffset_y,i.qoffset_z),S=Lf(i.affine),T=(0,w.eG)(w.pB.create(),C,w.Yu.fromValues(b,I,E,V),w.Oi,R),v=Pf.DA(Float64Array,f+1),N=Math.min(3,f);for(let y=0;y<N;++y){for(let A=0;A<N;++A)v[A*(f+1)+y]=T[A*4+y];v[f*(f+1)+y]=T[12+y]}return{value:{rank:f,sourceNames:p,viewNames:m,units:u,sourceScales:d,viewScales:h,description:i.description,transform:v,dataType:r.dataType,volumeSize:Uint32Array.from(i.dims.slice(1,1+f))}}}finally{n.dispose(),s?.dispose()}});let Va=class extends je(Ye()(vt),xa.C){async download(t,e){t.chunkDataSize=this.spec.chunkDataSize;const n=await La(this.chunkManager,this.credentialsProvider,this.parameters.url,()=>({priorityTier:t.priorityTier,priority:t.priority}),e),s=(0,nt.readImage)(n.header,n.uncompressedData);await Lt(t,e,s,n.header.littleEndian?xe.LITTLE:xe.BIG)}};Va=_f([O()],Va);/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Vf=yt("parseOBJFromArrayBuffer");var os=x(6015),Bf=Object.defineProperty,Ff=Object.getOwnPropertyDescriptor,Ba=(t,e,n,s)=>{for(var i=s>1?void 0:s?Ff(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&Bf(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const $f=50;class zf extends _e{constructor(){super(...arguments),this.data=null}freeSystemMemory(){this.data=null}serialize(e,n){super.serialize(e,n);const{vertexPositions:s,indices:i,vertexNormals:r,vertexAttributes:o}=this.data;e.vertexPositions=s,e.indices=i,e.vertexNormals=r,e.vertexAttributes=o;const a=new Set;a.add(s.buffer),a.add(i.buffer),a.add(r.buffer);for(const c of o)a.add(c.buffer);n.push(...a),this.data=null}downloadSucceeded(){const{vertexPositions:e,indices:n,vertexNormals:s,vertexAttributes:i}=this.data;let r=this.gpuMemoryBytes=e.byteLength+n.byteLength+s.byteLength;for(const o of i)r+=o.byteLength;this.systemMemoryBytes=this.gpuMemoryBytes=r,super.downloadSucceeded()}}const Fa=new Map;function $a(t,e){Fa.set(t,e)}const Gf=/^(?:([a-zA-Z-+_]+):\/\/)?(.*)$/;function jf(t,e){const n=e.match(Gf);if(n===null||n[1]===void 0)throw new Error('Data source URL must have the form "<protocol>://<path>".');const s=n[1],i=t.get(s);if(i===void 0)throw new Error(`Unsupported data source: ${JSON.stringify(s)}.`);return[i,n[2],s]}function Yf(t,e,n,s,i){const[r,o]=jf(Fa,n);return r.getMesh(t,e,o,s,i)}function Gg(t){let e=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;for(const s of t)e=Math.min(e,s),n=Math.max(n,s);return[e,n]}function za(t,e,n,s,i){return Yf(t,e,n.meshSourceUrl,s,i)}let Ga=class extends je(Ye()(K),os.Fe){getChunk(){const t=os.b7;let e=this.chunks.get(t);return e===void 0&&(e=this.getNewChunk_(zf),e.initialize(t),this.addChunk(e)),e}download(t,e){const n=()=>({priorityTier:t.priorityTier,priority:t.priority});return za(this.chunkManager,this.credentialsProvider,this.parameters,n,e).then(s=>{if((0,k.JB)(s.info)!==(0,k.JB)(this.parameters.info))throw new Error("Mesh info has changed.");s.vertexNormals===void 0&&(s.vertexNormals=wo(s.vertexPositions,s.indices)),t.data=s})}};Ga=Ba([O()],Ga);const Jf=At(It(U));let ja=class extends Jf{constructor(t,e){super(t,e),this.source=this.registerDisposer(t.getRef(e.source)),this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(()=>{this.updateChunkPriorities()}))}updateChunkPriorities(){const t=this.visibility.value;if(t===Number.NEGATIVE_INFINITY)return;const e=ht(t),n=ft(t),{source:s,chunkManager:i}=this,r=s.getChunk();i.requestChunk(r,e,n+$f)}};ja=Ba([O(os.nG)],ja);const Hf=1e3;Ke(os.N3,async function(t,e){const n=this.getRef(t.chunkManager),s=this.getOptionalRef(t.credentialsProvider);try{const i=t.parameters;return{value:(await za(n,s,i,()=>({priorityTier:se.VISIBLE,priority:Hf}),e)).info}}finally{n.dispose(),s?.dispose()}});/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Wf(t,e){return Be(Vf,e,[t],t)}$a("obj",{description:"OBJ",getMesh:(t,e,n,s,i)=>Rt.getUrl(t,e,Wf,n,s,i)});var Kf=x(8997),qf=Object.defineProperty,Qf=Object.getOwnPropertyDescriptor,Xf=(t,e,n,s)=>{for(var i=s>1?void 0:s?Qf(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&qf(e,n,i),i};/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const gi=new Map;gi.set("jpg",async(t,e,n)=>{const s=t.chunkDataSize,{uint8Array:i}=await Be(Zs,e,[n],new Uint8Array(n),s[0],s[1]*s[2],3,!0);await kn(t,e,i)}),gi.set("raw16",(t,e,n)=>Lt(t,e,n,xe.BIG));let Ya=class extends je(vt,Kf.vc){constructor(){super(...arguments),this.chunkDecoder=gi.get(this.parameters.encoding),this.queryString=(()=>{const{parameters:t}=this,e=[];return t.channel!==void 0&&e.push("channels="+t.channel),t.minIntensity!==void 0&&e.push(`minIntensity=${JSON.stringify(t.minIntensity)}`),t.maxIntensity!==void 0&&e.push(`maxIntensity=${JSON.stringify(t.maxIntensity)}`),t.maxTileSpecsToRender!==void 0&&e.push(`maxTileSpecsToRender=${JSON.stringify(t.maxTileSpecsToRender)}`),t.filter!==void 0&&e.push(`filter=${JSON.stringify(t.filter)}`),e.join("&")})()}async download(t,e){const{parameters:n}=this,{chunkGridPosition:s}=t,i=1/2**n.level;t.chunkDataSize=this.spec.chunkDataSize;const r=t.chunkDataSize[0]*2**n.level,o=t.chunkDataSize[1]*2**n.level,a=w.eR.create();a[0]=s[0]*r,a[1]=s[1]*o,a[2]=s[2];let c;n.encoding==="raw16"?c="raw16-image":c="jpeg-image";const l=`/render-ws/v1/owner/${n.owner}/project/${n.project}/stack/${n.stack}/z/${a[2]}/box/${a[0]},${a[1]},${r},${o},${i}/${c}`,u=await(0,Ie.Bk)(`${n.baseUrl}${l}?${this.queryString}`,{},Ie.Rc,e);await this.chunkDecoder(t,e,u)}};Ya=Xf([O()],Ya);/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Zf=yt("parseVTKFromArrayBuffer");/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function ep(t,e){return Be(Zf,e,[t],t)}$a("vtk",{description:"VTK",getMesh:(t,e,n,s,i)=>Rt.getUrl(t,e,ep,n,s,i).then(r=>{const o={info:{numTriangles:r.numTriangles,numVertices:r.numVertices,vertexAttributes:[]},indices:r.indices,vertexPositions:r.vertexPositions,vertexAttributes:[]};for(const a of r.vertexAttributes)o.info.vertexAttributes.push({name:a.name,dataType:ge.FLOAT32,numComponents:a.numComponents}),o.vertexAttributes.push(a.data);return o})});var Re=x(2334);/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const on={[Re.L.arrayToArray]:new Map,[Re.L.arrayToBytes]:new Map,[Re.L.bytesToBytes]:new Map,sharding:new Map};function Ft(t){t.kind===Re.L.arrayToBytes&&"getShardedKvStore"in t?on.sharding.set(t.name,t):on[t.kind].set(t.name,t)}async function Ja(t,e,n){const s=t[Re.L.bytesToBytes];for(let o=s.length;o--;){const a=s[o],c=on[Re.L.bytesToBytes].get(a.name);if(c===void 0)throw new Error(`Unsupported codec: ${JSON.stringify(a.name)}`);e=await c.decode(a.configuration,e,n)}let i;{const o=t[Re.L.arrayToBytes],a=on[Re.L.arrayToBytes].get(o.name);if(a===void 0)throw new Error(`Unsupported codec: ${JSON.stringify(o.name)}`);i=await a.decode(o.configuration,t.arrayInfo[t.arrayInfo.length-1],e,n)}const r=t[Re.L.arrayToArray];for(let o=r.length;o--;){const a=r[o],c=on[Re.L.arrayToArray].get(a.name);if(c===void 0)throw new Error(`Unsupported codec: ${JSON.stringify(a.name)}`);i=await c.decode(a.configuration,t.arrayInfo[o],i,n)}return i}function tp(t,e,n){let s=n,i=e;for(;;){const{shardingInfo:a}=i;if(a===void 0)break;const c=i[Re.L.arrayToBytes],l=on.sharding.get(c.name);if(l===void 0)throw new Error(`Unsupported codec: ${JSON.stringify(c.name)}`);s=l.getShardedKvStore(c.configuration,t,s),i=a.subChunkCodecs}const r=i;function o(a,c){let l=c;const u=a.length;let d=e;for(;d.shardingInfo!==void 0;){const h=e.layoutInfo[e.layoutInfo.length-1],{physicalToLogicalDimension:p,readChunkShape:m}=h,{subChunkShape:f,subChunkGridShape:b,subChunkCodecs:I}=d.shardingInfo,E=new Array(u);for(let V=0;V<u;++V){const R=p[u-1-V];E[R]=Math.floor(a[V]*m[R]/f[R])%b[R]}l={base:l,subChunk:E},d=I}return l}return{kvStore:s,getChunkKey:o,decodeCodecs:r}}/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */Ft({name:"blosc",kind:Re.L.bytesToBytes,decode(t,e,n){return Be(_a,n,[e.buffer],e)}});/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */Ft({name:"zstd",kind:Re.L.bytesToBytes,decode(t,e,n){return Be(Oa,n,[e.buffer],e)}});/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */Ft({name:"bytes",kind:Re.L.arrayToBytes,async decode(t,e,n,s){const{dataType:i,chunkShape:r}=e,o=r.reduce((u,d)=>u*d,1),a=Wt[i],c=o*a;if(n.byteLength!==c)throw new Error(`Raw-format chunk is ${n.byteLength} bytes, but ${o} * ${a} = ${c} bytes are expected.`);const l=ir(i,n.buffer,n.byteOffset,n.byteLength);return _s(l,t.endian,a),l}});/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const yi=4;Ft({name:"crc32c",kind:Re.L.bytesToBytes,async decode(t,e,n){if(e.length<yi)throw new Error(`Expected buffer of size at least ${yi} bytes but received: ${e.length} bytes`);return e.subarray(0,e.length-yi)}});var np=x(6742);/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */Ft({name:"gzip",kind:Re.L.bytesToBytes,decode(t,e,n){return Be(tn,n,[e.buffer],e)}});/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function sp(t,e,n){(0,k.Rf)(t);const s=(0,k.cQ)(t,"name",r=>e((0,k.zr)(r))),i=(0,k.cQ)(t,"configuration",r=>(r===void 0?r={}:(0,k.Rf)(r),n(r,s)));return{name:s,configuration:i}}/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function ip(t){const{name:e,configuration:n}=sp(t,s=>{const i=Ha.get(s);if(i===void 0)throw new Error(`Unknown codec: ${JSON.stringify(s)}`);return i},s=>s);return{resolver:e,configuration:n}}const Ha=new Map;function rp(t){Ha.set(t.name,t)}function Wa(t,e){const n=[],s=[],i=[],r=[];s.push(e);const o=(0,k.$v)(t,ip),a=o.length;let c=0;for(;c<a;++c){const{resolver:f,configuration:b}=o[c];if(f.kind!==Re.L.arrayToArray)break;const I=f,{configuration:E,encodedArrayInfo:V}=I.resolve(b,e);s.push(V),e=V,n.push({kind:Re.L.arrayToArray,name:f.name,configuration:E})}if(c===a||o[c].resolver.kind!==Re.L.arrayToBytes)throw new Error("Missing array -> bytes codec");const{codecSpec:l,layoutInfo:u,encodedSize:d,shardingInfo:h}=(()=>{const{resolver:f,configuration:b}=o[c],I=f,{configuration:E,shardingInfo:V,encodedSize:R}=I.resolve(b,e);if(V!==void 0&&c+1!==a)throw new Error("bytes -> bytes codecs not supported following sharding codec");const C=I.getDecodedArrayLayoutInfo(E,e);return{codecSpec:{name:f.name,kind:Re.L.arrayToBytes,configuration:E},layoutInfo:C,encodedSize:R,shardingInfo:V}})();i[c]=u,r.push(d);const p=d,m=[];for(++c;c<a;){const{resolver:f,configuration:b}=o[c];if(f.kind!==Re.L.bytesToBytes)throw new Error(`Expected bytes -> bytes codec, but received ${JSON.stringify(f.name)} of kind ${Re.L[f.kind]}`);const I=f,{configuration:E,encodedSize:V}=I.resolve(b,p);m.push({name:f.name,kind:f.kind,configuration:E}),r.push(V),++c}for(let f=n.length-1;f>=0;--f)i[f]=o[f].resolver.getDecodedArrayLayoutInfo(n[f].configuration,s[f],i[f+1]);return{[Re.L.arrayToArray]:n,[Re.L.arrayToBytes]:l,[Re.L.bytesToBytes]:m,arrayInfo:s,layoutInfo:i,shardingInfo:h,encodedSize:r}}/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var Ka=(t=>(t[t.DEFAULT=0]="DEFAULT",t[t.V2=1]="V2",t))(Ka||{});/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function qa(t){return parseArray(t,e=>{if(typeof e!="number"||!Number.isInteger(e)||e<0)throw new Error(`Expected non-negative integer, but received: ${JSON.stringify(e)}`);return e})}function vi(t,e){return(0,k.Xu)(new Array(e),t,n=>{if(typeof n!="number"||!Number.isInteger(n)||n<=0)throw new Error(`Expected positive integer, but received: ${JSON.stringify(n)}`);return n})}function Qa(t){if(t!=="."&&t!=="/")throw new Error(`Expected "." or "/", but received: ${JSON.stringify(t)}`);return t}const wi=new Map([["",{unit:"",scale:1}],["angstrom",{unit:"m",scale:1e-10}],["foot",{unit:"m",scale:.3048}],["inch",{unit:"m",scale:.0254}],["mile",{unit:"m",scale:1609.34}],["parsec",{unit:"m",scale:0x6da012f95c9e88}],["yard",{unit:"m",scale:.9144}],["minute",{unit:"s",scale:60}],["hour",{unit:"s",scale:60*60}],["day",{unit:"s",scale:60*60*24}]]);for(const t of["meter","second"])for(const e of Ti){const{longPrefix:n,prefix:s}=e;if(n===void 0)continue;const i={unit:t[0],scale:10**e.exponent};wi.set(`${n}${t}`,i),wi.set(`${s}${t[0]}`,i)}function jg(t){if(t===null)return{scale:1,unit:""};if(typeof t!="string")throw new Error(`Expected string but received: ${JSON.stringify(t)}`);const e=t.trim(),n=/^([-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)(?:[eE][-+]?\d+)?)\s*(.*)/,s=e.match(n);let i,r;s===null?(i=1,r=e):(i=Number(s[1]),r=s[2]);const o=wi.get(r);if(o===void 0)throw new Error(`Unsupported unit: ${JSON.stringify(r)}`);return{unit:o.unit,scale:i*o.scale}}function Xa(t,e){switch(t){case DataType.UINT8:case DataType.INT8:case DataType.UINT16:case DataType.INT16:case DataType.UINT32:case DataType.INT32:case DataType.UINT64:if(typeof e!="number"||!Number.isInteger(e))throw new Error(`Expected integer but received: ${JSON.stringify(e)}`);return e;case DataType.FLOAT32:if(typeof e=="number")return e;if(typeof e=="string"){if(e==="Infinity")return Number.POSITIVE_INFINITY;if(e==="-Infinity")return Number.NEGATIVE_INFINITY;if(e==="NaN")return new Float32Array(Uint32Array.of(2143289344).buffer)[0];if(e.match(/^0x[a-fA-F0-9]+$/))return new Float32Array(Uint32Array.of(Number(e)).buffer)[0]}throw new Error(`Expected number, "Infinity", "-Infinity", "NaN", or hex string but received: ${JSON.stringify(e)}`)}}function Yg(t,e){try{verifyObject(t),verifyObjectProperty(t,"zarr_format",m=>{verifyConstant(m,3)});const n=verifyObjectProperty(t,"node_type",m=>{if(e!==void 0&&verifyConstant(m,e),m!=="array"&&m!=="group")throw new Error(`Expected "array" or "group" but received: ${JSON.stringify(m)}`);return m});if(e=n,n==="group")return{zarrVersion:3,nodeType:"group",userAttributes:verifyOptionalObjectProperty(t,"attributes",verifyObject,{})};const s=verifyObjectProperty(t,"shape",qa),i=s.length,r=verifyObjectProperty(t,"dimension_names",m=>verifyOptionalFixedLengthArrayOfStringOrNull(m??void 0,i)),o=verifyObjectProperty(t,"data_type",m=>verifyEnumString(m,DataType,/^[a-z0-9]+$/)),{configuration:a}=verifyObjectProperty(t,"chunk_grid",m=>parseNameAndConfiguration(m,f=>verifyConstant(f,"regular"),f=>verifyObjectProperty(f,"chunk_shape",b=>vi(b,i)))),{userAttributes:c,dimensionUnits:l}=verifyObjectProperty(t,"attributes",m=>{m===void 0&&(m={}),verifyObject(m);const f=verifyObjectProperty(m,"dimension_units",b=>verifyOptionalFixedLengthArrayOfStringOrNull(b,i));return{userAttributes:m,dimensionUnits:f}}),{configuration:u,name:d}=verifyObjectProperty(t,"chunk_key_encoding",m=>parseNameAndConfiguration(m,f=>verifyEnumString(f,ChunkKeyEncoding,/^(v2|default)$/),(f,b)=>verifyOptionalObjectProperty(f,"separator",Qa,b===ChunkKeyEncoding.DEFAULT?"/":"."))),h=verifyObjectProperty(t,"fill_value",m=>Xa(o,m)),p=verifyObjectProperty(t,"codecs",m=>parseCodecChainSpec(m,{dataType:o,chunkShape:a}));return{zarrVersion:3,nodeType:n,rank:i,shape:s,chunkShape:a,dataType:o,fillValue:h,dimensionNames:r,dimensionUnits:l,chunkKeyEncoding:d,dimensionSeparator:u,userAttributes:c,codecs:p}}catch(n){const s=e===void 0?"":`${e} `;throw new Error(`Error parsing zarr v3 ${s}metadata: ${n.message}`)}}function Jg(t,e,n){try{verifyObject(t),verifyObjectProperty(t,"zarr_format",p=>{verifyConstant(p,2)});const s=verifyObjectProperty(t,"shape",qa),i=s.length,r=verifyObjectProperty(t,"chunks",p=>vi(p,i)),o=verifyObjectProperty(t,"order",p=>{if(p!=="C"&&p!=="F")throw new Error(`Expected "C" or "F", but received: ${JSON.stringify(p)}`);return p}),a=verifyOptionalObjectProperty(t,"dimension_separator",n===void 0?Qa:p=>verifyConstant(p,n),n??"."),c=verifyObjectProperty(t,"dtype",p=>parseNumpyDtype(verifyString(p))),l=c.dataType,u=verifyObjectProperty(t,"fill_value",p=>p===null?0:Xa(l,p)),d=[];o==="F"&&d.push({name:"transpose",configuration:{order:Array.from(s,(p,m)=>i-m-1)}}),d.push({name:"bytes",configuration:{endian:c.endianness===Endianness.LITTLE?"little":"big"}}),verifyObjectProperty(t,"compressor",p=>{if(p===null)return;verifyObject(p);const m=verifyObjectProperty(p,"id",verifyString);switch(m){case"blosc":d.push({name:"blosc",configuration:{cname:verifyObjectProperty(p,"cname",verifyString),clevel:verifyObjectProperty(p,"clevel",verifyInt),typesize:DATA_TYPE_BYTES[l],shuffle:verifyObjectProperty(p,"shuffle",f=>{switch(f){case-1:return DATA_TYPE_BYTES[l]===1?"bitshuffle":"shuffle";case 0:return"noshuffle";case 1:return"shuffle";case 2:return"bitshuffle"}throw new Error(`Invalid value: ${JSON.stringify(f)}`)}),blocksize:verifyOptionalObjectProperty(p,"blocksize",verifyInt,0)}});break;case"zlib":case"gzip":d.push({name:"gzip",configuration:{level:verifyObjectProperty(p,"level",verifyInt)}});break;case"zstd":d.push({name:"zstd",configuration:{level:verifyObjectProperty(p,"level",verifyInt)}});break;default:throw new Error(`Unsupported compressor: ${JSON.stringify(m)}`)}});const h=parseCodecChainSpec(d,{dataType:l,chunkShape:r});return{zarrVersion:2,nodeType:"array",rank:i,shape:s,chunkShape:r,dataType:l,fillValue:u,dimensionNames:verifyObjectProperty(e,"_ARRAY_DIMENSIONS",p=>verifyOptionalFixedLengthArrayOfStringOrNull(p,i)),dimensionUnits:verifyObjectProperty(e,"dimension_units",p=>verifyOptionalFixedLengthArrayOfStringOrNull(p,i)),userAttributes:e,dimensionSeparator:a,chunkKeyEncoding:ChunkKeyEncoding.V2,codecs:h}}catch(s){throw new Error(`Error parsing zarr v2 metadata: ${s.message}`)}}/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var as=(t=>(t[t.START=0]="START",t[t.END=1]="END",t))(as||{});rp({name:"sharding_indexed",kind:Re.L.arrayToBytes,resolve(t,e){(0,k.Rf)(t);const n=(0,k.cQ)(t,"chunk_shape",c=>vi(c,e.chunkShape.length)),s=(0,k.MM)(t,"index_location",c=>(0,k.sl)(c,as,/^[a-z]+$/),1),i=Array.from(e.chunkShape,(c,l)=>{const u=n[l];if(c%u!==0)throw new Error(`sub-chunk shape of ${JSON.stringify(u)} does not evenly divide outer chunk shape of ${JSON.stringify(e.chunkShape)}`);return c/u}),r=Array.from(i);r.push(2);const o=(0,k.cQ)(t,"index_codecs",c=>Wa(c,{dataType:ge.UINT64,chunkShape:r}));if(o.encodedSize[o.encodedSize.length-1]===void 0)throw new Error("index_codecs must specify fixed-size encoding");const a=(0,k.cQ)(t,"codecs",c=>Wa(c,{dataType:e.dataType,chunkShape:n}));return{configuration:{indexCodecs:o,subChunkCodecs:a,subChunkShape:n,subChunkGridShape:i,indexLocation:s},shardingInfo:{subChunkShape:n,subChunkGridShape:i,subChunkCodecs:a}}},getDecodedArrayLayoutInfo(t,e){return t.subChunkCodecs.layoutInfo[0]}});/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Za(t,e){if(e===void 0)return{outer:t,inner:{offset:0,length:t.length}};if("suffixLength"in e){const n=Math.min(t.length,e.suffixLength);return{outer:{offset:t.offset+(t.length-n),length:n},inner:{offset:t.length-n,length:n}}}if(e.offset+e.length>t.length)throw new Error(`Requested byte range ${JSON.stringify(e)} not valid for value of length ${t.length}`);return{outer:{offset:t.offset+e.offset,length:e.length},inner:e}}/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ec=BigInt("18446744073709551615");class op extends J.O8{constructor(e,n,s){super(),this.configuration=e,this.base=s,this.indexCache=this.registerDisposer(new da(n.addRef(),{get:async(l,u)=>{const{indexCodecs:d}=e,h=d.encodedSize[d.encodedSize.length-1];let p;switch(e.indexLocation){case as.START:p={offset:0,length:h};break;case as.END:p={suffixLength:h};break}const m=await s.read(l,{cancellationToken:u,byteRange:p});if(m===void 0)return{size:0,data:void 0};const f=await Ja(e.indexCodecs,m.data,u);return{size:f.byteLength,data:new BigUint64Array(f.buffer,f.byteOffset,f.byteLength/8)}}}));const{subChunkGridShape:i}=this.configuration,r=i.length,o=this.configuration.indexCodecs.layoutInfo[0].physicalToLogicalDimension,a=this.indexStrides=new Array(r+1);let c=1;for(let l=r;l>=0;--l){const u=o[l];a[u]=c,c*=u===r?2:i[u]}}async read(e,n){const s=await this.indexCache.get(e.base,n.cancellationToken??j.fx);if(s===void 0)return;const i=this.configuration.subChunkShape.length,{subChunk:r}=e,{indexStrides:o}=this;let a=0;for(let m=0;m<i;++m){const f=r[m];a+=f*o[m]}const c=s[a],l=s[a+o[i]];if(c===ec&&l===ec)return;const u={offset:Number(c),length:Number(l)},{outer:d,inner:h}=Za(u,n.byteRange);if(d.length===0)return{data:new Uint8Array(0),dataRange:h,totalSize:u.length};const p=await this.base.read(e.base,{cancellationToken:n.cancellationToken,byteRange:d});if(p!==void 0){if(p.dataRange.offset!==d.offset||p.dataRange.length!==d.length)throw new Error(`Received truncated response, expected ${JSON.stringify(d)} but received ${JSON.stringify(p.dataRange)}`);return{data:p.data,dataRange:h,totalSize:u.length}}}}Ft({name:"sharding_indexed",kind:Re.L.arrayToBytes,getShardedKvStore(t,e,n){return new op(t,e,n)}});/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */Ft({name:"transpose",kind:Re.L.arrayToArray,async decode(t,e,n,s){return n}});/**
 * @license
 * Copyright 2023 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function ap(t){if(t!==void 0)return"suffixLength"in t?`bytes=-${t.suffixLength}`:`bytes=${t.offset}-${t.offset+t.length-1}`}const cp=navigator.userAgent.indexOf("Chrome")!==-1?"no-store":"default";class lp{constructor(e,n){this.credentialsProvider=e,this.baseUrl=n}async getObjectLength(e,n){const{cancellationToken:s=j.fx}=n,i=await He(this.credentialsProvider,e,{method:"HEAD"},async a=>a,s);if(i.status!==200)throw new Error("Failed to determine total size in order to fetch suffix");const r=i.headers.get("content-length");if(r===void 0)throw new Error("Failed to determine total size in order to fetch suffix");return Number(r)}async read(e,n){const{cancellationToken:s=j.fx}=n;let{byteRange:i}=n;const r=this.baseUrl+e;for(let o=0;;++o)try{const a={},c=ap(i);c!==void 0&&(a.headers={range:c},a.cache=cp);const{response:l,data:u}=await He(this.credentialsProvider,r,a,async p=>({response:p,data:await p.arrayBuffer()}),s);let d,h;if(l.status===206){const p=l.headers.get("content-range");if(p===null)if(i!==void 0)"suffixLength"in i?d={offset:await this.getObjectLength(r,n)-i.suffixLength,length:Number(l.headers.get("content-length"))}:d={offset:i.offset,length:u.byteLength};else throw new Error("Unexpected HTTP 206 response when no byte range specified.");if(p!==null){const m=p.match(/bytes ([0-9]+)-([0-9]+)\/([0-9]+|\*)/);if(m===null)throw new Error(`Invalid content-range header: ${JSON.stringify(p)}`);const f=parseInt(m[1],10);if(parseInt(m[2],10)!==f+u.byteLength-1)throw new Error(`Length in content-range header ${JSON.stringify(p)} does not match content length ${u.byteLength}`);h=m[3]==="*"?void 0:parseInt(m[3],10),d={offset:f,length:u.byteLength}}}return d===void 0&&(d={offset:0,length:u.byteLength},h=u.byteLength),{data:new Uint8Array(u),dataRange:d,totalSize:h}}catch(a){if(o===0&&a instanceof Ie.j$&&a.status===416&&n.byteRange!==void 0&&"suffixLength"in n.byteRange){const c=await this.getObjectLength(r,n);i=Za({offset:0,length:c},i).outer;continue}if((0,Ie.El)(a))return;throw a}}}function up(t,e){return new lp(t,e)}var dp=Object.defineProperty,hp=Object.getOwnPropertyDescriptor,fp=(t,e,n,s)=>{for(var i=s>1?void 0:s?hp(e,n):e,r=t.length-1,o;r>=0;r--)(o=t[r])&&(i=(s?o(e,n,i):o(i))||i);return s&&i&&dp(e,n,i),i};/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let tc=class extends je(Ye()(vt),np.j){constructor(){super(...arguments),this.chunkKvStore=tp(this.chunkManager,this.parameters.metadata.codecs,up(this.credentialsProvider,this.parameters.url+"/"))}async download(t,e){t.chunkDataSize=this.spec.chunkDataSize;const{parameters:n}=this,{chunkGridPosition:s}=t,{metadata:i}=n;let r="";const o=this.spec.rank,{physicalToLogicalDimension:a}=i.codecs.layoutInfo[0];let c;i.chunkKeyEncoding===Ka.DEFAULT?(r+="c",c=i.dimensionSeparator):(c="",o===0&&(r+="0"));const l=new Array(o),{readChunkShape:u}=i.codecs.layoutInfo[0],{chunkShape:d}=i;for(let m=0;m<o;++m){const f=a[o-1-m];l[f]=Math.floor(s[m]*u[f]/d[f])}for(let m=0;m<o;++m)r+=`${c}${l[m]}`,c=i.dimensionSeparator;const{chunkKvStore:h}=this,p=await h.kvStore.read(h.getChunkKey(s,r),{cancellationToken:e});if(p!==void 0){const m=await Ja(h.decodeCodecs,p.data,e);await kn(t,e,m)}}};tc=fp([O()],tc);/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const nc=new et(self,!1);nc.sendReady(),globalThis.rpc=nc}},rc={};function Ce(te){var Se=rc[te];if(Se!==void 0)return Se.exports;var x=rc[te]={exports:{}};return ic[te].call(x.exports,x,x.exports,Ce),x.exports}Ce.m=ic,Ce.x=()=>{var te=Ce.O(void 0,[562,108,367],()=>Ce(6499));return te=Ce.O(te),te},(()=>{var te=[];Ce.O=(Se,x,me,j)=>{if(x){j=j||0;for(var J=te.length;J>0&&te[J-1][2]>j;J--)te[J]=te[J-1];te[J]=[x,me,j];return}for(var be=1/0,J=0;J<te.length;J++){for(var[x,me,j]=te[J],ae=!0,ye=0;ye<x.length;ye++)(j&!1||be>=j)&&Object.keys(Ce.O).every(ze=>Ce.O[ze](x[ye]))?x.splice(ye--,1):(ae=!1,j<be&&(be=j));if(ae){te.splice(J--,1);var Me=me();Me!==void 0&&(Se=Me)}}return Se}})(),Ce.d=(te,Se)=>{for(var x in Se)Ce.o(Se,x)&&!Ce.o(te,x)&&Object.defineProperty(te,x,{enumerable:!0,get:Se[x]})},Ce.f={},Ce.e=te=>Promise.all(Object.keys(Ce.f).reduce((Se,x)=>(Ce.f[x](te,Se),Se),[])),Ce.u=te=>te===562?"562.1d0cecad9cc0725955f0.js":te===367?"367.ad6071abcab399305157.js":""+(te===491?"neuroglancer_async_computation":te)+"."+{108:"0a5667e8aa66afecd11a",491:"0e1ff0b6cf9b1e029679"}[te]+".js",Ce.miniCssF=te=>{},Ce.o=(te,Se)=>Object.prototype.hasOwnProperty.call(te,Se),Ce.r=te=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(te,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(te,"__esModule",{value:!0})},(()=>{var te;if(typeof import.meta.url=="string"&&(te=import.meta.url),!te)throw new Error("Automatic publicPath is not supported in this browser");te=te.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),Ce.p=te})(),(()=>{Ce.b=new URL("./",import.meta.url);var te={717:0},Se=x=>{var{ids:me,modules:j,runtime:J}=x,be,ae,ye=0;for(be in j)Ce.o(j,be)&&(Ce.m[be]=j[be]);for(J&&J(Ce);ye<me.length;ye++)ae=me[ye],Ce.o(te,ae)&&te[ae]&&te[ae][0](),te[me[ye]]=0;Ce.O()};Ce.f.j=(x,me)=>{var j=Ce.o(te,x)?te[x]:void 0;if(j!==0)if(j)me.push(j[1]);else{var J=import("./"+Ce.u(x)).then(Se,be=>{throw te[x]!==0&&(te[x]=void 0),be}),J=Promise.race([J,new Promise(be=>j=te[x]=[be])]);me.push(j[1]=J)}},Ce.O.j=x=>te[x]===0})(),(()=>{var te=Ce.x;Ce.x=()=>Promise.all([562,108,367].map(Ce.e,Ce)).then(te)})();var Kg=Ce.x();

//# sourceMappingURL=neuroglancer_chunk_worker.6de531489d574d806f47.js.map