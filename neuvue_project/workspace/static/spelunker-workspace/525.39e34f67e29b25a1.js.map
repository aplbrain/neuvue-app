{"version":3,"file":"525.39e34f67e29b25a1.js","sources":["webpack://neuroglancer/./src/segmentation_graph/segment_id.ts","webpack://neuroglancer/./src/trackable_value.ts","webpack://neuroglancer/./src/util/disposable.ts","webpack://neuroglancer/./src/util/geom.ts","webpack://neuroglancer/./src/util/json.ts","webpack://neuroglancer/./src/util/matrix.ts","webpack://neuroglancer/./src/util/signal.ts","webpack://neuroglancer/./src/mesh/draco/index.ts","webpack://neuroglancer/./src/credentials_provider/index.ts","webpack://neuroglancer/./src/chunk_manager/base.ts","webpack://neuroglancer/./src/navigation_state.ts","webpack://neuroglancer/./src/util/data_type.ts","webpack://neuroglancer/./src/util/endian.ts","webpack://neuroglancer/./src/annotation/index.ts","webpack://neuroglancer/./src/datasource/nifti/backend.ts","webpack://neuroglancer/./src/single_mesh/backend.ts","webpack://neuroglancer/./src/datasource/zarr/codec/sharding_indexed/resolve.ts","webpack://neuroglancer/./src/datasource/zarr/codec/resolve.ts","webpack://neuroglancer/./src/kvstore/special/index.ts","webpack://neuroglancer/./src/util/abort.ts","webpack://neuroglancer/./src/worker_rpc.ts","webpack://neuroglancer/./src/shared_watchable_value.ts","webpack://neuroglancer/./src/util/linked_list.1.ts","webpack://neuroglancer/./src/util/pairing_heap.0.ts","webpack://neuroglancer/./src/util/pairing_heap.1.ts","webpack://neuroglancer/./src/chunk_manager/backend.ts","webpack://neuroglancer/./src/render_layer_backend.ts","webpack://neuroglancer/./src/util/array.ts","webpack://neuroglancer/./src/util/si_units.ts","webpack://neuroglancer/./src/util/vector.ts","webpack://neuroglancer/./src/coordinate_transform.ts","webpack://neuroglancer/./src/util/trackable.ts","webpack://neuroglancer/./src/display_context.ts","webpack://neuroglancer/./src/render_coordinate_transform.ts","webpack://neuroglancer/./src/sliceview/base.ts","webpack://neuroglancer/./src/util/velocity_estimation.ts","webpack://neuroglancer/./src/visibility_priority/backend.ts","webpack://neuroglancer/./src/sliceview/backend.ts","webpack://neuroglancer/./src/util/erf.ts","webpack://neuroglancer/./src/perspective_view/backend.ts","webpack://neuroglancer/./src/volume_rendering/base.ts","webpack://neuroglancer/./src/volume_rendering/backend.ts","webpack://neuroglancer/./src/annotation/base.ts","webpack://neuroglancer/./src/util/color.ts","webpack://neuroglancer/./src/util/hex.ts","webpack://neuroglancer/./src/util/float.ts","webpack://neuroglancer/./src/util/random.ts","webpack://neuroglancer/./src/util/lerp.ts","webpack://neuroglancer/./src/shared_disjoint_sets.ts","webpack://neuroglancer/./src/gpu_hash/hash_table.ts","webpack://neuroglancer/./src/uint64_map.ts","webpack://neuroglancer/./src/uint64_set.ts","webpack://neuroglancer/./src/segmentation_display_state/base.ts","webpack://neuroglancer/./src/segmentation_display_state/backend.ts","webpack://neuroglancer/./src/annotation/backend.ts","webpack://neuroglancer/./src/credentials_provider/shared_counterpart.ts","webpack://neuroglancer/./src/util/http_request.ts","webpack://neuroglancer/./src/credentials_provider/http_request.ts","webpack://neuroglancer/./src/datasource/boss/api.ts","webpack://neuroglancer/./src/mesh/triangle_strips.ts","webpack://neuroglancer/./src/util/zorder.ts","webpack://neuroglancer/./src/mesh/backend.ts","webpack://neuroglancer/./src/mesh/multiscale.ts","webpack://neuroglancer/./src/async_computation/index.ts","webpack://neuroglancer/./src/async_computation/encode_compressed_segmentation_request.ts","webpack://neuroglancer/./src/async_computation/request.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/postprocess.ts","webpack://neuroglancer/./src/util/gzip.ts","webpack://neuroglancer/./src/util/numpy_dtype.ts","webpack://neuroglancer/./src/util/npy.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/bossNpz.ts","webpack://neuroglancer/./src/async_computation/decode_jpeg_request.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/jpeg.ts","webpack://neuroglancer/./src/sliceview/volume/backend.ts","webpack://neuroglancer/./src/datasource/boss/backend.ts","webpack://neuroglancer/./src/credentials_provider/oauth2.ts","webpack://neuroglancer/./src/datasource/brainmaps/api.ts","webpack://neuroglancer/./src/skeleton/backend.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/compressed_segmentation.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/raw.ts","webpack://neuroglancer/./src/datasource/brainmaps/backend.ts","webpack://neuroglancer/./src/async_computation/decode_png_request.ts","webpack://neuroglancer/./src/util/special_protocol_request.ts","webpack://neuroglancer/./src/util/s3.ts","webpack://neuroglancer/./src/datasource/deepzoom/backend.ts","webpack://neuroglancer/./src/datasource/dvid/api.ts","webpack://neuroglancer/./src/skeleton/decode_swc_skeleton.ts","webpack://neuroglancer/./src/datasource/dvid/backend.ts","webpack://neuroglancer/./src/datasource/graphene/base.ts","webpack://neuroglancer/./src/chunk_manager/generic_file_source.ts","webpack://neuroglancer/./src/async_computation/decode_compresso_request.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/compresso.ts","webpack://neuroglancer/./src/async_computation/decode_jxl_request.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/jxl.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/png.ts","webpack://neuroglancer/./src/util/byte_range_http_requests.ts","webpack://neuroglancer/./src/util/hash.ts","webpack://neuroglancer/./src/datasource/precomputed/backend.ts","webpack://neuroglancer/./src/skeleton/decode_precomputed_skeleton.ts","webpack://neuroglancer/./src/datasource/graphene/backend.ts","webpack://neuroglancer/./src/async_computation/decode_blosc_request.ts","webpack://neuroglancer/./src/async_computation/decode_zstd_request.ts","webpack://neuroglancer/./src/datasource/n5/backend.ts","webpack://neuroglancer/./src/async_computation/obj_mesh_request.ts","webpack://neuroglancer/./src/datasource/obj/backend.ts","webpack://neuroglancer/./src/datasource/render/backend.ts","webpack://neuroglancer/./src/async_computation/vtk_mesh_request.ts","webpack://neuroglancer/./src/datasource/vtk/backend.ts","webpack://neuroglancer/./src/datasource/zarr/codec/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/blosc/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/zstd/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/bytes/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/crc32c/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/gzip/decode.ts","webpack://neuroglancer/./src/datasource/zarr/metadata/parse_util.ts","webpack://neuroglancer/./src/datasource/zarr/metadata/parse.ts","webpack://neuroglancer/./src/kvstore/index.ts","webpack://neuroglancer/./src/datasource/zarr/codec/sharding_indexed/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/transpose/decode.ts","webpack://neuroglancer/./src/datasource/zarr/backend.ts","webpack://neuroglancer/./src/worker_rpc_context.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Uint64 } from \"#src/util/uint64.js\";\n\nexport enum VisibleSegmentEquivalencePolicy {\n  MIN_REPRESENTATIVE = 0, // defafult, representative elmement is the minimum element in equivalence set\n  MAX_REPRESENTATIVE = 1, // representative elmement is the maximum element in equivalence set\n  REPRESENTATIVE_EXCLUDED = 1 << 1, // filter out the representative element when iterating over visible segments\n  NONREPRESENTATIVE_EXCLUDED = 1 << 2, // filter out non representative elements when iterating over visible segments\n}\n\n// Returns `true` if `segmentId` is a base segment id, rather than a segment id added to the graph.\nexport function isBaseSegmentId(segmentId: Uint64) {\n  return segmentId.high >>> 31 ? false : true;\n}\n\nexport const UNKNOWN_NEW_SEGMENT_ID = new Uint64(0xffffffff, 0xffffffff);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debounce } from \"lodash-es\";\nimport type { Borrowed, Disposable, Owned } from \"#src/util/disposable.js\";\nimport { invokeDisposers, RefCounted } from \"#src/util/disposable.js\";\nimport type { NullaryReadonlySignal } from \"#src/util/signal.js\";\nimport { neverSignal, NullarySignal, Signal } from \"#src/util/signal.js\";\nimport type { Trackable } from \"#src/util/trackable.js\";\n\nexport interface WatchableValueInterface<T> {\n  value: T;\n  changed: NullaryReadonlySignal;\n}\n\nexport interface WatchableValueChangeInterface<T> {\n  readonly value: T;\n  readonly changed: Signal<(oldValue: T, newValue: T) => void>;\n}\n\nexport class WatchableValue<T> implements WatchableValueInterface<T> {\n  get value() {\n    return this.value_;\n  }\n  set value(newValue: T) {\n    if (newValue !== this.value_) {\n      this.value_ = newValue;\n      this.changed.dispatch();\n    }\n  }\n  changed = new NullarySignal();\n  constructor(protected value_: T) {}\n}\n\nexport class TrackableValue<T> extends WatchableValue<T> implements Trackable {\n  constructor(\n    value: T,\n    public validator: (value: any) => T,\n    public defaultValue = value,\n  ) {\n    super(value);\n  }\n  toJSON(): any {\n    const { value_ } = this;\n    if (value_ === this.defaultValue) {\n      return undefined;\n    }\n    return this.value_;\n  }\n  reset() {\n    this.value = this.defaultValue;\n  }\n  restoreState(x: any) {\n    if (x !== undefined) {\n      const { validator } = this;\n      try {\n        this.value = validator(x);\n        return;\n      } catch {\n        // Ignore invalid values in JSON representation.\n      }\n    }\n    this.value = this.defaultValue;\n  }\n}\n\nclass DerivedWatchableValue<U>\n  extends RefCounted\n  implements WatchableValueInterface<U>\n{\n  changed = new NullarySignal();\n  get value() {\n    return this.f(...this.ws.map((w) => w.value));\n  }\n  private f: (...v: any[]) => U;\n  private ws: WatchableValueInterface<any>[];\n\n  constructor(f: (...v: any[]) => U, ws: WatchableValueInterface<any>[]) {\n    super();\n    this.f = f;\n    this.ws = ws;\n    for (const w of ws) {\n      this.registerDisposer(w.changed.add(this.changed.dispatch));\n    }\n  }\n}\n\nexport function makeDerivedWatchableValue<U, T extends any[]>(\n  f: (...v: T) => U,\n  ...ws: { [K in keyof T]: WatchableValueInterface<T[K]> }\n) {\n  return new DerivedWatchableValue(f, ws);\n}\n\nclass CachedLazyDerivedWatchableValue<U>\n  extends RefCounted\n  implements WatchableValueInterface<U>\n{\n  changed = new NullarySignal();\n  private value_: U | undefined;\n  private valueGeneration = -1;\n  get value() {\n    const generation = this.changed.count;\n    if (generation !== this.valueGeneration) {\n      this.value_ = this.f(...this.ws.map((w) => w.value));\n      this.valueGeneration = generation;\n    }\n    return this.value_ as U;\n  }\n  private f: (...v: any[]) => U;\n  private ws: WatchableValueInterface<any>[];\n\n  constructor(f: (...v: any[]) => U, ws: WatchableValueInterface<any>[]) {\n    super();\n    this.f = f;\n    this.ws = ws;\n    for (const w of ws) {\n      this.registerDisposer(w.changed.add(this.changed.dispatch));\n    }\n  }\n}\n\nexport function makeCachedLazyDerivedWatchableValue<U, T extends any[]>(\n  f: (...v: T) => U,\n  ...ws: { [K in keyof T]: WatchableValueInterface<T[K]> }\n) {\n  return new CachedLazyDerivedWatchableValue(f, ws);\n}\n\nexport class CachedWatchableValue<T>\n  extends RefCounted\n  implements WatchableValueInterface<T>\n{\n  changed = new Signal();\n  value: T;\n  constructor(\n    base: WatchableValueInterface<T>,\n    isEqual: (a: T, b: T) => boolean = (a, b) => a === b,\n  ) {\n    super();\n    this.value = base.value;\n    this.registerDisposer(\n      base.changed.add(() => {\n        const newValue = base.value;\n        if (!isEqual(this.value, newValue)) {\n          this.value = newValue;\n          this.changed.dispatch();\n        }\n      }),\n    );\n  }\n}\n\nexport function makeCachedDerivedWatchableValue<U, T extends any[]>(\n  f: (...v: T) => U,\n  ws: { [K in keyof T]: WatchableValueInterface<T[K]> },\n  isEqual?: (a: U, b: U) => boolean,\n) {\n  const derived = new DerivedWatchableValue(f, ws);\n  const cached = new CachedWatchableValue(derived, isEqual);\n  cached.registerDisposer(derived);\n  return cached;\n}\n\nexport class AggregateWatchableValue<T>\n  extends RefCounted\n  implements WatchableValueInterface<T>\n{\n  changed = new NullarySignal();\n  value: T;\n  constructor(\n    getWatchables: (self: RefCounted) => {\n      [k in keyof T]: WatchableValueInterface<T[k]>;\n    },\n  ) {\n    super();\n    const watchables = getWatchables(this);\n    const keys = Object.keys(watchables) as (keyof T)[];\n    const updateValue = () => {\n      const obj = (Array.isArray(watchables) ? [] : {}) as T;\n      for (const k of keys) {\n        obj[k] = watchables[k].value;\n      }\n      this.value = obj;\n      this.changed.dispatch();\n    };\n    updateValue();\n    for (const k of keys) {\n      const watchable = watchables[k];\n      // Ensure a unique function is used each time in case the same watchable is assigned to\n      // multiple properties.\n      this.registerDisposer(watchable.changed.add(() => updateValue()));\n    }\n  }\n}\n\nexport class ComputedWatchableValue<U>\n  extends RefCounted\n  implements WatchableValueInterface<U>\n{\n  get value() {\n    return this.f();\n  }\n  changed = new NullarySignal();\n  constructor(\n    public f: () => U,\n    ...signals: NullarySignal[]\n  ) {\n    super();\n    for (const signal of signals) {\n      this.registerDisposer(signal.add(this.changed.dispatch));\n    }\n  }\n}\n\nexport class WatchableRefCounted<T extends RefCounted>\n  extends RefCounted\n  implements WatchableValueInterface<T | undefined>\n{\n  changed = new NullarySignal();\n\n  private value_: Owned<T> | undefined;\n  private valueHandler: (() => void) | undefined;\n\n  get value(): Borrowed<T> | undefined {\n    return this.value_;\n  }\n\n  set value(value: Owned<T> | undefined) {\n    const { value_ } = this;\n    this.value_ = value;\n    if (value_ !== undefined) {\n      value_.dispose();\n      value_.unregisterDisposer(this.valueHandler!);\n      this.valueHandler = undefined;\n    }\n    if (value !== undefined) {\n      const valueHandler = (this.valueHandler = () => {\n        if (this.value_ === value) {\n          this.value_ = undefined;\n          this.changed.dispatch();\n        }\n      });\n      value.registerDisposer(valueHandler);\n    }\n\n    if (value !== value_) {\n      this.changed.dispatch();\n    }\n  }\n\n  reset() {\n    this.value = undefined;\n  }\n\n  disposed() {\n    if (this.value_ !== undefined) {\n      this.value_.unregisterDisposer(this.valueHandler!);\n      this.value_.dispose();\n    }\n    this.value_ = undefined;\n    super.disposed();\n  }\n}\n\nexport interface TrackableValueInterface<T>\n  extends WatchableValueInterface<T>,\n    Trackable {}\n\nexport class TrackableRefCounted<T extends RefCounted>\n  extends WatchableRefCounted<T>\n  implements TrackableValueInterface<T | undefined>\n{\n  constructor(\n    public validator: (value: any) => T | undefined,\n    public jsonConverter: (value: T) => any,\n  ) {\n    super();\n  }\n  toJSON() {\n    const { value } = this;\n    return value && this.jsonConverter(value);\n  }\n\n  restoreState(x: any) {\n    this.value = this.validator(x);\n  }\n}\n\nexport class WatchableSet<T> {\n  changed = new Signal<(x: T | null, add: boolean) => void>();\n  values: Set<T>;\n  constructor(values?: Iterable<T>) {\n    if (values === undefined) {\n      this.values = new Set();\n    } else {\n      this.values = new Set(values);\n    }\n  }\n  add(x: T) {\n    const { values } = this;\n    if (!values.has(x)) {\n      values.add(x);\n      this.changed.dispatch(x, true);\n    }\n    return this;\n  }\n  delete(x: T) {\n    const { values } = this;\n    if (values.delete(x)) {\n      this.changed.dispatch(x, false);\n      return true;\n    }\n    return false;\n  }\n  has(x: T) {\n    return this.values.has(x);\n  }\n  get size() {\n    return this.values.size;\n  }\n  [Symbol.iterator]() {\n    return this.values[Symbol.iterator]();\n  }\n  clear() {\n    const { values } = this;\n    if (values.size > 0) {\n      values.clear();\n      this.changed.dispatch(null, false);\n    }\n  }\n}\n\nexport interface NestedStateManager<T = undefined> extends Disposable {\n  flush: () => void;\n  value: T;\n}\n\nexport function registerNested<U, T extends any[]>(\n  f: (context: RefCounted, ...values: T) => U,\n  ...watchables: { [K in keyof T]: WatchableValueInterface<T[K]> }\n): NestedStateManager<U> {\n  const values = watchables.map((w) => w.value) as T;\n  const count = watchables.length;\n  let context = new RefCounted();\n  let result = f(context, ...values);\n\n  const handleChange = debounce(() => {\n    let changed = false;\n    for (let i = 0; i < count; ++i) {\n      const watchable = watchables[i];\n      const value = watchable.value;\n      if (values[i] !== value) {\n        values[i] = value;\n        changed = true;\n      }\n    }\n    if (!changed) return;\n    context.dispose();\n    context = new RefCounted();\n    result = f(context, ...values);\n  }, 0);\n\n  const signalDisposers = watchables.map((w) => w.changed.add(handleChange));\n\n  return {\n    flush() {\n      handleChange.flush();\n    },\n    dispose() {\n      handleChange.cancel();\n      invokeDisposers(signalDisposers);\n      context.dispose();\n    },\n    get value() {\n      handleChange.flush();\n      return result;\n    },\n  };\n}\n\nexport function registerNestedSync<U, T extends any[]>(\n  f: (context: RefCounted, ...values: T) => U,\n  ...watchables: { [K in keyof T]: WatchableValueInterface<T[K]> }\n): { readonly value: U; dispose(): void } {\n  const values = watchables.map((w) => w.value) as T;\n  const count = watchables.length;\n  let context = new RefCounted();\n  let result = f(context, ...values);\n\n  const handleChange = () => {\n    let changed = false;\n    for (let i = 0; i < count; ++i) {\n      const watchable = watchables[i];\n      const value = watchable.value;\n      if (values[i] !== value) {\n        values[i] = value;\n        changed = true;\n      }\n    }\n    if (!changed) return;\n    context.dispose();\n    context = new RefCounted();\n    result = f(context, ...values);\n  };\n\n  const signalDisposers = watchables.map((w) => w.changed.add(handleChange));\n\n  return {\n    dispose() {\n      invokeDisposers(signalDisposers);\n      context.dispose();\n    },\n    get value() {\n      return result;\n    },\n  };\n}\n\nexport function constantWatchableValue<T>(\n  value: T,\n): WatchableValueInterface<T> {\n  return { changed: neverSignal, value };\n}\n\nexport function observeWatchable<T>(\n  callback: (value: T) => void,\n  watchable: WatchableValueInterface<T>,\n) {\n  callback(watchable.value);\n  return watchable.changed.add(() => callback(watchable.value));\n}\n\nexport function linkWatchableValue<T>(\n  source: WatchableValueInterface<T>,\n  target: WatchableValueInterface<T>,\n) {\n  target.value = source.value;\n  return source.changed.add(() => {\n    target.value = source.value;\n  });\n}\n\nexport class IndirectWatchableValue<U, T>\n  implements Disposable, WatchableValueInterface<T>\n{\n  protected inner: WatchableValueInterface<T>;\n  changed = new NullarySignal();\n  disposer: (() => void) | undefined;\n  private update = () => {\n    const { disposer, outer } = this;\n    if (disposer !== undefined) {\n      disposer();\n    }\n    const inner = (this.inner = this.getInner(outer.value));\n    this.disposer = inner.changed.add(this.changed.dispatch);\n    this.changed.dispatch();\n  };\n  constructor(\n    private outer: WatchableValueInterface<U>,\n    private getInner: (outer: U) => WatchableValueInterface<T>,\n  ) {\n    outer.changed.add(this.update);\n    this.update();\n  }\n\n  dispose() {\n    this.outer.changed.remove(this.update);\n    this.disposer!();\n  }\n\n  get value() {\n    return this.inner.value;\n  }\n  set value(value: T) {\n    this.inner.value = value;\n  }\n}\n\nexport class IndirectTrackableValue<U, T>\n  extends IndirectWatchableValue<U, T>\n  implements Trackable\n{\n  declare inner: TrackableValueInterface<T>;\n  reset() {\n    this.inner.reset();\n  }\n  restoreState(obj: unknown) {\n    this.inner.restoreState(obj);\n  }\n  toJSON() {\n    return this.inner.toJSON();\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface Disposable {\n  dispose: () => void;\n}\n\nexport type Disposer = Disposable | (() => void);\n\nconst DEBUG_REF_COUNTS = false;\n\nexport function invokeDisposer(disposer: Disposer) {\n  if (typeof disposer === \"object\") {\n    disposer.dispose();\n  } else {\n    disposer();\n  }\n}\n\nexport function invokeDisposers(disposers: Disposer[]) {\n  for (let i = disposers.length; i > 0; --i) {\n    invokeDisposer(disposers[i - 1]);\n  }\n}\n\nexport function registerEventListener(\n  target: EventTarget,\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions,\n) {\n  target.addEventListener(type, listener, options);\n  return () => target.removeEventListener(type, listener, options);\n}\n\nexport class RefCounted implements Disposable {\n  public refCount = 1;\n  wasDisposed: boolean | undefined;\n  private disposers: Disposer[];\n  addRef() {\n    ++this.refCount;\n    return this;\n  }\n  disposedStacks: any;\n  dispose() {\n    if (DEBUG_REF_COUNTS) {\n      (this.disposedStacks = this.disposedStacks || []).push(new Error().stack);\n    }\n    if (--this.refCount !== 0) {\n      return;\n    }\n    this.refCountReachedZero();\n  }\n  [Symbol.dispose]() {\n    this.dispose();\n  }\n\n  protected refCountReachedZero() {\n    this.disposed();\n    const { disposers } = this;\n    if (disposers !== undefined) {\n      invokeDisposers(disposers);\n      this.disposers = <any>undefined;\n    }\n    this.wasDisposed = true;\n  }\n  disposed() {}\n  registerDisposer<T extends Disposer>(f: T): T {\n    const { disposers } = this;\n    if (disposers == null) {\n      this.disposers = [f];\n    } else {\n      disposers.push(f);\n    }\n    return f;\n  }\n  unregisterDisposer<T extends Disposer>(f: T): T {\n    const { disposers } = this;\n    if (disposers != null) {\n      const index = disposers.indexOf(f);\n      if (index !== -1) {\n        disposers.splice(index, 1);\n      }\n    }\n    return f;\n  }\n  registerEventListener(\n    target: EventTarget,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ) {\n    this.registerDisposer(\n      registerEventListener(target, type, listener, options),\n    );\n  }\n  registerCancellable<T extends { cancel: () => void }>(cancellable: T) {\n    this.registerDisposer(() => {\n      cancellable.cancel();\n    });\n    return cancellable;\n  }\n}\n\nexport class RefCountedValue<T> extends RefCounted {\n  constructor(public value: T) {\n    super();\n  }\n}\n\n/**\n * A variable of this type is associated with an increment of the reference count.  If a function\n * parameter is declared with this type, then callers must donate a reference count.\n */\nexport type Owned<T extends Disposable> = T;\n\n/**\n * A variable of this type is not associated with an increment of the reference count.\n */\nexport type Borrowed<T extends Disposable> = T;\n\nexport function disposableOnce(value: Disposer | undefined) {\n  return () => {\n    if (value !== undefined) {\n      const x = value;\n      value = undefined;\n      invokeDisposer(x);\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { mat3 } from \"gl-matrix\";\nimport { mat4, quat, vec3, vec4 } from \"gl-matrix\";\nimport type { TypedArray } from \"#src/util/array.js\";\nimport { findMatchingIndices } from \"#src/util/array.js\";\n\nexport { mat2, mat3, mat4, quat, vec2, vec3, vec4 } from \"gl-matrix\";\n\nexport const identityMat4 = mat4.create();\n\nexport const AXES_NAMES = [\"x\", \"y\", \"z\"];\n\nexport const kAxes = [\n  vec3.fromValues(1, 0, 0),\n  vec3.fromValues(0, 1, 0),\n  vec3.fromValues(0, 0, 1),\n];\nexport const kZeroVec = vec3.fromValues(0, 0, 0);\nexport const kZeroVec4 = vec4.fromValues(0, 0, 0, 0);\nexport const kOneVec = vec3.fromValues(1, 1, 1);\nexport const kInfinityVec = vec3.fromValues(Infinity, Infinity, Infinity);\nexport const kIdentityQuat = quat.create();\n\nexport function prod3(x: ArrayLike<number>) {\n  return x[0] * x[1] * x[2];\n}\n\nexport function prod4(x: ArrayLike<number>) {\n  return x[0] * x[1] * x[2] * x[3];\n}\n\n/**\n * Implements a one-to-one conversion from Vec3 to string, suitable for use a Map key.\n *\n * Specifically, returns the string representation of the 3 values separated by commas.\n */\nexport function vec3Key(x: ArrayLike<number>) {\n  return `${x[0]},${x[1]},${x[2]}`;\n}\n\n/**\n * Transforms `a` by a 180-degree rotation about X, stores result in `out`.\n */\nexport function quatRotateX180(out: quat, a: quat) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  const w = a[3];\n  out[0] = w;\n  out[1] = z;\n  out[2] = -y;\n  out[3] = -x;\n}\n\n/**\n * Transforms `a` by a 180-degree rotation about Y, stores result in `out`.\n */\nexport function quatRotateY180(out: quat, a: quat) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  const w = a[3];\n  out[0] = -z;\n  out[1] = w;\n  out[2] = x;\n  out[3] = -y;\n}\n\n/**\n * Transforms `a` by a 180-degree rotation about Z, stores result in `out`.\n */\nexport function quatRotateZ180(out: quat, a: quat) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  const w = a[3];\n  out[0] = y;\n  out[1] = -x;\n  out[2] = w;\n  out[3] = -z;\n}\n\n/**\n * Transforms a vector `a` by a homogenous transformation matrix `m`.  The translation component of\n * `m` is ignored.\n */\nexport function transformVectorByMat4(out: vec3, a: vec3, m: mat4) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  out[0] = m[0] * x + m[4] * y + m[8] * z;\n  out[1] = m[1] * x + m[5] * y + m[9] * z;\n  out[2] = m[2] * x + m[6] * y + m[10] * z;\n  return out;\n}\n\n/**\n * Transforms a vector `a` by the transpose of a homogenous transformation matrix `m`.  The\n * translation component of `m` is ignored.\n */\nexport function transformVectorByMat4Transpose(out: vec3, a: vec3, m: mat4) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  out[0] = m[0] * x + m[1] * y + m[2] * z;\n  out[1] = m[4] * x + m[5] * y + m[6] * z;\n  out[2] = m[8] * x + m[9] * y + m[10] * z;\n  return out;\n}\n\nexport function translationRotationScaleZReflectionToMat4(\n  out: mat4,\n  translation: vec3,\n  rotation: quat,\n  scale: vec3,\n  zReflection: number,\n) {\n  const temp: Float32Array = out;\n  out[0] = scale[0];\n  out[1] = scale[1];\n  out[2] = scale[2] * zReflection;\n  return mat4.fromRotationTranslationScale(\n    out,\n    rotation,\n    translation,\n    <vec3>temp,\n  );\n}\n\n/**\n * Returns the value of `t` that minimizes `(p - (a + t * (b - a)))`.\n */\nexport function findClosestParameterizedLinePosition(\n  a: Float32Array,\n  b: Float32Array,\n  p: Float32Array,\n) {\n  // http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n  // Compute t: -dot(a-p, b-a) / |b - a|^2\n  const rank = p.length;\n  let denominator = 0;\n  for (let i = 0; i < rank; ++i) {\n    denominator += (a[i] - b[i]) ** 2;\n  }\n  let numerator = 0;\n  for (let i = 0; i < rank; ++i) {\n    const aValue = a[i];\n    numerator -= (aValue - p[i]) * (b[i] - aValue);\n  }\n  return numerator / Math.max(denominator, 1e-6);\n}\n\n/**\n * Sets `out` to the position on the line segment `[a, b]` closest to `p`.\n */\nexport function projectPointToLineSegment(\n  out: Float32Array,\n  a: Float32Array,\n  b: Float32Array,\n  p: Float32Array,\n) {\n  const rank = out.length;\n  let t = findClosestParameterizedLinePosition(a, b, p);\n  t = Math.max(0.0, Math.min(1.0, t));\n  for (let i = 0; i < rank; ++i) {\n    const aValue = a[i];\n    out[i] = aValue + t * (b[i] - aValue);\n  }\n  return out;\n}\n\nexport function mat3FromMat4(out: mat3, m: mat4) {\n  const m00 = m[0];\n  const m01 = m[1];\n  const m02 = m[2];\n  const m10 = m[4];\n  const m11 = m[5];\n  const m12 = m[6];\n  const m20 = m[8];\n  const m21 = m[9];\n  const m22 = m[10];\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Extracts the left, right, bottom, top, near, far clipping planes from `projectionMat`.\n * @param out Row-major array of shape `(6, 4)` specifying for each of the left, right, bottom, top,\n *     near, far clipping planes the `a`, `b`, `c`, `d` coefficients such that\n *     `0 < a * x + b * y + c * z + d` if the point `x, y, z` is inside the half-space of the\n * clipping plane.\n * @param m Projection matrix\n */\nexport function getFrustrumPlanes(out: Float32Array, m: mat4): Float32Array {\n  // http://web.archive.org/web/20120531231005/http://crazyjoke.free.fr/doc/3D/plane%20extraction.pdf\n  const m00 = m[0];\n  const m10 = m[1];\n  const m20 = m[2];\n  const m30 = m[3];\n  const m01 = m[4];\n  const m11 = m[5];\n  const m21 = m[6];\n  const m31 = m[7];\n  const m02 = m[8];\n  const m12 = m[9];\n  const m22 = m[10];\n  const m32 = m[11];\n  const m03 = m[12];\n  const m13 = m[13];\n  const m23 = m[14];\n  const m33 = m[15];\n\n  out[0] = m30 + m00; // left: a\n  out[1] = m31 + m01; // left: b\n  out[2] = m32 + m02; // left: c\n  out[3] = m33 + m03; // left: d\n\n  out[4] = m30 - m00; // right: a\n  out[5] = m31 - m01; // right: b\n  out[6] = m32 - m02; // right: c\n  out[7] = m33 - m03; // right: d\n\n  out[8] = m30 + m10; // bottom: a\n  out[9] = m31 + m11; // bottom: b\n  out[10] = m32 + m12; // bottom: c\n  out[11] = m33 + m13; // bottom: d\n\n  out[12] = m30 - m10; // top: a\n  out[13] = m31 - m11; // top: b\n  out[14] = m32 - m12; // top: c\n  out[15] = m33 - m13; // top: d\n\n  const nearA = m30 + m20; // near: a\n  const nearB = m31 + m21; // near: b\n  const nearC = m32 + m22; // near: c\n  const nearD = m33 + m23; // near: d\n\n  const farA = m30 - m20; // far: a\n  const farB = m31 - m21; // far: b\n  const farC = m32 - m22; // far: c\n  const farD = m33 - m23; // far: d\n\n  // Normalize near plane\n  const nearNorm = Math.sqrt(nearA ** 2 + nearB ** 2 + nearC ** 2);\n  out[16] = nearA / nearNorm;\n  out[17] = nearB / nearNorm;\n  out[18] = nearC / nearNorm;\n  out[19] = nearD / nearNorm;\n\n  // Also normalize far plane\n  const farNorm = Math.sqrt(farA ** 2 + farB ** 2 + farC ** 2);\n  out[20] = farA / farNorm;\n  out[21] = farB / farNorm;\n  out[22] = farC / farNorm;\n  out[23] = farD / farNorm;\n\n  return out;\n}\n\n/**\n * Checks whether the specified axis-aligned bounding box (AABB) intersects the view frustrum.\n *\n * @param clippingPlanes Array of length 24 specifying the clipping planes of the view frustrum, as\n *     computed by `getFrustrumPlanes`\n */\nexport function isAABBVisible(\n  xLower: number,\n  yLower: number,\n  zLower: number,\n  xUpper: number,\n  yUpper: number,\n  zUpper: number,\n  clippingPlanes: Float32Array,\n) {\n  for (let i = 0; i < 6; ++i) {\n    const a = clippingPlanes[i * 4];\n    const b = clippingPlanes[i * 4 + 1];\n    const c = clippingPlanes[i * 4 + 2];\n    const d = clippingPlanes[i * 4 + 3];\n    const sum =\n      Math.max(a * xLower, a * xUpper) +\n      Math.max(b * yLower, b * yUpper) +\n      Math.max(c * zLower, c * zUpper) +\n      d;\n    if (sum < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isAABBIntersectingPlane(\n  xLower: number,\n  yLower: number,\n  zLower: number,\n  xUpper: number,\n  yUpper: number,\n  zUpper: number,\n  clippingPlanes: Float32Array,\n) {\n  for (let i = 0; i < 4; ++i) {\n    const a = clippingPlanes[i * 4];\n    const b = clippingPlanes[i * 4 + 1];\n    const c = clippingPlanes[i * 4 + 2];\n    const d = clippingPlanes[i * 4 + 3];\n    const sum =\n      Math.max(a * xLower, a * xUpper) +\n      Math.max(b * yLower, b * yUpper) +\n      Math.max(c * zLower, c * zUpper) +\n      d;\n    if (sum < 0) {\n      return false;\n    }\n  }\n  {\n    const i = 5;\n    const a = clippingPlanes[i * 4];\n    const b = clippingPlanes[i * 4 + 1];\n    const c = clippingPlanes[i * 4 + 2];\n    const d = clippingPlanes[i * 4 + 3];\n    const maxSum =\n      Math.max(a * xLower, a * xUpper) +\n      Math.max(b * yLower, b * yUpper) +\n      Math.max(c * zLower, c * zUpper);\n    const minSum =\n      Math.min(a * xLower, a * xUpper) +\n      Math.min(b * yLower, b * yUpper) +\n      Math.min(c * zLower, c * zUpper);\n    const epsilon = Math.abs(d) * 1e-6;\n    if (minSum > -d + epsilon || maxSum < -d - epsilon) return false;\n  }\n  return true;\n}\n\n/**\n * Returns the list (in sorted order) of input dimensions that depend on any of the specified output\n * dimensions.\n */\nexport function getDependentTransformInputDimensions(\n  transform: Float32Array | Float64Array,\n  rank: number,\n  outputDimensions: readonly number[],\n  transpose = false,\n): number[] {\n  const numOutputDimensions = outputDimensions.length;\n  const isDependentInputDimension: boolean[] = [];\n  const inputStride = transpose ? 1 : rank + 1;\n  const outputStride = transpose ? rank + 1 : 1;\n  for (let i = 0; i < numOutputDimensions; ++i) {\n    const outputDim = outputDimensions[i];\n    for (let inputDim = 0; inputDim < rank; ++inputDim) {\n      if (transform[inputDim * inputStride + outputDim * outputStride] !== 0) {\n        isDependentInputDimension[inputDim] = true;\n      }\n    }\n  }\n  return findMatchingIndices(isDependentInputDimension, true);\n}\n\nexport function scaleMat3Input(out: mat3, input: mat3, scales: TypedArray) {\n  for (let j = 0; j < 3; ++j) {\n    const s = scales[j];\n    for (let i = 0; i < 3; ++i) {\n      out[i + j * 3] = s * input[i + j * 3];\n    }\n  }\n  return out;\n}\n\nexport function scaleMat3Output(out: mat3, input: mat3, scales: TypedArray) {\n  for (let i = 0; i < 3; ++i) {\n    const s = scales[i];\n    for (let j = 0; j < 3; ++j) {\n      out[i + j * 3] = s * input[i + j * 3];\n    }\n  }\n  return out;\n}\n\nexport function getViewFrustrumVolume(projectionMat: mat4) {\n  if (projectionMat[15] === 1) {\n    // orthographic projection\n    const depth = 2 / Math.abs(projectionMat[10]);\n    const width = 2 / Math.abs(projectionMat[0]);\n    const height = 2 / Math.abs(projectionMat[5]);\n    return width * height * depth;\n  }\n  // perspective projection\n  // a = (far + near) / (near - far);\n  // b = 2 * far * near / (near - far);\n  const a = projectionMat[10];\n  const b = projectionMat[14];\n  const near = (2 * b) / (2 * a - 2);\n  const far = ((a - 1) * near) / (a + 1);\n\n  const baseArea = 4 / (projectionMat[0] * projectionMat[5]);\n  return (baseArea / 3) * (Math.abs(far) ** 3 - Math.abs(near) ** 3);\n}\n\nexport function getViewFrustrumDepthRange(projectionMat: mat4) {\n  if (projectionMat[15] === 1) {\n    // orthographic projection\n    const depth = 2 / Math.abs(projectionMat[10]);\n    return depth;\n  }\n  // perspective projection\n  // a = (far + near) / (near - far);\n  // b = 2 * far * near / (near - far);\n  const a = projectionMat[10];\n  const b = projectionMat[14];\n  const near = (2 * b) / (2 * a - 2);\n  const far = ((a - 1) * near) / (a + 1);\n  const depth = Math.abs(far - near);\n  return depth;\n}\n\n// Ensures the z output is 0.  Useful for disabling depth clipping.\nexport function disableZProjection(mat: mat4) {\n  mat[2] = 0;\n  mat[6] = 0;\n  mat[10] = 0;\n  mat[14] = 0;\n  return mat;\n}\n\nconst tempVec3 = vec3.create();\n\n// Determines the bounding box in world coordinates of the view frustrum for a given view-projection\n// matrix.\n//\n// https://gamedev.stackexchange.com/questions/29999/how-do-i-create-a-bounding-frustum-from-a-view-projection-matrix\nexport function getViewFrustrumWorldBounds(\n  invViewProjectionMat: mat4,\n  bounds: Float32Array,\n) {\n  bounds[0] = bounds[1] = bounds[2] = Number.POSITIVE_INFINITY;\n  bounds[3] = bounds[4] = bounds[5] = Number.NEGATIVE_INFINITY;\n  for (let i = 0; i < 8; ++i) {\n    tempVec3[0] = 2 * (i & 1) - 1;\n    tempVec3[1] = 2 * ((i >>> 1) & 1) - 1;\n    tempVec3[2] = 2 * ((i >>> 2) & 1) - 1;\n    vec3.transformMat4(tempVec3, tempVec3, invViewProjectionMat);\n    for (let j = 0; j < 3; ++j) {\n      const x = tempVec3[j];\n      bounds[j] = Math.min(bounds[j], x);\n      bounds[j + 3] = Math.max(bounds[j + 3], x);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { WritableArrayLike } from \"#src/util/array.js\";\nimport { vec3 } from \"#src/util/geom.js\";\n\nexport function verifyFloat(obj: any): number {\n  const t = typeof obj;\n  if (t === \"number\" || t === \"string\") {\n    const x = parseFloat(\"\" + obj);\n    if (!Number.isNaN(x)) {\n      return x;\n    }\n  }\n  throw new Error(\n    `Expected floating-point number, but received: ${JSON.stringify(obj)}.`,\n  );\n}\n\nexport function verifyFiniteFloat(obj: any): number {\n  const x = verifyFloat(obj);\n  if (Number.isFinite(x)) {\n    return x;\n  }\n  throw new Error(`Expected finite floating-point number, but received: ${x}.`);\n}\n\nexport function verifyFiniteNonNegativeFloat(obj: any): number {\n  const x = verifyFloat(obj);\n  if (Number.isFinite(x) && x >= 0) {\n    return x;\n  }\n  throw new Error(\n    `Expected finite non-negative floating-point number, but received: ${x}.`,\n  );\n}\n\nexport function verifyFinitePositiveFloat(obj: any): number {\n  const x = verifyFiniteFloat(obj);\n  if (x > 0) {\n    return x;\n  }\n  throw new Error(\n    `Expected positive finite floating-point number, but received: ${x}.`,\n  );\n}\n\nexport function makeVerifyNumberInInterval(minValue: number, maxValue: number) {\n  return (obj: any) => {\n    const x = verifyFloat(obj);\n    if (x >= minValue && x <= maxValue) {\n      return x;\n    }\n    throw new Error(\n      `Expected floating-point number in range [${minValue}, ${maxValue}], but received: ${x}.`,\n    );\n  };\n}\n\nexport function parseXYZ<A extends WritableArrayLike<number>>(\n  out: A,\n  obj: any,\n  validator: (x: any) => number = verifyFloat,\n): A {\n  verifyObject(obj);\n  out[0] = out[1] = out[2] = 0;\n  for (const key of Object.keys(obj)) {\n    switch (key) {\n      case \"x\":\n        out[0] = validator(obj[key]);\n        break;\n      case \"y\":\n        out[1] = validator(obj[key]);\n        break;\n      case \"z\":\n        out[2] = validator(obj[key]);\n        break;\n      default:\n        throw new Error(\n          `Expected object to have keys ['x', 'y', 'z'], but received: ${JSON.stringify(\n            obj,\n          )}.`,\n        );\n    }\n  }\n  return out;\n}\n\nexport function parseFiniteVec<U extends WritableArrayLike<number>>(\n  out: U,\n  obj: any[],\n) {\n  const length = out.length;\n  if (!Array.isArray(obj) || obj.length !== length) {\n    throw new Error(\"Incompatible sizes\");\n  }\n\n  for (let i = 0; i < length; ++i) {\n    if (!Number.isFinite(parseFloat(obj[i]))) {\n      throw new Error(\"Non-finite value.\");\n    }\n  }\n  for (let i = 0; i < length; ++i) {\n    out[i] = parseFloat(obj[i]);\n  }\n  return out;\n}\n\nexport function parseIntVec<U extends WritableArrayLike<number>>(\n  out: U,\n  obj: any,\n) {\n  const length = out.length;\n  if (!Array.isArray(obj) || obj.length !== length) {\n    throw new Error(\"Incompatible sizes.\");\n  }\n\n  for (let i = 0; i < length; ++i) {\n    const val = parseInt(obj[i], undefined);\n    if (!Number.isInteger(val)) {\n      throw new Error(\"Non-integer value.\");\n    }\n  }\n\n  for (let i = 0; i < length; ++i) {\n    out[i] = parseInt(obj[i], undefined);\n  }\n  return out;\n}\n\n/**\n * Returns a JSON representation of x, with object keys sorted to ensure a\n * consistent result.\n */\nexport function stableStringify(x: any) {\n  if (typeof x === \"object\") {\n    if (x === null) {\n      return \"null\";\n    }\n    if (Array.isArray(x)) {\n      let s = \"[\";\n      const size = x.length;\n      let i = 0;\n      if (i < size) {\n        s += stableStringify(x[i]);\n        while (++i < size) {\n          s += \",\";\n          s += stableStringify(x[i]);\n        }\n      }\n      s += \"]\";\n      return s;\n    }\n    let s = \"{\";\n    const keys = Object.keys(x).sort();\n    let i = 0;\n    const size = keys.length;\n    if (i < size) {\n      let key = keys[i];\n      s += JSON.stringify(key);\n      s += \":\";\n      s += stableStringify(x[key]);\n      while (++i < size) {\n        s += \",\";\n        key = keys[i];\n        s += JSON.stringify(key);\n        s += \":\";\n        s += stableStringify(x[key]);\n      }\n    }\n    s += \"}\";\n    return s;\n  }\n  return JSON.stringify(x);\n}\n\nfunction swapQuotes(x: string) {\n  return x.replace(/['\"]/g, (s) => {\n    return s === '\"' ? \"'\" : '\"';\n  });\n}\n\nexport function urlSafeStringifyString(x: string) {\n  return swapQuotes(JSON.stringify(swapQuotes(x)));\n}\n\nconst URL_SAFE_COMMA = \"_\";\n\nexport function urlSafeStringify(x: any): string {\n  if (typeof x === \"object\") {\n    if (x === null) {\n      return \"null\";\n    }\n    const toJSON = x.toJSON;\n    if (typeof toJSON === \"function\") {\n      return urlSafeStringify(toJSON.call(x));\n    }\n    if (Array.isArray(x)) {\n      let s = \"[\";\n      const size = x.length;\n      let i = 0;\n      if (i < size) {\n        s += urlSafeStringify(x[i]);\n        while (++i < size) {\n          s += URL_SAFE_COMMA;\n          s += urlSafeStringify(x[i]);\n        }\n      }\n      s += \"]\";\n      return s;\n    }\n    let s = \"{\";\n    const keys = Object.keys(x);\n    let first = true;\n    for (const key of keys) {\n      const value = x[key];\n      if (value === undefined) {\n        continue;\n      }\n      const valueString = urlSafeStringify(value);\n      if (!valueString) {\n        continue;\n      }\n      if (!first) {\n        s += URL_SAFE_COMMA;\n      } else {\n        first = false;\n      }\n      s += urlSafeStringifyString(key);\n      s += \":\";\n      s += valueString;\n    }\n    s += \"}\";\n    return s;\n  }\n  if (typeof x === \"string\") {\n    return urlSafeStringifyString(x);\n  }\n  return JSON.stringify(x);\n}\n\nconst SINGLE_QUOTE_STRING_PATTERN = /('(?:[^'\\\\]|(?:\\\\.))*')/;\nconst DOUBLE_QUOTE_STRING_PATTERN = /(\"(?:[^\"\\\\]|(?:\\\\.))*\")/;\nconst SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN = new RegExp(\n  `${SINGLE_QUOTE_STRING_PATTERN.source}|${DOUBLE_QUOTE_STRING_PATTERN.source}`,\n);\nconst DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN = new RegExp(\n  `${DOUBLE_QUOTE_STRING_PATTERN.source}|${SINGLE_QUOTE_STRING_PATTERN.source}`,\n);\n\nconst DOUBLE_QUOTE_PATTERN = /^((?:[^\"'\\\\]|(?:\\\\[^']))*)(\"|\\\\')/;\nconst SINGLE_QUOTE_PATTERN = /^((?:[^\"'\\\\]|(?:\\\\.))*)'/;\n\nfunction convertStringLiteral(\n  x: string,\n  quoteInitial: string,\n  quoteReplace: string,\n  quoteSearch: RegExp,\n) {\n  if (\n    x.length >= 2 &&\n    x.charAt(0) === quoteInitial &&\n    x.charAt(x.length - 1) === quoteInitial\n  ) {\n    let inner = x.substr(1, x.length - 2);\n    let s = quoteReplace;\n    while (inner.length > 0) {\n      const m = inner.match(quoteSearch);\n      if (m === null) {\n        s += inner;\n        break;\n      }\n      s += m[1];\n      if (m[2] === quoteReplace) {\n        // We received a single unescaped quoteReplace character.\n        s += \"\\\\\";\n        s += quoteReplace;\n      } else {\n        // We received \"\\\\\" + quoteInitial.  We need to remove the escaping.\n        s += quoteInitial;\n      }\n      inner = inner.substr(m.index! + m[0].length);\n    }\n    s += quoteReplace;\n    return s;\n  }\n  return x;\n}\n\n/**\n * Converts a string literal delimited by either single or double quotes into a string literal\n * delimited by double quotes.\n */\nexport function normalizeStringLiteral(x: string) {\n  return convertStringLiteral(x, \"'\", '\"', DOUBLE_QUOTE_PATTERN);\n}\n\n// quoteChar: des\nfunction convertJsonHelper(\n  x: string,\n  desiredCommaChar: string,\n  desiredQuoteChar: string,\n) {\n  const commaSearch = /[&_,]/g;\n  let quoteInitial: string;\n  let quoteSearch: RegExp;\n  let stringLiteralPattern: RegExp;\n  if (desiredQuoteChar === '\"') {\n    quoteInitial = \"'\";\n    quoteSearch = DOUBLE_QUOTE_PATTERN;\n    stringLiteralPattern = SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN;\n  } else {\n    quoteInitial = '\"';\n    quoteSearch = SINGLE_QUOTE_PATTERN;\n    stringLiteralPattern = DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN;\n  }\n  let s = \"\";\n  while (x.length > 0) {\n    const m = x.match(stringLiteralPattern);\n    let before: string;\n    let replacement: string;\n    if (m === null) {\n      before = x;\n      x = \"\";\n      replacement = \"\";\n    } else {\n      before = x.substr(0, m.index);\n      x = x.substr(m.index! + m[0].length);\n      const originalString = m[1];\n      if (originalString !== undefined) {\n        replacement = convertStringLiteral(\n          originalString,\n          quoteInitial,\n          desiredQuoteChar,\n          quoteSearch,\n        );\n      } else {\n        replacement = m[2];\n      }\n    }\n    s += before.replace(commaSearch, desiredCommaChar);\n    s += replacement;\n  }\n  return s;\n}\n\nexport function urlSafeToJSON(x: string) {\n  return convertJsonHelper(x, \",\", '\"');\n}\n\nexport function jsonToUrlSafe(x: string) {\n  return convertJsonHelper(x, \"_\", \"'\");\n}\n\nexport function urlSafeParse(x: string) {\n  return JSON.parse(urlSafeToJSON(x));\n}\n\n// Converts a string containing a Python literal into a string containing an equivalent JSON\n// literal.\nexport function pythonLiteralToJSON(x: string) {\n  let s = \"\";\n  while (x.length > 0) {\n    const m = x.match(SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN);\n    let before: string;\n    let replacement: string;\n    if (m === null) {\n      before = x;\n      x = \"\";\n      replacement = \"\";\n    } else {\n      before = x.substr(0, m.index);\n      x = x.substr(m.index! + m[0].length);\n      const singleQuoteString = m[1];\n      if (singleQuoteString !== undefined) {\n        replacement = normalizeStringLiteral(singleQuoteString);\n      } else {\n        replacement = m[2];\n      }\n    }\n    s += before\n      .replace(/\\(/g, \"[\")\n      .replace(/\\)/g, \"]\")\n      .replace(\"True\", \"true\")\n      .replace(\"False\", \"false\")\n      .replace(/,\\s*([}\\]])/g, \"$1\");\n    s += replacement;\n  }\n  return s;\n}\n\n// Converts a string containing a Python literal into an equivalent JavaScript value.\nexport function pythonLiteralParse(x: string) {\n  return JSON.parse(pythonLiteralToJSON(x));\n}\n\nexport function expectArray(x: unknown, length?: number): any[] {\n  if (!Array.isArray(x)) {\n    throw new Error(`Expected array, but received: ${JSON.stringify(x)}.`);\n  }\n  if (length !== undefined && x.length !== length) {\n    throw new Error(\n      `Expected array of length ${length}, but received: ${JSON.stringify(x)}.`,\n    );\n  }\n  return x;\n}\n\n// Checks that `x' is an array, maps each element by parseElement.\nexport function parseArray<T>(\n  x: any,\n  parseElement: (x: any, index: number) => T,\n): T[] {\n  if (!Array.isArray(x)) {\n    throw new Error(`Expected array, but received: ${JSON.stringify(x)}.`);\n  }\n  return (<any[]>x).map(parseElement);\n}\n\nexport function parseFixedLengthArray<T, U extends WritableArrayLike<T>>(\n  out: U,\n  obj: any,\n  parseElement: (x: any, index: number) => T,\n): U {\n  const length = out.length;\n  if (!Array.isArray(obj) || obj.length !== length) {\n    throw new Error(\n      `Expected length ${length} array, but received: ${JSON.stringify(obj)}.`,\n    );\n  }\n  for (let i = 0; i < length; ++i) {\n    out[i] = parseElement(obj[i], i);\n  }\n  return out;\n}\n\nexport function verifyObject(obj: any) {\n  if (typeof obj !== \"object\" || obj == null || Array.isArray(obj)) {\n    throw new Error(\n      `Expected JSON object, but received: ${JSON.stringify(obj)}.`,\n    );\n  }\n  return obj;\n}\n\nexport function verifyInt(obj: any) {\n  const result = parseInt(obj, 10);\n  if (!Number.isInteger(result)) {\n    throw new Error(`Expected integer, but received: ${JSON.stringify(obj)}.`);\n  }\n  return result;\n}\n\nexport function verifyPositiveInt(obj: any) {\n  const result = verifyInt(obj);\n  if (result <= 0) {\n    throw new Error(`Expected positive integer, but received: ${result}.`);\n  }\n  return result;\n}\n\nexport function verifyNonnegativeInt(obj: any) {\n  const result = verifyInt(obj);\n  if (result < 0) {\n    throw new Error(`Expected non-negative integer, but received: ${result}.`);\n  }\n  return result;\n}\n\nexport function verifyMapKey<U>(obj: any, map: Map<string, U>) {\n  const result = map.get(obj);\n  if (result === undefined) {\n    throw new Error(\n      `Expected one of ${JSON.stringify(Array.from(map.keys()))}, ` +\n        `but received: ${JSON.stringify(obj)}.`,\n    );\n  }\n  return result;\n}\n\nexport function verifyString(obj: any) {\n  if (typeof obj !== \"string\") {\n    throw new Error(`Expected string, but received: ${JSON.stringify(obj)}.`);\n  }\n  return obj;\n}\n\nexport function verifyOptionalString(obj: any): string | undefined {\n  if (obj === undefined) {\n    return undefined;\n  }\n  return verifyString(obj);\n}\n\nexport function verifyOptionalInt(obj: any): number | undefined {\n  if (obj === undefined) {\n    return undefined;\n  }\n  return verifyInt(obj);\n}\n\nexport function verifyOptionalBoolean(obj: any): boolean | undefined {\n  if (obj === undefined) {\n    return undefined;\n  }\n  if (typeof obj === \"boolean\") {\n    return obj;\n  }\n  if (obj === \"true\") {\n    return true;\n  }\n  if (obj === \"false\") {\n    return false;\n  }\n  throw new Error(\n    `Expected string or boolean but received: ${JSON.stringify(obj)}`,\n  );\n}\n\nexport function valueOr<T>(value: T | undefined, defaultValue: T) {\n  return value === undefined ? defaultValue : value;\n}\n\nexport function verifyObjectProperty<T>(\n  obj: any,\n  propertyName: string,\n  validator: (value: any) => T,\n): T {\n  const value = Object.prototype.hasOwnProperty.call(obj, propertyName)\n    ? obj[propertyName]\n    : undefined;\n  try {\n    return validator(value);\n  } catch (parseError) {\n    throw new Error(\n      `Error parsing ${JSON.stringify(propertyName)} property: ${\n        parseError.message\n      }`,\n    );\n  }\n}\n\nexport function verifyOptionalObjectProperty<T>(\n  obj: any,\n  propertyName: string,\n  validator: (value: any) => T,\n): T | undefined;\n\nexport function verifyOptionalObjectProperty<T>(\n  obj: any,\n  propertyName: string,\n  validator: (value: any) => T,\n  defaultValue: T,\n): T;\n\nexport function verifyOptionalObjectProperty<T>(\n  obj: any,\n  propertyName: string,\n  validator: (value: any) => T,\n  defaultValue?: any,\n) {\n  return verifyObjectProperty(obj, propertyName, (x) =>\n    x === undefined ? defaultValue : validator(x),\n  );\n}\n\nexport function verifyObjectAsMap<T>(\n  obj: any,\n  validator: (value: any) => T,\n): Map<string, T> {\n  verifyObject(obj);\n  const map = new Map<string, T>();\n  for (const key of Object.keys(obj)) {\n    try {\n      map.set(key, validator(obj[key]));\n    } catch (parseError) {\n      throw new Error(\n        `Error parsing value associated with key ${JSON.stringify(key)}: ${\n          parseError.message\n        }`,\n      );\n    }\n  }\n  return map;\n}\n\nexport function verifyFloat01(obj: any): number {\n  if (typeof obj !== \"number\" || !Number.isFinite(obj) || obj < 0 || obj > 1) {\n    throw new Error(\n      `Expected floating point number in [0,1], but received: ${JSON.stringify(\n        obj,\n      )}.`,\n    );\n  }\n  return obj;\n}\n\n/**\n * The query string parameters may either be specified in the usual\n * 'name=value&otherName=otherValue' form or as (optionally urlSafe) JSON: '{\"name\":\"value\"}`.\n */\nexport function parseQueryStringParameters(queryString: string) {\n  if (queryString === \"\") {\n    return {};\n  }\n  if (queryString.startsWith(\"{\")) {\n    return urlSafeParse(queryString);\n  }\n  const result: any = {};\n  const parts = queryString.split(/[&;]/);\n  for (const part of parts) {\n    const m = part.match(/^([^=&;]+)=([^&;]*)$/);\n    if (m === null) {\n      throw new Error(`Invalid query string part: ${JSON.stringify(part)}.`);\n    }\n    result[m[1]] = decodeURIComponent(m[2]);\n  }\n  return result;\n}\n\nexport function unparseQueryStringParameters(parameters: any) {\n  if (parameters === undefined) return \"\";\n  const keys = Object.keys(parameters);\n  if (keys.length === 0) return \"\";\n  if (keys.some((key) => typeof parameters[key] !== \"string\")) {\n    return JSON.stringify(parameters);\n  }\n  return keys\n    .map(\n      (key) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(parameters[key])}`,\n    )\n    .join(\"&\");\n}\n\n/**\n * Verifies that `obj' is a string that, when converted to uppercase, matches a string property of\n * `enumType`.\n *\n * @returns The corresponding numerical value.\n */\nexport function verifyEnumString<T extends number>(\n  obj: any,\n  enumType: { [x: string]: T | string },\n  pattern: RegExp = /^[a-zA-Z]/,\n): T {\n  if (typeof obj === \"string\" && obj.match(pattern) !== null) {\n    const objUpperCase = obj.toUpperCase();\n    if (Object.prototype.hasOwnProperty.call(enumType, objUpperCase)) {\n      return enumType[objUpperCase] as T;\n    }\n  }\n  throw new Error(`Invalid enum value: ${JSON.stringify(obj)}.`);\n}\n\nexport function verify3dVec(obj: any) {\n  return parseFixedLengthArray(vec3.create(), obj, verifyFiniteFloat);\n}\n\nexport function verify3dScale(obj: any) {\n  return parseFixedLengthArray(vec3.create(), obj, verifyFinitePositiveFloat);\n}\n\nexport function verify3dDimensions(obj: any) {\n  return parseFixedLengthArray(vec3.create(), obj, verifyPositiveInt);\n}\n\nexport function verifyStringArray(a: any) {\n  if (!Array.isArray(a)) {\n    throw new Error(`Expected array, received: ${JSON.stringify(a)}.`);\n  }\n  for (const x of a) {\n    if (typeof x !== \"string\") {\n      throw new Error(`Expected string, received: ${JSON.stringify(x)}.`);\n    }\n  }\n  return <string[]>a;\n}\n\nexport function verifyIntegerArray(a: unknown) {\n  if (!Array.isArray(a)) {\n    throw new Error(`Expected array, received: ${JSON.stringify(a)}.`);\n  }\n  for (const x of a) {\n    if (!Number.isInteger(x)) {\n      throw new Error(`Expected integer, received: ${JSON.stringify(x)}.`);\n    }\n  }\n  return <number[]>a;\n}\n\nexport function verifyFloatArray(a: unknown) {\n  if (!Array.isArray(a)) {\n    throw new Error(`Expected array, received: ${JSON.stringify(a)}.`);\n  }\n  for (const x of a) {\n    verifyFloat(x);\n  }\n  return <number[]>a;\n}\n\nexport function verifyBoolean(x: any) {\n  if (typeof x !== \"boolean\") {\n    throw new Error(`Expected boolean, received: ${JSON.stringify(x)}`);\n  }\n  return x;\n}\n\n// If `x` is an empty object/array/string, returns undefined.  Otherwise returns `x`.\nexport function emptyToUndefined(x: any) {\n  for (const _ in x) {\n    return x;\n  }\n  return undefined;\n}\n\nexport function verifyConstant<T>(actual: unknown, expected: T) {\n  if (actual !== expected) {\n    throw new Error(\n      `Expected ${JSON.stringify(expected)}, but received: ${JSON.stringify(\n        actual,\n      )}`,\n    );\n  }\n  return expected;\n}\n\nexport function verifyOptionalFixedLengthArrayOfStringOrNull(\n  obj: unknown,\n  rank: number,\n) {\n  if (obj === undefined) {\n    const array = new Array<string | null>(rank);\n    array.fill(null);\n    return array;\n  }\n  return parseFixedLengthArray(new Array<string | null>(rank), obj, (value) => {\n    if (value !== null && typeof value !== \"string\") {\n      throw new Error(\n        `Expected string or null, but received: ${JSON.stringify(name)}`,\n      );\n    }\n    return value;\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TypedArray } from \"#src/util/array.js\";\n\n/**\n * Sets the `m * k` matrix `c` to the product of `m * n` matrix `a` and `n * k` matrix `b`.\n *\n * `a`, `b` and `c` are column-major with column strides of `lda`, `ldb`, and `ldc`, respectively.\n * `c` must not overlap `a` or `b`.\n */\nexport function multiply<T extends TypedArray>(\n  c: T,\n  ldc: number,\n  a: T,\n  lda: number,\n  b: T,\n  ldb: number,\n  m: number,\n  n: number,\n  k: number,\n): T {\n  for (let mIndex = 0; mIndex < m; ++mIndex) {\n    for (let kIndex = 0; kIndex < k; ++kIndex) {\n      let sum = 0;\n      for (let nIndex = 0; nIndex < n; ++nIndex) {\n        sum += a[mIndex + lda * nIndex] * b[nIndex + ldb * kIndex];\n      }\n      c[mIndex + ldc * kIndex] = sum;\n    }\n  }\n  return c;\n}\n\nexport function identity<T extends TypedArray>(\n  a: T,\n  lda: number,\n  n: number,\n): T {\n  for (let i = 0; i < n; ++i) {\n    const start = lda * i;\n    a.fill(0, start, start + n);\n    a[start + i] = 1;\n  }\n  return a;\n}\n\nexport function createIdentity<T extends TypedArray>(\n  c: { new (n: number): T },\n  rows: number,\n  cols: number = rows,\n): T {\n  return identity(new c(rows * cols), rows, Math.min(rows, cols));\n}\n\nexport function createHomogeneousScaleMatrix<T extends TypedArray>(\n  c: { new (length: number): T },\n  scales: ArrayLike<number>,\n  square = true,\n): T {\n  const rank = scales.length;\n  const stride = square ? rank + 1 : rank;\n  const m = new c(stride * (rank + 1));\n  if (square) {\n    m[m.length - 1] = 1;\n  }\n  for (let i = 0; i < rank; ++i) {\n    m[(stride + 1) * i] = scales[i];\n  }\n  return m;\n}\n\nexport function createHomogeneousTranslationMatrix<T extends TypedArray>(\n  c: { new (length: number): T },\n  translation: ArrayLike<number>,\n  square = true,\n): T {\n  const rank = translation.length;\n  const stride = square ? rank + 1 : rank;\n  const m = createIdentity(c, stride, rank + 1);\n  for (let i = 0; i < rank; ++i) {\n    m[stride * rank + i] = translation[i];\n  }\n  return m;\n}\n\nexport function isIdentity<T extends TypedArray>(a: T, lda: number, n: number) {\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0; j < n; ++j) {\n      if (a[i * lda + j] !== (i === j ? 1 : 0)) return false;\n    }\n  }\n  return true;\n}\n\nexport function copy<T extends TypedArray>(\n  b: T,\n  ldb: number,\n  a: T,\n  lda: number,\n  m: number,\n  n: number,\n): T {\n  for (let col = 0; col < n; ++col) {\n    const aOff = col * lda;\n    const bOff = col * ldb;\n    for (let row = 0; row < m; ++row) {\n      b[bOff + row] = a[aOff + row];\n    }\n  }\n  return b;\n}\n\nexport function extendHomogeneousTransform<T extends TypedArray>(\n  b: T,\n  bRank: number,\n  a: T,\n  aRank: number,\n) {\n  copy(b, bRank + 1, a, aRank + 1, aRank, aRank);\n  for (let i = 0; i < aRank; ++i) {\n    b[(bRank + 1) * bRank + i] = a[(aRank + 1) * aRank + i];\n  }\n  b[b.length - 1] = 1;\n  for (let i = aRank; i < bRank; ++i) {\n    b[(bRank + 1) * i + i] = 1;\n  }\n  return b;\n}\n\nlet pivots: Uint32Array | undefined;\n\n/**\n * Computes the inverse of a square matrix in place, and returns the determinant.\n */\nexport function inverseInplace<T extends TypedArray>(\n  a: T,\n  lda: number,\n  n: number,\n): number {\n  let determinant = 1;\n  // Use Gauss-Jordan elimination with partial pivoting to compute inverse.\n  if (pivots === undefined || pivots.length < n) {\n    pivots = new Uint32Array(n);\n  }\n  for (let i = 0; i < n; ++i) {\n    pivots[i] = i;\n  }\n  for (let k = 0; k < n; ++k) {\n    const kColOff = lda * k;\n    // Find best pivot (row >= `k` with maximum-magnitude element in column `k`).\n    let pivotRow = k;\n    {\n      let bestPivot = Math.abs(a[kColOff + k]);\n      for (let row = k + 1; row < n; ++row) {\n        const mag = Math.abs(a[kColOff + row]);\n        if (mag > bestPivot) {\n          bestPivot = mag;\n          pivotRow = row;\n        }\n      }\n    }\n    // Swap rows `k` and `pivotRow`.\n    if (k !== pivotRow) {\n      determinant *= -1;\n      for (let col = 0; col < n; ++col) {\n        const off = lda * col;\n        const temp = a[off + k];\n        a[off + k] = a[off + pivotRow];\n        a[off + pivotRow] = temp;\n      }\n\n      // Swap `pivots[k]` with `pivots[pivotRow]`.\n      {\n        const tempPivot = pivots[k];\n        pivots[k] = pivots[pivotRow];\n        pivots[pivotRow] = tempPivot;\n      }\n    }\n    // Eliminate.\n    const pivotValue = a[kColOff + k];\n    const pivotInv = 1.0 / pivotValue;\n\n    // Divide row `k` by the pivot element.\n    determinant *= pivotValue;\n    for (let j = 0; j < n; ++j) {\n      a[lda * j + k] *= pivotInv;\n    }\n    // Convert `a(k, k)` to contain the inverse element.\n    a[kColOff + k] = pivotInv;\n\n    // Subtract a suitable multiple of row `k` from all other rows to ensure column `k` becomes `0`.\n    for (let row = 0; row < n; ++row) {\n      if (row === k) continue;\n      const factor = -a[lda * k + row];\n      for (let j = 0; j < n; ++j) {\n        const jColOff = lda * j;\n        a[jColOff + row] += factor * a[jColOff + k];\n      }\n      // Convert element in column `k` to contain the inverse element.\n      a[lda * k + row] = factor * pivotInv;\n    }\n  }\n  // Permute columns back to correct order.\n  for (let col = 0; col < n; ++col) {\n    let targetCol = pivots[col];\n    while (targetCol !== col) {\n      const colOff = lda * col;\n      const targetColOff = lda * targetCol;\n      for (let i = 0; i < n; ++i) {\n        const off1 = colOff + i;\n        const off2 = targetColOff + i;\n        const temp = a[off1];\n        a[off1] = a[off2];\n        a[off2] = temp;\n      }\n      const temp = (pivots[col] = pivots[targetCol]);\n      pivots[targetCol] = targetCol;\n      targetCol = temp;\n    }\n  }\n  return determinant;\n}\n\n/**\n * Computes the inverse and returns the determinant.\n */\nexport function inverse<T extends TypedArray>(\n  b: T,\n  ldb: number,\n  a: T,\n  lda: number,\n  n: number,\n): number {\n  copy(b, ldb, a, lda, n, n);\n  return inverseInplace(b, ldb, n);\n}\n\nexport function equal<T extends TypedArray>(\n  a: T,\n  lda: number,\n  b: T,\n  ldb: number,\n  m: number,\n  n: number,\n) {\n  for (let j = 0; j < n; ++j) {\n    const offA = lda * j;\n    const offB = ldb * j;\n    for (let i = 0; i < m; ++i) {\n      if (a[offA + i] !== b[offB + i]) return false;\n    }\n  }\n  return true;\n}\n\nexport function transpose<T extends TypedArray>(\n  b: T,\n  ldb: number,\n  a: T,\n  lda: number,\n  m: number,\n  n: number,\n) {\n  for (let i = 0; i < m; ++i) {\n    for (let j = 0; j < n; ++j) {\n      b[j + i * ldb] = a[i + j * lda];\n    }\n  }\n  return b;\n}\n\nexport function transformPoint<\n  Out extends TypedArray,\n  Matrix extends TypedArray,\n  Vector extends TypedArray,\n>(out: Out, mat: Matrix, matrixStride: number, vec: Vector, rank: number): Out {\n  for (let i = 0; i < rank; ++i) {\n    let sum = mat[matrixStride * rank + i];\n    for (let j = 0; j < rank; ++j) {\n      sum += mat[matrixStride * j + i] * vec[j];\n    }\n    out[i] = sum;\n  }\n  return out;\n}\n\nexport function transformVector<\n  Out extends TypedArray,\n  Matrix extends TypedArray,\n  Vector extends TypedArray,\n>(out: Out, mat: Matrix, matrixStride: number, vec: Vector, rank: number): Out {\n  for (let i = 0; i < rank; ++i) {\n    let sum = 0;\n    for (let j = 0; j < rank; ++j) {\n      sum += mat[matrixStride * j + i] * vec[j];\n    }\n    out[i] = sum;\n  }\n  return out;\n}\n\nexport function permuteRows<\n  Output extends TypedArray,\n  Input extends TypedArray,\n>(\n  output: Output,\n  outputStride: number,\n  input: Input,\n  inputStride: number,\n  outputToInputRow: ReadonlyArray<number>,\n  cols: number,\n) {\n  const rows = outputToInputRow.length;\n  for (let outRow = 0; outRow < rows; ++outRow) {\n    const inRow = outputToInputRow[outRow];\n    for (let col = 0; col < cols; ++col) {\n      output[col * outputStride + outRow] = input[col * inputStride + inRow];\n    }\n  }\n  return output;\n}\n\nexport function permuteCols<\n  Output extends TypedArray,\n  Input extends TypedArray,\n>(\n  output: Output,\n  outputStride: number,\n  input: Input,\n  inputStride: number,\n  outputToInputCol: ReadonlyArray<number>,\n  rows: number,\n) {\n  const cols = outputToInputCol.length;\n  for (let outCol = 0; outCol < cols; ++outCol) {\n    const inCol = outputToInputCol[outCol];\n    for (let row = 0; row < rows; ++row) {\n      output[outCol * outputStride + row] = input[inCol * inputStride + row];\n    }\n  }\n  return output;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Simple signal dispatch mechanism.\n */\n\n/**\n * This class provides a simple signal dispatch mechanism.  Handlers can be added, and then the\n * `dispatch` method calls all of them.\n *\n * If specified, Callable should be an interface containing only a callable signature returning\n * void.  Due to limitations in TypeScript, any interface containing a callable signature will be\n * accepted by the compiler, but the resultant signature of `dispatch` will not be correct.\n */\nexport class Signal<Callable extends Function = () => void> {\n  private handlers = new Set<Callable>();\n\n  /**\n   * Count of number of times this signal has been dispatched.  This is incremented each time\n   * `dispatch` is called prior to invoking the handlers.\n   */\n  count = 0;\n\n  constructor() {\n    const obj = this;\n    this.dispatch = <Callable>(<Function>function (this: any) {\n      ++obj.count;\n      obj.handlers.forEach((handler) => {\n        // eslint-disable-next-line prefer-rest-params\n        handler.apply(this, arguments);\n      });\n    });\n  }\n\n  /**\n   * Add a handler function.  If `dispatch` is currently be called, then the new handler will be\n   * called before `dispatch` returns.\n   *\n   * @param handler The handler function to add.\n   *\n   * @return A function that unregisters the handler.\n   */\n  add(handler: Callable): () => boolean {\n    this.handlers.add(handler);\n    return () => {\n      return this.remove(handler);\n    };\n  }\n\n  addOnce(handler: Callable): void {\n    const { handlers } = this;\n    function onceWrapper(...args: any) {\n      handlers.delete(onceWrapper as any);\n      handler(...args);\n    }\n    handlers.add(onceWrapper as any);\n  }\n\n  /**\n   * Remove a handler function.  If `dispatch` is currently be called and the new handler has not\n   * yet been called, then it will not be called.\n   *\n   * @param handler Handler to remove.\n   * @return `true` if the handler was present, `false` otherwise.\n   */\n  remove(handler: Callable): boolean {\n    return this.handlers.delete(handler);\n  }\n\n  /**\n   * Invokes each handler function with the same parameters (including `this`) with which it is\n   * called.  Handlers are invoked in the order in which they were added.\n   */\n  dispatch: Callable;\n\n  /**\n   * Disposes of resources.  No methods, including `dispatch`, may be invoked afterwards.\n   */\n  dispose() {\n    this.handlers = <any>undefined;\n  }\n}\n\nexport function observeSignal(\n  callback: () => void,\n  ...signals: {\n    add(callback: () => void): void;\n    remove(callback: () => void): void;\n  }[]\n) {\n  callback();\n  for (let i = 0, count = signals.length; i < count; ++i) {\n    signals[i].add(callback);\n  }\n  return () => {\n    for (let i = 0, count = signals.length; i < count; ++i) {\n      signals[i].remove(callback);\n    }\n  };\n}\n\n/**\n * Simple specialization of Signal for the common case of a nullary handler signature.\n */\nexport class NullarySignal extends Signal<() => void> {}\n\n/**\n * Interface for a signal excluding the dispatch method.\n *\n * Unlike Signal, this interface is covariant in the type of Callable.\n */\nexport interface ReadonlySignal<Callable extends Function> {\n  readonly count: number;\n  add(handler: Callable): () => void;\n  addOnce(handler: Callable): void;\n  remove(handler: Callable): boolean;\n}\n\nexport type NullaryReadonlySignal = ReadonlySignal<() => void>;\n\nexport const neverSignal: NullaryReadonlySignal = {\n  count: 0,\n  add(_handler: any) {\n    return () => {};\n  },\n  addOnce(_handler: any) {},\n  remove(_handler: any) {\n    return false;\n  },\n};\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { RawPartitionedMeshData, RawMeshData } from \"#src/mesh/backend.js\";\n\nlet decodeResult: RawPartitionedMeshData | Error | undefined = undefined;\nlet numPartitions = 0;\n\nlet wasmModule: WebAssembly.Instance | undefined;\n\nconst libraryEnv = {\n  emscripten_notify_memory_growth: (memoryIndex: number) => {\n    memoryIndex;\n  },\n  neuroglancer_draco_receive_decoded_mesh: (\n    numFaces: number,\n    numVertices: number,\n    indicesPointer: number,\n    vertexPositionsPointer: number,\n    subchunkOffsetsPointer: number,\n  ) => {\n    const numIndices = numFaces * 3;\n    const memory = wasmModule!.exports.memory as WebAssembly.Memory;\n    const indices = new Uint32Array(\n      memory.buffer,\n      indicesPointer,\n      numIndices,\n    ).slice();\n    const vertexPositions = new Uint32Array(\n      memory.buffer,\n      vertexPositionsPointer,\n      3 * numVertices,\n    ).slice();\n    const subChunkOffsets = new Uint32Array(\n      memory.buffer,\n      subchunkOffsetsPointer,\n      numPartitions + 1,\n    ).slice();\n    const mesh: RawPartitionedMeshData = {\n      indices,\n      vertexPositions,\n      subChunkOffsets,\n    };\n    decodeResult = mesh;\n  },\n  proc_exit: (code: number) => {\n    throw `proc exit: ${code}`;\n  },\n};\nlet dracoModulePromise: Promise<WebAssembly.Instance> | undefined;\n\nfunction getDracoModulePromise() {\n  if (dracoModulePromise == undefined) {\n    dracoModulePromise = (async () => {\n      const m = (wasmModule = (\n        await WebAssembly.instantiateStreaming(\n          fetch(new URL(\"./neuroglancer_draco.wasm\", import.meta.url)),\n          {\n            env: libraryEnv,\n            wasi_snapshot_preview1: libraryEnv,\n          },\n        )\n      ).instance);\n      (m.exports._initialize as Function)();\n      return m;\n    })();\n  }\n  return dracoModulePromise;\n}\n\nexport async function decodeDracoPartitioned(\n  buffer: Uint8Array,\n  vertexQuantizationBits: number,\n  partition: boolean,\n): Promise<RawPartitionedMeshData> {\n  const m = await getDracoModulePromise();\n  const offset = (m.exports.malloc as Function)(buffer.byteLength);\n  const heap = new Uint8Array((m.exports.memory as WebAssembly.Memory).buffer);\n  heap.set(buffer, offset);\n  numPartitions = partition ? 8 : 1;\n  const code = (m.exports.neuroglancer_draco_decode as Function)(\n    offset,\n    buffer.byteLength,\n    partition,\n    vertexQuantizationBits,\n    true,\n  );\n  if (code === 0) {\n    const r = decodeResult;\n    decodeResult = undefined;\n    if (r instanceof Error) throw r;\n    return r!;\n  }\n  throw new Error(`Failed to decode draco mesh: ${code}`);\n}\n\nexport async function decodeDraco(buffer: Uint8Array): Promise<RawMeshData> {\n  const m = await getDracoModulePromise();\n  const offset = (m.exports.malloc as Function)(buffer.byteLength);\n  const heap = new Uint8Array((m.exports.memory as WebAssembly.Memory).buffer);\n  heap.set(buffer, offset);\n  const code = (m.exports.neuroglancer_draco_decode as Function)(\n    offset,\n    buffer.byteLength,\n    false,\n    0,\n    false,\n  );\n  if (code === 0) {\n    const r = decodeResult;\n    decodeResult = undefined;\n    if (r instanceof Error) throw r;\n    r!.vertexPositions = new Float32Array(r!.vertexPositions.buffer);\n    return r!;\n  }\n  throw new Error(`Failed to decode draco mesh: ${code}`);\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Generic facility for providing authentication/authorization credentials.\n */\n\nimport type { OAuth2Credentials } from \"#src/credentials_provider/oauth2.js\";\nimport { raceWithAbort, SharedAbortController } from \"#src/util/abort.js\";\nimport type { Owned } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport type { HttpError } from \"#src/util/http_request.js\";\nimport { StringMemoize } from \"#src/util/memoize.js\";\n\n/**\n * Wraps an arbitrary JSON credentials object with a generation number.\n *\n * The generation number is used for tracking whether the credentials have been updated/renewed.\n */\nexport interface CredentialsWithGeneration<T> {\n  generation: number;\n  credentials: T;\n}\n\nexport abstract class CredentialsProvider<Credentials> extends RefCounted {\n  /**\n   * Request valid credentials.  If `invalidCredentials` is specified, it indicates that the\n   * specified credentials are invalid.\n   *\n   * This method can be conveniently defined using the `makeCredentialsGetter` function.\n   */\n  abstract get: (\n    invalidCredentials?: CredentialsWithGeneration<Credentials>,\n    abortSignal?: AbortSignal | undefined,\n  ) => Promise<CredentialsWithGeneration<Credentials>>;\n\n  errorHandler? = async (\n    error: HttpError,\n    credentials: OAuth2Credentials,\n  ): Promise<\"refresh\"> => {\n    const { status } = error;\n    if (status === 401) {\n      // 401: Authorization needed.  OAuth2 token may have expired.\n      return \"refresh\";\n    }\n    if (status === 403 && !credentials.accessToken) {\n      // Anonymous access denied.  Request credentials.\n      return \"refresh\";\n    }\n    if (error instanceof Error && credentials.email !== undefined) {\n      error.message += `  (Using credentials for ${JSON.stringify(\n        credentials.email,\n      )})`;\n    }\n    throw error;\n  };\n}\n\nexport function makeCachedCredentialsGetter<Credentials>(\n  getUncached: (\n    invalidCredentials: CredentialsWithGeneration<Credentials> | undefined,\n    abortSignal: AbortSignal,\n  ) => Promise<CredentialsWithGeneration<Credentials>>,\n) {\n  let cachedCredentials: CredentialsWithGeneration<Credentials> | undefined;\n  let pendingCredentials:\n    | Promise<CredentialsWithGeneration<Credentials>>\n    | undefined;\n  let pendingAbortController: SharedAbortController | undefined;\n  return (\n    invalidCredentials?: CredentialsWithGeneration<Credentials>,\n    abortSignal?: AbortSignal,\n  ) => {\n    if (\n      pendingCredentials !== undefined &&\n      (cachedCredentials === undefined ||\n        invalidCredentials === undefined ||\n        cachedCredentials.generation !== invalidCredentials.generation)\n    ) {\n      if (cachedCredentials === undefined) {\n        pendingAbortController!.addConsumer(abortSignal);\n      }\n      return raceWithAbort(pendingCredentials, abortSignal);\n    }\n    cachedCredentials = undefined;\n    pendingAbortController = new SharedAbortController();\n    pendingCredentials = getUncached(\n      invalidCredentials,\n      pendingAbortController.signal,\n    ).then(\n      (credentials) => {\n        cachedCredentials = credentials;\n        pendingAbortController![Symbol.dispose]();\n        pendingAbortController = undefined;\n        return credentials;\n      },\n      (reason) => {\n        pendingAbortController![Symbol.dispose]();\n        if (pendingAbortController?.signal.aborted) {\n          pendingAbortController = undefined;\n          pendingCredentials = undefined;\n        }\n        throw reason;\n      },\n    );\n    return pendingCredentials;\n  };\n}\n\nexport function makeCredentialsGetter<Credentials>(\n  getWithoutGeneration: (abortSignal: AbortSignal) => Promise<Credentials>,\n) {\n  let generation = 0;\n  return makeCachedCredentialsGetter<Credentials>(\n    (_invalidCredentials, abortSignal) =>\n      getWithoutGeneration(abortSignal).then((credentials) => ({\n        generation: ++generation,\n        credentials,\n      })),\n  );\n}\n\n/**\n * Interface for obtaining a CredentialsProvider based on a string key.\n */\nexport interface CredentialsManager {\n  getCredentialsProvider<Credentials>(\n    key: string,\n    parameters?: any,\n  ): Owned<CredentialsProvider<Credentials>>;\n}\n\nexport type ProviderGetter<Credentials> = (\n  parameters: any,\n  credentialsManager: CredentialsManager,\n) => Owned<CredentialsProvider<Credentials>>;\n\n/**\n * CredentialsManager that supports registration.\n */\nexport class MapBasedCredentialsManager implements CredentialsManager {\n  providers = new Map<\n    string,\n    (\n      parameters: any,\n      credentialsManager: CredentialsManager,\n    ) => Owned<CredentialsProvider<any>>\n  >();\n  topLevelManager: CredentialsManager = this;\n  register<Credentials>(\n    key: string,\n    providerGetter: ProviderGetter<Credentials>,\n  ) {\n    this.providers.set(key, providerGetter);\n  }\n\n  getCredentialsProvider<Credentials>(\n    key: string,\n    parameters?: any,\n  ): Owned<CredentialsProvider<Credentials>> {\n    const getter = this.providers.get(key);\n    if (getter === undefined) {\n      throw new Error(\n        `No registered credentials provider: ${JSON.stringify(key)}`,\n      );\n    }\n    return getter(parameters, this.topLevelManager);\n  }\n}\n\n/**\n * CredentialsManager that wraps another and caches the CredentialsProvider objects.\n */\nexport class CachingCredentialsManager<Base extends CredentialsManager>\n  extends RefCounted\n  implements CredentialsManager\n{\n  memoize = new StringMemoize();\n\n  constructor(public base: Base) {\n    super();\n  }\n\n  getCredentialsProvider<Credentials>(\n    key: string,\n    parameters?: any,\n  ): Owned<CredentialsProvider<Credentials>> {\n    return this.memoize.get({ key, parameters }, () =>\n      this.registerDisposer(\n        this.base.getCredentialsProvider<Credentials>(key, parameters).addRef(),\n      ),\n    );\n  }\n}\n\nexport class CachingMapBasedCredentialsManager extends CachingCredentialsManager<MapBasedCredentialsManager> {\n  constructor() {\n    super(new MapBasedCredentialsManager());\n    this.base.topLevelManager = this;\n  }\n\n  register<Credentials>(\n    key: string,\n    providerGetter: ProviderGetter<Credentials>,\n  ) {\n    this.base.register(key, providerGetter);\n  }\n}\n\nexport type MaybeOptionalCredentialsProvider<T> = T extends undefined\n  ? undefined\n  : CredentialsProvider<Exclude<T, undefined>>;\n\nexport class AnonymousFirstCredentialsProvider<\n  T,\n> extends CredentialsProvider<T> {\n  private anonymous = true;\n  constructor(\n    private baseProvider: CredentialsProvider<T>,\n    private anonymousCredentials: T,\n  ) {\n    super();\n  }\n\n  get = makeCachedCredentialsGetter(\n    (invalidCredentials?: CredentialsWithGeneration<T>) => {\n      if (this.anonymous && invalidCredentials === undefined) {\n        return Promise.resolve({\n          generation: -10,\n          credentials: this.anonymousCredentials,\n        });\n      }\n      this.anonymous = false;\n      return this.baseProvider.get(invalidCredentials);\n    },\n  );\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum ChunkState {\n  // Chunk is stored in GPU memory in addition to system memory.\n  GPU_MEMORY = 0,\n  // Chunk is stored only in system memory but not in GPU memory.\n  SYSTEM_MEMORY = 1,\n\n  // Chunk is stored in system memory on worker.\n  SYSTEM_MEMORY_WORKER = 2,\n\n  // Chunk is downloading.\n  DOWNLOADING = 3,\n  // Chunk is not yet downloading.\n  QUEUED = 4,\n\n  // Chunk has just been added.\n  NEW = 5,\n\n  // Download failed.\n  FAILED = 6,\n\n  EXPIRED = 7,\n\n  // If new states are added, keep numChangeStates in sync.\n}\n\nexport const numChunkStates = 8;\n\nexport enum ChunkPriorityTier {\n  FIRST_TIER = 0,\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  FIRST_ORDERED_TIER = 0,\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  VISIBLE = 0,\n  PREFETCH = 1,\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  LAST_ORDERED_TIER = 1,\n  RECENT = 2,\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  LAST_TIER = 2,\n}\n\nexport const numChunkPriorityTiers = 3;\n\nexport enum ChunkDownloadStatistics {\n  totalTime = 0,\n  totalChunks = 1,\n}\n\nexport enum ChunkMemoryStatistics {\n  numChunks = 0,\n  systemMemoryBytes = 1,\n  gpuMemoryBytes = 2,\n}\n\nexport const numChunkMemoryStatistics = 3;\n\nexport const numChunkDownloadStatistics = 2;\n\nexport const numChunkStatistics =\n  numChunkStates * numChunkPriorityTiers * numChunkMemoryStatistics +\n  numChunkDownloadStatistics;\n\nexport function getChunkStateStatisticIndex(\n  state: ChunkState,\n  priorityTier: ChunkPriorityTier,\n) {\n  return state * numChunkPriorityTiers + priorityTier;\n}\n\nexport function getChunkDownloadStatisticIndex(\n  statistic: ChunkDownloadStatistics,\n) {\n  return (\n    numChunkStates * numChunkPriorityTiers * numChunkMemoryStatistics +\n    statistic\n  );\n}\n\nexport const PREFETCH_PRIORITY_MULTIPLIER = 1e13;\n\nexport const CHUNK_QUEUE_MANAGER_RPC_ID = \"ChunkQueueManager\";\nexport const CHUNK_MANAGER_RPC_ID = \"ChunkManager\";\nexport const CHUNK_SOURCE_INVALIDATE_RPC_ID = \"ChunkSource.invalidate\";\n\nexport const REQUEST_CHUNK_STATISTICS_RPC_ID =\n  \"ChunkQueueManager.requestChunkStatistics\";\n\n// Used for sending per-layer visible/prefetch chunk statistics from backend to frontend.\nexport const CHUNK_LAYER_STATISTICS_RPC_ID =\n  \"ChunkManager.chunkLayerStatistics\";\n\nexport interface ChunkSourceParametersConstructor<T> {\n  new (): T;\n  RPC_ID: string;\n}\n\nexport class LayerChunkProgressInfo {\n  numVisibleChunksNeeded = 0;\n  numVisibleChunksAvailable = 0;\n  numPrefetchChunksNeeded = 0;\n  numPrefetchChunksAvailable = 0;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  CoordinateSpace,\n  DimensionId,\n} from \"#src/coordinate_transform.js\";\nimport {\n  clampAndRoundCoordinateToVoxelCenter,\n  dimensionNamesFromJson,\n  emptyInvalidCoordinateSpace,\n  getBoundingBoxCenter,\n  getCenterBound,\n} from \"#src/coordinate_transform.js\";\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { arraysEqual } from \"#src/util/array.js\";\nimport type { Borrowed, Owned } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { mat3, mat4, quat, vec3 } from \"#src/util/geom.js\";\nimport {\n  parseArray,\n  parseFiniteVec,\n  verifyBoolean,\n  verifyEnumString,\n  verifyFiniteFloat,\n  verifyFinitePositiveFloat,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalObjectProperty,\n} from \"#src/util/json.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\nimport type { Trackable } from \"#src/util/trackable.js\";\nimport { optionallyRestoreFromJsonMember } from \"#src/util/trackable.js\";\nimport { TrackableEnum } from \"#src/util/trackable_enum.js\";\nimport * as vector from \"#src/util/vector.js\";\n\nexport enum NavigationLinkType {\n  LINKED = 0,\n  RELATIVE = 1,\n  UNLINKED = 2,\n}\n\nexport enum NavigationSimpleLinkType {\n  LINKED = 0,\n  UNLINKED = 2,\n}\n\nexport class TrackableNavigationLink extends TrackableEnum<NavigationLinkType> {\n  constructor(value = NavigationLinkType.LINKED) {\n    super(NavigationLinkType, value);\n  }\n}\n\nexport class TrackableNavigationSimpleLink extends TrackableEnum<NavigationSimpleLinkType> {\n  constructor(value = NavigationSimpleLinkType.LINKED) {\n    super(NavigationSimpleLinkType, value);\n  }\n}\n\nconst tempVec3 = vec3.create();\nconst tempQuat = quat.create();\n\nfunction makeLinked<\n  T extends RefCounted & { changed: NullarySignal },\n  Difference,\n>(\n  self: T,\n  peer: T,\n  link: TrackableNavigationLink,\n  operations: {\n    assign: (target: T, source: T) => void;\n    isValid: (a: T) => boolean;\n    difference: (a: T, b: T) => Difference;\n    add: (target: T, source: T, amount: Difference) => void;\n    subtract: (target: T, source: T, amount: Difference) => void;\n  },\n): T {\n  let updatingSelf = false;\n  const updatingPeer = false;\n  let selfMinusPeer: Difference | undefined;\n  self.registerDisposer(peer);\n  const handlePeerUpdate = () => {\n    if (updatingPeer) {\n      return;\n    }\n    updatingSelf = true;\n    switch (link.value) {\n      case NavigationLinkType.UNLINKED:\n        if (operations.isValid(self)) {\n          break;\n        }\n      // fallthrough\n      case NavigationLinkType.LINKED:\n        operations.assign(self, peer);\n        break;\n      case NavigationLinkType.RELATIVE:\n        operations.add(self, peer, selfMinusPeer!);\n        break;\n    }\n    updatingSelf = false;\n  };\n  const handleSelfUpdate = () => {\n    if (updatingSelf) {\n      return;\n    }\n    switch (link.value) {\n      case NavigationLinkType.UNLINKED:\n        break;\n      case NavigationLinkType.LINKED:\n        operations.assign(peer, self);\n        break;\n      case NavigationLinkType.RELATIVE:\n        operations.subtract(peer, self, selfMinusPeer!);\n        break;\n    }\n  };\n  let previousLinkValue = NavigationLinkType.UNLINKED;\n  const handleLinkUpdate = () => {\n    const linkValue = link.value;\n    if (linkValue !== previousLinkValue) {\n      switch (linkValue) {\n        case NavigationLinkType.UNLINKED:\n          selfMinusPeer = undefined;\n          break;\n        case NavigationLinkType.LINKED:\n          selfMinusPeer = undefined;\n          operations.assign(self, peer);\n          break;\n        case NavigationLinkType.RELATIVE:\n          selfMinusPeer = operations.difference(self, peer);\n          break;\n      }\n    }\n    previousLinkValue = linkValue;\n    self.changed.dispatch();\n  };\n  self.registerDisposer(self.changed.add(handleSelfUpdate));\n  self.registerDisposer(peer.changed.add(handlePeerUpdate));\n  self.registerDisposer(link.changed.add(handleLinkUpdate));\n  handleLinkUpdate();\n  return self;\n}\n\nfunction makeSimpleLinked<T extends RefCounted & { changed: NullarySignal }>(\n  self: T,\n  peer: T,\n  link: TrackableNavigationSimpleLink,\n  operations: {\n    assign: (target: T, source: T) => void;\n    isValid: (a: T) => boolean;\n  },\n) {\n  return makeLinked(self, peer, link as any, operations as any);\n}\n\nexport class Position extends RefCounted {\n  private coordinates_: Float32Array = vector.kEmptyFloat32Vec;\n  private curCoordinateSpace: CoordinateSpace | undefined;\n  changed = new NullarySignal();\n  constructor(\n    public coordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  ) {\n    super();\n    this.registerDisposer(\n      coordinateSpace.changed.add(() => {\n        this.handleCoordinateSpaceChanged();\n      }),\n    );\n  }\n\n  get valid() {\n    return this.coordinateSpace.value.valid;\n  }\n\n  /**\n   * Returns the position in voxels.\n   */\n  get value() {\n    this.handleCoordinateSpaceChanged();\n    return this.coordinates_;\n  }\n\n  reset() {\n    this.curCoordinateSpace = undefined;\n    this.coordinates_ = vector.kEmptyFloat32Vec;\n    this.changed.dispatch();\n  }\n\n  set value(coordinates: Float32Array) {\n    const { curCoordinateSpace } = this;\n    if (\n      curCoordinateSpace === undefined ||\n      !curCoordinateSpace.valid ||\n      curCoordinateSpace.rank !== coordinates.length\n    ) {\n      return;\n    }\n    const { coordinates_ } = this;\n    coordinates_.set(coordinates);\n    this.changed.dispatch();\n  }\n\n  private handleCoordinateSpaceChanged() {\n    const coordinateSpace = this.coordinateSpace.value;\n    const prevCoordinateSpace = this.curCoordinateSpace;\n    if (coordinateSpace === prevCoordinateSpace) return;\n    this.curCoordinateSpace = coordinateSpace;\n    const { rank } = coordinateSpace;\n    if (!coordinateSpace.valid) return;\n    if (prevCoordinateSpace === undefined || !prevCoordinateSpace.valid) {\n      let { coordinates_ } = this;\n      if (coordinates_ !== undefined && coordinates_.length === rank) {\n        // Use the existing voxel coordinates if rank is the same.  Otherwise, ignore.\n      } else {\n        coordinates_ = this.coordinates_ = new Float32Array(rank);\n        getBoundingBoxCenter(coordinates_, coordinateSpace.bounds);\n        const { voxelCenterAtIntegerCoordinates } = coordinateSpace.bounds;\n        for (let i = 0; i < rank; ++i) {\n          if (voxelCenterAtIntegerCoordinates[i]) {\n            coordinates_[i] = Math.round(coordinates_[i]);\n          } else {\n            coordinates_[i] = Math.floor(coordinates_[i]) + 0.5;\n          }\n        }\n      }\n      this.changed.dispatch();\n      return;\n    }\n    // Match dimensions by ID.\n    const newCoordinates = new Float32Array(rank);\n    const prevCoordinates = this.coordinates_;\n    const { ids, scales: newScales } = coordinateSpace;\n    const { ids: prevDimensionIds, scales: oldScales } = prevCoordinateSpace;\n    for (let newDim = 0; newDim < rank; ++newDim) {\n      const newDimId = ids[newDim];\n      const oldDim = prevDimensionIds.indexOf(newDimId);\n      if (oldDim === -1) {\n        newCoordinates[newDim] = getCenterBound(\n          coordinateSpace.bounds.lowerBounds[newDim],\n          coordinateSpace.bounds.upperBounds[newDim],\n        );\n      } else {\n        newCoordinates[newDim] =\n          prevCoordinates[oldDim] * (oldScales[oldDim] / newScales[newDim]);\n      }\n    }\n    this.coordinates_ = newCoordinates;\n    this.changed.dispatch();\n  }\n\n  toJSON() {\n    if (!this.valid && this.coordinates_.length === 0) return undefined;\n    this.handleCoordinateSpaceChanged();\n    const { value } = this;\n    if (value.length === 0) return undefined;\n    return Array.from(value);\n  }\n\n  restoreState(obj: any) {\n    if (obj === undefined) {\n      this.reset();\n      return;\n    }\n    this.curCoordinateSpace = undefined;\n    this.coordinates_ = Float32Array.from(parseArray(obj, verifyFiniteFloat));\n    this.handleCoordinateSpaceChanged();\n    this.changed.dispatch();\n  }\n\n  snapToVoxel() {\n    this.handleCoordinateSpaceChanged();\n    const {\n      bounds: { voxelCenterAtIntegerCoordinates },\n    } = this.coordinateSpace.value;\n    const { coordinates_ } = this;\n    const rank = coordinates_.length;\n    for (let i = 0; i < rank; ++i) {\n      if (voxelCenterAtIntegerCoordinates[i]) {\n        coordinates_[i] = Math.round(coordinates_[i]);\n      } else {\n        coordinates_[i] = Math.floor(coordinates_[i]) + 0.5;\n      }\n    }\n    this.changed.dispatch();\n  }\n\n  assign(other: Borrowed<Position>) {\n    other.handleCoordinateSpaceChanged();\n    const { curCoordinateSpace, coordinates_ } = other;\n    this.curCoordinateSpace = curCoordinateSpace;\n    this.coordinates_ = Float32Array.from(coordinates_);\n    this.changed.dispatch();\n  }\n\n  /**\n   * Get the offset of `a` relative to `b`.\n   */\n  static getOffset(a: Position, b: Position): Float32Array | undefined {\n    const aCoordinates = a.coordinates_;\n    const bCoordinates = b.coordinates_;\n    const rank = aCoordinates.length;\n    if (rank === bCoordinates.length) {\n      return vector.subtract(\n        new Float32Array(aCoordinates.length),\n        aCoordinates,\n        bCoordinates,\n      );\n    }\n    return undefined;\n  }\n  static addOffset(\n    target: Position,\n    source: Position,\n    offset: Float32Array | undefined,\n    scale = 1,\n  ): void {\n    target.handleCoordinateSpaceChanged();\n    const { value: sourceCoordinates } = source;\n    if (offset !== undefined && sourceCoordinates.length === offset.length) {\n      vector.scaleAndAdd(target.value, sourceCoordinates, offset, scale);\n      target.changed.dispatch();\n    }\n  }\n\n  get legacyJsonView() {\n    const self = this;\n    return {\n      changed: self.changed,\n      toJSON() {\n        return self.toJSON();\n      },\n      reset() {\n        self.reset();\n      },\n      restoreState(obj: unknown) {\n        if (obj === undefined || Array.isArray(obj)) {\n          self.restoreState(obj);\n          return;\n        }\n        verifyObject(obj);\n        optionallyRestoreFromJsonMember(obj, \"voxelCoordinates\", self);\n      },\n    };\n  }\n}\n\nexport enum VelocityBoundaryBehavior {\n  STOP = 0,\n  LOOP = 1,\n  REVERSE = 2,\n}\n\nexport const DEFAULT_PLAYBACK_VELOCITY = 10;\n\nexport class DimensionPlaybackVelocity {\n  // Velocity in global coordinates per second.\n  velocity: number = DEFAULT_PLAYBACK_VELOCITY;\n  atBoundary: VelocityBoundaryBehavior = VelocityBoundaryBehavior.REVERSE;\n  paused = true;\n}\n\nexport function dimensionVelocitiesEqual(\n  a: DimensionPlaybackVelocity,\n  b: DimensionPlaybackVelocity,\n): boolean {\n  return (\n    a.velocity === b.velocity &&\n    a.atBoundary === b.atBoundary &&\n    a.paused === b.paused\n  );\n}\n\nfunction dimensionVelocityFromJson(obj: unknown) {\n  verifyObject(obj);\n  return {\n    velocity: verifyOptionalObjectProperty(\n      obj,\n      \"velocity\",\n      verifyFiniteFloat,\n      DEFAULT_PLAYBACK_VELOCITY,\n    ),\n    atBoundary: verifyOptionalObjectProperty(\n      obj,\n      \"atBoundary\",\n      (value) => verifyEnumString(value, VelocityBoundaryBehavior),\n      VelocityBoundaryBehavior.STOP,\n    ),\n    paused: verifyOptionalObjectProperty(obj, \"paused\", verifyBoolean, true),\n  };\n}\n\nfunction dimensionVelocityToJson(info: DimensionPlaybackVelocity) {\n  const { velocity, atBoundary, paused } = info;\n  return {\n    velocity: velocity,\n    atBoundary:\n      atBoundary === VelocityBoundaryBehavior.STOP\n        ? undefined\n        : VelocityBoundaryBehavior[atBoundary].toLowerCase(),\n    paused: paused ? undefined : false,\n  };\n}\n\nexport class CoordinateSpacePlaybackVelocity extends RefCounted {\n  private velocities_: (Readonly<DimensionPlaybackVelocity> | undefined)[];\n  private curCoordinateSpace: CoordinateSpace | undefined;\n  changed = new NullarySignal();\n  constructor(\n    public coordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  ) {\n    super();\n    this.registerDisposer(\n      coordinateSpace.changed.add(() => {\n        this.handleCoordinateSpaceChanged();\n      }),\n    );\n    this.curCoordinateSpace = coordinateSpace.value;\n    this.velocities_ = new Array(this.curCoordinateSpace?.rank ?? 0);\n  }\n\n  get valid() {\n    return this.coordinateSpace.value.valid;\n  }\n\n  get value(): (Readonly<DimensionPlaybackVelocity> | undefined)[] {\n    this.handleCoordinateSpaceChanged();\n    return this.velocities_;\n  }\n\n  set value(velocities: (Readonly<DimensionPlaybackVelocity> | undefined)[]) {\n    const { curCoordinateSpace } = this;\n    if (\n      curCoordinateSpace === undefined ||\n      curCoordinateSpace.rank !== velocities.length\n    ) {\n      return;\n    }\n    this.velocities_ = velocities;\n    this.changed.dispatch();\n  }\n\n  get(id: DimensionId): DimensionPlaybackVelocity | undefined {\n    const ids = this.coordinateSpace.value?.ids;\n    if (ids === undefined) return;\n    const index = ids.indexOf(id);\n    if (index === -1) return;\n    const velocities = this.value;\n    return velocities[index];\n  }\n\n  dimensionVelocity(\n    owner: RefCounted,\n    id: DimensionId,\n  ): WatchableValueInterface<DimensionPlaybackVelocity | undefined> {\n    const changed = new NullarySignal();\n    let index = -1;\n    const updateIndex = () => {\n      const ids = this.coordinateSpace.value?.ids;\n      if (ids === undefined) {\n        index = -1;\n      } else if (index === -1 || ids[index] !== id) {\n        index = ids.indexOf(id);\n      }\n    };\n    const getVelocity = () => {\n      updateIndex();\n      if (index === -1) return undefined;\n      return this.value[index];\n    };\n    const setVelocity = (\n      newVelocity: Readonly<DimensionPlaybackVelocity> | undefined,\n    ) => {\n      updateIndex();\n      if (index === -1) return;\n      const velocities = this.value;\n      const oldVelocity = velocities[index];\n      if (oldVelocity === newVelocity) return;\n      velocities[index] = newVelocity;\n      this.changed.dispatch();\n    };\n    let prevVelocity = getVelocity();\n    owner.registerDisposer(\n      this.changed.add(() => {\n        const curVelocity = getVelocity();\n        if (curVelocity !== prevVelocity) {\n          prevVelocity = curVelocity;\n          changed.dispatch();\n        }\n      }),\n    );\n    return {\n      get value() {\n        return getVelocity();\n      },\n      set value(newVelocity: Readonly<DimensionPlaybackVelocity> | undefined) {\n        setVelocity(newVelocity);\n      },\n      changed,\n    };\n  }\n\n  modifyDimension(\n    id: DimensionId,\n    callback: (\n      oldInfo: DimensionPlaybackVelocity | undefined,\n    ) => DimensionPlaybackVelocity | undefined,\n  ) {\n    const ids = this.coordinateSpace.value?.ids;\n    if (ids === undefined) return;\n    const index = ids.indexOf(id);\n    if (index === -1) return;\n    const velocities = this.value;\n    const oldInfo = velocities[index];\n    const newInfo = callback(oldInfo);\n    if (oldInfo === newInfo) return;\n    velocities[index] = newInfo;\n    this.changed.dispatch();\n  }\n\n  togglePlayback(id: DimensionId, newValue: boolean | undefined = undefined) {\n    this.modifyDimension(id, (oldInfo = new DimensionPlaybackVelocity()) => {\n      return { ...oldInfo, paused: newValue ?? !oldInfo.paused };\n    });\n  }\n\n  playbackEnabled(id: DimensionId): WatchableValueInterface<boolean> {\n    const self = this;\n    return {\n      changed: this.changed,\n      get value() {\n        return self.get(id) !== undefined;\n      },\n      set value(enabled: boolean) {\n        self.modifyDimension(id, (oldInfo) =>\n          enabled ? (oldInfo ?? new DimensionPlaybackVelocity()) : undefined,\n        );\n      },\n    };\n  }\n\n  multiplyVelocity(id: DimensionId, factor: number) {\n    this.modifyDimension(id, (oldInfo = new DimensionPlaybackVelocity()) => {\n      let newVelocity = Math.round(oldInfo.velocity * factor);\n      if (newVelocity === 0) {\n        newVelocity = Math.sign(oldInfo.velocity) || 1;\n      }\n      return { ...oldInfo, velocity: newVelocity };\n    });\n  }\n\n  private handleCoordinateSpaceChanged() {\n    const coordinateSpace = this.coordinateSpace.value;\n    const prevCoordinateSpace = this.curCoordinateSpace;\n    if (coordinateSpace === prevCoordinateSpace) return;\n    this.curCoordinateSpace = coordinateSpace;\n    const { rank } = coordinateSpace;\n    if (!coordinateSpace.valid) return;\n    if (prevCoordinateSpace === undefined) {\n      let { velocities_ } = this;\n      if (velocities_.length === rank) {\n        // Use the existing velocities if rank is the same.  Otherwise, ignore.\n      } else {\n        velocities_ = new Array<\n          Readonly<DimensionPlaybackVelocity> | undefined\n        >(rank);\n      }\n      this.changed.dispatch();\n      return;\n    }\n    // Match dimensions by ID.\n    const newVelocities = new Array<\n      Readonly<DimensionPlaybackVelocity> | undefined\n    >(rank);\n    const prevVelocities = this.velocities_;\n    const { ids } = coordinateSpace;\n    const { ids: prevDimensionIds } = prevCoordinateSpace;\n    for (let newDim = 0; newDim < rank; ++newDim) {\n      const newDimId = ids[newDim];\n      const oldDim = prevDimensionIds.indexOf(newDimId);\n      if (oldDim !== -1) {\n        newVelocities[newDim] = prevVelocities[oldDim];\n      }\n    }\n    this.velocities_ = newVelocities;\n    this.changed.dispatch();\n  }\n\n  toJSON() {\n    this.handleCoordinateSpaceChanged();\n    const { velocities_: velocities, curCoordinateSpace } = this;\n    if (\n      !curCoordinateSpace?.valid ||\n      !velocities.some((velocity) => velocity !== undefined)\n    ) {\n      return undefined;\n    }\n    const obj: Record<string, any> = {};\n    const { names, rank } = curCoordinateSpace;\n    for (let i = 0; i < rank; ++i) {\n      const info = velocities[i];\n      if (info === undefined) continue;\n      obj[names[i]] = dimensionVelocityToJson(info);\n    }\n    return obj;\n  }\n\n  reset() {\n    this.handleCoordinateSpaceChanged();\n    this.velocities_ = new Array(this.curCoordinateSpace?.rank ?? 0);\n  }\n\n  restoreState(obj: any) {\n    if (obj === undefined) {\n      this.reset();\n      return;\n    }\n    verifyObject(obj);\n    const curCoordinateSpace = (this.curCoordinateSpace =\n      this.coordinateSpace.value);\n    this.velocities_ = new Array(curCoordinateSpace?.rank ?? 0);\n    if (curCoordinateSpace === undefined) {\n      throw new Error(\"Must specify dimensions in order to specify velocities\");\n    }\n    const velocities = (this.velocities_ = new Array(\n      curCoordinateSpace?.rank ?? 0,\n    ));\n    const { names } = curCoordinateSpace;\n    for (const key of Object.keys(obj)) {\n      const i = names.indexOf(key);\n      if (i === -1) {\n        throw new Error(`Invalid dimension name: ${JSON.stringify(key)}`);\n      }\n      velocities[i] = verifyObjectProperty(obj, key, dimensionVelocityFromJson);\n    }\n    this.changed.dispatch();\n  }\n\n  assign(other: Borrowed<CoordinateSpacePlaybackVelocity>) {\n    const otherVelocities = other.value;\n    const velocities = this.value;\n    const rank = velocities.length;\n    let changed = false;\n    for (let i = 0; i < rank; ++i) {\n      const newVelocity = otherVelocities[i];\n      const curVelocity = velocities[i];\n      if (newVelocity !== curVelocity) {\n        if (\n          curVelocity === undefined ||\n          newVelocity === undefined ||\n          !dimensionVelocitiesEqual(curVelocity, newVelocity)\n        ) {\n          changed = true;\n        }\n        velocities[i] = newVelocity;\n      }\n    }\n    if (changed) {\n      this.changed.dispatch();\n    }\n  }\n}\n\nexport class LinkedCoordinateSpacePlaybackVelocity extends RefCounted {\n  changed = new NullarySignal();\n  velocity: CoordinateSpacePlaybackVelocity;\n\n  constructor(\n    public peer: Owned<CoordinateSpacePlaybackVelocity>,\n    public positionLink: TrackableLinkInterface,\n  ) {\n    super();\n    this.velocity = this.registerDisposer(\n      new CoordinateSpacePlaybackVelocity(peer.coordinateSpace),\n    );\n\n    this.registerDisposer(peer);\n    this.velocity.changed.add(() => {\n      if (this.positionLink.value === NavigationLinkType.UNLINKED) {\n        this.changed.dispatch();\n      } else {\n        this.peer.assign(this.velocity);\n      }\n    });\n    const updateSelf = () => {\n      if (this.positionLink.value !== NavigationLinkType.UNLINKED) {\n        this.velocity.assign(this.peer);\n      }\n    };\n    this.registerDisposer(peer.changed.add(updateSelf));\n    updateSelf();\n  }\n\n  toJSON() {\n    if (this.positionLink.value !== NavigationLinkType.UNLINKED) {\n      return undefined;\n    }\n    return this.velocity.toJSON();\n  }\n\n  reset() {\n    if (this.positionLink.value === NavigationLinkType.UNLINKED) {\n      this.velocity.reset();\n    }\n  }\n\n  restoreState(obj: unknown) {\n    if (this.positionLink.value === NavigationLinkType.UNLINKED) {\n      this.velocity.restoreState(obj);\n    }\n  }\n\n  copyToPeer() {\n    if (this.positionLink.value === NavigationLinkType.UNLINKED) {\n      this.peer.assign(this.velocity);\n    }\n  }\n}\n\ninterface DimensionPlaybackState {\n  dimensionIndex: number;\n  prevCoordinate: number;\n  prevTime: number;\n  generation: number;\n}\n\nexport class PlaybackManager extends RefCounted {\n  private dimensionStates = new Map<DimensionId, DimensionPlaybackState>();\n  private lastUpdateGeneration = 0;\n  private unregisterUpdateStartedCallback: (() => void) | undefined;\n\n  constructor(\n    public display: { updateStarted: NullarySignal; scheduleRedraw(): void },\n    public position: Position,\n    public velocity: CoordinateSpacePlaybackVelocity,\n  ) {\n    super();\n    this.handleVelocityChanged();\n    this.registerDisposer(\n      velocity.changed.add(() => this.handleVelocityChanged()),\n    );\n  }\n\n  disposed() {\n    this.unregisterUpdateStartedCallback?.();\n    super.disposed();\n  }\n\n  private handleVelocityChanged() {\n    const { dimensionStates } = this;\n    const ids = this.position.coordinateSpace.value?.ids ?? [];\n    const rank = ids.length;\n    const velocities = this.velocity.value;\n    const generation = ++this.lastUpdateGeneration;\n    const positionVector = this.position.value;\n    const curTime = Date.now();\n    for (let i = 0; i < rank; ++i) {\n      const velocity = velocities[i];\n      if (velocity === undefined) continue;\n      if (velocity.velocity === 0 || velocity.paused) continue;\n      const id = ids[i];\n      const state = dimensionStates.get(id);\n      if (state === undefined) {\n        dimensionStates.set(id, {\n          prevTime: curTime,\n          dimensionIndex: i,\n          prevCoordinate: positionVector[i],\n          generation,\n        });\n      } else {\n        state.generation = generation;\n        state.dimensionIndex = i;\n      }\n    }\n    for (const [id, state] of dimensionStates) {\n      if (state.generation !== generation) {\n        dimensionStates.delete(id);\n      }\n    }\n    if (dimensionStates.size === 0) {\n      const { unregisterUpdateStartedCallback } = this;\n      if (unregisterUpdateStartedCallback !== undefined) {\n        unregisterUpdateStartedCallback();\n        this.unregisterUpdateStartedCallback = undefined;\n      }\n    } else {\n      if (this.unregisterUpdateStartedCallback === undefined) {\n        this.unregisterUpdateStartedCallback = this.display.updateStarted.add(\n          () => this.updateStarted(),\n        );\n        this.display.scheduleRedraw();\n      }\n    }\n  }\n\n  private updateStarted() {\n    const coordinateSpace = this.position.coordinateSpace.value;\n    if (coordinateSpace === undefined) {\n      return;\n    }\n    const ids = coordinateSpace.ids;\n    const positionVector = this.position.value;\n    let positionChanged = false;\n    let velocityChanged = false;\n    const curTime = Date.now();\n    const velocities = this.velocity.value;\n    const {\n      bounds: { lowerBounds, upperBounds },\n    } = coordinateSpace;\n    for (const [id, dimensionState] of this.dimensionStates) {\n      const { dimensionIndex } = dimensionState;\n      if (ids[dimensionIndex] !== id) continue;\n      const velocity = velocities[dimensionIndex];\n      if (\n        Math.floor(positionVector[dimensionIndex]) !==\n        Math.floor(dimensionState.prevCoordinate)\n      ) {\n        // Pause this dimension.\n        if (velocity?.paused === false) {\n          velocities[dimensionIndex] = { ...velocity, paused: true };\n          velocityChanged = true;\n        }\n        continue;\n      }\n      const timeDelta = curTime - dimensionState.prevTime;\n      const velocityValue = velocity?.velocity ?? 0;\n      const delta = (timeDelta * velocityValue) / 1000;\n      if (delta === 0) continue;\n      let newCoordinate = positionVector[dimensionIndex] + delta;\n      const lowerBound = lowerBounds[dimensionIndex];\n      const upperBound = Math.ceil(upperBounds[dimensionIndex] - 1);\n      const limit = delta > 0 ? upperBound : lowerBound;\n      const oppositeLimit = delta > 0 ? lowerBound : upperBound;\n      const deltaSign = Math.sign(delta);\n      if (\n        Number.isFinite(limit) &&\n        newCoordinate * deltaSign >= limit * deltaSign\n      ) {\n        switch (velocity!.atBoundary) {\n          case VelocityBoundaryBehavior.LOOP:\n            if (Number.isFinite(oppositeLimit)) {\n              newCoordinate = oppositeLimit;\n              break;\n            }\n          // fallthrough\n          case VelocityBoundaryBehavior.STOP:\n            velocities[dimensionIndex] = { ...velocity!, paused: true };\n            velocityChanged = true;\n            newCoordinate = limit;\n            break;\n          case VelocityBoundaryBehavior.REVERSE:\n            velocities[dimensionIndex] = {\n              ...velocity!,\n              velocity: -velocityValue,\n            };\n            velocityChanged = true;\n            newCoordinate = limit;\n            break;\n        }\n      }\n      positionVector[dimensionIndex] = newCoordinate;\n      dimensionState.prevCoordinate = positionVector[dimensionIndex];\n      dimensionState.prevTime = curTime;\n      positionChanged = true;\n    }\n    if (positionChanged) {\n      this.position.changed.dispatch();\n    }\n    if (velocityChanged) {\n      this.velocity.changed.dispatch();\n    }\n    this.display.scheduleRedraw();\n  }\n}\n\ntype TrackableLinkInterface =\n  | TrackableNavigationLink\n  | TrackableNavigationSimpleLink;\n\nfunction restoreLinkedFromJson(\n  link: TrackableLinkInterface,\n  value: { restoreState(obj: unknown): void },\n  json: any,\n) {\n  if (json === undefined || Object.keys(json).length === 0) {\n    link.value = NavigationLinkType.LINKED;\n    return;\n  }\n  verifyObject(json);\n  link.value = NavigationLinkType.UNLINKED;\n  verifyObjectProperty(json, \"value\", (x) => {\n    if (x !== undefined) {\n      value.restoreState(x);\n    }\n  });\n  verifyObjectProperty(json, \"link\", (x) => link.restoreState(x));\n}\n\ninterface LinkableState<T> extends RefCounted, Trackable {\n  assign(other: T): void;\n}\n\nabstract class LinkedBase<\n  T extends LinkableState<T>,\n  Link extends TrackableLinkInterface = TrackableNavigationLink,\n> implements Trackable\n{\n  value: T;\n  get changed() {\n    return this.value.changed;\n  }\n  constructor(\n    public peer: Owned<T>,\n    public link: Link = new TrackableNavigationLink() as any,\n  ) {}\n\n  toJSON() {\n    const { link } = this;\n    if (link.value === NavigationLinkType.LINKED) {\n      return undefined;\n    }\n    return { link: link.toJSON(), value: this.getValueJson() };\n  }\n\n  protected getValueJson(): any {\n    return this.value.toJSON();\n  }\n\n  reset() {\n    this.link.value = NavigationLinkType.LINKED;\n  }\n\n  restoreState(obj: any) {\n    restoreLinkedFromJson(this.link, this.value, obj);\n  }\n\n  copyToPeer() {\n    if (this.link.value !== NavigationLinkType.LINKED) {\n      this.link.value = NavigationLinkType.UNLINKED;\n      this.peer.assign(this.value);\n      this.link.value = NavigationLinkType.LINKED;\n    }\n  }\n}\n\nabstract class SimpleLinkedBase<\n    T extends RefCounted & Trackable & { assign(other: T): void },\n  >\n  extends LinkedBase<T, TrackableNavigationSimpleLink>\n  implements Trackable {}\n\nexport class LinkedPosition extends LinkedBase<Position> {\n  value = makeLinked(\n    new Position(this.peer.coordinateSpace),\n    this.peer,\n    this.link,\n    {\n      assign: (a: Position, b: Position) => a.assign(b),\n      isValid: (a: Position) => {\n        return a.valid;\n      },\n      difference: Position.getOffset,\n      add: Position.addOffset,\n      subtract: (\n        target: Position,\n        source: Position,\n        amount: Float32Array | undefined,\n      ) => {\n        Position.addOffset(target, source, amount, -1);\n      },\n    },\n  );\n}\n\nfunction quaternionIsIdentity(q: quat) {\n  return q[0] === 0 && q[1] === 0 && q[2] === 0 && q[3] === 1;\n}\n\nexport class OrientationState extends RefCounted {\n  orientation: quat;\n  changed = new NullarySignal();\n\n  constructor(orientation?: quat) {\n    super();\n    if (orientation == null) {\n      orientation = quat.create();\n    }\n    this.orientation = orientation;\n  }\n  toJSON() {\n    const { orientation } = this;\n    quat.normalize(this.orientation, this.orientation);\n    if (quaternionIsIdentity(orientation)) {\n      return undefined;\n    }\n    return Array.prototype.slice.call(this.orientation);\n  }\n  restoreState(obj: any) {\n    try {\n      parseFiniteVec(this.orientation, obj);\n      quat.normalize(this.orientation, this.orientation);\n    } catch {\n      quat.identity(this.orientation);\n    }\n    this.changed.dispatch();\n  }\n\n  reset() {\n    quat.identity(this.orientation);\n    this.changed.dispatch();\n  }\n\n  snap() {\n    const mat = mat3.create();\n    mat3.fromQuat(mat, this.orientation);\n    const usedAxes = [false, false, false];\n    for (let i = 0; i < 3; ++i) {\n      let maxComponent = 0;\n      let argmaxComponent = 0;\n      for (let j = 0; j < 3; ++j) {\n        const value = mat[i * 3 + j];\n        mat[i * 3 + j] = 0;\n        if (usedAxes[j]) {\n          continue;\n        }\n        if (Math.abs(value) > Math.abs(maxComponent)) {\n          maxComponent = value;\n          argmaxComponent = j;\n        }\n      }\n      mat[i * 3 + argmaxComponent] = Math.sign(maxComponent);\n      usedAxes[argmaxComponent] = true;\n    }\n    quat.fromMat3(this.orientation, mat);\n    this.changed.dispatch();\n  }\n\n  /**\n   * Returns a new OrientationState with orientation fixed to peerToSelf * peer.orientation.  Any\n   * changes to the returned OrientationState will cause a corresponding change in peer, and vice\n   * versa.\n   */\n  static makeRelative(peer: OrientationState, peerToSelf: quat) {\n    const self = new OrientationState(\n      quat.multiply(quat.create(), peer.orientation, peerToSelf),\n    );\n    let updatingPeer = false;\n    self.registerDisposer(\n      peer.changed.add(() => {\n        if (!updatingPeer) {\n          updatingSelf = true;\n          quat.multiply(self.orientation, peer.orientation, peerToSelf);\n          self.changed.dispatch();\n          updatingSelf = false;\n        }\n      }),\n    );\n    let updatingSelf = false;\n    const selfToPeer = quat.invert(quat.create(), peerToSelf);\n    self.registerDisposer(\n      self.changed.add(() => {\n        if (!updatingSelf) {\n          updatingPeer = true;\n          quat.multiply(peer.orientation, self.orientation, selfToPeer);\n          peer.changed.dispatch();\n          updatingPeer = false;\n        }\n      }),\n    );\n    return self;\n  }\n\n  assign(other: Borrowed<OrientationState>) {\n    quat.copy(this.orientation, other.orientation);\n    this.changed.dispatch();\n  }\n}\n\nexport class LinkedOrientationState extends LinkedBase<OrientationState> {\n  value = makeLinked(new OrientationState(), this.peer, this.link, {\n    assign: (a: OrientationState, b: OrientationState) => a.assign(b),\n    isValid: () => true,\n    difference: (a: OrientationState, b: OrientationState) => {\n      const temp = quat.create();\n      return quat.multiply(\n        temp,\n        quat.invert(temp, b.orientation),\n        a.orientation,\n      );\n    },\n    add: (target: OrientationState, source: OrientationState, amount: quat) => {\n      quat.multiply(target.orientation, source.orientation, amount);\n      target.changed.dispatch();\n    },\n    subtract: (\n      target: OrientationState,\n      source: OrientationState,\n      amount: quat,\n    ) => {\n      quat.multiply(\n        target.orientation,\n        source.orientation,\n        quat.invert(tempQuat, amount),\n      );\n      target.changed.dispatch();\n    },\n  });\n}\n\nexport interface RelativeDisplayScales {\n  /**\n   * Array of length `coordinateSpace.rank` specifying scale factors on top of (will be multiply by)\n   * `coordinateSpace.scales` to use for display purposes.  This allows non-uniform zooming.\n   */\n  factors: Float64Array;\n}\n\nexport class TrackableRelativeDisplayScales\n  extends RefCounted\n  implements Trackable, WatchableValueInterface<RelativeDisplayScales>\n{\n  changed = new NullarySignal();\n  private curCoordinateSpace = emptyInvalidCoordinateSpace;\n  private value_: RelativeDisplayScales = { factors: new Float64Array(0) };\n  constructor(\n    public coordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  ) {\n    super();\n    this.registerDisposer(coordinateSpace.changed.add(() => this.update()));\n    this.update();\n  }\n\n  get value() {\n    return this.update();\n  }\n\n  reset() {\n    this.value_ = { factors: new Float64Array(0) };\n    this.curCoordinateSpace = emptyInvalidCoordinateSpace;\n    this.changed.dispatch();\n  }\n\n  toJSON() {\n    const json: any = {};\n    let nonEmpty = false;\n    const { value } = this;\n    const { factors } = value;\n    const { names, rank } = this.curCoordinateSpace;\n    for (let i = 0; i < rank; ++i) {\n      const factor = factors[i];\n      if (factor === 1) continue;\n      json[names[i]] = factor;\n      nonEmpty = true;\n    }\n    if (nonEmpty) return json;\n    return undefined;\n  }\n\n  restoreState(json: unknown) {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n    } = this;\n    const { names, rank } = coordinateSpace;\n    const factors = new Float64Array(rank);\n    factors.fill(-1);\n    if (json !== undefined) {\n      const obj = verifyObject(json);\n      for (let i = 0; i < rank; ++i) {\n        factors[i] = verifyObjectProperty(obj, names[i], (x) =>\n          x === undefined ? 1 : verifyFinitePositiveFloat(x),\n        );\n      }\n    }\n    this.value_ = { factors };\n    this.curCoordinateSpace = coordinateSpace;\n    this.changed.dispatch();\n  }\n\n  setFactors(factors: Float64Array) {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n    } = this;\n    if (factors.length !== coordinateSpace.rank) return;\n    this.value_ = { factors };\n    this.curCoordinateSpace = coordinateSpace;\n    this.changed.dispatch();\n  }\n\n  private update() {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n    } = this;\n    let value = this.value_;\n    const { curCoordinateSpace } = this;\n    if (curCoordinateSpace === coordinateSpace) return value;\n    const { ids: oldDimensionIds } = curCoordinateSpace;\n    const { ids: newDimensionIds, rank } = coordinateSpace;\n    const oldFactors = value.factors;\n    const newFactors = new Float64Array(rank);\n    newFactors.fill(1);\n    for (let i = 0; i < rank; ++i) {\n      const id = newDimensionIds[i];\n      const oldIndex = oldDimensionIds.indexOf(id);\n      if (oldIndex === -1) continue;\n      newFactors[i] = oldFactors[oldIndex];\n    }\n    if (arraysEqual(newFactors, oldFactors)) return value;\n    value = this.value_ = { factors: newFactors };\n    this.curCoordinateSpace = coordinateSpace;\n    this.changed.dispatch();\n    return value;\n  }\n\n  assign(other: TrackableRelativeDisplayScales) {\n    this.setFactors(other.value.factors);\n  }\n}\n\nfunction mapPerDimensionValues<\n  T,\n  A extends { length: number; [index: number]: T },\n  C extends { new (n: number): A },\n>(\n  arrayConstructor: C,\n  input: A,\n  oldCoordinateSpace: CoordinateSpace,\n  newCoordinateSpace: CoordinateSpace,\n  defaultValue: (index: number) => T,\n): A {\n  if (oldCoordinateSpace === newCoordinateSpace) return input;\n  const { ids: oldDimensionIds } = oldCoordinateSpace;\n  const { rank: newRank, ids: newDimensionIds } = newCoordinateSpace;\n  const output = new arrayConstructor(newRank);\n  for (let newDim = 0; newDim < newRank; ++newDim) {\n    const id = newDimensionIds[newDim];\n    const oldDim = oldDimensionIds.indexOf(id);\n    output[newDim] = oldDim === -1 ? defaultValue(newDim) : input[oldDim];\n  }\n  return output;\n}\n\nexport class LinkedRelativeDisplayScales extends LinkedBase<TrackableRelativeDisplayScales> {\n  value = makeLinked(\n    new TrackableRelativeDisplayScales(this.peer.coordinateSpace),\n    this.peer,\n    this.link,\n    {\n      assign: (target, source) => target.assign(source),\n      difference: (a, b) => {\n        const { factors: fa } = a.value;\n        const coordinateSpace = a.coordinateSpace.value;\n        const fb = b.value.factors;\n        return {\n          coordinateSpace,\n          offsets: vector.subtract(new Float64Array(fa.length), fa, fb),\n        };\n      },\n      add: (\n        target,\n        source,\n        delta: { offsets: Float64Array; coordinateSpace: CoordinateSpace },\n      ) => {\n        const newOffsets = mapPerDimensionValues(\n          Float64Array,\n          delta.offsets,\n          delta.coordinateSpace,\n          target.coordinateSpace.value,\n          () => 0,\n        );\n        target.setFactors(\n          vector.add(\n            new Float64Array(newOffsets.length),\n            newOffsets,\n            source.value.factors,\n          ),\n        );\n      },\n      subtract: (\n        target,\n        source,\n        delta: { offsets: Float64Array; coordinateSpace: CoordinateSpace },\n      ) => {\n        const newOffsets = mapPerDimensionValues(\n          Float64Array,\n          delta.offsets,\n          delta.coordinateSpace,\n          target.coordinateSpace.value,\n          () => 0,\n        );\n        target.setFactors(\n          vector.subtract(\n            new Float64Array(newOffsets.length),\n            source.value.factors,\n            newOffsets,\n          ),\n        );\n      },\n      isValid: () => true,\n    },\n  );\n}\n\nexport interface DisplayDimensionRenderInfo {\n  /**\n   * Number of global dimensions.\n   */\n  globalRank: number;\n\n  /**\n   * Array of length `globalRank` specifying global dimension names.\n   */\n  globalDimensionNames: readonly string[];\n\n  /**\n   * Number of displayed dimensions.  Must be <= 3.\n   */\n  displayRank: number;\n\n  /**\n   * Array of length 3.  The first `displayRank` elements specify the indices of the the global\n   * dimensions that are displayed.  The remaining elements are `-1`.\n   */\n  displayDimensionIndices: Int32Array;\n\n  /**\n   * Array of length 3.  `voxelPhysicalScales[i]` equals\n   * `relativeDisplayScales[d] * coordinateSpace.scales[d]`,\n   * where `d = displayDimensionIndices[i]`, or `1` for `i >= rank`.\n   */\n  voxelPhysicalScales: Float64Array;\n\n  /**\n   * Unit corresponding to each dimension in `displayDimensionIndices`.  `displayDimensionUnits[i]`\n   * is equal to `coordinateSpace.units[displayDimensionIndices[i]]`, or `''` if\n   * `displayDimensionIndices[i] == -1`.\n   */\n  displayDimensionUnits: readonly string[];\n\n  /**\n   * Scale corresponding to each dimension in `displayDimensionIndices`.\n   * `displayDimensionScales[i]` is equal to `coordinateSpace.scales[displayDimensionIndices[i]]`,\n   * or `1` if `displayDimensionIndices[i] == -1`.\n   */\n  displayDimensionScales: Float64Array;\n\n  /**\n   * Physical scale corresponding to the canonical voxel.  Equal to minimum of\n   * `voxelPhysicalScales.slice(0, rank)`, or `1` if `rank == 0`.\n   */\n  canonicalVoxelPhysicalSize: number;\n\n  /**\n   * Array of length 3.  Amount by which the voxel coordinates of each display dimensions must be\n   * multiplied to convert to canonical voxels.  canonicalVoxelFactors[i] = voxelPhysicalScales[d] /\n   * canonicalVoxelPhysicalSize, where d = dimensionIndices[i], or `1` for `i >= rank`.\n   */\n  canonicalVoxelFactors: Float64Array;\n}\n\nfunction getDisplayDimensionRenderInfo(\n  coordinateSpace: CoordinateSpace,\n  displayDimensions: DisplayDimensions,\n  relativeDisplayScales: RelativeDisplayScales,\n): DisplayDimensionRenderInfo {\n  const {\n    rank: globalRank,\n    names: globalDimensionNames,\n    units,\n  } = coordinateSpace;\n  const { displayRank, displayDimensionIndices } = displayDimensions;\n  const canonicalVoxelFactors = new Float64Array(3);\n  const voxelPhysicalScales = new Float64Array(3);\n  let canonicalVoxelPhysicalSize: number;\n  const { factors } = relativeDisplayScales;\n  const displayDimensionUnits = new Array<string>(3);\n  const displayDimensionScales = new Float64Array(3);\n  canonicalVoxelFactors.fill(1);\n  voxelPhysicalScales.fill(1);\n  displayDimensionScales.fill(1);\n  displayDimensionUnits.fill(\"\");\n  if (displayRank === 0) {\n    canonicalVoxelPhysicalSize = 1;\n  } else {\n    canonicalVoxelPhysicalSize = Number.POSITIVE_INFINITY;\n    const { scales } = coordinateSpace;\n    for (let i = 0; i < displayRank; ++i) {\n      const dim = displayDimensionIndices[i];\n      const s = (voxelPhysicalScales[i] = factors[dim] * scales[dim]);\n      canonicalVoxelPhysicalSize = Math.min(canonicalVoxelPhysicalSize, s);\n      displayDimensionUnits[i] = units[dim];\n      displayDimensionScales[i] = scales[dim];\n    }\n    for (let i = 0; i < displayRank; ++i) {\n      canonicalVoxelFactors[i] =\n        voxelPhysicalScales[i] / canonicalVoxelPhysicalSize;\n    }\n  }\n  return {\n    globalRank,\n    globalDimensionNames,\n    displayRank,\n    displayDimensionIndices,\n    displayDimensionUnits,\n    displayDimensionScales,\n    canonicalVoxelFactors,\n    voxelPhysicalScales,\n    canonicalVoxelPhysicalSize,\n  };\n}\n\nexport function displayDimensionRenderInfosEqual(\n  a: DisplayDimensionRenderInfo,\n  b: DisplayDimensionRenderInfo,\n) {\n  return (\n    arraysEqual(a.globalDimensionNames, b.globalDimensionNames) &&\n    arraysEqual(a.displayDimensionIndices, b.displayDimensionIndices) &&\n    arraysEqual(a.canonicalVoxelFactors, b.canonicalVoxelFactors) &&\n    arraysEqual(a.voxelPhysicalScales, b.voxelPhysicalScales) &&\n    a.canonicalVoxelPhysicalSize === b.canonicalVoxelPhysicalSize &&\n    arraysEqual(a.displayDimensionUnits, b.displayDimensionUnits) &&\n    arraysEqual(a.displayDimensionScales, b.displayDimensionScales)\n  );\n}\n\nexport function validateDisplayDimensionRenderInfoProperty(\n  obj: { displayDimensionRenderInfo: DisplayDimensionRenderInfo },\n  expected: DisplayDimensionRenderInfo,\n): boolean {\n  const actual = obj.displayDimensionRenderInfo;\n  if (actual === expected) return true;\n  if (displayDimensionRenderInfosEqual(actual, expected)) {\n    obj.displayDimensionRenderInfo = expected;\n    return true;\n  }\n  return false;\n}\n\nexport class WatchableDisplayDimensionRenderInfo extends RefCounted {\n  changed = new NullarySignal();\n  private curRelativeDisplayScales: RelativeDisplayScales;\n  private curDisplayDimensions: DisplayDimensions;\n  private curCoordinateSpace: CoordinateSpace;\n  private value_: DisplayDimensionRenderInfo;\n  get value() {\n    const {\n      relativeDisplayScales: {\n        value: relativeDisplayScales,\n        coordinateSpace: { value: coordinateSpace },\n      },\n      displayDimensions: { value: displayDimensions },\n      curRelativeDisplayScales,\n      curDisplayDimensions,\n      curCoordinateSpace,\n    } = this;\n    let value = this.value_;\n    if (\n      curRelativeDisplayScales !== relativeDisplayScales ||\n      curDisplayDimensions !== displayDimensions ||\n      curCoordinateSpace !== coordinateSpace\n    ) {\n      this.curRelativeDisplayScales = relativeDisplayScales;\n      this.curDisplayDimensions = displayDimensions;\n      this.curCoordinateSpace = coordinateSpace;\n      const newValue = getDisplayDimensionRenderInfo(\n        coordinateSpace,\n        displayDimensions,\n        relativeDisplayScales,\n      );\n      if (!displayDimensionRenderInfosEqual(value, newValue)) {\n        this.value_ = value = newValue;\n        this.changed.dispatch();\n      }\n    }\n    return value;\n  }\n  constructor(\n    public relativeDisplayScales: Owned<TrackableRelativeDisplayScales>,\n    public displayDimensions: Owned<TrackableDisplayDimensions>,\n  ) {\n    super();\n    this.curRelativeDisplayScales = this.relativeDisplayScales.value;\n    this.curDisplayDimensions = this.displayDimensions.value;\n    this.curCoordinateSpace = this.relativeDisplayScales.coordinateSpace.value;\n    this.value_ = getDisplayDimensionRenderInfo(\n      this.curCoordinateSpace,\n      this.curDisplayDimensions,\n      this.curRelativeDisplayScales,\n    );\n\n    this.registerDisposer(relativeDisplayScales);\n    this.registerDisposer(displayDimensions);\n    const maybeUpdateValue = () => {\n      this.value;\n    };\n    this.registerDisposer(relativeDisplayScales.changed.add(maybeUpdateValue));\n    this.registerDisposer(displayDimensions.changed.add(maybeUpdateValue));\n  }\n}\n\nexport interface DisplayDimensions {\n  coordinateSpace: CoordinateSpace;\n  displayRank: number;\n  displayDimensionIndices: Int32Array;\n}\n\nexport class TrackableDisplayDimensions\n  extends RefCounted\n  implements Trackable\n{\n  changed = new NullarySignal();\n  private default_ = true;\n  private value_: DisplayDimensions | undefined = undefined;\n\n  constructor(\n    public coordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  ) {\n    super();\n    this.registerDisposer(\n      this.coordinateSpace.changed.add(this.changed.dispatch),\n    );\n    this.update();\n  }\n\n  get value() {\n    this.update();\n    return this.value_!;\n  }\n\n  private update() {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n    } = this;\n    const value = this.value_;\n    if (value !== undefined && value.coordinateSpace === coordinateSpace) {\n      return;\n    }\n    if (value === undefined || this.default_) {\n      this.setToDefault(coordinateSpace);\n      return;\n    }\n    const newDimensionIndices = new Int32Array(3);\n    const { ids: oldDimensionIds } = value.coordinateSpace;\n    const { ids: newDimensionIds } = coordinateSpace;\n    const oldDimensionIndices = value.displayDimensionIndices;\n    const oldRank = value.displayRank;\n    let newRank = 0;\n    for (let i = 0; i < oldRank; ++i) {\n      const newDim = newDimensionIds.indexOf(\n        oldDimensionIds[oldDimensionIndices[i]],\n      );\n      if (newDim === -1) continue;\n      newDimensionIndices[newRank] = newDim;\n      ++newRank;\n    }\n    newDimensionIndices.fill(-1, newRank);\n    if (newRank === 0) {\n      this.default_ = true;\n      this.setToDefault(coordinateSpace);\n      return;\n    }\n    this.assignValue(coordinateSpace, newRank, newDimensionIndices);\n    this.changed.dispatch();\n  }\n\n  private setToDefault(coordinateSpace: CoordinateSpace) {\n    const displayRank = Math.min(coordinateSpace.rank, 3);\n    const displayDimensionIndices = new Int32Array(3);\n    displayDimensionIndices.fill(-1);\n    for (let i = 0; i < displayRank; ++i) {\n      displayDimensionIndices[i] = i;\n    }\n    this.assignValue(coordinateSpace, displayRank, displayDimensionIndices);\n  }\n\n  private assignValue(\n    coordinateSpace: CoordinateSpace,\n    displayRank: number,\n    displayDimensionIndices: Int32Array,\n  ) {\n    this.value_ = {\n      coordinateSpace,\n      displayRank,\n      displayDimensionIndices,\n    };\n    this.changed.dispatch();\n  }\n\n  reset() {\n    this.default_ = true;\n    this.value_ = undefined;\n    this.changed.dispatch();\n  }\n\n  restoreState(obj: any) {\n    if (obj === undefined) {\n      this.reset();\n      return;\n    }\n    const displayDimensionNames = dimensionNamesFromJson(obj);\n    if (displayDimensionNames.length > 3) {\n      throw new Error(\"Number of spatial dimensions must be <= 3\");\n    }\n    const {\n      coordinateSpace: { value: coordinateSpace },\n    } = this;\n    const displayDimensionIndices = new Int32Array(3);\n    displayDimensionIndices.fill(-1);\n    const { names } = coordinateSpace;\n    let displayRank = 0;\n    for (const name of displayDimensionNames) {\n      const index = names.indexOf(name);\n      if (index === -1) continue;\n      displayDimensionIndices[displayRank++] = index;\n    }\n    if (displayRank === 0) {\n      this.reset();\n      return;\n    }\n    this.default_ = false;\n    this.assignValue(coordinateSpace, displayRank, displayDimensionIndices);\n  }\n\n  get default() {\n    this.update();\n    return this.default_;\n  }\n\n  set default(value: boolean) {\n    if (this.default_ === value) return;\n    if (value) {\n      this.default_ = true;\n      this.setToDefault(this.coordinateSpace.value);\n    } else {\n      this.default_ = false;\n      this.changed.dispatch();\n    }\n  }\n\n  setDimensionIndices(rank: number, dimensionIndices: Int32Array) {\n    this.default_ = false;\n    this.assignValue(this.coordinateSpace.value, rank, dimensionIndices);\n  }\n\n  toJSON() {\n    if (this.default_) return undefined;\n    const { value } = this;\n    const displayDimensionNames: string[] = [];\n    const {\n      displayRank,\n      displayDimensionIndices,\n      coordinateSpace: { names },\n    } = value;\n    if (displayRank === 0) return undefined;\n    for (let i = 0; i < displayRank; ++i) {\n      displayDimensionNames[i] = names[displayDimensionIndices[i]];\n    }\n    return displayDimensionNames;\n  }\n\n  assign(other: TrackableDisplayDimensions) {\n    if (other.default) {\n      this.default = true;\n    } else {\n      const { displayRank, displayDimensionIndices } = other.value;\n      this.setDimensionIndices(displayRank, displayDimensionIndices);\n    }\n  }\n}\n\nexport class LinkedDisplayDimensions extends SimpleLinkedBase<TrackableDisplayDimensions> {\n  value = makeSimpleLinked(\n    new TrackableDisplayDimensions(this.peer.coordinateSpace),\n    this.peer,\n    this.link,\n    {\n      assign: (target, source) => target.assign(source),\n      isValid: () => true,\n    },\n  );\n}\n\nexport class DisplayPose extends RefCounted {\n  changed = new NullarySignal();\n\n  get displayDimensions(): Borrowed<TrackableDisplayDimensions> {\n    return this.displayDimensionRenderInfo.displayDimensions;\n  }\n\n  get relativeDisplayScales(): Borrowed<TrackableRelativeDisplayScales> {\n    return this.displayDimensionRenderInfo.relativeDisplayScales;\n  }\n\n  constructor(\n    public position: Owned<Position>,\n    public displayDimensionRenderInfo: WatchableDisplayDimensionRenderInfo,\n    public orientation: Owned<OrientationState>,\n  ) {\n    super();\n    this.registerDisposer(position);\n    this.registerDisposer(orientation);\n    this.registerDisposer(displayDimensionRenderInfo);\n    this.registerDisposer(position.changed.add(this.changed.dispatch));\n    this.registerDisposer(orientation.changed.add(this.changed.dispatch));\n    this.registerDisposer(\n      displayDimensionRenderInfo.changed.add(this.changed.dispatch),\n    );\n  }\n\n  get valid() {\n    return this.position.valid;\n  }\n\n  /**\n   * Resets everything.\n   */\n  reset() {\n    this.position.reset();\n    this.orientation.reset();\n    this.displayDimensions.reset();\n  }\n\n  updateDisplayPosition(\n    fun: (pos: vec3) => boolean | void,\n    temp: vec3 = tempVec3,\n  ): boolean {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n      value: voxelCoordinates,\n    } = this.position;\n    const { displayDimensionIndices, displayRank } =\n      this.displayDimensions.value;\n    if (coordinateSpace === undefined) return false;\n    temp.fill(0);\n    for (let i = 0; i < displayRank; ++i) {\n      const dim = displayDimensionIndices[i];\n      temp[i] = voxelCoordinates[dim];\n    }\n    if (fun(temp) !== false) {\n      for (let i = 0; i < displayRank; ++i) {\n        const dim = displayDimensionIndices[i];\n        voxelCoordinates[dim] = temp[i];\n      }\n      this.position.changed.dispatch();\n      return true;\n    }\n    return false;\n  }\n\n  // Transform from view coordinates to global spatial coordinates.\n  toMat4(mat: mat4, zoom: number) {\n    mat4.fromQuat(mat, this.orientation.orientation);\n    const { value: voxelCoordinates } = this.position;\n    const { canonicalVoxelFactors, displayDimensionIndices } =\n      this.displayDimensionRenderInfo.value;\n    for (let i = 0; i < 3; ++i) {\n      const dim = displayDimensionIndices[i];\n      const scale = zoom / canonicalVoxelFactors[i];\n      mat[i] *= scale;\n      mat[4 + i] *= scale;\n      mat[8 + i] *= scale;\n      mat[12 + i] = voxelCoordinates[dim] || 0;\n    }\n  }\n\n  toMat3(mat: mat3, zoom: number) {\n    mat3.fromQuat(mat, this.orientation.orientation);\n    const { canonicalVoxelFactors, displayRank } =\n      this.displayDimensionRenderInfo.value;\n    for (let i = 0; i < displayRank; ++i) {\n      const scale = zoom / canonicalVoxelFactors[i];\n      mat[i] *= scale;\n      mat[3 + i] *= scale;\n      mat[6 + i] *= scale;\n    }\n  }\n\n  /**\n   * Snaps the orientation to the nearest axis-aligned orientation, and\n   * snaps the position to the nearest voxel.\n   */\n  snap() {\n    this.orientation.snap();\n    this.position.snapToVoxel();\n    this.changed.dispatch();\n  }\n\n  translateDimensionRelative(dimensionIndex: number, adjustment: number) {\n    if (!this.valid) {\n      return;\n    }\n    const { position } = this;\n    const { value: voxelCoordinates } = position;\n    const { bounds } = position.coordinateSpace.value;\n    voxelCoordinates[dimensionIndex] = clampAndRoundCoordinateToVoxelCenter(\n      bounds,\n      dimensionIndex,\n      voxelCoordinates[dimensionIndex] + adjustment,\n    );\n    position.changed.dispatch();\n  }\n\n  translateVoxelsRelative(translation: vec3) {\n    if (!this.valid) {\n      return;\n    }\n    const temp = vec3.transformQuat(\n      tempVec3,\n      translation,\n      this.orientation.orientation,\n    );\n    const { position } = this;\n    const { value: voxelCoordinates } = position;\n    const { displayDimensionIndices, displayRank } =\n      this.displayDimensions.value;\n    const { bounds } = position.coordinateSpace.value;\n    for (let i = 0; i < displayRank; ++i) {\n      const dim = displayDimensionIndices[i];\n      const adjustment = temp[i];\n      if (adjustment === 0) continue;\n      voxelCoordinates[dim] = clampAndRoundCoordinateToVoxelCenter(\n        bounds,\n        dim,\n        voxelCoordinates[dim] + adjustment,\n      );\n    }\n    this.position.changed.dispatch();\n  }\n\n  rotateRelative(axis: vec3, angle: number) {\n    const temp = quat.create();\n    quat.setAxisAngle(temp, axis, angle);\n    const orientation = this.orientation.orientation;\n    quat.multiply(orientation, orientation, temp);\n    this.orientation.changed.dispatch();\n  }\n\n  rotateAbsolute(axis: vec3, angle: number, fixedPoint: Float32Array) {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n      value: voxelCoordinates,\n    } = this.position;\n    if (coordinateSpace === undefined) return;\n    const {\n      relativeDisplayScales: {\n        value: { factors: relativeDisplayScales },\n      },\n      displayDimensions: {\n        value: { displayDimensionIndices, displayRank },\n      },\n    } = this;\n    const { scales } = coordinateSpace;\n    const temp = quat.create();\n    quat.setAxisAngle(temp, axis, angle);\n    const orientation = this.orientation.orientation;\n\n    // We want the coordinates in the transformed coordinate frame of the fixed point to remain\n    // the same after the rotation.\n\n    // We have the invariants:\n    // oldOrienation * fixedPointLocal + oldPosition == fixedPoint.\n    // newOrientation * fixedPointLocal + newPosition == fixedPoint.\n\n    // Therefore, we compute fixedPointLocal by:\n    // fixedPointLocal == inverse(oldOrientation) * (fixedPoint - oldPosition).\n    const fixedPointLocal = tempVec3;\n    tempVec3.fill(0);\n    for (let i = 0; i < displayRank; ++i) {\n      const dim = displayDimensionIndices[i];\n      const diff = fixedPoint[dim] - voxelCoordinates[dim];\n      fixedPointLocal[i] = diff * scales[dim] * relativeDisplayScales[dim];\n    }\n    const invOrientation = quat.invert(tempQuat, orientation);\n    vec3.transformQuat(fixedPointLocal, fixedPointLocal, invOrientation);\n\n    // We then compute the newPosition by:\n    // newPosition := fixedPoint - newOrientation * fixedPointLocal.\n    quat.multiply(orientation, temp, orientation);\n    vec3.transformQuat(fixedPointLocal, fixedPointLocal, orientation);\n\n    for (let i = 0; i < displayRank; ++i) {\n      const dim = displayDimensionIndices[i];\n      voxelCoordinates[dim] =\n        fixedPoint[dim] -\n        fixedPointLocal[i] / (scales[dim] * relativeDisplayScales[dim]);\n    }\n    this.position.changed.dispatch();\n    this.orientation.changed.dispatch();\n  }\n\n  translateNonDisplayDimension(\n    nonSpatialDimensionIndex: number,\n    adjustment: number,\n  ) {\n    if (!this.valid) return;\n    const { displayDimensionIndices } = this.displayDimensions.value;\n    const { position } = this;\n    const rank = position.coordinateSpace.value.rank;\n    for (let i = 0; i < rank; ++i) {\n      if (displayDimensionIndices.indexOf(i) !== -1) continue;\n      if (nonSpatialDimensionIndex-- === 0) {\n        this.translateDimensionRelative(i, adjustment);\n        return;\n      }\n    }\n  }\n}\n\nexport type TrackableZoomInterface =\n  | TrackableProjectionZoom\n  | TrackableCrossSectionZoom;\n\nexport class LinkedZoomState<\n  T extends TrackableProjectionZoom | TrackableCrossSectionZoom,\n> extends LinkedBase<T> {\n  constructor(\n    peer: Owned<T>,\n    displayDimensionRenderInfo: Owned<WatchableDisplayDimensionRenderInfo>,\n  ) {\n    super(peer);\n    this.value = (() => {\n      const self: T = new (peer.constructor as any)(displayDimensionRenderInfo);\n      const assign = (target: T, source: T) => {\n        target.assign(source);\n      };\n      const difference = (a: T, b: T) => {\n        return (\n          (a.value / b.value) *\n          (a.canonicalVoxelPhysicalSize / b.canonicalVoxelPhysicalSize)\n        );\n      };\n      const add = (target: T, source: T, amount: number) => {\n        target.setPhysicalScale(\n          source.value * amount,\n          source.canonicalVoxelPhysicalSize,\n        );\n      };\n      const subtract = (target: T, source: T, amount: number) => {\n        target.setPhysicalScale(\n          source.value / amount,\n          source.canonicalVoxelPhysicalSize,\n        );\n      };\n      const isValid = (x: T) =>\n        x.coordinateSpaceValue.valid && x.canonicalVoxelPhysicalSize !== 0;\n      makeLinked(\n        self as RefCounted & { changed: NullarySignal },\n        this.peer,\n        this.link,\n        {\n          assign,\n          isValid,\n          difference,\n          add,\n          subtract,\n        },\n      );\n      return self;\n    })();\n  }\n}\n\nexport function linkedStateLegacyJsonView<\n  T extends LinkableState<T> & { readonly legacyJsonView: Trackable },\n>(linked: LinkedBase<T>) {\n  return {\n    changed: linked.changed,\n    toJSON() {\n      return linked.toJSON();\n    },\n    restoreState(obj: unknown) {\n      restoreLinkedFromJson(linked.link, linked.value.legacyJsonView, obj);\n    },\n    reset() {\n      linked.reset();\n    },\n  };\n}\n\nabstract class TrackableZoom\n  extends RefCounted\n  implements Trackable, WatchableValueInterface<number>\n{\n  readonly changed = new NullarySignal();\n  private curCanonicalVoxelPhysicalSize = 0;\n  private value_: number = Number.NaN;\n  protected legacyValue_: number = Number.NaN;\n\n  /**\n   * Zoom factor.  For cross section views, in canonical voxels per viewport pixel.  For projection\n   * views, in canonical voxels per viewport height (for orthographic projection).\n   */\n  get value() {\n    this.handleCoordinateSpaceChanged();\n    return this.value_;\n  }\n\n  set value(value: number) {\n    const { canonicalVoxelPhysicalSize } = this;\n    if (\n      Object.is(value, this.value_) &&\n      canonicalVoxelPhysicalSize === this.curCanonicalVoxelPhysicalSize\n    ) {\n      return;\n    }\n    this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;\n    this.legacyValue_ = Number.NaN;\n    this.value_ = value;\n    this.changed.dispatch();\n  }\n\n  get canonicalVoxelPhysicalSize() {\n    return this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;\n  }\n\n  get coordinateSpaceValue() {\n    return this.displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace\n      .value;\n  }\n\n  /**\n   * Sets the zoom factor in the legacy units.  For cross section views, `1e-9` spatial units per\n   * viewport pixel.  For projection views, `2 * 100 * Math.tan(Math.PI / 8) * 1e-9` spatial units\n   * per viewport height (for orthographic projection).\n   */\n  set legacyValue(value: number) {\n    if (Object.is(value, this.legacyValue_)) return;\n    this.value_ = Number.NaN;\n    this.legacyValue_ = value;\n    this.curCanonicalVoxelPhysicalSize = 0;\n    this.changed.dispatch();\n  }\n\n  get legacyValue() {\n    return this.legacyValue_;\n  }\n\n  constructor(\n    public displayDimensionRenderInfo: Owned<WatchableDisplayDimensionRenderInfo>,\n  ) {\n    super();\n    this.registerDisposer(displayDimensionRenderInfo);\n    this.registerDisposer(\n      displayDimensionRenderInfo.changed.add(() =>\n        this.handleCoordinateSpaceChanged(),\n      ),\n    );\n    this.registerDisposer(\n      displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace.changed.add(\n        () => this.handleCoordinateSpaceChanged(),\n      ),\n    );\n    this.handleCoordinateSpaceChanged();\n  }\n\n  handleCoordinateSpaceChanged() {\n    const { value_ } = this;\n    const {\n      displayDimensionRenderInfo: {\n        value: { canonicalVoxelPhysicalSize },\n        relativeDisplayScales: {\n          coordinateSpace: { value: coordinateSpace },\n        },\n      },\n    } = this;\n    const { curCanonicalVoxelPhysicalSize } = this;\n    if (\n      !Number.isNaN(value_) &&\n      canonicalVoxelPhysicalSize === curCanonicalVoxelPhysicalSize\n    ) {\n      return;\n    }\n    if (!Number.isNaN(value_)) {\n      if (curCanonicalVoxelPhysicalSize !== 0) {\n        this.value_ =\n          value_ * (curCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize);\n        this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;\n        this.changed.dispatch();\n      }\n      return;\n    }\n    if (!coordinateSpace.valid || canonicalVoxelPhysicalSize === 0) {\n      return;\n    }\n    this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;\n    this.value_ = this.getDefaultValue();\n    this.changed.dispatch();\n  }\n\n  protected abstract getDefaultValue(): number;\n\n  toJSON() {\n    const { value } = this;\n    return Number.isNaN(value) ? undefined : value;\n  }\n\n  restoreState(obj: any) {\n    this.curCanonicalVoxelPhysicalSize = 0;\n    this.legacyValue_ = Number.NaN;\n    if (obj === undefined) {\n      this.value_ = Number.NaN;\n    } else {\n      this.value_ = verifyFinitePositiveFloat(obj);\n    }\n    this.changed.dispatch();\n  }\n\n  reset() {\n    this.curCanonicalVoxelPhysicalSize = 0;\n    this.value_ = Number.NaN;\n    this.legacyValue_ = Number.NaN;\n    this.changed.dispatch();\n  }\n\n  get legacyJsonView() {\n    const self = this;\n    return {\n      changed: self.changed,\n      toJSON() {\n        return self.toJSON();\n      },\n      reset() {\n        return self.reset();\n      },\n      restoreState(obj: any) {\n        self.legacyValue = verifyFinitePositiveFloat(obj);\n      },\n    };\n  }\n\n  setPhysicalScale(\n    scaleInCanonicalVoxels: number,\n    canonicalVoxelPhysicalSize: number,\n  ) {\n    const curCanonicalVoxelPhysicalSize = (this.curCanonicalVoxelPhysicalSize =\n      this.canonicalVoxelPhysicalSize);\n    this.value =\n      scaleInCanonicalVoxels *\n      (canonicalVoxelPhysicalSize / curCanonicalVoxelPhysicalSize);\n  }\n\n  assign(source: TrackableZoomInterface) {\n    const { legacyValue } = source;\n    if (!Number.isNaN(legacyValue)) {\n      this.legacyValue = legacyValue;\n    } else {\n      this.setPhysicalScale(source.value, source.canonicalVoxelPhysicalSize);\n    }\n  }\n}\n\nexport class TrackableCrossSectionZoom extends TrackableZoom {\n  protected getDefaultValue() {\n    const { legacyValue_ } = this;\n    if (Number.isNaN(legacyValue_)) {\n      // Default is 1 voxel per viewport pixel.\n      return 1;\n    }\n    const { canonicalVoxelPhysicalSize } = this;\n    return (this.legacyValue_ * 1e-9) / canonicalVoxelPhysicalSize;\n  }\n}\n\nexport class TrackableProjectionZoom extends TrackableZoom {\n  protected getDefaultValue() {\n    const { legacyValue_ } = this;\n    if (!Number.isNaN(legacyValue_)) {\n      this.legacyValue_ = Number.NaN;\n      const { canonicalVoxelPhysicalSize } = this;\n      return (\n        (2 * 100 * Math.tan(Math.PI / 8) * 1e-9 * legacyValue_) /\n        canonicalVoxelPhysicalSize\n      );\n    }\n    const {\n      coordinateSpaceValue: {\n        bounds: { lowerBounds, upperBounds },\n      },\n    } = this;\n    const { canonicalVoxelFactors, displayDimensionIndices } =\n      this.displayDimensionRenderInfo.value;\n    let value = canonicalVoxelFactors.reduce((x, factor, i) => {\n      const dim = displayDimensionIndices[i];\n      const extent = (upperBounds[dim] - lowerBounds[dim]) * factor;\n      return Math.max(x, extent);\n    }, 0);\n    if (!Number.isFinite(value)) {\n      // Default to showing 1024 voxels if there is no bounds information.\n      value = 1024;\n    } else {\n      value = 2 ** Math.ceil(Math.log2(value));\n    }\n    return value;\n  }\n}\n\nexport class TrackableDepthRange\n  extends RefCounted\n  implements WatchableValueInterface<number>\n{\n  changed = new NullarySignal();\n\n  constructor(\n    public readonly defaultValue: number,\n    public displayDimensionRenderInfo: WatchableValueInterface<DisplayDimensionRenderInfo>,\n  ) {\n    super();\n    this.value_ = defaultValue;\n    this.canonicalVoxelPhysicalSize =\n      displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;\n    this.registerDisposer(\n      displayDimensionRenderInfo.changed.add(() => {\n        this.value;\n      }),\n    );\n  }\n\n  private value_: number;\n  canonicalVoxelPhysicalSize: number;\n\n  get value() {\n    let { value_ } = this;\n    if (value_ > 0) {\n      const { canonicalVoxelPhysicalSize } =\n        this.displayDimensionRenderInfo.value;\n      const prevCanonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;\n      if (canonicalVoxelPhysicalSize !== prevCanonicalVoxelPhysicalSize) {\n        this.canonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;\n        value_ =\n          this.value_ =\n          value_ =\n            prevCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize;\n        this.changed.dispatch();\n      }\n    }\n    return value_;\n  }\n\n  set value(value: number) {\n    if (value === this.value) return;\n    this.value_ = value;\n    const { canonicalVoxelPhysicalSize } =\n      this.displayDimensionRenderInfo.value;\n    this.canonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;\n    this.changed.dispatch();\n  }\n\n  toJSON() {\n    const { value } = this;\n    if (value === this.defaultValue) return undefined;\n    return value;\n  }\n\n  reset() {\n    this.value = this.defaultValue;\n  }\n\n  restoreState(obj: unknown) {\n    if (typeof obj !== \"number\" || !Number.isFinite(obj) || obj === 0) {\n      this.value = this.defaultValue;\n    } else {\n      this.value = obj;\n    }\n  }\n\n  setValueAbsolute(value: number, sourceCanonicalVoxelPhysicalSize: number) {\n    if (value > 0) {\n      const { canonicalVoxelPhysicalSize } =\n        this.displayDimensionRenderInfo.value;\n      value =\n        value * (sourceCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize);\n    }\n    this.value = value;\n  }\n\n  assign(other: TrackableDepthRange) {\n    this.setValueAbsolute(other.value, other.canonicalVoxelPhysicalSize);\n  }\n}\n\nexport class LinkedDepthRange extends SimpleLinkedBase<TrackableDepthRange> {\n  constructor(\n    peer: Owned<TrackableDepthRange>,\n    displayDimensionRenderInfo: WatchableValueInterface<DisplayDimensionRenderInfo>,\n  ) {\n    super(peer);\n    this.value = makeSimpleLinked(\n      new TrackableDepthRange(peer.defaultValue, displayDimensionRenderInfo),\n      this.peer,\n      this.link,\n      {\n        assign: (target, source) => target.assign(source),\n        isValid: () => true,\n      },\n    );\n  }\n}\n\nexport class NavigationState<\n  Zoom extends TrackableZoomInterface = TrackableZoomInterface,\n> extends RefCounted {\n  changed = new NullarySignal();\n\n  constructor(\n    public pose: Owned<DisplayPose>,\n    public zoomFactor: Owned<Zoom>,\n    public depthRange: Owned<TrackableDepthRange>,\n  ) {\n    super();\n    this.registerDisposer(pose);\n    this.registerDisposer(zoomFactor);\n    this.registerDisposer(depthRange);\n    this.registerDisposer(this.pose.changed.add(this.changed.dispatch));\n    this.registerDisposer(this.zoomFactor.changed.add(this.changed.dispatch));\n    this.registerDisposer(this.depthRange.changed.add(this.changed.dispatch));\n  }\n  get coordinateSpace() {\n    return this.pose.position.coordinateSpace;\n  }\n\n  /**\n   * Resets everything.\n   */\n  reset() {\n    this.pose.reset();\n    this.zoomFactor.reset();\n  }\n\n  get position() {\n    return this.pose.position;\n  }\n  get displayDimensions() {\n    return this.pose.displayDimensions;\n  }\n  get relativeDisplayScales() {\n    return this.pose.relativeDisplayScales;\n  }\n  get displayDimensionRenderInfo() {\n    return this.pose.displayDimensionRenderInfo;\n  }\n  toMat4(mat: mat4) {\n    this.pose.toMat4(mat, this.zoomFactor.value);\n  }\n  toMat3(mat: mat3) {\n    this.pose.toMat3(mat, this.zoomFactor.value);\n  }\n\n  get relativeDepthRange() {\n    let depthRange = this.depthRange.value;\n    if (depthRange > 0) {\n      depthRange /= this.zoomFactor.value;\n    } else {\n      depthRange *= -1;\n    }\n    return depthRange;\n  }\n\n  get valid() {\n    return this.pose.valid && !Number.isNaN(this.zoomFactor.value);\n  }\n\n  zoomBy(factor: number) {\n    this.zoomFactor.value *= factor;\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TypedArrayConstructor } from \"#src/util/array.js\";\n\n/**\n * If this is updated, DATA_TYPE_BYTES must also be updated.\n */\nexport enum DataType {\n  UINT8 = 0,\n  INT8 = 1,\n  UINT16 = 2,\n  INT16 = 3,\n  UINT32 = 4,\n  INT32 = 5,\n  UINT64 = 6,\n  FLOAT32 = 7,\n}\n\nexport const DATA_TYPE_SIGNED: Record<DataType, boolean | undefined> = {\n  [DataType.UINT8]: false,\n  [DataType.INT8]: true,\n  [DataType.UINT16]: false,\n  [DataType.INT16]: true,\n  [DataType.UINT32]: false,\n  [DataType.INT32]: true,\n  [DataType.UINT64]: false,\n  [DataType.FLOAT32]: undefined,\n};\n\nexport const DATA_TYPE_BYTES: Record<DataType, number> = {\n  [DataType.UINT8]: 1,\n  [DataType.INT8]: 1,\n  [DataType.UINT16]: 2,\n  [DataType.INT16]: 2,\n  [DataType.UINT32]: 4,\n  [DataType.INT32]: 4,\n  [DataType.UINT64]: 8,\n  [DataType.FLOAT32]: 4,\n};\n\nexport const DATA_TYPE_ARRAY_CONSTRUCTOR: Record<\n  DataType,\n  TypedArrayConstructor\n> = {\n  [DataType.UINT8]: Uint8Array,\n  [DataType.INT8]: Int8Array,\n  [DataType.UINT16]: Uint16Array,\n  [DataType.INT16]: Int16Array,\n  [DataType.UINT32]: Uint32Array,\n  [DataType.INT32]: Int32Array,\n  [DataType.UINT64]: Uint32Array,\n  [DataType.FLOAT32]: Float32Array,\n};\n\nexport const DATA_TYPE_JAVASCRIPT_ELEMENTS_PER_ARRAY_ELEMENT: Record<\n  DataType,\n  number\n> = {\n  [DataType.UINT8]: 1,\n  [DataType.INT8]: 1,\n  [DataType.UINT16]: 1,\n  [DataType.INT16]: 1,\n  [DataType.UINT32]: 1,\n  [DataType.INT32]: 1,\n  [DataType.UINT64]: 2,\n  [DataType.FLOAT32]: 1,\n};\n\nexport function makeDataTypeArrayView<TArrayBuffer extends ArrayBufferLike>(\n  dataType: DataType,\n  buffer: TArrayBuffer,\n  byteOffset = 0,\n  byteLength: number = buffer.byteLength,\n): ArrayBufferView<TArrayBuffer> {\n  const bytesPerElement = DATA_TYPE_BYTES[dataType];\n  const javascriptElementsPerArrayElement =\n    DATA_TYPE_JAVASCRIPT_ELEMENTS_PER_ARRAY_ELEMENT[dataType];\n  return new (DATA_TYPE_ARRAY_CONSTRUCTOR[\n    dataType\n  ] as TypedArrayConstructor<TArrayBuffer>)(\n    buffer,\n    byteOffset,\n    (byteLength / bytesPerElement) * javascriptElementsPerArrayElement,\n  );\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Facilities for endianness detection and swapping.\n */\n\nexport enum Endianness {\n  LITTLE = 0,\n  BIG = 1,\n}\n\nexport function determineEndianness() {\n  const a = Uint16Array.of(0x1122);\n  const b = new Uint8Array(a.buffer);\n  return b[0] === 0x11 ? Endianness.BIG : Endianness.LITTLE;\n}\n\n/**\n * The native endianness of the runtime.\n */\nexport const ENDIANNESS = determineEndianness();\n\n/**\n * Swaps the endianness of an array assumed to contain 16-bit values.\n */\nexport function swapEndian16(array: ArrayBufferView) {\n  const view = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n  for (let i = 0, length = view.length; i < length; i += 2) {\n    const temp = view[i];\n    view[i] = view[i + 1];\n    view[i + 1] = temp;\n  }\n}\n\n/**\n * Swaps the endianness of an array assumed to contain 32-bit values.\n */\nexport function swapEndian32(array: ArrayBufferView) {\n  const view = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n  for (let i = 0, length = view.length; i < length; i += 4) {\n    let temp = view[i];\n    view[i] = view[i + 3];\n    view[i + 3] = temp;\n    temp = view[i + 1];\n    view[i + 1] = view[i + 2];\n    view[i + 2] = temp;\n  }\n}\n\nexport function swapEndian64(array: ArrayBufferView) {\n  const view = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n  for (let i = 0, length = view.length; i < length; i += 8) {\n    let temp = view[i];\n    view[i] = view[i + 7];\n    view[i + 7] = temp;\n    temp = view[i + 1];\n    view[i + 1] = view[i + 6];\n    view[i + 6] = temp;\n    temp = view[i + 2];\n    view[i + 2] = view[i + 5];\n    view[i + 5] = temp;\n    temp = view[i + 3];\n    view[i + 3] = view[i + 4];\n    view[i + 4] = temp;\n  }\n}\n\n/**\n * Converts the endianness of an array assumed to contain 16-bit values from source to target.\n *\n * This does nothing if source === target.\n */\nexport function convertEndian16(\n  array: ArrayBufferView,\n  source: Endianness,\n  target: Endianness = ENDIANNESS,\n) {\n  if (source !== target) {\n    swapEndian16(array);\n  }\n}\n\n/**\n * Converts the endianness of an array assumed to contain 32-bit values from source to target.\n *\n * This does nothing if source === target.\n */\nexport function convertEndian32(\n  array: ArrayBufferView,\n  source: Endianness,\n  target: Endianness = ENDIANNESS,\n) {\n  if (source !== target) {\n    swapEndian32(array);\n  }\n}\n\n/**\n * Converts the endianness of an array assumed to contain 64-bit values from source to target.\n *\n * This does nothing if source === target.\n */\nexport function convertEndian64(\n  array: ArrayBufferView,\n  source: Endianness,\n  target: Endianness = ENDIANNESS,\n) {\n  if (source !== target) {\n    swapEndian64(array);\n  }\n}\n\nexport function convertEndian(\n  array: ArrayBufferView,\n  source: Endianness,\n  elementBytes: number,\n  target: Endianness = ENDIANNESS,\n) {\n  if (source === target || elementBytes === 1) return;\n  switch (elementBytes) {\n    case 2:\n      swapEndian16(array);\n      break;\n    case 4:\n      swapEndian32(array);\n      break;\n    case 8:\n      swapEndian64(array);\n      break;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Basic annotation data structures.\n */\n\nimport type {\n  BoundingBox,\n  CoordinateSpaceTransform,\n  WatchableCoordinateSpaceTransform,\n} from \"#src/coordinate_transform.js\";\nimport { WatchableValue } from \"#src/trackable_value.js\";\nimport { arraysEqual } from \"#src/util/array.js\";\nimport {\n  packColor,\n  parseRGBAColorSpecification,\n  parseRGBColorSpecification,\n  serializeColor,\n  unpackRGB,\n  unpackRGBA,\n} from \"#src/util/color.js\";\nimport { DataType } from \"#src/util/data_type.js\";\nimport type { Borrowed } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { Endianness, ENDIANNESS } from \"#src/util/endian.js\";\nimport {\n  expectArray,\n  parseArray,\n  parseFixedLengthArray,\n  verifyEnumString,\n  verifyFiniteFloat,\n  verifyFiniteNonNegativeFloat,\n  verifyFloat,\n  verifyInt,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalObjectProperty,\n  verifyOptionalString,\n  verifyString,\n} from \"#src/util/json.js\";\nimport { parseDataTypeValue } from \"#src/util/lerp.js\";\nimport { getRandomHexString } from \"#src/util/random.js\";\nimport { NullarySignal, Signal } from \"#src/util/signal.js\";\nimport { Uint64 } from \"#src/util/uint64.js\";\n\nexport type AnnotationId = string;\n\nexport class AnnotationReference extends RefCounted {\n  changed = new NullarySignal();\n\n  /**\n   * If `undefined`, we are still waiting to look up the result.  If `null`, annotation has been\n   * deleted.\n   */\n  value: Annotation | null | undefined;\n\n  constructor(public id: AnnotationId) {\n    super();\n  }\n}\n\nexport enum AnnotationType {\n  POINT = 0,\n  LINE = 1,\n  AXIS_ALIGNED_BOUNDING_BOX = 2,\n  ELLIPSOID = 3,\n}\n\nexport const annotationTypes = [\n  AnnotationType.POINT,\n  AnnotationType.LINE,\n  AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,\n  AnnotationType.ELLIPSOID,\n];\n\nexport interface AnnotationPropertySpecBase {\n  identifier: string;\n  description: string | undefined;\n}\n\nexport interface AnnotationColorPropertySpec\n  extends AnnotationPropertySpecBase {\n  type: \"rgb\" | \"rgba\";\n  default: number;\n}\n\nexport interface AnnotationNumericPropertySpec\n  extends AnnotationPropertySpecBase {\n  type: \"float32\" | \"uint32\" | \"int32\" | \"uint16\" | \"int16\" | \"uint8\" | \"int8\";\n  default: number;\n  enumValues?: number[];\n  enumLabels?: string[];\n  min?: number;\n  max?: number;\n  step?: number;\n  tag?: string;\n}\n\nexport interface AnnotationTagPropertySpec\n  extends AnnotationNumericPropertySpec {\n  type: \"int8\";\n  tag: string;\n}\n\nexport const propertyTypeDataType: Record<\n  AnnotationPropertySpec[\"type\"],\n  DataType | undefined\n> = {\n  float32: DataType.FLOAT32,\n  uint32: DataType.UINT32,\n  int32: DataType.INT32,\n  uint16: DataType.UINT16,\n  int16: DataType.INT16,\n  uint8: DataType.UINT8,\n  int8: DataType.INT8,\n  rgb: undefined,\n  rgba: undefined,\n};\n\nexport type AnnotationPropertySpec =\n  | AnnotationColorPropertySpec\n  | AnnotationNumericPropertySpec;\n\nexport function isAnnotationNumericPropertySpec(\n  spec: AnnotationPropertySpec,\n): spec is AnnotationNumericPropertySpec {\n  return spec.type !== \"rgb\" && spec.type !== \"rgba\";\n}\n\nexport function isAnnotationTagPropertySpec(\n  spec: AnnotationPropertySpec,\n): spec is AnnotationTagPropertySpec {\n  return spec.type === \"uint8\" && spec.tag !== undefined;\n}\n\nexport interface AnnotationPropertyTypeHandler {\n  serializedBytes(rank: number): number;\n  alignment(rank: number): number;\n  serializeCode(property: string, offset: string, rank: number): string;\n  deserializeCode(property: string, offset: string, rank: number): string;\n  deserializeJson(obj: unknown): number;\n  serializeJson(value: number): any;\n}\n\nexport const annotationPropertyTypeHandlers: {\n  [K in AnnotationPropertySpec[\"type\"]]: AnnotationPropertyTypeHandler;\n} = {\n  rgb: {\n    serializedBytes() {\n      return 3;\n    },\n    alignment() {\n      return 1;\n    },\n    serializeCode(property: string, offset: string) {\n      return (\n        `dv.setUint16(${offset}, ${property}, true);` +\n        `dv.setUint8(${offset} + 2, ${property} >>> 16);`\n      );\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getUint16(${offset}, true) | (dv.getUint8(${offset} + 2) << 16);`;\n    },\n    deserializeJson(obj: unknown) {\n      return packColor(parseRGBColorSpecification(obj));\n    },\n    serializeJson(value: number) {\n      return serializeColor(unpackRGB(value));\n    },\n  },\n  rgba: {\n    serializedBytes() {\n      return 4;\n    },\n    alignment() {\n      return 1;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setUint32(${offset}, ${property}, true);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getUint32(${offset}, true);`;\n    },\n    deserializeJson(obj: unknown) {\n      return packColor(parseRGBAColorSpecification(obj));\n    },\n    serializeJson(value: number) {\n      return serializeColor(unpackRGBA(value));\n    },\n  },\n  float32: {\n    serializedBytes() {\n      return 4;\n    },\n    alignment() {\n      return 4;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setFloat32(${offset}, ${property}, isLittleEndian);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getFloat32(${offset}, isLittleEndian);`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyFloat(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  uint32: {\n    serializedBytes() {\n      return 4;\n    },\n    alignment() {\n      return 4;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setUint32(${offset}, ${property}, isLittleEndian);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getUint32(${offset}, isLittleEndian);`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  int32: {\n    serializedBytes() {\n      return 4;\n    },\n    alignment() {\n      return 4;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setInt32(${offset}, ${property}, isLittleEndian);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getInt32(${offset}, isLittleEndian);`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  uint16: {\n    serializedBytes() {\n      return 2;\n    },\n    alignment() {\n      return 2;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setUint16(${offset}, ${property}, isLittleEndian);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getUint16(${offset}, isLittleEndian);`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  int16: {\n    serializedBytes() {\n      return 2;\n    },\n    alignment() {\n      return 2;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setInt16(${offset}, ${property}, isLittleEndian);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getInt16(${offset}, isLittleEndian);`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  uint8: {\n    serializedBytes() {\n      return 1;\n    },\n    alignment() {\n      return 1;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setUint8(${offset}, ${property});`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getUint8(${offset});`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  int8: {\n    serializedBytes() {\n      return 2;\n    },\n    alignment() {\n      return 1;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setInt8(${offset}, ${property});`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getInt8(${offset});`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n};\n\n// Maximum stride value supported by WebGL.\nconst MAX_BUFFER_STRIDE = 255;\n\nexport function getPropertyOffsets(\n  rank: number,\n  firstGroupInitialOffset: number,\n  propertySpecs: readonly Readonly<AnnotationPropertySpec>[],\n): {\n  serializedBytes: number;\n  offsets: { group: number; offset: number }[];\n  propertyGroupBytes: number[];\n} {\n  let serializedBytes = 0;\n  const numProperties = propertySpecs.length;\n  const permutation = new Array<number>(numProperties);\n  const propertyGroupBytes: number[] = [];\n  for (let i = 0; i < numProperties; ++i) {\n    permutation[i] = i;\n  }\n  const getAlignment = (i: number) =>\n    annotationPropertyTypeHandlers[propertySpecs[i].type].alignment(rank);\n  permutation.sort((i, j) => getAlignment(j) - getAlignment(i));\n  let propertyGroupIndex = 0;\n  const offsets = new Array<{ group: number; offset: number }>(numProperties);\n  let propertyGroupOffset = firstGroupInitialOffset;\n  const nextPropertyGroup = () => {\n    propertyGroupOffset += (4 - (propertyGroupOffset % 4)) % 4;\n    serializedBytes += propertyGroupOffset;\n    propertyGroupBytes[propertyGroupIndex] = propertyGroupOffset;\n    propertyGroupOffset = 0;\n    ++propertyGroupIndex;\n  };\n  for (let outputIndex = 0; outputIndex < numProperties; ++outputIndex) {\n    const propertyIndex = permutation[outputIndex];\n    const spec = propertySpecs[propertyIndex];\n    const handler = annotationPropertyTypeHandlers[spec.type];\n    const numBytes = handler.serializedBytes(rank);\n    const alignment = handler.alignment(rank);\n    // Check if the property fits in the current property group.\n    const alignmentOffset =\n      (alignment - (propertyGroupOffset % alignment)) % alignment;\n    const newStartOffset = propertyGroupOffset + alignmentOffset;\n    const newEndOffset = newStartOffset + numBytes;\n    const newAlignedEndOffset = newEndOffset + ((4 - (newEndOffset % 4)) % 4);\n    if (newAlignedEndOffset <= MAX_BUFFER_STRIDE) {\n      // Property fits\n      propertyGroupOffset += alignmentOffset;\n    } else {\n      // Property does not fit.\n      nextPropertyGroup();\n    }\n    offsets[propertyIndex] = {\n      offset: propertyGroupOffset,\n      group: propertyGroupIndex,\n    };\n    propertyGroupOffset += numBytes;\n  }\n  nextPropertyGroup();\n  return { serializedBytes, offsets, propertyGroupBytes };\n}\n\nexport class AnnotationPropertySerializer {\n  serializedBytes: number;\n  serialize: (\n    buffer: DataView,\n    offset: number,\n    annotationIndex: number,\n    annotationCount: number,\n    isLittleEndian: boolean,\n    properties: any[],\n  ) => void;\n  deserialize: (\n    buffer: DataView,\n    offset: number,\n    annotationIndex: number,\n    annotationCount: number,\n    isLittleEndian: boolean,\n    properties: any[],\n  ) => void;\n  propertyGroupBytes: number[];\n  constructor(\n    public rank: number,\n    public firstGroupInitialOffset: number,\n    public propertySpecs: readonly Readonly<AnnotationPropertySpec>[],\n  ) {\n    if (propertySpecs.length === 0) {\n      this.serializedBytes = firstGroupInitialOffset;\n      this.serialize = this.deserialize = () => {};\n      this.propertyGroupBytes = [firstGroupInitialOffset];\n      return;\n    }\n    const { serializedBytes, offsets, propertyGroupBytes } = getPropertyOffsets(\n      rank,\n      firstGroupInitialOffset,\n      propertySpecs,\n    );\n    this.propertyGroupBytes = propertyGroupBytes;\n    let groupOffsetCode = \"let groupOffset0 = offset;\";\n    for (\n      let groupIndex = 1;\n      groupIndex < propertyGroupBytes.length;\n      ++groupIndex\n    ) {\n      groupOffsetCode += `let groupOffset${groupIndex} = groupOffset${\n        groupIndex - 1\n      } + ${propertyGroupBytes[groupIndex - 1]}*annotationCount;`;\n    }\n    for (\n      let groupIndex = 0;\n      groupIndex < propertyGroupBytes.length;\n      ++groupIndex\n    ) {\n      groupOffsetCode += `groupOffset${groupIndex} += ${propertyGroupBytes[groupIndex]}*annotationIndex;`;\n    }\n    let serializeCode = groupOffsetCode;\n    let deserializeCode = groupOffsetCode;\n    const numProperties = propertySpecs.length;\n    for (\n      let propertyIndex = 0;\n      propertyIndex < numProperties;\n      ++propertyIndex\n    ) {\n      const { group, offset } = offsets[propertyIndex];\n      const spec = propertySpecs[propertyIndex];\n      const handler = annotationPropertyTypeHandlers[spec.type];\n      const propId = `properties[${propertyIndex}]`;\n      const offsetExpr = `groupOffset${group} + ${offset}`;\n      serializeCode += handler.serializeCode(propId, offsetExpr, rank);\n      deserializeCode += handler.deserializeCode(propId, offsetExpr, rank);\n    }\n    this.serializedBytes = serializedBytes;\n    this.serialize = new Function(\n      \"dv\",\n      \"offset\",\n      \"annotationIndex\",\n      \"annotationCount\",\n      \"isLittleEndian\",\n      \"properties\",\n      serializeCode,\n    ) as any;\n    this.deserialize = new Function(\n      \"dv\",\n      \"offset\",\n      \"annotationIndex\",\n      \"annotationCount\",\n      \"isLittleEndian\",\n      \"properties\",\n      deserializeCode,\n    ) as any;\n  }\n}\n\nexport function makeAnnotationPropertySerializers(\n  rank: number,\n  propertySpecs: readonly Readonly<AnnotationPropertySpec>[],\n) {\n  const serializers: AnnotationPropertySerializer[] = [];\n  for (const annotationType of annotationTypes) {\n    const handler = annotationTypeHandlers[annotationType];\n    serializers[annotationType] = new AnnotationPropertySerializer(\n      rank,\n      handler.serializedBytes(rank),\n      propertySpecs,\n    );\n  }\n  return serializers;\n}\n\nexport function formatNumericProperty(\n  property: AnnotationNumericPropertySpec,\n  value: number,\n): string {\n  const formattedValue =\n    property.type === \"float32\" ? value.toPrecision(6) : value.toString();\n  const { enumValues, enumLabels } = property;\n  if (enumValues !== undefined) {\n    const enumIndex = enumValues.indexOf(value);\n    if (enumIndex !== -1) {\n      return `${enumLabels![enumIndex]} (${formattedValue})`;\n    }\n  }\n  return formattedValue;\n}\n\nexport function formatAnnotationPropertyValue(\n  property: AnnotationPropertySpec,\n  value: any,\n): string {\n  switch (property.type) {\n    case \"rgb\":\n      return serializeColor(unpackRGB(value));\n    case \"rgba\":\n      return serializeColor(unpackRGBA(value));\n    default:\n      return formatNumericProperty(property, value);\n  }\n}\n\nexport function parseAnnotationPropertyId(obj: unknown) {\n  const s = verifyString(obj);\n  if (s.match(/^[a-z][a-zA-Z0-9_]*$/) === null) {\n    throw new Error(`Invalid property identifier: ${JSON.stringify(obj)}`);\n  }\n  return s;\n}\n\nexport function parseAnnotationPropertyType(obj: unknown) {\n  verifyString(obj);\n  if (\n    !Object.prototype.hasOwnProperty.call(annotationPropertyTypeHandlers, obj)\n  ) {\n    throw new Error(\"Unsupported property type: $JSON.stringify(obj)}\");\n  }\n  return obj as AnnotationPropertySpec[\"type\"];\n}\n\nexport function ensureUniqueAnnotationPropertyIds(\n  properties: AnnotationPropertySpec[],\n) {\n  const ids = new Set<string>();\n  for (const p of properties) {\n    if (ids.has(p.identifier)) {\n      throw new Error(`Duplicate property identifier: ${p.identifier}`);\n    }\n    ids.add(p.identifier);\n  }\n}\n\nfunction parseAnnotationPropertySpec(obj: unknown): AnnotationPropertySpec {\n  verifyObject(obj);\n  const identifier = verifyObjectProperty(obj, \"id\", parseAnnotationPropertyId);\n  const type = verifyObjectProperty(obj, \"type\", parseAnnotationPropertyType);\n  const description = verifyOptionalObjectProperty(\n    obj,\n    \"description\",\n    verifyString,\n  );\n  const defaultValue = verifyOptionalObjectProperty(\n    obj,\n    \"default\",\n    (x) => annotationPropertyTypeHandlers[type].deserializeJson(x),\n    0,\n  );\n  let enumValues: number[] | undefined;\n  let enumLabels: string[] | undefined;\n  let tag: string | undefined;\n  switch (type) {\n    case \"rgb\":\n    case \"rgba\":\n      break;\n    default: {\n      const dataType: DataType = DataType[type.toUpperCase() as any] as any;\n      enumValues = verifyOptionalObjectProperty(\n        obj,\n        \"enum_values\",\n        (valuesObj) =>\n          parseArray(\n            valuesObj,\n            (x) => parseDataTypeValue(dataType, x) as number,\n          ),\n      );\n      if (enumValues !== undefined) {\n        enumLabels = verifyObjectProperty(obj, \"enum_labels\", (labelsObj) =>\n          parseFixedLengthArray(\n            new Array<string>(enumValues!.length),\n            labelsObj,\n            verifyString,\n          ),\n        );\n      }\n      tag = verifyOptionalObjectProperty(obj, \"tag\", verifyString);\n    }\n  }\n  return {\n    type,\n    identifier,\n    description,\n    default: defaultValue,\n    enumValues,\n    enumLabels,\n    tag,\n  } as AnnotationPropertySpec;\n}\n\nfunction annotationPropertySpecToJson(spec: AnnotationPropertySpec) {\n  const defaultValue = spec.default;\n  const isNumeric = isAnnotationNumericPropertySpec(spec);\n  const tag = isNumeric ? spec.tag : undefined;\n  const enum_values = isNumeric ? spec.enumValues : undefined;\n  const enum_labels = isNumeric ? spec.enumLabels : undefined;\n  return {\n    id: spec.identifier,\n    description: spec.description,\n    type: spec.type,\n    tag,\n    enum_values,\n    enum_labels,\n    default:\n      defaultValue === 0\n        ? undefined\n        : annotationPropertyTypeHandlers[spec.type].serializeJson(defaultValue),\n  };\n}\n\nexport function annotationPropertySpecsToJson(\n  specs: AnnotationPropertySpec[] | undefined,\n) {\n  if (specs === undefined || specs.length === 0) return undefined;\n  return specs.map(annotationPropertySpecToJson);\n}\n\nexport function parseAnnotationPropertySpecs(obj: unknown) {\n  if (obj === undefined) return [];\n  const properties = parseArray(obj, parseAnnotationPropertySpec);\n  ensureUniqueAnnotationPropertyIds(properties);\n  return properties;\n}\n\nexport interface AnnotationBase {\n  /**\n   * If equal to `undefined`, then the description is unknown (possibly still being loaded).  If\n   * equal to `null`, then there is no description.\n   */\n  description?: string | undefined | null;\n\n  id: AnnotationId;\n  type: AnnotationType;\n\n  relatedSegments?: Uint64[][];\n  properties: any[];\n}\n\nexport interface Line extends AnnotationBase {\n  pointA: Float32Array;\n  pointB: Float32Array;\n  type: AnnotationType.LINE;\n}\n\nexport interface Point extends AnnotationBase {\n  point: Float32Array;\n  type: AnnotationType.POINT;\n}\n\nexport interface AxisAlignedBoundingBox extends AnnotationBase {\n  pointA: Float32Array;\n  pointB: Float32Array;\n  type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX;\n}\n\nexport interface Ellipsoid extends AnnotationBase {\n  center: Float32Array;\n  radii: Float32Array;\n  type: AnnotationType.ELLIPSOID;\n}\n\nexport type Annotation = Line | Point | AxisAlignedBoundingBox | Ellipsoid;\n\nexport interface AnnotationTypeHandler<T extends Annotation = Annotation> {\n  icon: string;\n  description: string;\n  toJSON: (annotation: T, rank: number) => any;\n  restoreState: (annotation: T, obj: any, rank: number) => void;\n  serializedBytes: (rank: number) => number;\n  serialize: (\n    buffer: DataView,\n    offset: number,\n    isLittleEndian: boolean,\n    rank: number,\n    annotation: T,\n  ) => void;\n  deserialize: (\n    buffer: DataView,\n    offset: number,\n    isLittleEndian: boolean,\n    rank: number,\n    id: string,\n  ) => T;\n  visitGeometry: (\n    annotation: T,\n    callback: (vec: Float32Array, isVector: boolean) => void,\n  ) => void;\n}\n\nfunction serializeFloatVector(\n  buffer: DataView,\n  offset: number,\n  isLittleEndian: boolean,\n  rank: number,\n  vec: Float32Array,\n) {\n  for (let i = 0; i < rank; ++i) {\n    buffer.setFloat32(offset, vec[i], isLittleEndian);\n    offset += 4;\n  }\n  return offset;\n}\n\nfunction serializeTwoFloatVectors(\n  buffer: DataView,\n  offset: number,\n  isLittleEndian: boolean,\n  rank: number,\n  vecA: Float32Array,\n  vecB: Float32Array,\n) {\n  offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, vecA);\n  offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, vecB);\n  return offset;\n}\n\nfunction deserializeFloatVector(\n  buffer: DataView,\n  offset: number,\n  isLittleEndian: boolean,\n  rank: number,\n  vec: Float32Array,\n) {\n  for (let i = 0; i < rank; ++i) {\n    vec[i] = buffer.getFloat32(offset, isLittleEndian);\n    offset += 4;\n  }\n  return offset;\n}\n\nfunction deserializeTwoFloatVectors(\n  buffer: DataView,\n  offset: number,\n  isLittleEndian: boolean,\n  rank: number,\n  vecA: Float32Array,\n  vecB: Float32Array,\n) {\n  offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, vecA);\n  offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, vecB);\n  return offset;\n}\n\nexport const annotationTypeHandlers: Record<\n  AnnotationType,\n  AnnotationTypeHandler\n> = {\n  [AnnotationType.LINE]: {\n    icon: \"\",\n    description: \"Line\",\n    toJSON(annotation: Line) {\n      return {\n        pointA: Array.from(annotation.pointA),\n        pointB: Array.from(annotation.pointB),\n      };\n    },\n    restoreState(annotation: Line, obj: any, rank: number) {\n      annotation.pointA = verifyObjectProperty(obj, \"pointA\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n      annotation.pointB = verifyObjectProperty(obj, \"pointB\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n    },\n    serializedBytes(rank: number) {\n      return 2 * 4 * rank;\n    },\n    serialize(\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      annotation: Line,\n    ) {\n      serializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        annotation.pointA,\n        annotation.pointB,\n      );\n    },\n    deserialize: (\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      id: string,\n    ): Line => {\n      const pointA = new Float32Array(rank);\n      const pointB = new Float32Array(rank);\n      deserializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        pointA,\n        pointB,\n      );\n      return { type: AnnotationType.LINE, pointA, pointB, id, properties: [] };\n    },\n    visitGeometry(annotation: Line, callback) {\n      callback(annotation.pointA, false);\n      callback(annotation.pointB, false);\n    },\n  },\n  [AnnotationType.POINT]: {\n    icon: \"\",\n    description: \"Point\",\n    toJSON: (annotation: Point) => {\n      return {\n        point: Array.from(annotation.point),\n      };\n    },\n    restoreState: (annotation: Point, obj: any, rank: number) => {\n      annotation.point = verifyObjectProperty(obj, \"point\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n    },\n    serializedBytes: (rank) => rank * 4,\n    serialize: (\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      annotation: Point,\n    ) => {\n      serializeFloatVector(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        annotation.point,\n      );\n    },\n    deserialize: (\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      id: string,\n    ): Point => {\n      const point = new Float32Array(rank);\n      deserializeFloatVector(buffer, offset, isLittleEndian, rank, point);\n      return { type: AnnotationType.POINT, point, id, properties: [] };\n    },\n    visitGeometry(annotation: Point, callback) {\n      callback(annotation.point, false);\n    },\n  },\n  [AnnotationType.AXIS_ALIGNED_BOUNDING_BOX]: {\n    icon: \"\",\n    description: \"Bounding Box\",\n    toJSON: (annotation: AxisAlignedBoundingBox) => {\n      return {\n        pointA: Array.from(annotation.pointA),\n        pointB: Array.from(annotation.pointB),\n      };\n    },\n    restoreState: (\n      annotation: AxisAlignedBoundingBox,\n      obj: any,\n      rank: number,\n    ) => {\n      annotation.pointA = verifyObjectProperty(obj, \"pointA\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n      annotation.pointB = verifyObjectProperty(obj, \"pointB\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n    },\n    serializedBytes: (rank) => 2 * 4 * rank,\n    serialize(\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      annotation: AxisAlignedBoundingBox,\n    ) {\n      serializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        annotation.pointA,\n        annotation.pointB,\n      );\n    },\n    deserialize: (\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      id: string,\n    ): AxisAlignedBoundingBox => {\n      const pointA = new Float32Array(rank);\n      const pointB = new Float32Array(rank);\n      deserializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        pointA,\n        pointB,\n      );\n      return {\n        type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,\n        pointA,\n        pointB,\n        id,\n        properties: [],\n      };\n    },\n    visitGeometry(annotation: AxisAlignedBoundingBox, callback) {\n      callback(annotation.pointA, false);\n      callback(annotation.pointB, false);\n    },\n  },\n  [AnnotationType.ELLIPSOID]: {\n    icon: \"\",\n    description: \"Ellipsoid\",\n    toJSON: (annotation: Ellipsoid) => {\n      return {\n        center: Array.from(annotation.center),\n        radii: Array.from(annotation.radii),\n      };\n    },\n    restoreState: (annotation: Ellipsoid, obj: any, rank: number) => {\n      annotation.center = verifyObjectProperty(obj, \"center\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n      annotation.radii = verifyObjectProperty(obj, \"radii\", (x) =>\n        parseFixedLengthArray(\n          new Float32Array(rank),\n          x,\n          verifyFiniteNonNegativeFloat,\n        ),\n      );\n    },\n    serializedBytes: (rank) => 2 * 4 * rank,\n    serialize(\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      annotation: Ellipsoid,\n    ) {\n      serializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        annotation.center,\n        annotation.radii,\n      );\n    },\n    deserialize: (\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      id: string,\n    ): Ellipsoid => {\n      const center = new Float32Array(rank);\n      const radii = new Float32Array(rank);\n      deserializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        center,\n        radii,\n      );\n      return {\n        type: AnnotationType.ELLIPSOID,\n        center,\n        radii,\n        id,\n        properties: [],\n      };\n    },\n    visitGeometry(annotation: Ellipsoid, callback) {\n      callback(annotation.center, false);\n      callback(annotation.radii, true);\n    },\n  },\n};\n\nexport interface AnnotationSchema {\n  rank: number;\n  relationships: readonly string[];\n  properties: WatchableValue<readonly Readonly<AnnotationPropertySpec>[]>;\n}\n\nexport function annotationToJson(\n  annotation: Annotation,\n  schema: AnnotationSchema,\n) {\n  const result = annotationTypeHandlers[annotation.type].toJSON(\n    annotation,\n    schema.rank,\n  );\n  result.type = AnnotationType[annotation.type].toLowerCase();\n  result.id = annotation.id;\n  result.description = annotation.description || undefined;\n  const { relatedSegments } = annotation;\n  if (relatedSegments?.some((x) => x.length !== 0)) {\n    result.segments = relatedSegments.map((segments) =>\n      segments.map((x) => x.toString()),\n    );\n  }\n  const propertySpecs = schema.properties.value;\n  if (propertySpecs.length !== 0) {\n    result.props = annotation.properties.map((prop, i) =>\n      annotationPropertyTypeHandlers[propertySpecs[i].type].serializeJson(prop),\n    );\n  }\n  return result;\n}\n\nfunction restoreAnnotation(\n  obj: any,\n  schema: AnnotationSchema,\n  allowMissingId = false,\n): Annotation {\n  verifyObject(obj);\n  const type = verifyObjectProperty(obj, \"type\", (x) =>\n    verifyEnumString(x, AnnotationType),\n  );\n  const id =\n    verifyObjectProperty(\n      obj,\n      \"id\",\n      allowMissingId ? verifyOptionalString : verifyString,\n    ) || makeAnnotationId();\n  const relatedSegments = verifyObjectProperty(obj, \"segments\", (relObj) => {\n    if (relObj === undefined) {\n      return schema.relationships.map(() => []);\n    }\n    const a = expectArray(relObj);\n    if (a.length === 0) {\n      return schema.relationships.map(() => []);\n    }\n    if (schema.relationships.length === 1 && !Array.isArray(a[0])) {\n      return [parseArray(a, (x) => Uint64.parseString(x))];\n    }\n    return parseArray(\n      expectArray(relObj, schema.relationships.length),\n      (segments) => parseArray(segments, (y) => Uint64.parseString(y)),\n    );\n  });\n  const properties = verifyObjectProperty(obj, \"props\", (propsObj) => {\n    const propSpecs = schema.properties.value;\n    if (propsObj === undefined) return propSpecs.map((x) => x.default);\n    return parseArray(expectArray(propsObj, propSpecs.length), (x, i) =>\n      annotationPropertyTypeHandlers[propSpecs[i].type].deserializeJson(x),\n    );\n  });\n  const result: Annotation = {\n    id,\n    description: verifyObjectProperty(obj, \"description\", verifyOptionalString),\n    relatedSegments,\n    properties,\n    type,\n  } as Annotation;\n  annotationTypeHandlers[type].restoreState(result, obj, schema.rank);\n  return result;\n}\n\nexport interface AnnotationSourceSignals {\n  changed: NullarySignal;\n  childAdded: Signal<(annotation: Annotation) => void>;\n  childUpdated: Signal<(annotation: Annotation) => void>;\n  childCommitted: Signal<(annotationId: string) => void>;\n  childDeleted: Signal<(annotationId: string) => void>;\n}\n\nexport class AnnotationSource\n  extends RefCounted\n  implements AnnotationSourceSignals\n{\n  protected annotationMap = new Map<AnnotationId, Annotation>();\n  changed = new NullarySignal();\n  readonly = false;\n  childAdded = new Signal<(annotation: Annotation) => void>();\n  childUpdated = new Signal<(annotation: Annotation) => void>();\n  childCommitted = new Signal<(annotationId: string) => void>();\n  childDeleted = new Signal<(annotationId: string) => void>();\n\n  public pending = new Set<AnnotationId>();\n\n  protected rank_: number;\n\n  get rank() {\n    return this.rank_;\n  }\n\n  annotationPropertySerializers: AnnotationPropertySerializer[];\n\n  constructor(\n    rank: number,\n    public readonly relationships: readonly string[] = [],\n    public readonly properties: WatchableValue<\n      readonly Readonly<AnnotationPropertySpec>[]\n    > = new WatchableValue([]),\n  ) {\n    super();\n    this.rank_ = rank;\n    this.annotationPropertySerializers = makeAnnotationPropertySerializers(\n      rank,\n      properties.value,\n    );\n  }\n\n  hasNonSerializedProperties() {\n    return true;\n  }\n\n  add(annotation: Annotation, commit = true): AnnotationReference {\n    this.ensureUpdated();\n    if (!annotation.id) {\n      annotation.id = makeAnnotationId();\n    } else if (this.annotationMap.has(annotation.id)) {\n      throw new Error(\n        `Annotation id already exists: ${JSON.stringify(annotation.id)}.`,\n      );\n    }\n    this.annotationMap.set(annotation.id, annotation);\n    if (!commit) {\n      this.pending.add(annotation.id);\n    }\n    this.changed.dispatch();\n    this.childAdded.dispatch(annotation);\n    if (commit) {\n      this.childCommitted.dispatch(annotation.id);\n    }\n    return this.getReference(annotation.id);\n  }\n\n  commit(reference: AnnotationReference): void {\n    this.ensureUpdated();\n    const id = reference.id;\n    this.pending.delete(id);\n    this.changed.dispatch();\n    this.childCommitted.dispatch(id);\n  }\n\n  update(reference: AnnotationReference, annotation: Annotation) {\n    this.ensureUpdated();\n    if (reference.value === null) {\n      throw new Error(\"Annotation already deleted.\");\n    }\n    reference.value = annotation;\n    this.annotationMap.set(annotation.id, annotation);\n    reference.changed.dispatch();\n    this.changed.dispatch();\n    this.childUpdated.dispatch(annotation);\n  }\n\n  [Symbol.iterator]() {\n    this.ensureUpdated();\n    return this.annotationMap.values();\n  }\n\n  get(id: AnnotationId) {\n    this.ensureUpdated();\n    return this.annotationMap.get(id);\n  }\n\n  delete(reference: AnnotationReference) {\n    if (reference.value === null) {\n      return;\n    }\n    reference.value = null;\n    this.annotationMap.delete(reference.id);\n    this.pending.delete(reference.id);\n    reference.changed.dispatch();\n    this.changed.dispatch();\n    this.childDeleted.dispatch(reference.id);\n  }\n\n  getReference(id: AnnotationId): AnnotationReference {\n    let existing = this.references.get(id);\n    if (existing !== undefined) {\n      return existing.addRef();\n    }\n    existing = new AnnotationReference(id);\n    existing.value = this.annotationMap.get(id) || null;\n    this.references.set(id, existing);\n    existing.registerDisposer(() => {\n      this.references.delete(id);\n    });\n    return existing;\n  }\n\n  references = new Map<AnnotationId, Borrowed<AnnotationReference>>();\n\n  protected ensureUpdated() {}\n\n  toJSON() {\n    this.ensureUpdated();\n    const result: any[] = [];\n    const { pending } = this;\n    for (const annotation of this) {\n      if (pending.has(annotation.id)) {\n        // Don't serialize uncommitted annotations.\n        continue;\n      }\n      result.push(annotationToJson(annotation, this));\n    }\n    return result;\n  }\n\n  clear() {\n    this.annotationMap.clear();\n    this.pending.clear();\n    this.changed.dispatch();\n  }\n\n  restoreState(obj: any) {\n    this.ensureUpdated();\n    const { annotationMap } = this;\n    annotationMap.clear();\n    this.pending.clear();\n    if (obj !== undefined) {\n      parseArray(obj, (x) => {\n        const annotation = restoreAnnotation(x, this);\n        annotationMap.set(annotation.id, annotation);\n      });\n    }\n    for (const reference of this.references.values()) {\n      const { id } = reference;\n      const value = annotationMap.get(id);\n      reference.value = value || null;\n      reference.changed.dispatch();\n    }\n    this.changed.dispatch();\n  }\n\n  reset() {\n    this.clear();\n  }\n}\n\nexport class LocalAnnotationSource extends AnnotationSource {\n  private curCoordinateTransform: CoordinateSpaceTransform;\n\n  get rank() {\n    this.ensureUpdated();\n    return this.rank_;\n  }\n\n  constructor(\n    public watchableTransform: WatchableCoordinateSpaceTransform,\n    public readonly properties: WatchableValue<\n      AnnotationPropertySpec[]\n    > = new WatchableValue([]),\n    relationships: string[],\n  ) {\n    super(watchableTransform.value.sourceRank, relationships, properties);\n    this.curCoordinateTransform = watchableTransform.value;\n    this.registerDisposer(\n      watchableTransform.changed.add(() => this.ensureUpdated()),\n    );\n\n    this.registerDisposer(\n      properties.changed.add(() => {\n        this.updateAnnotationPropertySerializers();\n        this.changed.dispatch();\n      }),\n    );\n  }\n\n  updateAnnotationPropertySerializers() {\n    this.annotationPropertySerializers = makeAnnotationPropertySerializers(\n      this.rank_,\n      this.properties.value,\n    );\n  }\n\n  addProperty(property: AnnotationPropertySpec) {\n    this.properties.value.push(property);\n    for (const annotation of this) {\n      annotation.properties.push(property.default);\n    }\n    this.properties.changed.dispatch();\n  }\n\n  removeProperty(identifier: string) {\n    const propertyIndex = this.properties.value.findIndex(\n      (x) => x.identifier === identifier,\n    );\n    this.properties.value.splice(propertyIndex, 1);\n    for (const annotation of this) {\n      annotation.properties.splice(propertyIndex, 1);\n    }\n    this.properties.changed.dispatch();\n  }\n\n  getTagProperties = () => {\n    const { properties } = this;\n    return properties.value.filter(isAnnotationTagPropertySpec);\n  };\n\n  ensureUpdated() {\n    const transform = this.watchableTransform.value;\n    const { curCoordinateTransform } = this;\n    if (transform === curCoordinateTransform) return;\n    this.curCoordinateTransform = transform;\n    const sourceRank = transform.sourceRank;\n    const oldSourceRank = curCoordinateTransform.sourceRank;\n    if (\n      oldSourceRank === sourceRank &&\n      (curCoordinateTransform.inputSpace === transform.inputSpace ||\n        arraysEqual(\n          curCoordinateTransform.inputSpace.ids.slice(0, sourceRank),\n          transform.inputSpace.ids.slice(0, sourceRank),\n        ))\n    ) {\n      return;\n    }\n    const { ids: newIds } = transform.inputSpace;\n    const oldIds = curCoordinateTransform.inputSpace.ids;\n    const newToOldDims: number[] = [];\n    for (let newDim = 0; newDim < sourceRank; ++newDim) {\n      let oldDim = oldIds.indexOf(newIds[newDim]);\n      if (oldDim >= oldSourceRank) {\n        oldDim = -1;\n      }\n      newToOldDims.push(oldDim);\n    }\n    const mapVector = (radii: Float32Array) => {\n      const newRadii = new Float32Array(sourceRank);\n      for (let i = 0; i < sourceRank; ++i) {\n        const oldDim = newToOldDims[i];\n        newRadii[i] = oldDim === -1 ? 0 : radii[i];\n      }\n      return newRadii;\n    };\n\n    for (const annotation of this.annotationMap.values()) {\n      switch (annotation.type) {\n        case AnnotationType.POINT:\n          annotation.point = mapVector(annotation.point);\n          break;\n        case AnnotationType.LINE:\n        case AnnotationType.AXIS_ALIGNED_BOUNDING_BOX:\n          annotation.pointA = mapVector(annotation.pointA);\n          annotation.pointB = mapVector(annotation.pointB);\n          break;\n        case AnnotationType.ELLIPSOID:\n          annotation.center = mapVector(annotation.center);\n          annotation.radii = mapVector(annotation.radii);\n          break;\n      }\n    }\n    if (this.rank_ !== sourceRank) {\n      this.rank_ = sourceRank;\n      this.updateAnnotationPropertySerializers();\n    }\n    this.changed.dispatch();\n  }\n}\n\nexport const DATA_BOUNDS_DESCRIPTION = \"Data Bounds\";\n\nexport function makeAnnotationId() {\n  return getRandomHexString(160);\n}\n\nexport function makeDataBoundsBoundingBoxAnnotation(\n  box: BoundingBox,\n): AxisAlignedBoundingBox {\n  return {\n    type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,\n    id: \"data-bounds\",\n    description: DATA_BOUNDS_DESCRIPTION,\n    pointA: new Float32Array(box.lowerBounds),\n    pointB: new Float32Array(box.upperBounds),\n    properties: [],\n  };\n}\n\nexport function makeDataBoundsBoundingBoxAnnotationSet(\n  box: BoundingBox,\n): AnnotationSource {\n  const annotationSource = new AnnotationSource(box.lowerBounds.length);\n  annotationSource.readonly = true;\n  annotationSource.add(makeDataBoundsBoundingBoxAnnotation(box));\n  return annotationSource;\n}\n\nexport interface SerializedAnnotations {\n  data: Uint8Array<ArrayBuffer>;\n  typeToIds: string[][];\n  typeToOffset: number[];\n  typeToIdMaps: Map<string, number>[];\n}\n\nfunction serializeAnnotations(\n  allAnnotations: Annotation[][],\n  propertySerializers: AnnotationPropertySerializer[],\n): SerializedAnnotations {\n  let totalBytes = 0;\n  const typeToOffset: number[] = [];\n  for (const annotationType of annotationTypes) {\n    const propertySerializer = propertySerializers[annotationType];\n    const serializedPropertiesBytes = propertySerializer.serializedBytes;\n    typeToOffset[annotationType] = totalBytes;\n    const annotations: Annotation[] = allAnnotations[annotationType];\n    const count = annotations.length;\n    totalBytes += serializedPropertiesBytes * count;\n  }\n  const typeToIds: string[][] = [];\n  const typeToIdMaps: Map<string, number>[] = [];\n  const data = new ArrayBuffer(totalBytes);\n  const dataView = new DataView(data);\n  const isLittleEndian = ENDIANNESS === Endianness.LITTLE;\n  for (const annotationType of annotationTypes) {\n    const propertySerializer = propertySerializers[annotationType];\n    const { rank } = propertySerializer;\n    const serializeProperties = propertySerializer.serialize;\n    const annotations: Annotation[] = allAnnotations[annotationType];\n    typeToIds[annotationType] = annotations.map((x) => x.id);\n    typeToIdMaps[annotationType] = new Map(\n      annotations.map((x, i) => [x.id, i]),\n    );\n    const handler = annotationTypeHandlers[annotationType];\n    const serialize = handler.serialize;\n    const offset = typeToOffset[annotationType];\n    const geometryDataStride = propertySerializer.propertyGroupBytes[0];\n    for (let i = 0, count = annotations.length; i < count; ++i) {\n      const annotation = annotations[i];\n      serialize(\n        dataView,\n        offset + i * geometryDataStride,\n        isLittleEndian,\n        rank,\n        annotation,\n      );\n      serializeProperties(\n        dataView,\n        offset,\n        i,\n        count,\n        isLittleEndian,\n        annotation.properties,\n      );\n    }\n  }\n  return { data: new Uint8Array(data), typeToIds, typeToOffset, typeToIdMaps };\n}\n\nexport class AnnotationSerializer {\n  annotations: [Point[], Line[], AxisAlignedBoundingBox[], Ellipsoid[]] = [\n    [],\n    [],\n    [],\n    [],\n  ];\n  constructor(public propertySerializers: AnnotationPropertySerializer[]) {}\n  add(annotation: Annotation) {\n    (<Annotation[]>this.annotations[annotation.type]).push(annotation);\n  }\n  serialize(): SerializedAnnotations {\n    return serializeAnnotations(this.annotations, this.propertySerializers);\n  }\n}\n\nexport function fixAnnotationAfterStructuredCloning(obj: Annotation | null) {\n  if (obj == null) {\n    return obj;\n  }\n  const { relatedSegments } = obj;\n  if (relatedSegments !== undefined) {\n    for (\n      let i = 0, numRelationships = relatedSegments.length;\n      i < numRelationships;\n      ++i\n    ) {\n      const segments = relatedSegments[i];\n      if (segments === undefined) continue;\n      relatedSegments[i] = segments.map(\n        (x: { low: number; high: number }) => new Uint64(x.low, x.high),\n      );\n    }\n  }\n  return obj;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { NIFTI2 } from \"nifti-reader-js\";\nimport { isCompressed, NIFTI1, readHeader, readImage } from \"nifti-reader-js\";\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier } from \"#src/chunk_manager/base.js\";\nimport type { PriorityGetter } from \"#src/chunk_manager/generic_file_source.js\";\nimport { GenericSharedDataSource } from \"#src/chunk_manager/generic_file_source.js\";\nimport type { SharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport type { NiftiVolumeInfo } from \"#src/datasource/nifti/base.js\";\nimport {\n  GET_NIFTI_VOLUME_INFO_RPC_ID,\n  VolumeSourceParameters,\n} from \"#src/datasource/nifti/base.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { DataType } from \"#src/sliceview/volume/base.js\";\nimport type { Borrowed } from \"#src/util/disposable.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport {\n  kOneVec,\n  mat4,\n  quat,\n  translationRotationScaleZReflectionToMat4,\n  vec3,\n} from \"#src/util/geom.js\";\nimport { decodeGzip } from \"#src/util/gzip.js\";\nimport * as matrix from \"#src/util/matrix.js\";\nimport type {\n  SpecialProtocolCredentials,\n  SpecialProtocolCredentialsProvider,\n} from \"#src/util/special_protocol_request.js\";\nimport type { RPCPromise } from \"#src/worker_rpc.js\";\nimport { registerPromiseRPC, registerSharedObject } from \"#src/worker_rpc.js\";\n\nexport class NiftiFileData {\n  uncompressedData: ArrayBuffer;\n  header: NIFTI1 | NIFTI2;\n}\n\nasync function decodeNiftiFile(\n  buffer: ArrayBuffer,\n  _cancellationToken: AbortSignal,\n) {\n  if (isCompressed(buffer)) {\n    buffer = await decodeGzip(buffer, \"gzip\");\n  }\n  const data = new NiftiFileData();\n  data.uncompressedData = buffer;\n  const header = readHeader(buffer);\n  if (header === null) {\n    throw new Error(\"Failed to parse NIFTI header.\");\n  }\n  data.header = header;\n  return { data, size: buffer.byteLength };\n}\n\nfunction getNiftiFileData(\n  chunkManager: Borrowed<ChunkManager>,\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  url: string,\n  getPriority: PriorityGetter,\n  abortSignal: AbortSignal,\n) {\n  return GenericSharedDataSource.getUrl(\n    chunkManager,\n    credentialsProvider,\n    decodeNiftiFile,\n    url,\n    getPriority,\n    abortSignal,\n  );\n}\n\nconst NIFTI_HEADER_INFO_PRIORITY = 1000;\n\nasync function getNiftiHeaderInfo(\n  chunkManager: Borrowed<ChunkManager>,\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  url: string,\n  abortSignal: AbortSignal,\n) {\n  const data = await getNiftiFileData(\n    chunkManager,\n    credentialsProvider,\n    url,\n    () => ({\n      priorityTier: ChunkPriorityTier.VISIBLE,\n      priority: NIFTI_HEADER_INFO_PRIORITY,\n    }),\n    abortSignal,\n  );\n  return data.header;\n}\n\nfunction convertAffine(affine: number[][]) {\n  return mat4.fromValues(\n    affine[0][0],\n    affine[1][0],\n    affine[2][0],\n    affine[3][0],\n    affine[0][1],\n    affine[1][1],\n    affine[2][1],\n    affine[3][1],\n    affine[0][2],\n    affine[1][2],\n    affine[2][2],\n    affine[3][2],\n    affine[0][3],\n    affine[1][3],\n    affine[2][3],\n    affine[3][3],\n  );\n}\n\nenum NiftiDataType {\n  NONE = 0,\n  BINARY = 1,\n  UINT8 = 2,\n  INT16 = 4,\n  INT32 = 8,\n  FLOAT32 = 16,\n  COMPLEX64 = 32,\n  FLOAT64 = 64,\n  RGB24 = 128,\n  INT8 = 256,\n  UINT16 = 512,\n  UINT32 = 768,\n  INT64 = 1024,\n  UINT64 = 1280,\n  FLOAT128 = 1536,\n  COMPLEX128 = 1792,\n  COMPLEX256 = 2048,\n}\n\nconst DATA_TYPE_CONVERSIONS = new Map([\n  [NiftiDataType.INT8, { dataType: DataType.INT8 }],\n  [NiftiDataType.UINT8, { dataType: DataType.UINT8 }],\n  [NiftiDataType.INT16, { dataType: DataType.INT16 }],\n  [NiftiDataType.UINT16, { dataType: DataType.UINT16 }],\n  [NiftiDataType.INT32, { dataType: DataType.INT32 }],\n  [NiftiDataType.UINT32, { dataType: DataType.UINT32 }],\n  [NiftiDataType.INT64, { dataType: DataType.UINT64 }],\n  [NiftiDataType.UINT64, { dataType: DataType.UINT64 }],\n  [NiftiDataType.FLOAT32, { dataType: DataType.FLOAT32 }],\n]);\n\nregisterPromiseRPC(\n  GET_NIFTI_VOLUME_INFO_RPC_ID,\n  async function (x, abortSignal): RPCPromise<NiftiVolumeInfo> {\n    const chunkManager = this.getRef<ChunkManager>(x.chunkManager);\n    const credentialsProvider = this.getOptionalRef<\n      SharedCredentialsProviderCounterpart<\n        Exclude<SpecialProtocolCredentials, undefined>\n      >\n    >(x.credentialsProvider);\n    try {\n      const header = await getNiftiHeaderInfo(\n        chunkManager,\n        credentialsProvider,\n        x.url,\n        abortSignal,\n      );\n      const dataTypeInfo = DATA_TYPE_CONVERSIONS.get(header.datatypeCode);\n      if (dataTypeInfo === undefined) {\n        throw new Error(\n          \"Unsupported data type: \" +\n            `${NiftiDataType[header.datatypeCode] || header.datatypeCode}.`,\n        );\n      }\n      let spatialInvScale = 1;\n      let spatialUnit = \"\";\n      switch (header.xyzt_units & NIFTI1.SPATIAL_UNITS_MASK) {\n        case NIFTI1.UNITS_METER:\n          spatialInvScale = 1;\n          spatialUnit = \"m\";\n          break;\n        case NIFTI1.UNITS_MM:\n          spatialInvScale = 1e3;\n          spatialUnit = \"m\";\n          break;\n        case NIFTI1.UNITS_MICRON:\n          spatialInvScale = 1e6;\n          spatialUnit = \"m\";\n          break;\n      }\n\n      let timeUnit = \"\";\n      let timeInvScale = 1;\n      switch (header.xyzt_units & NIFTI1.TEMPORAL_UNITS_MASK) {\n        case NIFTI1.UNITS_SEC:\n          timeUnit = \"s\";\n          timeInvScale = 1;\n          break;\n        case NIFTI1.UNITS_MSEC:\n          timeUnit = \"s\";\n          timeInvScale = 1e3;\n          break;\n        case NIFTI1.UNITS_USEC:\n          timeUnit = \"s\";\n          timeInvScale = 1e6;\n          break;\n        case NIFTI1.UNITS_HZ:\n          timeUnit = \"Hz\";\n          timeInvScale = 1;\n          break;\n        case NIFTI1.UNITS_RADS:\n          timeUnit = \"rad/s\";\n          timeInvScale = 1;\n          break;\n      }\n      let units: string[] = [\n        spatialUnit,\n        spatialUnit,\n        spatialUnit,\n        timeUnit,\n        \"\",\n        \"\",\n        \"\",\n      ];\n      let sourceScales = Float64Array.of(\n        header.pixDims[1] / spatialInvScale,\n        header.pixDims[2] / spatialInvScale,\n        header.pixDims[3] / spatialInvScale,\n        header.pixDims[4] / timeInvScale,\n        header.pixDims[5],\n        header.pixDims[6],\n        header.pixDims[7],\n      );\n      let viewScales = Float64Array.of(\n        1 / spatialInvScale,\n        1 / spatialInvScale,\n        1 / spatialInvScale,\n        1 / timeInvScale,\n        1,\n        1,\n        1,\n      );\n      let sourceNames = [\"i\", \"j\", \"k\", \"m\", \"c^\", \"c1^\", \"c2^\"];\n      let viewNames = [\"x\", \"y\", \"z\", \"t\", \"c^\", \"c1^\", \"c2^\"];\n      const rank = header.dims[0];\n      sourceNames = sourceNames.slice(0, rank);\n      viewNames = viewNames.slice(0, rank);\n      units = units.slice(0, rank);\n      sourceScales = sourceScales.slice(0, rank);\n      viewScales = viewScales.slice(0, rank);\n      const { quatern_b, quatern_c, quatern_d } = header;\n      const quatern_a = Math.sqrt(\n        1.0 -\n          quatern_b * quatern_b -\n          quatern_c * quatern_c -\n          quatern_d * quatern_d,\n      );\n      const qfac = header.pixDims[0] === -1 ? -1 : 1;\n      const qoffset = vec3.fromValues(\n        header.qoffset_x,\n        header.qoffset_y,\n        header.qoffset_z,\n      );\n      // https://nifti.nimh.nih.gov/nifti-1/documentation/nifti1fields/nifti1fields_pages/qsform.html\n      const method3Transform = convertAffine(header.affine);\n      method3Transform;\n      const method2Transform = translationRotationScaleZReflectionToMat4(\n        mat4.create(),\n        qoffset,\n        quat.fromValues(quatern_b, quatern_c, quatern_d, quatern_a),\n        kOneVec,\n        qfac,\n      );\n      const transform = matrix.createIdentity(Float64Array, rank + 1);\n      const copyRank = Math.min(3, rank);\n      for (let row = 0; row < copyRank; ++row) {\n        for (let col = 0; col < copyRank; ++col) {\n          transform[col * (rank + 1) + row] = method2Transform[col * 4 + row];\n        }\n        transform[rank * (rank + 1) + row] = method2Transform[12 + row];\n      }\n      const info: NiftiVolumeInfo = {\n        rank,\n        sourceNames,\n        viewNames,\n        units,\n        sourceScales,\n        viewScales,\n        description: header.description,\n        transform,\n        dataType: dataTypeInfo.dataType,\n        volumeSize: Uint32Array.from(header.dims.slice(1, 1 + rank)),\n      };\n      return { value: info };\n    } finally {\n      chunkManager.dispose();\n      credentialsProvider?.dispose();\n    }\n  },\n);\n\n@registerSharedObject()\nexport class NiftiVolumeChunkSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    VolumeChunkSource,\n  ),\n  VolumeSourceParameters,\n) {\n  async download(chunk: VolumeChunk, abortSignal: AbortSignal) {\n    chunk.chunkDataSize = this.spec.chunkDataSize;\n    const data = await getNiftiFileData(\n      this.chunkManager,\n      this.credentialsProvider,\n      this.parameters.url,\n      () => ({ priorityTier: chunk.priorityTier, priority: chunk.priority }),\n      abortSignal,\n    );\n    const imageBuffer = readImage(data.header, data.uncompressedData);\n    await decodeRawChunk(\n      chunk,\n      abortSignal,\n      imageBuffer,\n      data.header.littleEndian ? Endianness.LITTLE : Endianness.BIG,\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport {\n  Chunk,\n  ChunkSource,\n  withChunkManager,\n  WithParameters,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier } from \"#src/chunk_manager/base.js\";\nimport type { PriorityGetter } from \"#src/chunk_manager/generic_file_source.js\";\nimport type { SharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport { computeVertexNormals } from \"#src/mesh/backend.js\";\nimport type {\n  SingleMeshData,\n  SingleMeshInfo,\n  SingleMeshSourceParameters,\n  VertexAttributeInfo,\n} from \"#src/single_mesh/base.js\";\nimport {\n  GET_SINGLE_MESH_INFO_RPC_ID,\n  SINGLE_MESH_CHUNK_KEY,\n  SINGLE_MESH_LAYER_RPC_ID,\n  SingleMeshSourceParametersWithInfo,\n} from \"#src/single_mesh/base.js\";\nimport type { TypedArray } from \"#src/util/array.js\";\nimport { stableStringify } from \"#src/util/json.js\";\nimport type {\n  SpecialProtocolCredentials,\n  SpecialProtocolCredentialsProvider,\n} from \"#src/util/special_protocol_request.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC, RPCPromise } from \"#src/worker_rpc.js\";\nimport {\n  registerPromiseRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nconst SINGLE_MESH_CHUNK_PRIORITY = 50;\n\n/**\n * Chunk that contains the single mesh.\n */\nexport class SingleMeshChunk extends Chunk {\n  data: SingleMeshData | null = null;\n  freeSystemMemory() {\n    this.data = null;\n  }\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    const { vertexPositions, indices, vertexNormals, vertexAttributes } =\n      this.data!;\n    msg.vertexPositions = vertexPositions;\n    msg.indices = indices;\n    msg.vertexNormals = vertexNormals;\n    msg.vertexAttributes = vertexAttributes;\n    const transferSet = new Set<ArrayBuffer>();\n    transferSet.add(vertexPositions!.buffer);\n    transferSet.add(indices!.buffer);\n    transferSet.add(vertexNormals!.buffer);\n    for (const data of vertexAttributes!) {\n      transferSet.add(data.buffer);\n    }\n    transfers.push(...transferSet);\n    this.data = null;\n  }\n  downloadSucceeded() {\n    const { vertexPositions, indices, vertexNormals, vertexAttributes } =\n      this.data!;\n    let totalBytes = (this.gpuMemoryBytes =\n      vertexPositions.byteLength +\n      indices.byteLength +\n      vertexNormals!.byteLength);\n    for (const data of vertexAttributes) {\n      totalBytes += data.byteLength;\n    }\n    this.systemMemoryBytes = this.gpuMemoryBytes = totalBytes;\n    super.downloadSucceeded();\n  }\n}\n\nexport interface SingleMesh extends SingleMeshData {\n  info: SingleMeshInfo;\n}\n\nexport interface SingleMeshVertexAttributes {\n  numVertices: number;\n  attributeInfo: VertexAttributeInfo[];\n  attributes: Float32Array[];\n}\n\ninterface SingleMeshFactory {\n  description?: string;\n  getMesh: (\n    chunkManager: ChunkManager,\n    credentialsProvider: SpecialProtocolCredentialsProvider,\n    url: string,\n    getPriority: PriorityGetter,\n    abortSignal: AbortSignal,\n  ) => Promise<SingleMesh>;\n}\n\nconst singleMeshFactories = new Map<string, SingleMeshFactory>();\nexport function registerSingleMeshFactory(\n  name: string,\n  factory: SingleMeshFactory,\n) {\n  singleMeshFactories.set(name, factory);\n}\n\nconst protocolPattern = /^(?:([a-zA-Z-+_]+):\\/\\/)?(.*)$/;\n\nfunction getDataSource<T>(\n  factories: Map<string, T>,\n  url: string,\n): [T, string, string] {\n  const m = url.match(protocolPattern);\n  if (m === null || m[1] === undefined) {\n    throw new Error(\n      `Data source URL must have the form \"<protocol>://<path>\".`,\n    );\n  }\n  const dataSource = m[1];\n  const factory = factories.get(dataSource);\n  if (factory === undefined) {\n    throw new Error(`Unsupported data source: ${JSON.stringify(dataSource)}.`);\n  }\n  return [factory, m[2], dataSource];\n}\n\nexport function getMesh(\n  chunkManager: ChunkManager,\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  url: string,\n  getPriority: PriorityGetter,\n  abortSignal: AbortSignal,\n) {\n  const [factory, path] = getDataSource(singleMeshFactories, url);\n  return factory.getMesh(\n    chunkManager,\n    credentialsProvider,\n    path,\n    getPriority,\n    abortSignal,\n  );\n}\n\nexport function getMinMax(array: TypedArray): [number, number] {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n  for (const value of array) {\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n  }\n  return [min, max];\n}\n\nexport function getCombinedMesh(\n  chunkManager: ChunkManager,\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  parameters: SingleMeshSourceParameters,\n  getPriority: PriorityGetter,\n  abortSignal: AbortSignal,\n) {\n  return getMesh(\n    chunkManager,\n    credentialsProvider,\n    parameters.meshSourceUrl,\n    getPriority,\n    abortSignal,\n  );\n}\n\n@registerSharedObject()\nexport class SingleMeshSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    ChunkSource,\n  ),\n  SingleMeshSourceParametersWithInfo,\n) {\n  getChunk() {\n    const key = SINGLE_MESH_CHUNK_KEY;\n    let chunk = <SingleMeshChunk>this.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(SingleMeshChunk);\n      chunk.initialize(key);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n\n  download(chunk: SingleMeshChunk, abortSignal: AbortSignal) {\n    const getPriority = () => ({\n      priorityTier: chunk.priorityTier,\n      priority: chunk.priority,\n    });\n    return getCombinedMesh(\n      this.chunkManager,\n      this.credentialsProvider,\n      this.parameters,\n      getPriority,\n      abortSignal,\n    ).then((data) => {\n      if (\n        stableStringify(data.info) !== stableStringify(this.parameters.info)\n      ) {\n        throw new Error(\"Mesh info has changed.\");\n      }\n      if (data.vertexNormals === undefined) {\n        data.vertexNormals = computeVertexNormals(\n          data.vertexPositions,\n          data.indices,\n        );\n      }\n      chunk.data = data;\n    });\n  }\n}\n\nconst SingleMeshLayerBase = withSharedVisibility(\n  withChunkManager(SharedObjectCounterpart),\n);\n@registerSharedObject(SINGLE_MESH_LAYER_RPC_ID)\nexport class SingleMeshLayer extends SingleMeshLayerBase {\n  source: SingleMeshSource;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = this.registerDisposer(\n      rpc.getRef<SingleMeshSource>(options.source),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateChunkPriorities();\n      }),\n    );\n  }\n\n  private updateChunkPriorities() {\n    const visibility = this.visibility.value;\n    if (visibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    const priorityTier = getPriorityTier(visibility);\n    const basePriority = getBasePriority(visibility);\n    const { source, chunkManager } = this;\n    const chunk = source.getChunk();\n    chunkManager.requestChunk(\n      chunk,\n      priorityTier,\n      basePriority + SINGLE_MESH_CHUNK_PRIORITY,\n    );\n  }\n}\n\nconst INFO_PRIORITY = 1000;\n\nregisterPromiseRPC(\n  GET_SINGLE_MESH_INFO_RPC_ID,\n  async function (x, abortSignal): RPCPromise<SingleMeshInfo> {\n    const chunkManager = this.getRef<ChunkManager>(x.chunkManager);\n    const credentialsProvider = this.getOptionalRef<\n      SharedCredentialsProviderCounterpart<\n        Exclude<SpecialProtocolCredentials, undefined>\n      >\n    >(x.credentialsProvider);\n    try {\n      const parameters = <SingleMeshSourceParameters>x.parameters;\n      const mesh = await getCombinedMesh(\n        chunkManager,\n        credentialsProvider,\n        parameters,\n        () => ({\n          priorityTier: ChunkPriorityTier.VISIBLE,\n          priority: INFO_PRIORITY,\n        }),\n        abortSignal,\n      );\n      return { value: mesh.info };\n    } finally {\n      chunkManager.dispose();\n      credentialsProvider?.dispose();\n    }\n  },\n);\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  CodecArrayInfo,\n  CodecArrayLayoutInfo,\n  CodecChainSpec,\n} from \"#src/datasource/zarr/codec/index.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport {\n  parseCodecChainSpec,\n  registerCodec,\n} from \"#src/datasource/zarr/codec/resolve.js\";\nimport { parseChunkShape } from \"#src/datasource/zarr/metadata/parse.js\";\nimport { DataType } from \"#src/util/data_type.js\";\nimport {\n  verifyEnumString,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalObjectProperty,\n} from \"#src/util/json.js\";\n\nexport enum ShardIndexLocation {\n  START,\n  END,\n}\n\nexport interface Configuration {\n  indexCodecs: CodecChainSpec;\n  indexLocation: ShardIndexLocation;\n  subChunkCodecs: CodecChainSpec;\n  subChunkShape: number[];\n  subChunkGridShape: number[];\n}\n\nregisterCodec({\n  name: \"sharding_indexed\",\n  kind: CodecKind.arrayToBytes,\n  resolve(configuration: unknown, decodedArrayInfo: CodecArrayInfo) {\n    verifyObject(configuration);\n    const subChunkShape = verifyObjectProperty(\n      configuration,\n      \"chunk_shape\",\n      (value) => parseChunkShape(value, decodedArrayInfo.chunkShape.length),\n    );\n    const indexLocation = verifyOptionalObjectProperty(\n      configuration,\n      \"index_location\",\n      (x) => verifyEnumString(x, ShardIndexLocation, /^[a-z]+$/),\n      ShardIndexLocation.END,\n    );\n    const subChunkGridShape = Array.from(\n      decodedArrayInfo.chunkShape,\n      (outerSize, i) => {\n        const innerSize = subChunkShape[i];\n        if (outerSize % innerSize !== 0) {\n          throw new Error(\n            `sub-chunk shape of ${JSON.stringify(\n              innerSize,\n            )} does not evenly divide outer chunk shape of ${JSON.stringify(\n              decodedArrayInfo.chunkShape,\n            )}`,\n          );\n        }\n        return outerSize / innerSize;\n      },\n    );\n    const indexShape = Array.from(subChunkGridShape);\n    indexShape.push(2);\n    const indexCodecs = verifyObjectProperty(\n      configuration,\n      \"index_codecs\",\n      (value) =>\n        parseCodecChainSpec(value, {\n          dataType: DataType.UINT64,\n          chunkShape: indexShape,\n        }),\n    );\n    if (\n      indexCodecs.encodedSize[indexCodecs.encodedSize.length - 1] === undefined\n    ) {\n      throw new Error(\"index_codecs must specify fixed-size encoding\");\n    }\n    const subChunkCodecs = verifyObjectProperty(\n      configuration,\n      \"codecs\",\n      (value) =>\n        parseCodecChainSpec(value, {\n          dataType: decodedArrayInfo.dataType,\n          chunkShape: subChunkShape,\n        }),\n    );\n    return {\n      configuration: {\n        indexCodecs,\n        subChunkCodecs,\n        subChunkShape,\n        subChunkGridShape,\n        indexLocation,\n      },\n      shardingInfo: { subChunkShape, subChunkGridShape, subChunkCodecs },\n    };\n  },\n  getDecodedArrayLayoutInfo(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n  ): CodecArrayLayoutInfo {\n    decodedArrayInfo;\n    return configuration.subChunkCodecs.layoutInfo[0];\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  CodecArrayInfo,\n  CodecArrayLayoutInfo,\n  CodecChainSpec,\n  CodecSpec,\n  ShardingInfo,\n} from \"#src/datasource/zarr/codec/index.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport { parseNameAndConfiguration } from \"#src/datasource/zarr/metadata/parse_util.js\";\nimport { parseArray } from \"#src/util/json.js\";\n\nfunction getCodecResolver(obj: unknown): {\n  resolver: CodecResolver;\n  configuration: unknown;\n} {\n  const { name: resolver, configuration } = parseNameAndConfiguration(\n    obj,\n    (name) => {\n      const resolver = codecRegistry.get(name);\n      if (resolver === undefined) {\n        throw new Error(`Unknown codec: ${JSON.stringify(name)}`);\n      }\n      return resolver;\n    },\n    (configuration) => configuration,\n  );\n  return { resolver, configuration };\n}\n\nexport interface CodecResolver {\n  name: string;\n  kind: CodecKind;\n}\n\nexport interface ArrayToArrayCodecResolver<Configuration>\n  extends CodecResolver {\n  kind: CodecKind.arrayToArray;\n  resolve(\n    configuration: unknown,\n    decodedArrayInfo: CodecArrayInfo,\n  ): {\n    configuration: Configuration;\n    encodedArrayInfo: CodecArrayInfo;\n  };\n  getDecodedArrayLayoutInfo(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n    encodedLayout: CodecArrayLayoutInfo,\n  ): CodecArrayLayoutInfo;\n}\n\nexport interface ArrayToBytesCodecResolver<Configuration>\n  extends CodecResolver {\n  kind: CodecKind.arrayToBytes;\n  resolve(\n    configuration: unknown,\n    decodedArrayInfo: CodecArrayInfo,\n  ): {\n    configuration: Configuration;\n    shardingInfo?: ShardingInfo;\n    encodedSize?: number;\n  };\n  getDecodedArrayLayoutInfo(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n  ): CodecArrayLayoutInfo;\n}\n\nexport interface BytesToBytesCodecResolver<Configuration>\n  extends CodecResolver {\n  kind: CodecKind.bytesToBytes;\n  resolve(\n    configuration: unknown,\n    decodedSize: number | undefined,\n  ): {\n    configuration: Configuration;\n    encodedSize?: number;\n  };\n}\n\nconst codecRegistry = new Map<string, CodecResolver>();\n\nexport function registerCodec<Configuration>(\n  resolver:\n    | ArrayToArrayCodecResolver<Configuration>\n    | ArrayToBytesCodecResolver<Configuration>\n    | BytesToBytesCodecResolver<Configuration>,\n) {\n  codecRegistry.set(resolver.name, resolver);\n}\n\nexport function parseCodecChainSpec(\n  obj: unknown,\n  decodedArrayInfo: CodecArrayInfo,\n): CodecChainSpec {\n  const arrayToArray: CodecSpec<CodecKind.arrayToArray>[] = [];\n  const arrayInfo: CodecArrayInfo[] = [];\n  const layoutInfo: CodecArrayLayoutInfo[] = [];\n  const encodedSize: (number | undefined)[] = [];\n\n  arrayInfo.push(decodedArrayInfo);\n\n  const codecSpecs = parseArray(obj, getCodecResolver);\n  const numCodecs = codecSpecs.length;\n  let i = 0;\n\n  for (; i < numCodecs; ++i) {\n    const { resolver, configuration: initialConfiguration } = codecSpecs[i];\n    if (resolver.kind !== CodecKind.arrayToArray) {\n      break;\n    }\n    const arrayResolver = resolver as ArrayToArrayCodecResolver<unknown>;\n    const { configuration, encodedArrayInfo } = arrayResolver.resolve(\n      initialConfiguration,\n      decodedArrayInfo,\n    );\n    arrayInfo.push(encodedArrayInfo);\n    decodedArrayInfo = encodedArrayInfo;\n    arrayToArray.push({\n      kind: CodecKind.arrayToArray,\n      name: resolver.name,\n      configuration,\n    });\n  }\n\n  if (\n    i === numCodecs ||\n    codecSpecs[i].resolver.kind !== CodecKind.arrayToBytes\n  ) {\n    throw new Error(\"Missing array -> bytes codec\");\n  }\n\n  const {\n    codecSpec: arrayToBytes,\n    layoutInfo: finalLayoutInfo,\n    encodedSize: initialEncodedSize,\n    shardingInfo,\n  } = (() => {\n    const { resolver, configuration: initialConfiguration } = codecSpecs[i];\n    const arrayToBytesResolver = resolver as ArrayToBytesCodecResolver<unknown>;\n    const { configuration, shardingInfo, encodedSize } =\n      arrayToBytesResolver.resolve(initialConfiguration, decodedArrayInfo);\n    if (shardingInfo !== undefined) {\n      if (i + 1 !== numCodecs) {\n        throw new Error(\n          \"bytes -> bytes codecs not supported following sharding codec\",\n        );\n      }\n    }\n    const layoutInfo = arrayToBytesResolver.getDecodedArrayLayoutInfo(\n      configuration,\n      decodedArrayInfo,\n    );\n    const codecSpec: CodecSpec<CodecKind.arrayToBytes> = {\n      name: resolver.name,\n      kind: CodecKind.arrayToBytes,\n      configuration,\n    };\n    return { codecSpec, layoutInfo, encodedSize, shardingInfo };\n  })();\n\n  layoutInfo[i] = finalLayoutInfo;\n  encodedSize.push(initialEncodedSize);\n  const curEncodedSize = initialEncodedSize;\n\n  const bytesToBytes: CodecSpec<CodecKind.bytesToBytes>[] = [];\n\n  ++i;\n\n  while (i < numCodecs) {\n    const { resolver, configuration: initialConfiguration } = codecSpecs[i];\n    if (resolver.kind !== CodecKind.bytesToBytes) {\n      throw new Error(\n        `Expected bytes -> bytes codec, but received ${JSON.stringify(\n          resolver.name,\n        )} of kind ${CodecKind[resolver.kind]}`,\n      );\n    }\n    const bytesResolver = resolver as BytesToBytesCodecResolver<unknown>;\n    const { configuration, encodedSize: newEncodedSize } =\n      bytesResolver.resolve(initialConfiguration, curEncodedSize);\n    bytesToBytes.push({\n      name: resolver.name,\n      kind: resolver.kind,\n      configuration,\n    });\n    encodedSize.push(newEncodedSize);\n    ++i;\n  }\n\n  for (let j = arrayToArray.length - 1; j >= 0; --j) {\n    layoutInfo[j] = (\n      codecSpecs[j].resolver as ArrayToArrayCodecResolver<unknown>\n    ).getDecodedArrayLayoutInfo(\n      arrayToArray[j].configuration,\n      arrayInfo[j],\n      layoutInfo[j + 1],\n    );\n  }\n\n  return {\n    [CodecKind.arrayToArray]: arrayToArray,\n    [CodecKind.arrayToBytes]: arrayToBytes,\n    [CodecKind.bytesToBytes]: bytesToBytes,\n    arrayInfo,\n    layoutInfo,\n    shardingInfo,\n    encodedSize,\n  };\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ByteRange,\n  ByteRangeRequest,\n  ReadableKvStore,\n  ReadOptions,\n  ReadResponse,\n} from \"#src/kvstore/index.js\";\nimport { composeByteRangeRequest } from \"#src/kvstore/index.js\";\nimport { isNotFoundError } from \"#src/util/http_request.js\";\nimport type { SpecialProtocolCredentialsProvider } from \"#src/util/special_protocol_request.js\";\nimport { fetchSpecialOk } from \"#src/util/special_protocol_request.js\";\n\nfunction getRangeHeader(\n  request: ByteRangeRequest | undefined,\n): string | undefined {\n  if (request === undefined) return undefined;\n  if (\"suffixLength\" in request) {\n    return `bytes=-${request.suffixLength}`;\n  }\n  return `bytes=${request.offset}-${request.offset + request.length - 1}`;\n}\n\n/**\n * On Chromium, multiple concurrent byte range requests to the same URL are serialized unless the\n * cache is disabled.  Disabling the cache works around the problem.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=969828\n */\nconst byteRangeCacheMode =\n  navigator.userAgent.indexOf(\"Chrome\") !== -1 ? \"no-store\" : \"default\";\n\nclass SpecialProtocolKvStore implements ReadableKvStore {\n  constructor(\n    public credentialsProvider: SpecialProtocolCredentialsProvider,\n    public baseUrl: string,\n  ) {}\n\n  async getObjectLength(url: string, options: ReadOptions) {\n    // Use a HEAD request to get the length of an object\n    const headResponse = await fetchSpecialOk(this.credentialsProvider, url, {\n      method: \"HEAD\",\n      signal: options.abortSignal,\n    });\n\n    if (headResponse.status !== 200) {\n      throw new Error(\n        \"Failed to determine total size in order to fetch suffix\",\n      );\n    }\n    const contentLength = headResponse.headers.get(\"content-length\");\n    if (contentLength === undefined) {\n      throw new Error(\n        \"Failed to determine total size in order to fetch suffix\",\n      );\n    }\n    const contentLengthNumber = Number(contentLength);\n    return contentLengthNumber;\n  }\n\n  async read(\n    key: string,\n    options: ReadOptions,\n  ): Promise<ReadResponse | undefined> {\n    let { byteRange: byteRangeRequest } = options;\n    const url = this.baseUrl + key;\n\n    try {\n      // The HTTP spec supports suffixLength requests directly via \"Range:\n      // bytes=-N\" requests, which avoids the need for a separate HEAD request.\n      // However, per\n      // https://fetch.spec.whatwg.org/#cors-safelisted-request-header a suffix\n      // length byte range request header will always trigger an OPTIONS preflight\n      // request, which would otherwise be avoided. This negates the benefit of\n      // using a suffixLength request directly. Additionally, some servers such as\n      // the npm http-server package and https://uk1s3.embassy.ebi.ac.uk/ do not\n      // correctly handle suffixLength requests or do not correctly handle CORS\n      // preflight requests. To avoid those issues, always just issue a separate\n      // HEAD request to determine the length.\n      let totalSize: number | undefined;\n      if (\n        byteRangeRequest !== undefined &&\n        \"suffixLength\" in byteRangeRequest\n      ) {\n        const totalSize = await this.getObjectLength(url, options);\n        byteRangeRequest = composeByteRangeRequest(\n          { offset: 0, length: totalSize },\n          byteRangeRequest,\n        ).outer;\n      }\n      const requestInit: RequestInit = { signal: options.abortSignal };\n      const rangeHeader = getRangeHeader(byteRangeRequest);\n      if (rangeHeader !== undefined) {\n        requestInit.headers = { range: rangeHeader };\n        requestInit.cache = byteRangeCacheMode;\n      }\n      const response = await fetchSpecialOk(\n        this.credentialsProvider,\n        url,\n        requestInit,\n      );\n      const data = await response.arrayBuffer();\n      let byteRange: ByteRange | undefined;\n      if (response.status === 206) {\n        const contentRange = response.headers.get(\"content-range\");\n        if (contentRange === null) {\n          // Content-range should always be sent, but some buggy servers don't\n          // send it.\n          if (byteRangeRequest !== undefined) {\n            byteRange = {\n              offset: byteRangeRequest.offset,\n              length: data.byteLength,\n            };\n          } else {\n            throw new Error(\n              \"Unexpected HTTP 206 response when no byte range specified.\",\n            );\n          }\n        }\n        if (contentRange !== null) {\n          const m = contentRange.match(/bytes ([0-9]+)-([0-9]+)\\/([0-9]+|\\*)/);\n          if (m === null) {\n            throw new Error(\n              `Invalid content-range header: ${JSON.stringify(contentRange)}`,\n            );\n          }\n          const beginPos = parseInt(m[1], 10);\n          const endPos = parseInt(m[2], 10);\n          if (endPos !== beginPos + data.byteLength - 1) {\n            throw new Error(\n              `Length in content-range header ${JSON.stringify(\n                contentRange,\n              )} does not match content length ${data.byteLength}`,\n            );\n          }\n          if (m[3] !== \"*\") {\n            totalSize = parseInt(m[3], 10);\n          }\n          byteRange = { offset: beginPos, length: data.byteLength };\n        }\n      }\n      if (byteRange === undefined) {\n        byteRange = { offset: 0, length: data.byteLength };\n        totalSize = data.byteLength;\n      }\n      return { data: new Uint8Array(data), dataRange: byteRange, totalSize };\n    } catch (e) {\n      if (isNotFoundError(e)) {\n        return undefined;\n      }\n      throw e;\n    }\n  }\n}\nexport function getSpecialProtocolKvStore(\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  baseUrl: string,\n): ReadableKvStore {\n  return new SpecialProtocolKvStore(credentialsProvider, baseUrl);\n}\n","/**\n * @license\n * Copyright 2024 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function scopedAbortCallback(\n  signal: AbortSignal | undefined,\n  callback: (reason: any) => void,\n): Disposable | undefined {\n  if (signal === undefined) return undefined;\n  if (signal.aborted) {\n    callback(signal.reason);\n    return undefined;\n  }\n  function wrappedCallback(this: AbortSignal) {\n    callback(this.reason);\n  }\n  signal.addEventListener(\"abort\", wrappedCallback, { once: true });\n  return {\n    [Symbol.dispose]() {\n      signal.removeEventListener(\"abort\", wrappedCallback);\n    },\n  };\n}\n\n// Abort controller that aborts when *all* consumers have aborted.\nexport class SharedAbortController {\n  private consumers = new Map<(this: AbortSignal) => void, AbortSignal>();\n  private controller = new AbortController();\n  private retainCount = 0;\n\n  get signal(): AbortSignal {\n    return this.controller.signal;\n  }\n\n  addConsumer(abortSignal: AbortSignal | undefined): void {\n    if (this.controller.signal.aborted) return undefined;\n    if (abortSignal !== undefined) {\n      if (abortSignal.aborted) return;\n      const self = this;\n      function wrappedCallback(this: AbortSignal) {\n        self.consumers.delete(wrappedCallback);\n        if (--self.retainCount === 0) {\n          self.controller.abort();\n          self[Symbol.dispose]();\n        }\n      }\n      abortSignal.addEventListener(\"abort\", wrappedCallback, { once: true });\n    }\n    ++this.retainCount;\n  }\n\n  [Symbol.dispose](): void {\n    for (const [wrappedCallback, abortSignal] of this.consumers) {\n      abortSignal.removeEventListener(\"abort\", wrappedCallback);\n    }\n    this.consumers.clear();\n    this.retainCount = 0;\n  }\n\n  // Marks this controller as started. Aborts if there are no consumers.\n  start(): void {\n    if (this.retainCount === 0) {\n      this.controller.abort();\n    }\n  }\n}\n\nexport function promiseWithResolversAndAbortCallback<T>(\n  abortSignal: AbortSignal,\n  abortCallback: (reason: any) => void,\n): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason: any) => void;\n} {\n  const { promise, resolve, reject } = Promise.withResolvers<T>();\n  const cleanup = scopedAbortCallback(abortSignal, abortCallback);\n  return {\n    promise,\n    resolve: (value: T) => {\n      cleanup?.[Symbol.dispose]();\n      resolve(value);\n    },\n    reject: (reason: any) => {\n      cleanup?.[Symbol.dispose]();\n      reject(reason);\n    },\n  };\n}\n\nexport function raceWithAbort<T>(\n  promise: Promise<T>,\n  abortSignal: AbortSignal | undefined,\n): Promise<T> {\n  if (abortSignal === undefined) return promise;\n  if (abortSignal.aborted) return Promise.reject(abortSignal.reason);\n\n  return new Promise((resolve, reject) => {\n    const cleanup = scopedAbortCallback(abortSignal, (reason) => {\n      reject(reason);\n    });\n    promise.then(\n      (value) => {\n        cleanup?.[Symbol.dispose]();\n        resolve(value);\n      },\n      (reason) => {\n        cleanup?.[Symbol.dispose]();\n        reject(reason);\n      },\n    );\n  });\n}\n\nexport function abortPromise(abortSignal: AbortSignal) {\n  return new Promise((_resolve, reject) => {\n    abortSignal.addEventListener(\n      \"abort\",\n      () => {\n        reject(abortSignal.reason);\n      },\n      { once: true },\n    );\n  });\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { promiseWithResolversAndAbortCallback } from \"#src/util/abort.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\n\nexport type RPCHandler = (this: RPC, x: any) => void;\n\nexport type RpcId = number;\n\nconst IS_WORKER = !(typeof Window !== \"undefined\" && self instanceof Window);\n\nconst DEBUG = false;\n\nconst DEBUG_MESSAGES = false;\n\nconst PROMISE_RESPONSE_ID = \"rpc.promise.response\";\nconst PROMISE_CANCEL_ID = \"rpc.promise.cancel\";\nconst READY_ID = \"rpc.ready\";\n\nconst handlers = new Map<string, RPCHandler>();\n\nexport function registerRPC(key: string, handler: RPCHandler) {\n  handlers.set(key, handler);\n}\n\nexport type RPCPromise<T> = Promise<{ value: T; transfers?: any[] }>;\n\nexport class RPCError extends Error {\n  constructor(\n    public name: string,\n    public message: string,\n  ) {\n    super(message);\n  }\n}\n\nexport function registerPromiseRPC<T>(\n  key: string,\n  handler: (this: RPC, x: any, abortSignal: AbortSignal) => RPCPromise<T>,\n) {\n  registerRPC(key, function (this: RPC, x: any) {\n    const id = <number>x.id;\n    const abortController = new AbortController();\n    const promise = handler.call(\n      this,\n      x,\n      abortController.signal,\n    ) as RPCPromise<T>;\n    this.set(id, { promise, abortController });\n    promise.then(\n      ({ value, transfers }) => {\n        this.delete(id);\n        this.invoke(PROMISE_RESPONSE_ID, { id: id, value: value }, transfers);\n      },\n      (error) => {\n        this.delete(id);\n        this.invoke(PROMISE_RESPONSE_ID, {\n          id: id,\n          error: error.message,\n          errorName: error.name,\n        });\n      },\n    );\n  });\n}\n\nregisterRPC(PROMISE_CANCEL_ID, function (this: RPC, x: any) {\n  const id = <number>x.id;\n  const request = this.get(id);\n  if (request !== undefined) {\n    const { abortController } = request;\n    abortController.abort();\n  }\n});\n\nregisterRPC(PROMISE_RESPONSE_ID, function (this: RPC, x: any) {\n  const id = <number>x.id;\n  const { resolve, reject } = this.get(id);\n  this.delete(id);\n  if (Object.prototype.hasOwnProperty.call(x, \"value\")) {\n    resolve(x.value);\n  } else {\n    reject(new RPCError(x.errorName, x.error));\n  }\n});\n\nregisterRPC(READY_ID, function (this: RPC, x: any) {\n  x;\n  this.onPeerReady();\n});\n\ninterface RPCTarget {\n  postMessage(message?: any, ports?: any): void;\n  onmessage: ((ev: MessageEvent) => any) | null;\n}\n\nconst INITIAL_RPC_ID = IS_WORKER ? -1 : 0;\n\nexport class RPC {\n  private objects = new Map<RpcId, any>();\n  private nextId: RpcId = INITIAL_RPC_ID;\n  private queue: { data: any; transfers?: any[] }[] | undefined;\n  constructor(\n    public target: RPCTarget,\n    waitUntilReady: boolean,\n  ) {\n    if (waitUntilReady) {\n      this.queue = [];\n    }\n    target.onmessage = (e) => {\n      const data = e.data;\n      if (DEBUG_MESSAGES) {\n        console.log(\"Received message\", data);\n      }\n      handlers.get(data.functionName)!.call(this, data);\n    };\n  }\n\n  sendReady() {\n    this.invoke(READY_ID, {});\n  }\n\n  onPeerReady() {\n    const { queue } = this;\n    if (queue === undefined) return;\n    this.queue = undefined;\n    for (const { data, transfers } of queue) {\n      this.target.postMessage(data, transfers);\n    }\n  }\n\n  get numObjects() {\n    return this.objects.size;\n  }\n\n  set(id: RpcId, value: any) {\n    this.objects.set(id, value);\n  }\n\n  delete(id: RpcId) {\n    this.objects.delete(id);\n  }\n  get(id: RpcId) {\n    return this.objects.get(id);\n  }\n  getRef<T extends SharedObject>(x: { id: RpcId; gen: number }): T {\n    const rpcId = x.id;\n    const obj = <T>this.get(rpcId);\n    obj.referencedGeneration = x.gen;\n    obj.addRef();\n    return obj;\n  }\n\n  getOptionalRef<T extends SharedObject>(x: {\n    id: RpcId;\n    gen: number;\n  }): T | undefined {\n    if (x === undefined) return undefined;\n    const rpcId = x.id;\n    const obj = this.get(rpcId) as T;\n    obj.referencedGeneration = x.gen;\n    obj.addRef();\n    return obj;\n  }\n\n  invoke(name: string, x: any, transfers?: any[]) {\n    x.functionName = name;\n    if (DEBUG_MESSAGES) {\n      console.trace(\"Sending message\", x);\n    }\n    const { queue } = this;\n    if (queue !== undefined) {\n      queue.push({ data: x, transfers });\n      return;\n    }\n    this.target.postMessage(x, transfers);\n  }\n\n  promiseInvoke<T>(\n    name: string,\n    x: any,\n    abortSignal?: AbortSignal | undefined,\n    transfers?: any[],\n  ): Promise<T> {\n    if (abortSignal?.aborted) {\n      return Promise.reject(abortSignal.reason);\n    }\n    const id = (x.id = this.newId());\n    this.invoke(name, x, transfers);\n    const { promise, resolve, reject } =\n      abortSignal === undefined\n        ? Promise.withResolvers<T>()\n        : promiseWithResolversAndAbortCallback<T>(abortSignal, () => {\n            this.invoke(PROMISE_CANCEL_ID, { id: id });\n          });\n    this.set(id, { resolve, reject });\n    return promise;\n  }\n\n  newId() {\n    return IS_WORKER ? this.nextId-- : this.nextId++;\n  }\n}\n\nexport class SharedObject extends RefCounted {\n  rpc: RPC | null = null;\n  rpcId: RpcId | null = null;\n  isOwner: boolean | undefined;\n  unreferencedGeneration: number;\n  referencedGeneration: number;\n\n  initializeSharedObject(rpc: RPC, rpcId = rpc.newId()) {\n    this.rpc = rpc;\n    this.rpcId = rpcId;\n    this.isOwner = false;\n    rpc.set(rpcId, this);\n  }\n\n  initializeCounterpart(rpc: RPC, options: any = {}) {\n    this.initializeSharedObject(rpc);\n    this.unreferencedGeneration = 0;\n    this.referencedGeneration = 0;\n    this.isOwner = true;\n    options.id = this.rpcId;\n    options.type = this.RPC_TYPE_ID;\n    rpc.invoke(\"SharedObject.new\", options);\n  }\n\n  dispose() {\n    super.dispose();\n  }\n\n  /**\n   * Precondition: this.isOwner === true.\n   */\n  addCounterpartRef() {\n    return { id: this.rpcId, gen: ++this.referencedGeneration };\n  }\n\n  protected refCountReachedZero() {\n    if (this.isOwner === true) {\n      if (this.referencedGeneration === this.unreferencedGeneration) {\n        this.ownerDispose();\n      }\n    } else if (this.isOwner === false) {\n      this.rpc!.invoke(\"SharedObject.refCountReachedZero\", {\n        id: this.rpcId,\n        gen: this.referencedGeneration,\n      });\n    } else {\n      super.refCountReachedZero();\n    }\n  }\n\n  /**\n   * Precondition: this.isOwner === true.\n   */\n  protected ownerDispose() {\n    if (DEBUG) {\n      console.log(`[${IS_WORKER}] #rpc object = ${this.rpc!.numObjects}`);\n    }\n    const { rpc, rpcId } = this;\n    super.refCountReachedZero();\n    rpc!.delete(rpcId!);\n    rpc!.invoke(\"SharedObject.dispose\", { id: rpcId });\n  }\n\n  /**\n   * Precondition: this.isOwner === true.\n   *\n   * This should be called when the counterpart's refCount is decremented and reaches zero.\n   */\n  counterpartRefCountReachedZero(generation: number) {\n    this.unreferencedGeneration = generation;\n    if (this.refCount === 0 && generation === this.referencedGeneration) {\n      this.ownerDispose();\n    }\n  }\n\n  /**\n   * Should be set to a constant specifying the SharedObject type identifier on the prototype of\n   * final derived owner classes.  It is not used on counterpart (non-owner) classes.\n   */\n  declare RPC_TYPE_ID: string;\n}\n\nexport function initializeSharedObjectCounterpart(\n  obj: SharedObject,\n  rpc?: RPC,\n  options: any = {},\n) {\n  if (rpc != null) {\n    obj.initializeSharedObject(rpc, options.id);\n  }\n}\n\n/**\n * Base class for defining a SharedObject type that will never be owned.\n */\nexport class SharedObjectCounterpart extends SharedObject {\n  constructor(rpc?: RPC, options: any = {}) {\n    super();\n    initializeSharedObjectCounterpart(this, rpc, options);\n  }\n}\n\nexport interface SharedObjectConstructor {\n  new (rpc: RPC, options: any): SharedObjectCounterpart;\n}\n\nregisterRPC(\"SharedObject.dispose\", function (x) {\n  const obj = <SharedObject>this.get(x.id);\n  if (obj.refCount !== 0) {\n    throw new Error(\n      \"Attempted to dispose object with non-zero reference count.\",\n    );\n  }\n  if (DEBUG) {\n    console.log(`[${IS_WORKER}] #rpc objects: ${this.numObjects}`);\n  }\n  obj.disposed();\n  this.delete(obj.rpcId!);\n  obj.rpcId = null;\n  obj.rpc = null;\n});\n\nregisterRPC(\"SharedObject.refCountReachedZero\", function (x) {\n  const obj = <SharedObject>this.get(x.id);\n  const generation = <number>x.gen;\n  obj.counterpartRefCountReachedZero(generation);\n});\n\nconst sharedObjectConstructors = new Map<string, SharedObjectConstructor>();\n\n/**\n * Register a class as a SharedObject owner type under the specified identifier.\n *\n * This is intended to be used as a decorator.\n */\nexport function registerSharedObjectOwner(identifier: string) {\n  return (constructorFunction: { prototype: { RPC_TYPE_ID: string } }) => {\n    constructorFunction.prototype.RPC_TYPE_ID = identifier;\n  };\n}\n\n/**\n * Register a class as a SharedObject counterpart type under the specified identifier.\n *\n * This is intended to be used as a decorator.\n *\n * Also register the type as a SharedObject owner, which is useful if this type is also used as a\n * SharedObject owner.\n */\nexport function registerSharedObject(identifier?: string) {\n  return (constructorFunction: SharedObjectConstructor) => {\n    if (identifier !== undefined) {\n      constructorFunction.prototype.RPC_TYPE_ID = identifier;\n    } else {\n      identifier = constructorFunction.prototype.RPC_TYPE_ID;\n      if (identifier === undefined) {\n        throw new Error(\"RPC_TYPE_ID should have already been defined\");\n      }\n    }\n    sharedObjectConstructors.set(identifier, constructorFunction);\n  };\n}\n\nregisterRPC(\"SharedObject.new\", function (x) {\n  const rpc = <RPC>this;\n  const typeName = <string>x.type;\n  const constructorFunction = sharedObjectConstructors.get(typeName)!;\n  const obj = new constructorFunction(rpc, x);\n  // Counterpart objects start with a reference count of zero.\n  --obj.refCount;\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Facility for sharing arbitrary values that support structural cloning between threads.\n */\n\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { WatchableValue } from \"#src/trackable_value.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nconst CHANGED_RPC_METHOD_ID = \"SharedWatchableValue.changed\";\n\n@registerSharedObject(\"SharedWatchableValue\")\nexport class SharedWatchableValue<T>\n  extends SharedObjectCounterpart\n  implements WatchableValueInterface<T>\n{\n  base: WatchableValueInterface<T>;\n\n  /**\n   * The value is being updated to reflect a remote change.\n   * @internal\n   */\n  updatingValue_ = false;\n\n  constructor(rpc?: RPC, options: any = {}) {\n    super(rpc, options);\n    if (rpc !== undefined) {\n      this.base = new WatchableValue<T>(options.value);\n      this.setupChangedHandler();\n    }\n  }\n\n  initializeCounterpart(rpc: RPC, options: any = {}) {\n    options.value = this.value;\n    super.initializeCounterpart(rpc, options);\n  }\n\n  private setupChangedHandler() {\n    this.registerDisposer(\n      this.base.changed.add(() => {\n        if (this.updatingValue_) {\n          this.updatingValue_ = false;\n        } else {\n          const { rpc } = this;\n          if (rpc !== null) {\n            rpc.invoke(CHANGED_RPC_METHOD_ID, {\n              id: this.rpcId,\n              value: this.value,\n            });\n          }\n        }\n      }),\n    );\n  }\n\n  static makeFromExisting<T>(rpc: RPC, base: WatchableValueInterface<T>) {\n    const obj = new SharedWatchableValue<T>();\n    obj.base = base;\n    obj.setupChangedHandler();\n    obj.initializeCounterpart(rpc);\n    return obj;\n  }\n\n  static make<T>(rpc: RPC, value: T) {\n    return SharedWatchableValue.makeFromExisting(\n      rpc,\n      new WatchableValue<T>(value),\n    );\n  }\n\n  get value() {\n    return this.base.value;\n  }\n\n  set value(value: T) {\n    this.base.value = value;\n  }\n\n  get changed() {\n    return this.base.changed;\n  }\n}\n\nregisterRPC(CHANGED_RPC_METHOD_ID, function (x) {\n  const obj = <SharedWatchableValue<any>>this.get(x.id);\n  obj.updatingValue_ = true;\n  obj.base.value = x.value;\n  obj.updatingValue_ = false;\n});\n","// DO NOT EDIT.  Generated from templates/util/linked_list.template.ts.\n/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ninterface Node<T> {\n  next1: T | null;\n  prev1: T | null;\n}\n\nexport default class {\n  static insertAfter<T extends Node<T>>(head: T, x: T) {\n    const next = <T>head.next1;\n    x.next1 = next;\n    x.prev1 = head;\n    head.next1 = x;\n    next.prev1 = x;\n  }\n  static insertBefore<T extends Node<T>>(head: T, x: T) {\n    const prev = <T>head.prev1;\n    x.prev1 = prev;\n    x.next1 = head;\n    head.prev1 = x;\n    prev.next1 = x;\n  }\n  static front<T extends Node<T>>(head: T) {\n    const next = head.next1;\n    if (next === head) {\n      return null;\n    }\n    return next;\n  }\n  static back<T extends Node<T>>(head: T) {\n    const next = head.prev1;\n    if (next === head) {\n      return null;\n    }\n    return next;\n  }\n  static pop<T extends Node<T>>(x: T) {\n    const next = <T>x.next1;\n    const prev = <T>x.prev1;\n    next.prev1 = prev;\n    prev.next1 = next;\n    x.next1 = null;\n    x.prev1 = null;\n    return x;\n  }\n  static *iterator<T extends Node<T>>(head: T) {\n    for (let x = <T>head.next1; x !== head; x = <T>x.next1) {\n      yield x;\n    }\n  }\n  static *reverseIterator<T extends Node<T>>(head: T) {\n    for (let x = <T>head.prev1; x !== head; x = <T>x.prev1) {\n      yield x;\n    }\n  }\n  static initializeHead<T extends Node<T>>(head: T) {\n    head.next1 = head.prev1 = head;\n  }\n}\n","// DO NOT EDIT.  Generated from templates/util/pairing_heap.template.ts.\n/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { PairingHeapOperations } from \"#src/util/pairing_heap.js\";\n\ninterface Node<T> {\n  child0: T | null;\n  next0: T | null;\n  prev0: T | null;\n}\n\n/**\n * Pairing heap.\n *\n * The root node is the minimum element according to comparator.\n *\n * @final\n */\nexport default class Implementation<T extends Node<T>>\n  implements PairingHeapOperations<T>\n{\n  /**\n   * @param compare Returns true iff a < b.\n   */\n  constructor(public compare: (a: T, b: T) => boolean) {}\n\n  meld(a: T | null, b: T | null) {\n    if (b === null) {\n      return a;\n    }\n    if (a === null) {\n      return b;\n    }\n    const { compare } = this;\n    if (compare(b, a)) {\n      const temp = a;\n      a = b;\n      b = temp;\n    }\n    const aChild = a.child0;\n    b.next0 = aChild;\n    b.prev0 = a;\n    if (aChild !== null) {\n      aChild.prev0 = b;\n    }\n    a.child0 = b;\n    return a;\n  }\n  private combineChildren(node: T) {\n    let cur = node.child0;\n    if (cur === null) {\n      return null;\n    }\n    // While in this function, we will use the nextProperty to create a\n    // singly-linked list of pairwise-merged nodes that still need to be\n    // merged together.\n    let head: T | null = null;\n    while (true) {\n      const curNext: T | null = cur.next0;\n      let next: T | null, m: T;\n      if (curNext === null) {\n        next = null;\n        m = cur;\n      } else {\n        next = curNext.next0;\n        m = this.meld(cur, curNext)!;\n      }\n      m.next0 = head;\n      head = m;\n      if (next === null) {\n        break;\n      }\n      cur = next;\n    }\n\n    let root = head;\n    head = head.next0;\n    while (true) {\n      if (head === null) {\n        break;\n      }\n      const next: T | null = head.next0;\n      root = this.meld(root, head)!;\n      head = next;\n    }\n    root.prev0 = null;\n    root.next0 = null;\n    return root;\n  }\n  removeMin(root: T) {\n    const newRoot = this.combineChildren(root);\n    root.next0 = null;\n    root.prev0 = null;\n    root.child0 = null;\n    return newRoot;\n  }\n\n  remove(root: T, node: T) {\n    if (root === node) {\n      return this.removeMin(root);\n    }\n    const prev = node.prev0!;\n    const next = node.next0!;\n    if (prev.child0 === node) {\n      prev.child0 = next;\n    } else {\n      prev.next0 = next;\n    }\n    if (next !== null) {\n      next.prev0 = prev;\n    }\n    const newRoot = this.meld(root, this.combineChildren(node));\n    node.next0 = null;\n    node.prev0 = null;\n    node.child0 = null;\n    return newRoot;\n  }\n\n  /**\n   * Returns a new iterator over the entries in the heap.\n   */\n  *entries(root: T): IterableIterator<T> {\n    if (root !== null) {\n      let child = root.child0;\n      yield root;\n      while (child !== null) {\n        const next: T | null = child.next0;\n        yield* this.entries(child);\n        child = next;\n      }\n    }\n  }\n\n  /**\n   * Returns a new iterator over the entries in the heap.  The entries\n   * will be removed as they are iterated.\n   */\n  *removedEntries(root: T): IterableIterator<T> {\n    if (root !== null) {\n      let child = root.child0;\n      root.child0 = null;\n      root.next0 = null;\n      root.prev0 = null;\n      yield root;\n      while (child !== null) {\n        const next: T | null = child.next0;\n        child.child0 = null;\n        child.next0 = null;\n        child.prev0 = null;\n        yield* this.entries(child);\n        child = next;\n      }\n    }\n  }\n}\n","// DO NOT EDIT.  Generated from templates/util/pairing_heap.template.ts.\n/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { PairingHeapOperations } from \"#src/util/pairing_heap.js\";\n\ninterface Node<T> {\n  child1: T | null;\n  next1: T | null;\n  prev1: T | null;\n}\n\n/**\n * Pairing heap.\n *\n * The root node is the minimum element according to comparator.\n *\n * @final\n */\nexport default class Implementation<T extends Node<T>>\n  implements PairingHeapOperations<T>\n{\n  /**\n   * @param compare Returns true iff a < b.\n   */\n  constructor(public compare: (a: T, b: T) => boolean) {}\n\n  meld(a: T | null, b: T | null) {\n    if (b === null) {\n      return a;\n    }\n    if (a === null) {\n      return b;\n    }\n    const { compare } = this;\n    if (compare(b, a)) {\n      const temp = a;\n      a = b;\n      b = temp;\n    }\n    const aChild = a.child1;\n    b.next1 = aChild;\n    b.prev1 = a;\n    if (aChild !== null) {\n      aChild.prev1 = b;\n    }\n    a.child1 = b;\n    return a;\n  }\n  private combineChildren(node: T) {\n    let cur = node.child1;\n    if (cur === null) {\n      return null;\n    }\n    // While in this function, we will use the nextProperty to create a\n    // singly-linked list of pairwise-merged nodes that still need to be\n    // merged together.\n    let head: T | null = null;\n    while (true) {\n      const curNext: T | null = cur.next1;\n      let next: T | null, m: T;\n      if (curNext === null) {\n        next = null;\n        m = cur;\n      } else {\n        next = curNext.next1;\n        m = this.meld(cur, curNext)!;\n      }\n      m.next1 = head;\n      head = m;\n      if (next === null) {\n        break;\n      }\n      cur = next;\n    }\n\n    let root = head;\n    head = head.next1;\n    while (true) {\n      if (head === null) {\n        break;\n      }\n      const next: T | null = head.next1;\n      root = this.meld(root, head)!;\n      head = next;\n    }\n    root.prev1 = null;\n    root.next1 = null;\n    return root;\n  }\n  removeMin(root: T) {\n    const newRoot = this.combineChildren(root);\n    root.next1 = null;\n    root.prev1 = null;\n    root.child1 = null;\n    return newRoot;\n  }\n\n  remove(root: T, node: T) {\n    if (root === node) {\n      return this.removeMin(root);\n    }\n    const prev = node.prev1!;\n    const next = node.next1!;\n    if (prev.child1 === node) {\n      prev.child1 = next;\n    } else {\n      prev.next1 = next;\n    }\n    if (next !== null) {\n      next.prev1 = prev;\n    }\n    const newRoot = this.meld(root, this.combineChildren(node));\n    node.next1 = null;\n    node.prev1 = null;\n    node.child1 = null;\n    return newRoot;\n  }\n\n  /**\n   * Returns a new iterator over the entries in the heap.\n   */\n  *entries(root: T): IterableIterator<T> {\n    if (root !== null) {\n      let child = root.child1;\n      yield root;\n      while (child !== null) {\n        const next: T | null = child.next1;\n        yield* this.entries(child);\n        child = next;\n      }\n    }\n  }\n\n  /**\n   * Returns a new iterator over the entries in the heap.  The entries\n   * will be removed as they are iterated.\n   */\n  *removedEntries(root: T): IterableIterator<T> {\n    if (root !== null) {\n      let child = root.child1;\n      root.child1 = null;\n      root.next1 = null;\n      root.prev1 = null;\n      yield root;\n      while (child !== null) {\n        const next: T | null = child.next1;\n        child.child1 = null;\n        child.next1 = null;\n        child.prev1 = null;\n        yield* this.entries(child);\n        child = next;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { throttle } from \"lodash-es\";\nimport type {\n  ChunkSourceParametersConstructor,\n  LayerChunkProgressInfo,\n} from \"#src/chunk_manager/base.js\";\nimport {\n  CHUNK_LAYER_STATISTICS_RPC_ID,\n  CHUNK_MANAGER_RPC_ID,\n  CHUNK_QUEUE_MANAGER_RPC_ID,\n  CHUNK_SOURCE_INVALIDATE_RPC_ID,\n  ChunkDownloadStatistics,\n  ChunkMemoryStatistics,\n  ChunkPriorityTier,\n  ChunkState,\n  getChunkDownloadStatisticIndex,\n  getChunkStateStatisticIndex,\n  numChunkMemoryStatistics,\n  numChunkStatistics,\n  REQUEST_CHUNK_STATISTICS_RPC_ID,\n} from \"#src/chunk_manager/base.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { TypedArray } from \"#src/util/array.js\";\nimport type { Borrowed, Disposable } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport LinkedList0 from \"#src/util/linked_list.0.js\";\nimport LinkedList1 from \"#src/util/linked_list.1.js\";\nimport type { LinkedListOperations } from \"#src/util/linked_list.js\";\nimport { StringMemoize } from \"#src/util/memoize.js\";\nimport PairingHeap0 from \"#src/util/pairing_heap.0.js\";\nimport PairingHeap1 from \"#src/util/pairing_heap.1.js\";\nimport type {\n  ComparisonFunction,\n  PairingHeapOperations,\n} from \"#src/util/pairing_heap.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  initializeSharedObjectCounterpart,\n  registerPromiseRPC,\n  registerRPC,\n  registerSharedObject,\n  registerSharedObjectOwner,\n  SharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nconst DEBUG_CHUNK_UPDATES = false;\n\nexport interface ChunkStateListener {\n  (chunk: Chunk, oldState: ChunkState): void;\n}\n\nlet nextMarkGeneration = 0;\nexport function getNextMarkGeneration() {\n  return ++nextMarkGeneration;\n}\n\nexport class Chunk implements Disposable {\n  // Node properties used for eviction/promotion heaps and LRU linked lists.\n  child0: Chunk | null = null;\n  next0: Chunk | null = null;\n  prev0: Chunk | null = null;\n  child1: Chunk | null = null;\n  next1: Chunk | null = null;\n  prev1: Chunk | null = null;\n\n  source: ChunkSource | null = null;\n\n  key: string | null = null;\n\n  private state_ = ChunkState.NEW;\n\n  error: any = null;\n\n  // Used by layers for marking chunks for various purposes.\n  markGeneration = -1;\n\n  /**\n   * Specifies existing priority within priority tier.  Only meaningful if priorityTier in\n   * CHUNK_ORDERED_PRIORITY_TIERS.  Higher numbers mean higher priority.\n   */\n  priority = 0;\n\n  /**\n   * Specifies updated priority within priority tier, not yet reflected in priority queue state.\n   * Only meaningful if newPriorityTier in CHUNK_ORDERED_PRIORITY_TIERS.\n   */\n  newPriority = 0;\n\n  priorityTier = ChunkPriorityTier.RECENT;\n\n  /**\n   * Specifies updated priority tier, not yet reflected in priority queue state.\n   */\n  newPriorityTier = ChunkPriorityTier.RECENT;\n\n  private systemMemoryBytes_ = 0;\n  private gpuMemoryBytes_ = 0;\n  private downloadSlots_ = 1;\n  isComputational = false;\n\n  /**\n   * Specifies lowest numeric state required by any request, if `prioritTier !==\n   * ChunkPriorityTier.RECENT`, then this must be one of `GPU_MEMORY`, `SYSTEM_MEMORY`, or\n   * `SYSTEM_MEMORY_WORKER`.\n   */\n  requestedState = ChunkState.NEW;\n\n  newRequestedState = ChunkState.NEW;\n\n  /**\n   * Abort controller used to cancel the pending download.  Set to undefined except when state !==\n   * DOWNLOADING.  This should not be accessed by code outside this module.\n   */\n  downloadAbortController: AbortController | undefined = undefined;\n\n  initialize(key: string) {\n    this.key = key;\n    this.priority = Number.NEGATIVE_INFINITY;\n    this.priorityTier = ChunkPriorityTier.RECENT;\n    this.newPriority = Number.NEGATIVE_INFINITY;\n    this.newPriorityTier = ChunkPriorityTier.RECENT;\n    this.error = null;\n    this.state = ChunkState.NEW;\n    this.requestedState = ChunkState.NEW;\n    this.newRequestedState = ChunkState.NEW;\n  }\n\n  /**\n   * Sets this.priority{Tier,} to this.newPriority{Tier,}, and resets this.newPriorityTier to\n   * ChunkPriorityTier.RECENT.\n   *\n   * This does not actually update any queues to reflect this change.\n   */\n  updatePriorityProperties() {\n    this.priorityTier = this.newPriorityTier;\n    this.priority = this.newPriority;\n    this.newPriorityTier = ChunkPriorityTier.RECENT;\n    this.newPriority = Number.NEGATIVE_INFINITY;\n    this.requestedState = this.newRequestedState;\n    this.newRequestedState = ChunkState.NEW;\n  }\n\n  dispose() {\n    this.source = null;\n    this.error = null;\n  }\n\n  get chunkManager() {\n    return (<ChunkSource>this.source).chunkManager;\n  }\n\n  get queueManager() {\n    return (<ChunkSource>this.source).chunkManager.queueManager;\n  }\n\n  downloadFailed(error: any) {\n    this.error = error;\n    this.queueManager.updateChunkState(this, ChunkState.FAILED);\n  }\n\n  downloadSucceeded() {\n    if (this.requestedState === ChunkState.SYSTEM_MEMORY) {\n      this.queueManager.moveChunkToFrontend(this);\n      this.queueManager.updateChunkState(this, ChunkState.SYSTEM_MEMORY);\n    } else {\n      this.queueManager.updateChunkState(this, ChunkState.SYSTEM_MEMORY_WORKER);\n    }\n  }\n\n  freeSystemMemory() {}\n\n  serialize(msg: any, _transfers: any[]) {\n    msg.id = this.key;\n    msg.source = (<ChunkSource>this.source).rpcId;\n    msg.new = true;\n  }\n\n  toString() {\n    return this.key;\n  }\n\n  set state(newState: ChunkState) {\n    if (newState === this.state_) {\n      return;\n    }\n    const oldState = this.state_;\n    this.state_ = newState;\n    this.source!.chunkStateChanged(this, oldState);\n  }\n\n  get state() {\n    return this.state_;\n  }\n\n  set systemMemoryBytes(bytes: number) {\n    updateChunkStatistics(this, -1);\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);\n    this.systemMemoryBytes_ = bytes;\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);\n    updateChunkStatistics(this, 1);\n    this.chunkManager.queueManager.scheduleUpdate();\n  }\n\n  get systemMemoryBytes() {\n    return this.systemMemoryBytes_;\n  }\n\n  set gpuMemoryBytes(bytes: number) {\n    updateChunkStatistics(this, -1);\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);\n    this.gpuMemoryBytes_ = bytes;\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);\n    updateChunkStatistics(this, 1);\n    this.chunkManager.queueManager.scheduleUpdate();\n  }\n\n  get gpuMemoryBytes() {\n    return this.gpuMemoryBytes_;\n  }\n\n  get downloadSlots() {\n    return this.downloadSlots_;\n  }\n\n  set downloadSlots(count: number) {\n    if (count === this.downloadSlots_) return;\n    updateChunkStatistics(this, -1);\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);\n    this.downloadSlots_ = count;\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);\n    updateChunkStatistics(this, 1);\n    this.chunkManager.queueManager.scheduleUpdate();\n  }\n\n  registerListener(listener: ChunkStateListener) {\n    if (!this.source) {\n      return false;\n    }\n    return this.source.registerChunkListener(this.key!, listener);\n  }\n\n  unregisterListener(listener: ChunkStateListener) {\n    if (!this.source) {\n      return false;\n    }\n    return this.source.unregisterChunkListener(this.key!, listener);\n  }\n\n  static priorityLess(a: Chunk, b: Chunk) {\n    return a.priority < b.priority;\n  }\n\n  static priorityGreater(a: Chunk, b: Chunk) {\n    return a.priority > b.priority;\n  }\n}\n\nexport interface ChunkConstructor<T extends Chunk> {\n  new (): T;\n}\n\nconst numSourceQueueLevels = 2;\n\n/**\n * Base class inherited by both ChunkSource, for implementing the backend part of chunk sources that\n * also have a frontend-part, as well as other chunk sources, such as the GenericFileSource, that\n * has only a backend part.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class ChunkSourceBase extends SharedObject {\n  private listeners_ = new Map<string, ChunkStateListener[]>();\n  chunks: Map<string, Chunk> = new Map<string, Chunk>();\n  freeChunks: Chunk[] = new Array<Chunk>();\n  statistics = new Float64Array(numChunkStatistics);\n\n  /**\n   * sourceQueueLevel must be greater than the sourceQueueLevel of any ChunkSource whose download\n   * method depends on chunks from this source.  A normal ChunkSource with no other dependencies\n   * should have a level of 0.\n   */\n  sourceQueueLevel = 0;\n\n  constructor(public chunkManager: Borrowed<ChunkManager>) {\n    super();\n    chunkManager.queueManager.sources.add(this);\n  }\n\n  disposed() {\n    this.chunkManager.queueManager.sources.delete(this);\n    super.disposed();\n  }\n\n  getNewChunk_<T extends Chunk>(chunkType: ChunkConstructor<T>): T {\n    const freeChunks = this.freeChunks;\n    const freeChunksLength = freeChunks.length;\n    if (freeChunksLength > 0) {\n      const chunk = <T>freeChunks[freeChunksLength - 1];\n      freeChunks.length = freeChunksLength - 1;\n      chunk.source = this;\n      return chunk;\n    }\n    const chunk = new chunkType();\n    chunk.source = this;\n    return chunk;\n  }\n\n  /**\n   * Adds the specified chunk to the chunk cache.\n   *\n   * If the chunk cache was previously empty, also call this.addRef() to increment the reference\n   * count.\n   */\n  addChunk(chunk: Chunk) {\n    const { chunks } = this;\n    if (chunks.size === 0) {\n      this.addRef();\n    }\n    chunks.set(chunk.key!, chunk);\n    updateChunkStatistics(chunk, 1);\n  }\n\n  /**\n   * Remove the specified chunk from the chunk cache.\n   *\n   * If the chunk cache becomes empty, also call this.dispose() to decrement the reference count.\n   */\n  removeChunk(chunk: Chunk) {\n    const { chunks, freeChunks } = this;\n    chunks.delete(chunk.key!);\n    chunk.dispose();\n    freeChunks[freeChunks.length] = chunk;\n    if (chunks.size === 0) {\n      this.dispose();\n    }\n  }\n\n  registerChunkListener(key: string, listener: ChunkStateListener) {\n    if (!this.listeners_.has(key)) {\n      this.listeners_.set(key, [listener]);\n    } else {\n      this.listeners_.get(key)!.push(listener);\n    }\n    return true;\n  }\n\n  unregisterChunkListener(key: string, listener: ChunkStateListener) {\n    if (!this.listeners_.has(key)) {\n      return false;\n    }\n    const keyListeners = this.listeners_.get(key)!;\n    const idx = keyListeners.indexOf(listener);\n    if (idx < 0) {\n      return false;\n    }\n    keyListeners.splice(idx, 1);\n    if (keyListeners.length === 0) {\n      this.listeners_.delete(key);\n    }\n    return true;\n  }\n\n  chunkStateChanged(chunk: Chunk, oldState: ChunkState) {\n    const { key } = chunk;\n    if (key === null) return;\n    const listeners = this.listeners_.get(key);\n    if (listeners === undefined) return;\n    for (const listener of listeners.slice()) {\n      listener(chunk, oldState);\n    }\n  }\n}\n\nfunction updateChunkStatistics(chunk: Chunk, sign: number) {\n  const { statistics } = chunk.source!;\n  const { systemMemoryBytes, gpuMemoryBytes } = chunk;\n  const index = getChunkStateStatisticIndex(chunk.state, chunk.priorityTier);\n  statistics[\n    index * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks\n  ] += sign;\n  statistics[\n    index * numChunkMemoryStatistics + ChunkMemoryStatistics.systemMemoryBytes\n  ] += sign * systemMemoryBytes;\n  statistics[\n    index * numChunkMemoryStatistics + ChunkMemoryStatistics.gpuMemoryBytes\n  ] += sign * gpuMemoryBytes;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface ChunkSourceBase {\n  /**\n   * Begin downloading the specified the chunk.  The returned promise should resolve when the\n   * downloaded data has been successfully decoded and stored in the chunk, or rejected if the\n   * download or decoding fails.\n   *\n   * Note: This method must be defined by subclasses.\n   *\n   * @param chunk Chunk to download.\n   * @param abortSignal Used to abort download.\n   *\n   * TODO(jbms): Move this back to the class definition above and declare this abstract once mixins\n   * are compatible with abstract classes.\n   */\n  download(chunk: Chunk, abortSignal: AbortSignal): Promise<void>;\n}\n\nexport class ChunkSource extends ChunkSourceBase {\n  constructor(rpc: RPC, options: any) {\n    // No need to add a reference, since the owner counterpart will hold a reference to the owner\n    // counterpart of chunkManager.\n    const chunkManager = <ChunkManager>rpc.get(options.chunkManager);\n    super(chunkManager);\n    initializeSharedObjectCounterpart(this, rpc, options);\n  }\n}\n\nfunction startChunkDownload(chunk: Chunk) {\n  const downloadAbortController = (chunk.downloadAbortController =\n    new AbortController());\n  const startTime = Date.now();\n  chunk.source!.download(chunk, downloadAbortController.signal).then(\n    () => {\n      if (chunk.downloadAbortController === downloadAbortController) {\n        chunk.downloadAbortController = undefined;\n        const endTime = Date.now();\n        const { statistics } = chunk.source!;\n        statistics[\n          getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalTime)\n        ] += endTime - startTime;\n        ++statistics[\n          getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalChunks)\n        ];\n        chunk.downloadSucceeded();\n      }\n    },\n    (error: any) => {\n      if (chunk.downloadAbortController === downloadAbortController) {\n        chunk.downloadAbortController = undefined;\n        chunk.downloadFailed(error);\n        console.log(`Error retrieving chunk ${chunk}: ${error}`);\n      }\n    },\n  );\n}\n\nfunction cancelChunkDownload(chunk: Chunk) {\n  const controller = chunk.downloadAbortController!;\n  chunk.downloadAbortController = undefined;\n  controller.abort();\n}\n\nclass ChunkPriorityQueue {\n  /**\n   * Heap roots for VISIBLE and PREFETCH priority tiers.\n   */\n  private heapRoots: (Chunk | null)[] = [null, null];\n\n  /**\n   * Head node for RECENT linked list.\n   */\n  private recentHead = new Chunk();\n  constructor(\n    private heapOperations: PairingHeapOperations<Chunk>,\n    private linkedListOperations: LinkedListOperations<Chunk>,\n  ) {\n    linkedListOperations.initializeHead(this.recentHead);\n  }\n\n  add(chunk: Chunk) {\n    const priorityTier = chunk.priorityTier;\n    if (priorityTier === ChunkPriorityTier.RECENT) {\n      this.linkedListOperations.insertAfter(this.recentHead, chunk);\n    } else {\n      const { heapRoots } = this;\n      heapRoots[priorityTier] = this.heapOperations.meld(\n        heapRoots[priorityTier],\n        chunk,\n      );\n    }\n  }\n\n  *candidates(): Iterator<Chunk> {\n    if (this.heapOperations.compare === Chunk.priorityLess) {\n      // Start with least-recently used RECENT chunk.\n      const { linkedListOperations, recentHead } = this;\n      while (true) {\n        const chunk = linkedListOperations.back(recentHead);\n        if (chunk == null) {\n          break;\n        }\n        yield chunk;\n      }\n      const { heapRoots } = this;\n      for (\n        let tier = ChunkPriorityTier.LAST_ORDERED_TIER;\n        tier >= ChunkPriorityTier.FIRST_ORDERED_TIER;\n        --tier\n      ) {\n        while (true) {\n          const root = heapRoots[tier];\n          if (root == null) {\n            break;\n          }\n          yield root;\n        }\n      }\n    } else {\n      const heapRoots = this.heapRoots;\n      for (\n        let tier = ChunkPriorityTier.FIRST_ORDERED_TIER;\n        tier <= ChunkPriorityTier.LAST_ORDERED_TIER;\n        ++tier\n      ) {\n        while (true) {\n          const root = heapRoots[tier];\n          if (root == null) {\n            break;\n          }\n          yield root;\n        }\n      }\n      const { linkedListOperations, recentHead } = this;\n      while (true) {\n        const chunk = linkedListOperations.front(recentHead);\n        if (chunk == null) {\n          break;\n        }\n        yield chunk;\n      }\n    }\n  }\n\n  /**\n   * Deletes a chunk from this priority queue.\n   * @param chunk The chunk to delete from the priority queue.\n   */\n  delete(chunk: Chunk) {\n    const priorityTier = chunk.priorityTier;\n    if (priorityTier === ChunkPriorityTier.RECENT) {\n      this.linkedListOperations.pop(chunk);\n    } else {\n      const heapRoots = this.heapRoots;\n      heapRoots[priorityTier] = this.heapOperations.remove(\n        <Chunk>heapRoots[priorityTier],\n        chunk,\n      );\n    }\n  }\n}\n\nfunction makeChunkPriorityQueue0(compare: ComparisonFunction<Chunk>) {\n  return new ChunkPriorityQueue(new PairingHeap0(compare), LinkedList0);\n}\n\nfunction makeChunkPriorityQueue1(compare: ComparisonFunction<Chunk>) {\n  return new ChunkPriorityQueue(new PairingHeap1(compare), LinkedList1);\n}\n\nfunction tryToFreeCapacity(\n  size: number,\n  capacity: AvailableCapacity,\n  priorityTier: ChunkPriorityTier,\n  priority: number,\n  evictionCandidates: Iterator<Chunk>,\n  evict: (chunk: Chunk) => void,\n) {\n  while (capacity.availableItems < 1 || capacity.availableSize < size) {\n    const evictionCandidate = evictionCandidates.next().value;\n    if (evictionCandidate === undefined) {\n      // No eviction candidates available, promotions are done.\n      return false;\n    }\n    const evictionTier = evictionCandidate.priorityTier;\n    if (\n      evictionTier < priorityTier ||\n      (evictionTier === priorityTier && evictionCandidate.priority >= priority)\n    ) {\n      // Lowest priority eviction candidate has priority >= highest\n      // priority promotion candidate.  No more promotions are\n      // possible.\n      return false;\n    }\n    evict(evictionCandidate);\n  }\n  return true;\n}\n\nclass AvailableCapacity extends RefCounted {\n  currentSize = 0;\n  currentItems = 0;\n\n  capacityChanged = new NullarySignal();\n\n  constructor(\n    public itemLimit: Borrowed<SharedWatchableValue<number>>,\n    public sizeLimit: Borrowed<SharedWatchableValue<number>>,\n  ) {\n    super();\n    this.registerDisposer(itemLimit.changed.add(this.capacityChanged.dispatch));\n    this.registerDisposer(sizeLimit.changed.add(this.capacityChanged.dispatch));\n  }\n\n  /**\n   * Adjust available capacity by the specified amounts.\n   */\n  adjust(items: number, size: number) {\n    this.currentItems -= items;\n    this.currentSize -= size;\n  }\n\n  get availableSize() {\n    return this.sizeLimit.value - this.currentSize;\n  }\n  get availableItems() {\n    return this.itemLimit.value - this.currentItems;\n  }\n\n  toString() {\n    return (\n      `bytes=${this.currentSize}/${this.sizeLimit.value},` +\n      `items=${this.currentItems}/${this.itemLimit.value}`\n    );\n  }\n}\n\n@registerSharedObject(CHUNK_QUEUE_MANAGER_RPC_ID)\nexport class ChunkQueueManager extends SharedObjectCounterpart {\n  gpuMemoryCapacity: AvailableCapacity;\n  systemMemoryCapacity: AvailableCapacity;\n\n  /**\n   * Download capacity for each sourceQueueLevel.\n   */\n  downloadCapacity: AvailableCapacity[];\n  computeCapacity: AvailableCapacity;\n\n  enablePrefetch: SharedWatchableValue<boolean>;\n\n  /**\n   * Set of chunk sources associated with this queue manager.\n   */\n  sources = new Set<Borrowed<ChunkSource>>();\n\n  /**\n   * Contains all chunks in QUEUED state pending download, for each sourceQueueLevel.\n   */\n  private queuedDownloadPromotionQueue = [\n    makeChunkPriorityQueue1(Chunk.priorityGreater),\n    makeChunkPriorityQueue1(Chunk.priorityGreater),\n  ];\n\n  /**\n   * Contains all chunks in QUEUED state pending compute.\n   */\n  private queuedComputePromotionQueue = makeChunkPriorityQueue1(\n    Chunk.priorityGreater,\n  );\n\n  /**\n   * Contains all chunks in DOWNLOADING state, for each sourceQueueLevel.\n   */\n  private downloadEvictionQueue = [\n    makeChunkPriorityQueue1(Chunk.priorityLess),\n    makeChunkPriorityQueue1(Chunk.priorityLess),\n  ];\n\n  /**\n   * Contains all chunks in COMPUTING state.\n   */\n  private computeEvictionQueue = makeChunkPriorityQueue1(Chunk.priorityLess);\n\n  /**\n   * Contains all chunks that take up memory (DOWNLOADING, SYSTEM_MEMORY,\n   * GPU_MEMORY).\n   */\n  private systemMemoryEvictionQueue = makeChunkPriorityQueue0(\n    Chunk.priorityLess,\n  );\n\n  /**\n   * Contains all chunks in SYSTEM_MEMORY state not in RECENT priority tier.\n   */\n  private gpuMemoryPromotionQueue = makeChunkPriorityQueue1(\n    Chunk.priorityGreater,\n  );\n\n  /**\n   * Contains all chunks in GPU_MEMORY state.\n   */\n  private gpuMemoryEvictionQueue = makeChunkPriorityQueue1(Chunk.priorityLess);\n\n  // Should be `number|null`, but marked `any` to work around @types/node being pulled in.\n  private updatePending: any = null;\n\n  gpuMemoryChanged = new NullarySignal();\n\n  private numQueued = 0;\n  private numFailed = 0;\n  private gpuMemoryGeneration = 0;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    const getCapacity = (capacity: any) => {\n      const result = this.registerDisposer(\n        new AvailableCapacity(\n          rpc.get(capacity.itemLimit),\n          rpc.get(capacity.sizeLimit),\n        ),\n      );\n      result.capacityChanged.add(() => this.scheduleUpdate());\n      return result;\n    };\n    this.gpuMemoryCapacity = getCapacity(options.gpuMemoryCapacity);\n    this.systemMemoryCapacity = getCapacity(options.systemMemoryCapacity);\n    this.enablePrefetch = rpc.get(options.enablePrefetch);\n    this.downloadCapacity = [\n      getCapacity(options.downloadCapacity),\n      getCapacity(options.downloadCapacity),\n    ];\n    this.computeCapacity = getCapacity(options.computeCapacity);\n  }\n\n  scheduleUpdate() {\n    if (this.updatePending === null) {\n      this.updatePending = setTimeout(this.process.bind(this), 0);\n    }\n  }\n\n  *chunkQueuesForChunk(chunk: Chunk) {\n    switch (chunk.state) {\n      case ChunkState.QUEUED:\n        if (chunk.isComputational) {\n          yield this.queuedComputePromotionQueue;\n        } else {\n          yield this.queuedDownloadPromotionQueue[\n            chunk.source!.sourceQueueLevel\n          ];\n        }\n        break;\n\n      case ChunkState.DOWNLOADING:\n        if (chunk.isComputational) {\n          yield this.computeEvictionQueue;\n        } else {\n          yield this.downloadEvictionQueue[chunk.source!.sourceQueueLevel];\n          yield this.systemMemoryEvictionQueue;\n        }\n        break;\n\n      case ChunkState.SYSTEM_MEMORY_WORKER:\n      case ChunkState.SYSTEM_MEMORY:\n        yield this.systemMemoryEvictionQueue;\n        if (chunk.requestedState === ChunkState.GPU_MEMORY) {\n          yield this.gpuMemoryPromotionQueue;\n        }\n        break;\n\n      case ChunkState.GPU_MEMORY:\n        yield this.systemMemoryEvictionQueue;\n        yield this.gpuMemoryEvictionQueue;\n        break;\n    }\n  }\n\n  adjustCapacitiesForChunk(chunk: Chunk, add: boolean) {\n    const factor = add ? -1 : 1;\n    switch (chunk.state) {\n      case ChunkState.FAILED:\n        this.numFailed -= factor;\n        break;\n\n      case ChunkState.QUEUED:\n        this.numQueued -= factor;\n        break;\n\n      case ChunkState.DOWNLOADING:\n        (chunk.isComputational\n          ? this.computeCapacity\n          : this.downloadCapacity[chunk.source!.sourceQueueLevel]\n        ).adjust(\n          factor * chunk.downloadSlots,\n          factor * chunk.systemMemoryBytes,\n        );\n        this.systemMemoryCapacity.adjust(\n          factor,\n          factor * chunk.systemMemoryBytes,\n        );\n        break;\n\n      case ChunkState.SYSTEM_MEMORY:\n      case ChunkState.SYSTEM_MEMORY_WORKER:\n        this.systemMemoryCapacity.adjust(\n          factor,\n          factor * chunk.systemMemoryBytes,\n        );\n        break;\n\n      case ChunkState.GPU_MEMORY:\n        this.systemMemoryCapacity.adjust(\n          factor,\n          factor * chunk.systemMemoryBytes,\n        );\n        this.gpuMemoryCapacity.adjust(factor, factor * chunk.gpuMemoryBytes);\n        break;\n    }\n  }\n\n  private removeChunkFromQueues_(chunk: Chunk) {\n    updateChunkStatistics(chunk, -1);\n    for (const queue of this.chunkQueuesForChunk(chunk)) {\n      queue.delete(chunk);\n    }\n  }\n\n  // var freedChunks = 0;\n  private addChunkToQueues_(chunk: Chunk) {\n    if (\n      chunk.state === ChunkState.QUEUED &&\n      chunk.priorityTier === ChunkPriorityTier.RECENT\n    ) {\n      // Delete this chunk.\n      const { source } = chunk;\n      source!.removeChunk(chunk);\n      this.adjustCapacitiesForChunk(chunk, false);\n      return false;\n    }\n    updateChunkStatistics(chunk, 1);\n    for (const queue of this.chunkQueuesForChunk(chunk)) {\n      queue.add(chunk);\n    }\n    return true;\n  }\n\n  performChunkPriorityUpdate(chunk: Chunk) {\n    if (\n      chunk.priorityTier === chunk.newPriorityTier &&\n      chunk.priority === chunk.newPriority\n    ) {\n      chunk.newPriorityTier = ChunkPriorityTier.RECENT;\n      chunk.newPriority = Number.NEGATIVE_INFINITY;\n      return;\n    }\n    if (DEBUG_CHUNK_UPDATES) {\n      console.log(\n        `${chunk}: changed priority ${chunk.priorityTier}:` +\n          `${chunk.priority} -> ${chunk.newPriorityTier}:${chunk.newPriority}`,\n      );\n    }\n    this.removeChunkFromQueues_(chunk);\n    chunk.updatePriorityProperties();\n    if (chunk.state === ChunkState.NEW) {\n      chunk.state = ChunkState.QUEUED;\n      this.adjustCapacitiesForChunk(chunk, true);\n    }\n    this.addChunkToQueues_(chunk);\n  }\n\n  updateChunkState(chunk: Chunk, newState: ChunkState) {\n    if (newState === chunk.state) {\n      return;\n    }\n    if (DEBUG_CHUNK_UPDATES) {\n      console.log(\n        `${chunk}: changed state ${ChunkState[chunk.state]} -> ${\n          ChunkState[newState]\n        }`,\n      );\n    }\n    this.adjustCapacitiesForChunk(chunk, false);\n    this.removeChunkFromQueues_(chunk);\n    chunk.state = newState;\n    this.adjustCapacitiesForChunk(chunk, true);\n    this.addChunkToQueues_(chunk);\n    this.scheduleUpdate();\n  }\n\n  private processGPUPromotions_() {\n    const queueManager = this;\n    function evictFromGPUMemory(chunk: Chunk) {\n      queueManager.freeChunkGPUMemory(chunk);\n      chunk.source!.chunkManager.queueManager.updateChunkState(\n        chunk,\n        ChunkState.SYSTEM_MEMORY,\n      );\n    }\n    const promotionCandidates = this.gpuMemoryPromotionQueue.candidates();\n    const evictionCandidates = this.gpuMemoryEvictionQueue.candidates();\n    const capacity = this.gpuMemoryCapacity;\n    while (true) {\n      const promotionCandidate = promotionCandidates.next().value;\n      if (promotionCandidate === undefined) {\n        break;\n      }\n      const priorityTier = promotionCandidate.priorityTier;\n      const priority = promotionCandidate.priority;\n      if (\n        !tryToFreeCapacity(\n          promotionCandidate.gpuMemoryBytes,\n          capacity,\n          priorityTier,\n          priority,\n          evictionCandidates,\n          evictFromGPUMemory,\n        )\n      ) {\n        break;\n      }\n      this.copyChunkToGPU(promotionCandidate);\n      this.updateChunkState(promotionCandidate, ChunkState.GPU_MEMORY);\n    }\n  }\n\n  freeChunkGPUMemory(chunk: Chunk) {\n    ++this.gpuMemoryGeneration;\n    this.rpc!.invoke(\"Chunk.update\", {\n      id: chunk.key,\n      state: ChunkState.SYSTEM_MEMORY,\n      source: chunk.source!.rpcId,\n    });\n  }\n\n  freeChunkSystemMemory(chunk: Chunk) {\n    if (chunk.state === ChunkState.SYSTEM_MEMORY_WORKER) {\n      chunk.freeSystemMemory();\n    } else {\n      this.rpc!.invoke(\"Chunk.update\", {\n        id: chunk.key,\n        state: ChunkState.EXPIRED,\n        source: chunk.source!.rpcId,\n      });\n    }\n  }\n\n  retrieveChunkData(chunk: Chunk) {\n    return this.rpc!.promiseInvoke<TypedArray>(\"Chunk.retrieve\", {\n      key: chunk.key!,\n      source: chunk.source!.rpcId,\n    });\n  }\n\n  copyChunkToGPU(chunk: Chunk) {\n    ++this.gpuMemoryGeneration;\n    const rpc = this.rpc!;\n    if (chunk.state === ChunkState.SYSTEM_MEMORY) {\n      rpc.invoke(\"Chunk.update\", {\n        id: chunk.key,\n        source: chunk.source!.rpcId,\n        state: ChunkState.GPU_MEMORY,\n      });\n    } else {\n      const msg: any = {};\n      const transfers: any[] = [];\n      chunk.serialize(msg, transfers);\n      msg.state = ChunkState.GPU_MEMORY;\n      rpc.invoke(\"Chunk.update\", msg, transfers);\n    }\n  }\n\n  moveChunkToFrontend(chunk: Chunk) {\n    const rpc = this.rpc!;\n    const msg: any = {};\n    const transfers: any[] = [];\n    chunk.serialize(msg, transfers);\n    msg.state = ChunkState.SYSTEM_MEMORY;\n    rpc.invoke(\"Chunk.update\", msg, transfers);\n  }\n\n  private processQueuePromotions_() {\n    const evict = (chunk: Chunk) => {\n      switch (chunk.state) {\n        case ChunkState.DOWNLOADING:\n          cancelChunkDownload(chunk);\n          break;\n        case ChunkState.GPU_MEMORY:\n          this.freeChunkGPUMemory(chunk);\n        // fallthrough\n        case ChunkState.SYSTEM_MEMORY_WORKER:\n        case ChunkState.SYSTEM_MEMORY:\n          this.freeChunkSystemMemory(chunk);\n          break;\n      }\n      // Note: After calling this, chunk may no longer be valid.\n      this.updateChunkState(chunk, ChunkState.QUEUED);\n    };\n\n    const promotionLambda = (\n      promotionCandidates: Iterator<Chunk>,\n      evictionCandidates: Iterator<Chunk>,\n      capacity: AvailableCapacity,\n    ) => {\n      const systemMemoryEvictionCandidates =\n        this.systemMemoryEvictionQueue.candidates();\n      const systemMemoryCapacity = this.systemMemoryCapacity;\n      while (true) {\n        const promotionCandidateResult = promotionCandidates.next();\n        if (promotionCandidateResult.done) {\n          return;\n        }\n        const promotionCandidate = promotionCandidateResult.value;\n        const size = 0; /* unknown size, since it hasn't been downloaded yet. */\n        const priorityTier = promotionCandidate.priorityTier;\n        const priority = promotionCandidate.priority;\n        // console.log(\"Download capacity: \" + downloadCapacity);\n        if (\n          !tryToFreeCapacity(\n            size,\n            capacity,\n            priorityTier,\n            priority,\n            evictionCandidates,\n            evict,\n          )\n        ) {\n          return;\n        }\n        if (\n          !tryToFreeCapacity(\n            size,\n            systemMemoryCapacity,\n            priorityTier,\n            priority,\n            systemMemoryEvictionCandidates,\n            evict,\n          )\n        ) {\n          return;\n        }\n        this.updateChunkState(promotionCandidate, ChunkState.DOWNLOADING);\n        startChunkDownload(promotionCandidate);\n      }\n    };\n\n    for (\n      let sourceQueueLevel = 0;\n      sourceQueueLevel < numSourceQueueLevels;\n      ++sourceQueueLevel\n    ) {\n      promotionLambda(\n        this.queuedDownloadPromotionQueue[sourceQueueLevel].candidates(),\n        this.downloadEvictionQueue[sourceQueueLevel].candidates(),\n        this.downloadCapacity[sourceQueueLevel],\n      );\n    }\n    promotionLambda(\n      this.queuedComputePromotionQueue.candidates(),\n      this.computeEvictionQueue.candidates(),\n      this.computeCapacity,\n    );\n  }\n\n  process() {\n    if (!this.updatePending) {\n      return;\n    }\n    this.updatePending = null;\n    const gpuMemoryGeneration = this.gpuMemoryGeneration;\n    this.processGPUPromotions_();\n    this.processQueuePromotions_();\n    this.logStatistics();\n    if (this.gpuMemoryGeneration !== gpuMemoryGeneration) {\n      this.gpuMemoryChanged.dispatch();\n    }\n  }\n\n  logStatistics() {\n    if (DEBUG_CHUNK_UPDATES) {\n      console.log(\n        `[Chunk status] QUEUED: ${this.numQueued}, FAILED: ` +\n          `${this.numFailed}, DOWNLOAD: ${this.downloadCapacity}, ` +\n          `MEM: ${this.systemMemoryCapacity}, GPU: ${this.gpuMemoryCapacity}`,\n      );\n    }\n  }\n\n  invalidateSourceCache(source: ChunkSource) {\n    for (const chunk of source.chunks.values()) {\n      switch (chunk.state) {\n        case ChunkState.DOWNLOADING:\n          cancelChunkDownload(chunk);\n          break;\n        case ChunkState.SYSTEM_MEMORY_WORKER:\n          chunk.freeSystemMemory();\n          break;\n      }\n      // Note: After calling this, chunk may no longer be valid.\n      this.updateChunkState(chunk, ChunkState.QUEUED);\n    }\n    this.rpc!.invoke(\"Chunk.update\", { source: source.rpcId });\n    this.scheduleUpdate();\n  }\n}\n\nexport class ChunkRenderLayerBackend\n  extends SharedObjectCounterpart\n  implements LayerChunkProgressInfo\n{\n  chunkManagerGeneration = -1;\n\n  numVisibleChunksNeeded = 0;\n  numVisibleChunksAvailable = 0;\n  numPrefetchChunksNeeded = 0;\n  numPrefetchChunksAvailable = 0;\n}\n\nconst LAYER_CHUNK_STATISTICS_INTERVAL = 200;\n\n@registerSharedObject(CHUNK_MANAGER_RPC_ID)\nexport class ChunkManager extends SharedObjectCounterpart {\n  queueManager: ChunkQueueManager;\n\n  /**\n   * Array of chunks within each existing priority tier.\n   */\n  private existingTierChunks: Chunk[][] = [];\n\n  /**\n   * Array of chunks whose new priorities have not yet been reflected in the\n   * queue states.\n   */\n  private newTierChunks: Chunk[] = [];\n\n  // Should be `number|null`, but marked `any` to workaround `@types/node` being pulled in.\n  private updatePending: any = null;\n\n  recomputeChunkPriorities = new NullarySignal();\n\n  /**\n   * Dispatched immediately after recomputeChunkPriorities is dispatched.\n   * This signal should be used for handlers that depend on the result of another handler.\n   */\n  recomputeChunkPrioritiesLate = new NullarySignal();\n\n  memoize = new StringMemoize();\n\n  layers: ChunkRenderLayerBackend[] = [];\n\n  private sendLayerChunkStatistics = this.registerCancellable(\n    throttle(() => {\n      this.rpc!.invoke(CHUNK_LAYER_STATISTICS_RPC_ID, {\n        id: this.rpcId,\n        layers: this.layers.map((layer) => ({\n          id: layer.rpcId,\n          numVisibleChunksAvailable: layer.numVisibleChunksAvailable,\n          numVisibleChunksNeeded: layer.numVisibleChunksNeeded,\n          numPrefetchChunksAvailable: layer.numPrefetchChunksAvailable,\n          numPrefetchChunksNeeded: layer.numPrefetchChunksNeeded,\n        })),\n      });\n    }, LAYER_CHUNK_STATISTICS_INTERVAL),\n  );\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.queueManager = (<ChunkQueueManager>(\n      rpc.get(options.chunkQueueManager)\n    )).addRef();\n\n    // Update chunk priorities periodically after GPU memory changes to ensure layer chunk\n    // statistics are updated.\n    this.registerDisposer(\n      this.queueManager.gpuMemoryChanged.add(\n        this.registerCancellable(\n          throttle(\n            () => this.scheduleUpdateChunkPriorities(),\n            LAYER_CHUNK_STATISTICS_INTERVAL,\n            { leading: false, trailing: true },\n          ),\n        ),\n      ),\n    );\n\n    for (\n      let tier = ChunkPriorityTier.FIRST_TIER;\n      tier <= ChunkPriorityTier.LAST_TIER;\n      ++tier\n    ) {\n      if (tier === ChunkPriorityTier.RECENT) {\n        continue;\n      }\n      this.existingTierChunks[tier] = [];\n    }\n  }\n\n  scheduleUpdateChunkPriorities() {\n    if (this.updatePending === null) {\n      this.updatePending = setTimeout(\n        this.recomputeChunkPriorities_.bind(this),\n        0,\n      );\n    }\n  }\n\n  registerLayer(layer: ChunkRenderLayerBackend) {\n    const generation = this.recomputeChunkPriorities.count;\n    if (layer.chunkManagerGeneration !== generation) {\n      layer.chunkManagerGeneration = generation;\n      this.layers.push(layer);\n      layer.numVisibleChunksAvailable = 0;\n      layer.numVisibleChunksNeeded = 0;\n      layer.numPrefetchChunksAvailable = 0;\n      layer.numPrefetchChunksNeeded = 0;\n    }\n  }\n\n  private recomputeChunkPriorities_() {\n    this.updatePending = null;\n    this.layers.length = 0;\n    this.recomputeChunkPriorities.dispatch();\n    this.recomputeChunkPrioritiesLate.dispatch();\n    this.updateQueueState([\n      ChunkPriorityTier.VISIBLE,\n      ChunkPriorityTier.PREFETCH,\n    ]);\n    this.sendLayerChunkStatistics();\n  }\n\n  /**\n   * @param chunk\n   * @param tier New priority tier.  Must not equal ChunkPriorityTier.RECENT.\n   * @param priority Priority within tier.\n   * @param requestedState Indicates requested chunk state.\n   */\n  requestChunk(\n    chunk: Chunk,\n    tier: ChunkPriorityTier,\n    priority: number,\n    requestedState: ChunkState = ChunkState.GPU_MEMORY,\n  ) {\n    if (Number.isNaN(priority)) {\n      return;\n    }\n    if (tier === ChunkPriorityTier.RECENT) {\n      throw new Error(\"Not going to request a chunk with the RECENT tier\");\n    }\n    chunk.newRequestedState = Math.min(chunk.newRequestedState, requestedState);\n    if (chunk.newPriorityTier === ChunkPriorityTier.RECENT) {\n      this.newTierChunks.push(chunk);\n    }\n    const newPriorityTier = chunk.newPriorityTier;\n    if (\n      tier < newPriorityTier ||\n      (tier === newPriorityTier && priority > chunk.newPriority)\n    ) {\n      chunk.newPriorityTier = tier;\n      chunk.newPriority = priority;\n    }\n  }\n\n  /**\n   * Update queue state to reflect updated contents of the specified priority tiers.  Existing\n   * chunks within those tiers not present in this.newTierChunks will be moved to the RECENT tier\n   * (and removed if in the QUEUED state).\n   */\n  updateQueueState(tiers: ChunkPriorityTier[]) {\n    const existingTierChunks = this.existingTierChunks;\n    const queueManager = this.queueManager;\n    for (const tier of tiers) {\n      const chunks = existingTierChunks[tier];\n      if (DEBUG_CHUNK_UPDATES) {\n        console.log(\n          `existingTierChunks[${ChunkPriorityTier[tier]}].length=${chunks.length}`,\n        );\n      }\n      for (const chunk of chunks) {\n        if (chunk.newPriorityTier === ChunkPriorityTier.RECENT) {\n          // Downgrade the priority of this chunk.\n          queueManager.performChunkPriorityUpdate(chunk);\n        }\n      }\n      chunks.length = 0;\n    }\n    const newTierChunks = this.newTierChunks;\n    for (const chunk of newTierChunks) {\n      queueManager.performChunkPriorityUpdate(chunk);\n      existingTierChunks[chunk.priorityTier].push(chunk);\n    }\n    if (DEBUG_CHUNK_UPDATES) {\n      console.log(\n        `updateQueueState: newTierChunks.length = ${newTierChunks.length}`,\n      );\n    }\n    newTierChunks.length = 0;\n    this.queueManager.scheduleUpdate();\n  }\n}\n\n/**\n * Mixin for adding a `parameters` member to a ChunkSource, and for registering the shared object\n * type based on the `RPC_ID` member of the Parameters class.\n */\nexport function WithParameters<\n  Parameters,\n  TBase extends { new (...args: any[]): SharedObject },\n>(\n  Base: TBase,\n  parametersConstructor: ChunkSourceParametersConstructor<Parameters>,\n) {\n  @registerSharedObjectOwner(parametersConstructor.RPC_ID)\n  class C extends Base {\n    parameters: Parameters;\n    constructor(...args: any[]) {\n      super(...args);\n      const options = args[1];\n      this.parameters = options.parameters;\n    }\n  }\n  return C;\n}\n\n/**\n * Interface that represents shared objects that request chunks from a ChunkManager.\n */\nexport interface ChunkRequester extends SharedObject {\n  chunkManager: ChunkManager;\n}\n\n/**\n * Mixin that adds a chunkManager property initialized from the RPC-supplied options.\n *\n * The resultant class implements `ChunkRequester`.\n */\nexport function withChunkManager<\n  T extends { new (...args: any[]): SharedObject },\n>(Base: T) {\n  return class extends Base implements ChunkRequester {\n    chunkManager: ChunkManager;\n    constructor(...args: any[]) {\n      super(...args);\n      const rpc: RPC = args[0];\n      const options = args[1];\n      // We don't increment the reference count, because our owner owns a reference to the\n      // ChunkManager.\n      this.chunkManager = <ChunkManager>rpc.get(options.chunkManager);\n    }\n  };\n}\n\nregisterRPC(CHUNK_SOURCE_INVALIDATE_RPC_ID, function (x) {\n  const source = <ChunkSource>this.get(x.id);\n  source.chunkManager.queueManager.invalidateSourceCache(source);\n});\n\nregisterPromiseRPC(\n  REQUEST_CHUNK_STATISTICS_RPC_ID,\n  function (x: { queue: number }) {\n    const queue = this.get(x.queue) as ChunkQueueManager;\n    const results = new Map<number, Float64Array>();\n    for (const source of queue.sources) {\n      results.set(source.rpcId!, source.statistics);\n    }\n    return Promise.resolve({ value: results });\n  },\n);\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ChunkRenderLayerBackend } from \"#src/chunk_manager/backend.js\";\nimport type { ProjectionParameters } from \"#src/projection_parameters.js\";\nimport {\n  PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID,\n  PROJECTION_PARAMETERS_RPC_ID,\n  RENDERED_VIEW_ADD_LAYER_RPC_ID,\n  RENDERED_VIEW_REMOVE_LAYER_RPC_ID,\n} from \"#src/render_layer_common.js\";\nimport type {\n  WatchableValueChangeInterface,\n  WatchableValueInterface,\n} from \"#src/trackable_value.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { Signal } from \"#src/util/signal.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nexport interface RenderedViewBackend {\n  visibility: WatchableValueInterface<number>;\n  projectionParameters: WatchableValueInterface<ProjectionParameters>;\n}\n\nexport class RenderLayerBackendAttachment<\n  ViewBackend extends RenderedViewBackend = RenderedViewBackend,\n  AttachmentState = unknown,\n> extends RefCounted {\n  state: AttachmentState | undefined = undefined;\n  constructor(public view: ViewBackend) {\n    super();\n  }\n}\n\nexport class RenderLayerBackend<\n  ViewBackend extends RenderedViewBackend = RenderedViewBackend,\n  AttachmentState = unknown,\n> extends ChunkRenderLayerBackend {\n  attachments = new Map<ViewBackend, RenderLayerBackendAttachment>();\n  attach(\n    attachment: RenderLayerBackendAttachment<ViewBackend, AttachmentState>,\n  ) {\n    attachment;\n  }\n}\n\nregisterRPC(RENDERED_VIEW_ADD_LAYER_RPC_ID, function (x) {\n  const view: RenderedViewBackend = this.get(x.view);\n  const layer: RenderLayerBackend = this.get(x.layer);\n  const attachment = new RenderLayerBackendAttachment(view);\n  layer.attachments.set(view, attachment);\n  layer.attach(attachment);\n});\n\nregisterRPC(RENDERED_VIEW_REMOVE_LAYER_RPC_ID, function (x) {\n  const view: RenderedViewBackend = this.get(x.view);\n  const layer: RenderLayerBackend = this.get(x.layer);\n  const attachment = layer.attachments.get(view)!;\n  layer.attachments.delete(view);\n  attachment.dispose();\n});\n\n@registerSharedObject(PROJECTION_PARAMETERS_RPC_ID)\nexport class SharedProjectionParametersBackend<\n    T extends ProjectionParameters = ProjectionParameters,\n  >\n  extends SharedObjectCounterpart\n  implements WatchableValueChangeInterface<T>\n{\n  value: T;\n  oldValue: T;\n  changed = new Signal<(oldValue: T, newValue: T) => void>();\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.value = options.value;\n    this.oldValue = Object.assign({}, this.value);\n  }\n}\n\nregisterRPC(PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID, function (x) {\n  const obj: SharedProjectionParametersBackend = this.get(x.id);\n  const { value, oldValue } = obj;\n  Object.assign(oldValue, value);\n  Object.assign(value, x.value);\n  obj.changed.dispatch(oldValue, value);\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface WritableArrayLike<T> {\n  length: number;\n  [n: number]: T;\n}\n\n/**\n * Partitions array[start:end] such that all elements for which predicate\n * returns true are before the elements for which predicate returns false.\n *\n * predicate will be called exactly once for each element in array[start:end],\n * in order.\n *\n * @returns {number} The index of the first element for which predicate returns\n * false, or end if there is no such element.\n */\nexport function partitionArray<T>(\n  array: T[],\n  start: number,\n  end: number,\n  predicate: (x: T) => boolean,\n): number {\n  while (start < end) {\n    const x = array[start];\n    if (predicate(x)) {\n      ++start;\n      continue;\n    }\n    --end;\n    array[start] = array[end];\n    array[end] = x;\n  }\n  return end;\n}\n\nexport function filterArrayInplace<T>(\n  array: T[],\n  predicate: (x: T, index: number, array: T[]) => boolean,\n) {\n  const length = array.length;\n  let outIndex = 0;\n  for (let i = 0; i < length; ++i) {\n    if (predicate(array[i], i, array)) {\n      array[outIndex] = array[i];\n      ++outIndex;\n    }\n  }\n  array.length = outIndex;\n}\n\nexport type TypedArrayConstructor<\n  TArrayBuffer extends ArrayBufferLike = ArrayBufferLike,\n> = (\n  | typeof Int8Array<TArrayBuffer>\n  | typeof Uint8Array<TArrayBuffer>\n  | typeof Int16Array<TArrayBuffer>\n  | typeof Uint16Array<TArrayBuffer>\n  | typeof Int32Array<TArrayBuffer>\n  | typeof Uint32Array<TArrayBuffer>\n  | typeof Float32Array<TArrayBuffer>\n  | typeof Float64Array<TArrayBuffer>\n) &\n  (TArrayBuffer extends ArrayBuffer\n    ? { new (count: number): TypedArray<ArrayBuffer> }\n    : Record<string, never>);\n\nexport type TypedArray<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> =\n\n    | Int8Array<TArrayBuffer>\n    | Uint8Array<TArrayBuffer>\n    | Int16Array<TArrayBuffer>\n    | Uint16Array<TArrayBuffer>\n    | Int32Array<TArrayBuffer>\n    | Uint32Array<TArrayBuffer>\n    | Float32Array<TArrayBuffer>\n    | Float64Array<TArrayBuffer>;\n\n/**\n * Returns an array of size newSize that starts with the contents of array.\n * Either returns array if it has the correct size, or a new array with zero\n * padding at the end.\n */\nexport function maybePadArray<\n  TArrayBuffer extends ArrayBufferLike,\n  T extends TypedArray<TArrayBuffer>,\n>(array: T, newSize: number): T {\n  if (array.length === newSize) {\n    return array;\n  }\n  const newArray = new (<any>array.constructor)(newSize);\n  newArray.set(array);\n  return newArray;\n}\n\nexport function getFortranOrderStrides(\n  size: ArrayLike<number>,\n  baseStride = 1,\n) {\n  const length = size.length;\n  const strides = new Array<number>(length);\n  let stride = (strides[0] = baseStride);\n  for (let i = 1; i < length; ++i) {\n    stride *= size[i - 1];\n    strides[i] = stride;\n  }\n  return strides;\n}\n\n/**\n * Converts an array of shape [majorSize, minorSize] to\n * [minorSize, majorSize].\n */\nexport function transposeArray2d<T extends TypedArray>(\n  array: T,\n  majorSize: number,\n  minorSize: number,\n): T {\n  const transpose = new (<any>array.constructor)(array.length);\n  for (let i = 0; i < majorSize * minorSize; i += minorSize) {\n    for (let j = 0; j < minorSize; j++) {\n      const index: number = i / minorSize;\n      transpose[j * majorSize + index] = array[i + j];\n    }\n  }\n  return transpose;\n}\n\nexport function tile2dArray<T extends TypedArray>(\n  array: T,\n  majorDimension: number,\n  minorTiles: number,\n  majorTiles: number,\n) {\n  const minorDimension = array.length / majorDimension;\n  const length = array.length * minorTiles * majorTiles;\n  const result: T = new (<any>array.constructor)(length);\n  const minorTileStride = array.length * majorTiles;\n  const majorTileStride = majorDimension;\n  const minorStride = majorDimension * majorTiles;\n  for (let minor = 0; minor < minorDimension; ++minor) {\n    for (let major = 0; major < majorDimension; ++major) {\n      const inputValue = array[minor * majorDimension + major];\n      const baseOffset = minor * minorStride + major;\n      for (let minorTile = 0; minorTile < minorTiles; ++minorTile) {\n        for (let majorTile = 0; majorTile < majorTiles; ++majorTile) {\n          result[\n            minorTile * minorTileStride +\n              majorTile * majorTileStride +\n              baseOffset\n          ] = inputValue;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nexport function binarySearch<T>(\n  haystack: ArrayLike<T>,\n  needle: T,\n  compare: (a: T, b: T) => number,\n  low = 0,\n  high = haystack.length,\n) {\n  while (low < high) {\n    const mid = (low + high - 1) >> 1;\n    const compareResult = compare(needle, haystack[mid]);\n    if (compareResult > 0) {\n      low = mid + 1;\n    } else if (compareResult < 0) {\n      high = mid;\n    } else {\n      return mid;\n    }\n  }\n  return ~low;\n}\n\n/**\n * Returns the index of the element in `haystack` that is closest to `needle`, according to\n * `compare`.  If there are multiple elements that are equally close, the index of the first such\n * element encountered is returned.  If `haystack` is empty, returns -1.\n */\nexport function findClosestMatchInSortedArray<T>(\n  haystack: ArrayLike<T>,\n  needle: T,\n  compare: (a: T, b: T) => number,\n  low = 0,\n  high = haystack.length,\n): number {\n  let bestIndex = -1;\n  let bestDistance = Infinity;\n  while (low < high) {\n    const mid = (low + high - 1) >> 1;\n    const compareResult = compare(needle, haystack[mid]);\n    if (compareResult > 0) {\n      low = mid + 1;\n    } else if (compareResult < 0) {\n      high = mid;\n    } else {\n      return mid;\n    }\n    const distance = Math.abs(compareResult);\n    if (distance < bestDistance) {\n      bestDistance = distance;\n      bestIndex = mid;\n    }\n  }\n  return bestIndex;\n}\n\n/**\n * Returns the first index in `[begin, end)` for which `predicate` is `true`, or returns `end` if no\n * such index exists.\n *\n * For any index `i` in `(begin, end)`, it must be the case that `predicate(i) >= predicate(i - 1)`.\n */\nexport function binarySearchLowerBound(\n  begin: number,\n  end: number,\n  predicate: (index: number) => boolean,\n): number {\n  let count = end - begin;\n  while (count > 0) {\n    const step = Math.floor(count / 2);\n    const i = begin + step;\n    if (predicate(i)) {\n      count = step;\n    } else {\n      begin = i + 1;\n      count -= step + 1;\n    }\n  }\n  return begin;\n}\n\n/**\n * Returns an array of indices into `input` that equal (under `===`) `value`.\n */\nexport function findMatchingIndices<T>(input: T[], value: T) {\n  const out: number[] = [];\n  for (let i = 0, length = input.length; i < length; ++i) {\n    if (input[i] === value) {\n      out.push(i);\n    }\n  }\n  return out;\n}\n\n/**\n * Returns an array of the indices in `[0, ..., max)` not in `indices`.\n */\nexport function getIndicesComplement(indices: number[], max: number) {\n  const mask: boolean[] = [];\n  mask.length = max;\n  for (const i of indices) {\n    mask[i] = true;\n  }\n  return findMatchingIndices(mask, undefined);\n}\n\nexport function arraysEqual<T>(a: ArrayLike<T>, b: ArrayLike<T>) {\n  const length = a.length;\n  if (b.length !== length) return false;\n  for (let i = 0; i < length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nexport function arraysEqualWithPredicate<T>(\n  a: ArrayLike<T>,\n  b: ArrayLike<T>,\n  elementsEqual: (a: T, b: T) => boolean = (a, b) => a === b,\n) {\n  const length = a.length;\n  if (b.length !== length) return false;\n  for (let i = 0; i < length; ++i) {\n    if (!elementsEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function getInsertPermutation(\n  n: number,\n  sourceIndex: number,\n  targetIndex: number,\n) {\n  const newToOld: number[] = [];\n  if (targetIndex === sourceIndex) {\n    for (let i = 0; i < n; ++i) {\n      newToOld[i] = i;\n    }\n    return newToOld;\n  }\n  newToOld[targetIndex] = sourceIndex;\n  for (let oldDim = 0, newDim = 0; oldDim < n; ) {\n    if (oldDim === sourceIndex) {\n      ++oldDim;\n      continue;\n    }\n    if (newDim === targetIndex) {\n      ++newDim;\n    }\n    newToOld[newDim++] = oldDim++;\n  }\n  return newToOld;\n}\n\nexport function scatterUpdate<\n  T,\n  Dest extends { [index: number]: T },\n  Source extends { readonly [index: number]: T },\n>(dest: Dest, source: Source, indices: ArrayLike<number>): Dest {\n  for (\n    let sourceIndex = 0, length = indices.length;\n    sourceIndex < length;\n    ++sourceIndex\n  ) {\n    const destIndex = indices[sourceIndex];\n    if (destIndex === -1) continue;\n    dest[destIndex] = source[sourceIndex];\n  }\n  return dest;\n}\n\nexport function gatherUpdate<\n  T,\n  Dest extends { [index: number]: T },\n  Source extends { readonly [index: number]: T },\n>(dest: Dest, source: Source, indices: ArrayLike<number>): Dest {\n  for (\n    let destIndex = 0, length = indices.length;\n    destIndex < length;\n    ++destIndex\n  ) {\n    const sourceIndex = indices[destIndex];\n    if (sourceIndex === -1) continue;\n    dest[destIndex] = source[sourceIndex];\n  }\n  return dest;\n}\n\nexport function transposeNestedArrays<T>(x: T[][]) {\n  const result: T[][] = [];\n  for (\n    let outerIndex = 0, outerLength = x.length;\n    outerIndex < outerLength;\n    ++outerIndex\n  ) {\n    const inner = x[outerIndex];\n    for (\n      let innerIndex = 0, innerLength = inner.length;\n      innerIndex < innerLength;\n      ++innerIndex\n    ) {\n      let resultInner = result[innerIndex];\n      if (resultInner === undefined) {\n        resultInner = result[innerIndex] = [];\n      }\n      resultInner.push(inner[innerIndex]);\n    }\n  }\n  return result;\n}\n\nexport interface ArraySpliceOp {\n  retainCount: number;\n  deleteCount: number;\n  insertCount: number;\n}\n\nexport function spliceArray<T>(\n  array: T[],\n  splices: readonly Readonly<ArraySpliceOp>[],\n) {\n  const parts: T[][] = [];\n  let origOffset = 0;\n  for (let i = 0, numSplices = splices.length; i < numSplices; ++i) {\n    const { retainCount, deleteCount, insertCount } = splices[i];\n    if (retainCount !== 0) {\n      parts.push(array.slice(origOffset, origOffset + retainCount));\n      origOffset += retainCount;\n    }\n    origOffset += deleteCount;\n    if (insertCount !== 0) {\n      parts.push(new Array<T>(insertCount));\n    }\n  }\n  const origLength = array.length;\n  if (origOffset !== origLength) {\n    parts.push(array.slice(origOffset));\n  }\n  return new Array(0).concat(...parts);\n}\n\nexport function getMergeSplices<T>(\n  oldArray: readonly T[],\n  newArray: readonly T[],\n  compare: (a: T, b: T) => number,\n): ArraySpliceOp[] {\n  const splices: ArraySpliceOp[] = [];\n  let oldIndex = 0;\n  let newIndex = 0;\n  const oldCount = oldArray.length;\n  const newCount = newArray.length;\n  while (oldIndex < oldCount && newIndex < newCount) {\n    let c: number;\n    const oldValue = oldArray[oldIndex];\n    const newValue = newArray[newIndex];\n    c = compare(oldValue, newValue);\n    if (c === 0) {\n      let retainCount = 1;\n      ++oldIndex;\n      ++newIndex;\n      while (\n        oldIndex < oldCount &&\n        newIndex < newCount &&\n        (c = compare(oldArray[oldIndex], newArray[newIndex])) === 0\n      ) {\n        ++retainCount;\n        ++oldIndex;\n        ++newIndex;\n      }\n      splices.push({ retainCount, deleteCount: 0, insertCount: 0 });\n      continue;\n    }\n    if (c < 0) {\n      let deleteCount = 1;\n      while (\n        ++oldIndex < oldCount &&\n        (c = compare(oldArray[oldIndex], newValue)) < 0\n      ) {\n        ++deleteCount;\n      }\n      splices.push({ retainCount: 0, deleteCount, insertCount: 0 });\n      continue;\n    }\n    if (c > 0) {\n      let insertCount = 1;\n      while (\n        ++newIndex < newCount &&\n        (c = compare(oldValue, newArray[newIndex])) > 0\n      ) {\n        ++insertCount;\n      }\n      splices.push({ retainCount: 0, deleteCount: 0, insertCount });\n    }\n  }\n  if (oldIndex < oldCount || newIndex < newCount) {\n    splices.push({\n      retainCount: 0,\n      deleteCount: oldCount - oldIndex,\n      insertCount: newCount - newIndex,\n    });\n  }\n  return splices;\n}\n\nexport function getFixedOrderMergeSplices<T>(\n  oldArray: readonly T[],\n  newArray: readonly T[],\n  equal: (a: T, b: T) => boolean,\n): ArraySpliceOp[] {\n  const splices: ArraySpliceOp[] = [];\n  let oldIndex = 0;\n  let newIndex = 0;\n  const oldCount = oldArray.length;\n  const newCount = newArray.length;\n  while (oldIndex < oldCount) {\n    let retainCount = 0;\n    while (\n      oldIndex < oldCount &&\n      newIndex < newCount &&\n      equal(oldArray[oldIndex], newArray[newIndex])\n    ) {\n      ++retainCount;\n      ++oldIndex;\n      ++newIndex;\n    }\n    if (retainCount !== 0) {\n      splices.push({ retainCount, deleteCount: 0, insertCount: 0 });\n    }\n    let deleteCount = 0;\n    while (\n      oldIndex < oldCount &&\n      (newIndex === newCount || !equal(oldArray[oldIndex], newArray[newIndex]))\n    ) {\n      ++deleteCount;\n      ++oldIndex;\n    }\n    if (deleteCount !== 0) {\n      splices.push({ retainCount: 0, deleteCount, insertCount: 0 });\n    }\n  }\n  if (newIndex !== newCount) {\n    splices.push({\n      retainCount: 0,\n      deleteCount: 0,\n      insertCount: newCount - newIndex,\n    });\n  }\n  return splices;\n}\n\nexport function mergeSequences(\n  aCount: number,\n  bCount: number,\n  compare: (a: number, b: number) => number,\n  aCallback: (a: number) => void,\n  bCallback: (b: number) => void,\n  abCallback: (a: number, b: number) => void,\n) {\n  let a = 0;\n  let b = 0;\n  if (aCount !== 0 && bCount !== 0) {\n    while (true) {\n      const x = compare(a, b);\n      if (x < 0) {\n        aCallback(a);\n        if (++a === aCount) break;\n      } else if (x > 0) {\n        bCallback(b);\n        if (++b === bCount) break;\n      } else {\n        abCallback(a, b);\n        ++a;\n        ++b;\n        if (a === aCount || b === bCount) break;\n      }\n    }\n  }\n  while (a < aCount) {\n    aCallback(a);\n    ++a;\n  }\n  while (b < bCount) {\n    bCallback(b);\n    ++b;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { binarySearchLowerBound } from \"#src/util/array.js\";\n\nexport interface SiPrefix {\n  readonly prefix: string;\n  readonly exponent: number;\n  readonly longPrefix?: string;\n}\n\nexport const preferredSiPrefixes: readonly SiPrefix[] = [\n  { prefix: \"Y\", exponent: 24, longPrefix: \"yotta\" },\n  { prefix: \"Z\", exponent: 21, longPrefix: \"zetta\" },\n  { prefix: \"E\", exponent: 18, longPrefix: \"exa\" },\n  { prefix: \"P\", exponent: 15, longPrefix: \"peta\" },\n  { prefix: \"T\", exponent: 12, longPrefix: \"tera\" },\n  { prefix: \"G\", exponent: 9, longPrefix: \"giga\" },\n  { prefix: \"M\", exponent: 6, longPrefix: \"mega\" },\n  { prefix: \"k\", exponent: 3, longPrefix: \"kilo\" },\n  { prefix: \"\", exponent: 0, longPrefix: \"\" },\n  { prefix: \"m\", exponent: -3, longPrefix: \"milli\" },\n  { prefix: \"\", exponent: -6, longPrefix: \"micro\" },\n  { prefix: \"n\", exponent: -9, longPrefix: \"nano\" },\n  { prefix: \"p\", exponent: -12, longPrefix: \"pico\" },\n  { prefix: \"f\", exponent: -15, longPrefix: \"femto\" },\n  { prefix: \"a\", exponent: -18, longPrefix: \"atto\" },\n  { prefix: \"z\", exponent: -21, longPrefix: \"zepto\" },\n  { prefix: \"y\", exponent: -24, longPrefix: \"yocto\" },\n];\n\nexport const allSiPrefixes: readonly SiPrefix[] = [\n  ...preferredSiPrefixes,\n  { prefix: \"h\", exponent: 2, longPrefix: \"hecto\" },\n  { prefix: \"da\", exponent: 1, longPrefix: \"deca\" },\n  { prefix: \"d\", exponent: -1, longPrefix: \"deci\" },\n  { prefix: \"c\", exponent: -2, longPrefix: \"centi\" },\n];\n\nconst siPrefixesWithAlternatives: readonly SiPrefix[] = [\n  { prefix: \"u\", exponent: -6 }, // Also allow \"u\" for micro\n  ...allSiPrefixes,\n];\n\nexport const supportedUnits = new Map<\n  string,\n  { unit: string; exponent: number }\n>();\nsupportedUnits.set(\"\", { unit: \"\", exponent: 0 });\nexport const exponentToPrefix = new Map<number, string>();\nfor (const { prefix, exponent } of siPrefixesWithAlternatives) {\n  exponentToPrefix.set(exponent, prefix);\n  for (const unit of [\"m\", \"s\", \"Hz\", \"rad/s\"]) {\n    supportedUnits.set(`${prefix}${unit}`, { unit, exponent });\n  }\n}\n\nexport function pickSiPrefix(x: number): SiPrefix {\n  const exponent = Math.log10(x);\n  const numPrefixes = preferredSiPrefixes.length;\n  const i = binarySearchLowerBound(\n    0,\n    numPrefixes,\n    (i) => preferredSiPrefixes[i].exponent <= exponent,\n  );\n  return preferredSiPrefixes[Math.min(i, numPrefixes - 1)];\n}\n\ninterface FormatScaleWithUnitOptions {\n  precision?: number;\n  elide1?: boolean;\n}\n\nexport function formatScaleWithUnit(\n  scale: number,\n  unit: string,\n  options: FormatScaleWithUnitOptions = {},\n): { scale: string; prefix: string; unit: string } {\n  const { precision = 6, elide1 = true } = options;\n  let adjustedScale = scale;\n  let prefix = \"\";\n  if (unit !== \"\") {\n    const result = pickSiPrefix(scale);\n    prefix = result.prefix;\n    adjustedScale = scaleByExp10(scale, -result.exponent);\n  }\n  if (elide1 && adjustedScale === 1) {\n    return { scale: \"\", unit, prefix };\n  }\n  let scaleString: string;\n  if (precision !== 0) {\n    if (adjustedScale < 1 || adjustedScale >= 1000) {\n      scaleString = adjustedScale.toPrecision(precision);\n    } else {\n      scaleString = adjustedScale.toFixed(precision);\n    }\n    const eIndex = scaleString.indexOf(\"e\");\n    let numString: string;\n    let exponentString: string;\n    if (eIndex !== -1) {\n      numString = scaleString.substring(0, eIndex);\n      exponentString = scaleString.substring(eIndex);\n    } else {\n      numString = scaleString;\n      exponentString = \"\";\n    }\n    const m = numString.match(/.*\\.(?:[0-9]*[1-9])?(0+)$/);\n    if (m !== null) {\n      numString = numString.substring(0, numString.length - m[1].length);\n      if (numString.endsWith(\".\")) {\n        numString = numString.substring(0, numString.length - 1);\n      }\n      scaleString = numString + exponentString;\n    }\n  } else {\n    scaleString = adjustedScale.toString();\n  }\n  return {\n    scale: scaleString,\n    unit,\n    prefix,\n  };\n}\n\nexport function formatScaleWithUnitAsString(\n  scale: number,\n  unit: string,\n  options?: FormatScaleWithUnitOptions,\n): string {\n  const {\n    scale: formattedScale,\n    unit: formattedUnit,\n    prefix,\n  } = formatScaleWithUnit(scale, unit, options);\n  return `${formattedScale}${prefix}${formattedUnit}`;\n}\n\nexport function parseScale(s: string) {\n  if (s === \"\") {\n    return { scale: 1, unit: \"\" };\n  }\n  const match = s.match(\n    /^((?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)?([a-zA-Z]+)?$/,\n  );\n  if (match === null) return undefined;\n  const scaleString = match[1];\n  let scale = scaleString === undefined ? 1 : Number(scaleString);\n  if (Number.isNaN(scale)) return undefined;\n  let unit = \"\";\n  if (match[2] !== undefined) {\n    const result = supportedUnits.get(match[2]);\n    if (result === undefined) {\n      return undefined;\n    }\n    unit = result.unit;\n    if (result.exponent > 0) {\n      scale *= 10 ** result.exponent;\n    } else {\n      scale /= 10 ** -result.exponent;\n    }\n  }\n  if (scale <= 0 || !Number.isFinite(scale)) return undefined;\n  return { scale, unit };\n}\n\nexport function unitFromJson(x: unknown) {\n  const result = supportedUnits.get(x as string);\n  if (result === undefined) {\n    throw new Error(`Invalid unit: ${JSON.stringify(x)}`);\n  }\n  return result;\n}\n\n/**\n * Returns `scale * 10**exponent`, but uses division for negative exponents to reduce loss of\n * precision.\n */\nexport function scaleByExp10(scale: number, exponent: number) {\n  if (exponent >= 0) return scale * 10 ** exponent;\n  return scale / 10 ** -exponent;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TypedArray } from \"#src/util/array.js\";\n\nexport function equal<T extends TypedArray, U extends TypedArray>(a: T, b: U) {\n  const n = a.length;\n  for (let i = 0; i < n; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nexport function add<\n  Out extends TypedArray,\n  A extends TypedArray,\n  B extends TypedArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] + b[i];\n  }\n  return out;\n}\nexport function subtract<\n  Out extends TypedArray,\n  A extends TypedArray,\n  B extends TypedArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] - b[i];\n  }\n  return out;\n}\nexport function multiply<\n  Out extends TypedArray,\n  A extends TypedArray,\n  B extends TypedArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] * b[i];\n  }\n  return out;\n}\nexport function divide<\n  Out extends TypedArray,\n  A extends TypedArray,\n  B extends TypedArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] / b[i];\n  }\n  return out;\n}\nexport function scaleAndAdd<\n  Out extends TypedArray,\n  A extends TypedArray,\n  B extends TypedArray,\n>(out: Out, a: A, b: B, scale: number) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] + b[i] * scale;\n  }\n  return out;\n}\nexport function scale<Out extends TypedArray, A extends TypedArray>(\n  out: Out,\n  a: A,\n  scale: number,\n) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] * scale;\n  }\n  return out;\n}\n\nexport function prod(array: ArrayLike<number>) {\n  let result = 1;\n  for (let i = 0, length = array.length; i < length; ++i) {\n    result *= array[i];\n  }\n  return result;\n}\n\nexport function min<\n  Out extends TypedArray,\n  A extends TypedArray,\n  B extends TypedArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = Math.min(a[i], b[i]);\n  }\n  return out;\n}\n\nexport function max<\n  Out extends TypedArray,\n  A extends TypedArray,\n  B extends TypedArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = Math.max(a[i], b[i]);\n  }\n  return out;\n}\n\nexport const kEmptyFloat32Vec = new Float32Array(0);\nexport const kEmptyFloat64Vec = new Float64Array(0);\nexport const kFloat64Vec3Of1 = Float64Array.of(1, 1, 1);\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { WatchableValue } from \"#src/trackable_value.js\";\nimport type { TypedArray } from \"#src/util/array.js\";\nimport {\n  arraysEqual,\n  arraysEqualWithPredicate,\n  getInsertPermutation,\n} from \"#src/util/array.js\";\nimport {\n  getDependentTransformInputDimensions,\n  mat4,\n  quat,\n  vec3,\n} from \"#src/util/geom.js\";\nimport {\n  expectArray,\n  parseArray,\n  parseFiniteVec,\n  parseFixedLengthArray,\n  verifyFiniteFloat,\n  verifyFinitePositiveFloat,\n  verifyIntegerArray,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalObjectProperty,\n  verifyString,\n  verifyStringArray,\n} from \"#src/util/json.js\";\nimport * as matrix from \"#src/util/matrix.js\";\nimport {\n  scaleByExp10,\n  supportedUnits,\n  unitFromJson,\n} from \"#src/util/si_units.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\nimport type { Trackable } from \"#src/util/trackable.js\";\nimport * as vector from \"#src/util/vector.js\";\n\nexport type DimensionId = number;\n\nlet nextDimensionId = 0;\n\nexport function newDimensionId(): DimensionId {\n  return ++nextDimensionId;\n}\n\nexport interface CoordinateArray {\n  // Indicates whether this coordinate array was specified explicitly, in which case it will be\n  // encoded in the JSON representation.\n  explicit: boolean;\n  // Specifies the coordinates.  Must be montonically increasing integers.\n  coordinates: number[];\n  // Specifies the label for each coordinate in `coordinates`.\n  labels: string[];\n}\n\nexport interface CoordinateSpace {\n  /**\n   * If `true`, has been fully initialized (i.e. based on at least one data source).  If `false`,\n   * may be partially initialized.\n   */\n  readonly valid: boolean;\n\n  readonly rank: number;\n\n  /**\n   * Specifies the name of each dimension.\n   */\n  readonly names: readonly string[];\n\n  readonly ids: readonly DimensionId[];\n\n  /**\n   * Timestamp of last user action that changed the name, scale, or unit of each dimension, or\n   * `undefined` if there was no user action.\n   */\n  readonly timestamps: readonly number[];\n\n  /**\n   * Specifies the physical units corresponding to this dimension.  May be empty to indicate\n   * unitless.\n   */\n  readonly units: readonly string[];\n\n  /**\n   * Specifies a scale for this dimension.\n   */\n  readonly scales: Float64Array;\n\n  readonly bounds: CoordinateSpaceBounds;\n  readonly boundingBoxes: readonly TransformedBoundingBox[];\n\n  readonly coordinateArrays: (CoordinateArray | undefined)[];\n}\n\nexport function boundingBoxesEqual(a: BoundingBox, b: BoundingBox) {\n  return (\n    arraysEqual(a.lowerBounds, b.lowerBounds) &&\n    arraysEqual(a.upperBounds, b.upperBounds)\n  );\n}\n\nexport function coordinateArraysEqual(\n  a: CoordinateArray | undefined,\n  b: CoordinateArray | undefined,\n) {\n  if (a === undefined) return b === undefined;\n  if (b === undefined) return false;\n  return (\n    a.explicit === b.explicit &&\n    arraysEqual(a.coordinates, b.coordinates) &&\n    arraysEqual(a.labels, b.labels)\n  );\n}\n\nexport function normalizeCoordinateArray(\n  coordinates: number[],\n  labels: string[],\n) {\n  const map = new Map<number, string>();\n  for (let i = 0, length = coordinates.length; i < length; ++i) {\n    map.set(coordinates[i], labels[i]);\n  }\n  coordinates = Array.from(map.keys());\n  coordinates.sort((a, b) => a - b);\n  labels = Array.from(coordinates, (x) => map.get(x)!);\n  return { coordinates, labels };\n}\n\nexport function mergeCoordinateArrays(\n  coordinateArrays: ReadonlyArray<CoordinateArray>,\n): CoordinateArray {\n  if (coordinateArrays.length === 1) return coordinateArrays[0];\n  const map = new Map<number, string>();\n  let explicit = false;\n  for (const x of coordinateArrays) {\n    if (x.explicit) explicit = true;\n    const { coordinates, labels } = x;\n    for (let i = 0, length = coordinates.length; i < length; ++i) {\n      map.set(coordinates[i], labels[i]);\n    }\n  }\n  const coordinates = Array.from(map.keys());\n  coordinates.sort((a, b) => a - b);\n  const labels = Array.from(coordinates, (x) => map.get(x)!);\n  return { explicit, coordinates, labels };\n}\n\nexport function mergeOptionalCoordinateArrays(\n  coordinateArrays: ReadonlyArray<CoordinateArray | undefined>,\n): CoordinateArray | undefined {\n  coordinateArrays = coordinateArrays.filter((x) => x !== undefined);\n  if (coordinateArrays.length === 0) return undefined;\n  return mergeCoordinateArrays(\n    coordinateArrays as ReadonlyArray<CoordinateArray>,\n  );\n}\n\nexport function transformedBoundingBoxesEqual(\n  a: TransformedBoundingBox,\n  b: TransformedBoundingBox,\n) {\n  return (\n    arraysEqual(a.transform, b.transform) && boundingBoxesEqual(a.box, b.box)\n  );\n}\n\nexport function coordinateSpacesEqual(a: CoordinateSpace, b: CoordinateSpace) {\n  return (\n    a.valid === b.valid &&\n    a.rank === b.rank &&\n    arraysEqual(a.names, b.names) &&\n    arraysEqual(a.ids, b.ids) &&\n    arraysEqual(a.timestamps, b.timestamps) &&\n    arraysEqual(a.units, b.units) &&\n    arraysEqual(a.scales, b.scales) &&\n    arraysEqualWithPredicate(\n      a.boundingBoxes,\n      b.boundingBoxes,\n      transformedBoundingBoxesEqual,\n    ) &&\n    arraysEqualWithPredicate(\n      a.coordinateArrays,\n      b.coordinateArrays,\n      coordinateArraysEqual,\n    )\n  );\n}\n\nexport function unitsFromJson(\n  units: string[],\n  scaleExponents: Float64Array,\n  obj: any,\n) {\n  parseFixedLengthArray(units, obj, (x: any, index: number) => {\n    const result = unitFromJson(x);\n    scaleExponents[index] = result.exponent;\n    return result.unit;\n  });\n}\n\nexport function makeCoordinateSpace(space: {\n  readonly valid?: boolean;\n  readonly names: readonly string[];\n  readonly units: readonly string[];\n  readonly scales: Float64Array;\n  readonly rank?: number;\n  readonly timestamps?: readonly number[];\n  readonly ids?: readonly DimensionId[];\n  readonly boundingBoxes?: readonly TransformedBoundingBox[];\n  readonly bounds?: CoordinateSpaceBounds;\n  readonly coordinateArrays?: (CoordinateArray | undefined)[];\n}): CoordinateSpace {\n  const { names, units, scales } = space;\n  const {\n    valid = true,\n    rank = names.length,\n    timestamps = names.map(() => Number.NEGATIVE_INFINITY),\n    ids = names.map((_, i) => -i),\n    boundingBoxes = [],\n  } = space;\n  const { coordinateArrays = new Array<CoordinateArray | undefined>(rank) } =\n    space;\n  const { bounds = computeCombinedBounds(boundingBoxes, rank) } = space;\n  return {\n    valid,\n    rank,\n    names,\n    timestamps,\n    ids,\n    units,\n    scales,\n    boundingBoxes,\n    bounds,\n    coordinateArrays,\n  };\n}\n\nexport const emptyInvalidCoordinateSpace = makeCoordinateSpace({\n  valid: false,\n  names: [],\n  units: [],\n  scales: vector.kEmptyFloat64Vec,\n  boundingBoxes: [],\n});\n\nexport const emptyValidCoordinateSpace = makeCoordinateSpace({\n  valid: true,\n  names: [],\n  units: [],\n  scales: vector.kEmptyFloat64Vec,\n  boundingBoxes: [],\n});\n\nfunction unitAndScaleFromJson(obj: unknown) {\n  const [scaleObj, unitObj] = expectArray(obj, 2);\n  const scale = verifyFinitePositiveFloat(scaleObj);\n  const unitString = verifyString(unitObj);\n  const result = supportedUnits.get(unitString);\n  if (result === undefined)\n    throw new Error(`Invalid unit: ${JSON.stringify(unitString)}`);\n  return { unit: result.unit, scale: scaleByExp10(scale, result.exponent) };\n}\n\nexport function coordinateSpaceFromJson(\n  obj: any,\n  allowNumericalDimensions = false,\n): CoordinateSpace {\n  if (obj === undefined) return emptyInvalidCoordinateSpace;\n  verifyObject(obj);\n  const names = dimensionNamesFromJson(\n    Object.keys(obj),\n    allowNumericalDimensions,\n  );\n  const rank = names.length;\n  const units = new Array<string>(rank);\n  const scales = new Float64Array(rank);\n  const coordinateArrays = new Array<CoordinateArray | undefined>(rank);\n  for (let i = 0; i < rank; ++i) {\n    verifyObjectProperty(obj, names[i], (mem) => {\n      if (Array.isArray(mem)) {\n        // Normal unit-scale dimension.\n        const { unit, scale } = unitAndScaleFromJson(mem);\n        units[i] = unit;\n        scales[i] = scale;\n      } else {\n        // Coordinate array dimension.\n        verifyObject(mem);\n        const coordinates = verifyObjectProperty(\n          mem,\n          \"coordinates\",\n          verifyIntegerArray,\n        );\n        const labels = verifyObjectProperty(mem, \"labels\", verifyStringArray);\n        const length = coordinates.length;\n        if (length !== labels.length) {\n          throw new Error(\n            `Length of coordinates array (${length}) ` +\n              `does not match length of labels array (${labels.length})`,\n          );\n        }\n        units[i] = \"\";\n        scales[i] = 1;\n        coordinateArrays[i] = {\n          explicit: true,\n          ...normalizeCoordinateArray(coordinates, labels),\n        };\n      }\n    });\n  }\n  return makeCoordinateSpace({\n    valid: false,\n    names,\n    units,\n    scales,\n    coordinateArrays,\n  });\n}\n\nexport function coordinateSpaceToJson(coordinateSpace: CoordinateSpace): any {\n  const { rank } = coordinateSpace;\n  if (rank === 0) return undefined;\n  const { names, units, scales, coordinateArrays } = coordinateSpace;\n  const json: any = {};\n  for (let i = 0; i < rank; ++i) {\n    const name = names[i];\n    const coordinateArray = coordinateArrays[i];\n    if (coordinateArray?.explicit) {\n      json[name] = {\n        coordinates: Array.from(coordinateArray.coordinates),\n        labels: coordinateArray.labels,\n      };\n    } else {\n      json[name] = [scales[i], units[i]];\n    }\n  }\n  return json;\n}\n\nexport class TrackableCoordinateSpace extends WatchableValue<CoordinateSpace> {\n  constructor() {\n    super(emptyInvalidCoordinateSpace);\n  }\n\n  toJSON() {\n    return coordinateSpaceToJson(this.value);\n  }\n  reset() {\n    this.value = emptyInvalidCoordinateSpace;\n  }\n  restoreState(obj: any) {\n    this.value = coordinateSpaceFromJson(obj);\n  }\n}\n\nexport interface BoundingBox {\n  lowerBounds: Float64Array;\n  upperBounds: Float64Array;\n}\n\nexport interface CoordinateSpaceBounds extends BoundingBox {\n  voxelCenterAtIntegerCoordinates: boolean[];\n}\n\nexport function roundCoordinateToVoxelCenter(\n  bounds: CoordinateSpaceBounds,\n  dimIndex: number,\n  coordinate: number,\n) {\n  if (bounds.voxelCenterAtIntegerCoordinates[dimIndex]) {\n    coordinate = Math.round(coordinate);\n  } else {\n    coordinate = Math.floor(coordinate) + 0.5;\n  }\n  return coordinate;\n}\n\nexport function getDisplayLowerUpperBounds(\n  bounds: CoordinateSpaceBounds,\n  dimIndex: number,\n) {\n  let lower = bounds.lowerBounds[dimIndex];\n  let upper = bounds.upperBounds[dimIndex];\n  if (bounds.voxelCenterAtIntegerCoordinates[dimIndex]) {\n    lower += 0.5;\n    upper += 0.5;\n  }\n  return [lower, upper];\n}\n\n// Clamps `coordinate` to `[lower, upper - 1]`.  This is intended to be used with\n// `roundCoordinateToVoxelCenter`.  If not rounding, it may be desirable to instead\n// clamp to `[lower upper]`.\nexport function clampCoordinateToBounds(\n  bounds: CoordinateSpaceBounds,\n  dimIndex: number,\n  coordinate: number,\n) {\n  const upperBound = bounds.upperBounds[dimIndex];\n  if (Number.isFinite(upperBound)) {\n    coordinate = Math.min(coordinate, upperBound - 1);\n  }\n\n  const lowerBound = bounds.lowerBounds[dimIndex];\n  if (Number.isFinite(lowerBound)) {\n    coordinate = Math.max(coordinate, lowerBound);\n  }\n  return coordinate;\n}\n\nexport function clampAndRoundCoordinateToVoxelCenter(\n  bounds: CoordinateSpaceBounds,\n  dimIndex: number,\n  coordinate: number,\n): number {\n  coordinate = clampCoordinateToBounds(bounds, dimIndex, coordinate);\n  return roundCoordinateToVoxelCenter(bounds, dimIndex, coordinate);\n}\n\nexport function getCenterBound(lower: number, upper: number) {\n  let x = (lower + upper) / 2;\n  if (!Number.isFinite(x)) x = Math.min(Math.max(0, lower), upper);\n  return x;\n}\n\nexport function getBoundingBoxCenter(\n  out: Float32Array,\n  bounds: BoundingBox,\n): Float32Array {\n  const { lowerBounds, upperBounds } = bounds;\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = getCenterBound(lowerBounds[i], upperBounds[i]);\n  }\n  return out;\n}\n\nexport interface TransformedBoundingBox {\n  box: BoundingBox;\n\n  /**\n   * Transform from \"box\" coordinate space to target coordinate space.\n   */\n  transform: Float64Array;\n}\n\nexport function makeIdentityTransformedBoundingBox(box: BoundingBox) {\n  const rank = box.lowerBounds.length;\n  return {\n    box,\n    transform: matrix.createIdentity(Float64Array, rank, rank + 1),\n  };\n}\n\nexport function computeCombinedLowerUpperBound(\n  boundingBox: TransformedBoundingBox,\n  outputDimension: number,\n  outputRank: number,\n): { lower: number; upper: number } | undefined {\n  const {\n    box: { lowerBounds: baseLowerBounds, upperBounds: baseUpperBounds },\n    transform,\n  } = boundingBox;\n  const inputRank = baseLowerBounds.length;\n  const stride = outputRank;\n  const offset = transform[stride * inputRank + outputDimension];\n  let targetLower = offset;\n  let targetUpper = offset;\n  let hasCoefficient = false;\n  for (let inputDim = 0; inputDim < inputRank; ++inputDim) {\n    const c = transform[stride * inputDim + outputDimension];\n    if (c === 0) continue;\n    const lower = c * baseLowerBounds[inputDim];\n    const upper = c * baseUpperBounds[inputDim];\n    targetLower += Math.min(lower, upper);\n    targetUpper += Math.max(lower, upper);\n    hasCoefficient = true;\n  }\n  if (!hasCoefficient) return undefined;\n  return { lower: targetLower, upper: targetUpper };\n}\n\nexport function computeCombinedBounds(\n  boundingBoxes: readonly TransformedBoundingBox[],\n  outputRank: number,\n): CoordinateSpaceBounds {\n  const lowerBounds = new Float64Array(outputRank);\n  const upperBounds = new Float64Array(outputRank);\n  lowerBounds.fill(Number.NEGATIVE_INFINITY);\n  upperBounds.fill(Number.POSITIVE_INFINITY);\n\n  // Number of bounding boxes for which both lower and upper bound has a fractional part of `0.5`.\n  const halfIntegerBounds = new Array<number>(outputRank);\n  halfIntegerBounds.fill(0);\n\n  // Number of bounding boxes for which both lower and upper bound has a fractional part of `0.0`.\n  const integerBounds = new Array<number>(outputRank);\n  integerBounds.fill(0);\n\n  for (const boundingBox of boundingBoxes) {\n    for (let outputDim = 0; outputDim < outputRank; ++outputDim) {\n      const result = computeCombinedLowerUpperBound(\n        boundingBox,\n        outputDim,\n        outputRank,\n      );\n      if (result === undefined) continue;\n      const { lower: targetLower, upper: targetUpper } = result;\n      if (Number.isFinite(targetLower) && Number.isFinite(targetUpper)) {\n        const lowerFloor = Math.floor(targetLower);\n        const upperFloor = Math.floor(targetUpper);\n        if (lowerFloor === targetLower && upperFloor === targetUpper) {\n          ++integerBounds[outputDim];\n        } else if (\n          targetLower - lowerFloor === 0.5 &&\n          targetUpper - upperFloor === 0.5\n        ) {\n          ++halfIntegerBounds[outputDim];\n        }\n      }\n      lowerBounds[outputDim] =\n        lowerBounds[outputDim] === Number.NEGATIVE_INFINITY\n          ? targetLower\n          : Math.min(lowerBounds[outputDim], targetLower);\n      upperBounds[outputDim] =\n        upperBounds[outputDim] === Number.POSITIVE_INFINITY\n          ? targetUpper\n          : Math.max(upperBounds[outputDim], targetUpper);\n    }\n  }\n\n  const voxelCenterAtIntegerCoordinates = integerBounds.map(\n    (integerCount, i) => {\n      const halfIntegerCount = halfIntegerBounds[i];\n      // If all bounding boxes have half-integer bounds, assume voxel center is at integer\n      // coordinates.  Otherwise, assume voxel center is at half-integer coordinates.\n      return halfIntegerCount > 0 && integerCount === 0;\n    },\n  );\n  return { lowerBounds, upperBounds, voxelCenterAtIntegerCoordinates };\n}\n\nexport function extendTransformedBoundingBox(\n  boundingBox: TransformedBoundingBox,\n  newOutputRank: number,\n  newOutputDims: readonly number[],\n): TransformedBoundingBox {\n  const { transform: oldTransform, box } = boundingBox;\n  const oldOutputRank = newOutputDims.length;\n  const inputRank = box.lowerBounds.length;\n  const newTransform = new Float64Array((inputRank + 1) * newOutputRank);\n  for (let oldOutputDim = 0; oldOutputDim < oldOutputRank; ++oldOutputDim) {\n    const newOutputDim = newOutputDims[oldOutputDim];\n    if (newOutputDim === -1) continue;\n    for (let inputDim = 0; inputDim <= inputRank; ++inputDim) {\n      newTransform[inputDim * newOutputRank + newOutputDim] =\n        oldTransform[inputDim * oldOutputRank + oldOutputDim];\n    }\n  }\n  return {\n    transform: newTransform,\n    box,\n  };\n}\n\nexport function makeSingletonDimTransformedBoundingBox(\n  outputRank: number,\n  outputDim: number,\n) {\n  const box = {\n    lowerBounds: Float64Array.of(0),\n    upperBounds: Float64Array.of(1),\n  };\n  const transform = new Float64Array(2 * outputRank);\n  transform[outputDim] = 1;\n  return { transform, box };\n}\n\nexport function extendTransformedBoundingBoxUpToRank(\n  boundingBox: TransformedBoundingBox,\n  oldOutputRank: number,\n  newOutputRank: number,\n): TransformedBoundingBox {\n  if (oldOutputRank === newOutputRank) return boundingBox;\n  const { box } = boundingBox;\n  const inputRank = box.lowerBounds.length;\n  const transform = new Float64Array((inputRank + 1) * newOutputRank);\n  matrix.copy(\n    transform,\n    newOutputRank,\n    boundingBox.transform,\n    oldOutputRank,\n    oldOutputRank,\n    inputRank + 1,\n  );\n  return { box, transform };\n}\n\nexport interface CoordinateSpaceTransform {\n  /**\n   * Equal to `outputSpace.rank`.\n   */\n  readonly rank: number;\n\n  /**\n   * The source rank, which is <= rank.  Input dimensions >= sourceRank are synthetic and serve only\n   * to embed the source data in a larger view space.\n   */\n  readonly sourceRank: number;\n\n  /**\n   * May have rank less than `outputSpace.rank`, in which case additional unnamed dimensions with\n   * range `[0, 1)` are implicitly added.\n   */\n  readonly inputSpace: CoordinateSpace;\n\n  readonly outputSpace: CoordinateSpace;\n\n  /**\n   * `(rank + 1) * (rank + 1)` homogeneous column-major transformation matrix, where columns\n   * correspond to input dimensions and rows correspond to output dimensions.\n   */\n  readonly transform: Float64Array;\n}\n\nexport function coordinateSpaceTransformsEquivalent(\n  defaultTransform: CoordinateSpaceTransform,\n  transform: CoordinateSpaceTransform,\n) {\n  const { rank, sourceRank } = defaultTransform;\n  if (rank !== transform.rank || sourceRank !== transform.sourceRank)\n    return false;\n  const { inputSpace: defaultInputSpace } = defaultTransform;\n  const { inputSpace } = transform;\n  if (\n    !arraysEqual(inputSpace.scales, defaultInputSpace.scales) ||\n    !arraysEqual(inputSpace.units, defaultInputSpace.units) ||\n    !arraysEqual(\n      transform.outputSpace.names,\n      defaultTransform.outputSpace.names,\n    )\n  ) {\n    return false;\n  }\n  return isTransformDerivableFromDefault(\n    defaultTransform.transform,\n    rank,\n    defaultTransform.outputSpace.scales,\n    transform.transform,\n    rank,\n    transform.outputSpace.scales,\n  );\n}\n\nexport function makeIdentityTransform(\n  inputSpace: CoordinateSpace,\n): CoordinateSpaceTransform {\n  return {\n    rank: inputSpace.rank,\n    sourceRank: inputSpace.rank,\n    inputSpace,\n    outputSpace: inputSpace,\n    transform: matrix.createIdentity(Float64Array, inputSpace.rank + 1),\n  };\n}\n\nfunction transformBoundingBox(\n  boundingBox: TransformedBoundingBox,\n  transform: Float64Array,\n  sourceScales: Float64Array,\n  targetScales: Float64Array,\n): TransformedBoundingBox {\n  const { transform: oldBoxTransform, box } = boundingBox;\n  const inputRank = boundingBox.box.lowerBounds.length;\n  const targetRank = targetScales.length;\n  // transform is a column-major homogeneous `(rows=targetRank+1, cols=targetRank+1)` matrix.\n  // oldBoxTransform is a column-major `(rows=targetRank, cols=inputRank+1)` matrix.\n  // newBoxTransform is a column-major `(rows=targetRank, cols=inputRank+1)` matrix.\n  const newBoxTransform = new Float64Array((inputRank + 1) * targetRank);\n  for (let targetDim = 0; targetDim < targetRank; ++targetDim) {\n    const targetScale = targetScales[targetDim];\n    // Compute the rotation/scaling components\n    for (let inputDim = 0; inputDim < inputRank; ++inputDim) {\n      let sum = 0;\n      for (let sourceDim = 0; sourceDim < targetRank; ++sourceDim) {\n        const sourceScale = sourceScales[sourceDim];\n        sum +=\n          transform[(targetRank + 1) * sourceDim + targetDim] *\n          oldBoxTransform[targetRank * inputDim + sourceDim] *\n          (sourceScale / targetScale);\n      }\n      newBoxTransform[targetRank * inputDim + targetDim] = sum;\n    }\n    // Compute the translation component\n    let sum = transform[(targetRank + 1) * targetRank + targetDim];\n    for (let sourceDim = 0; sourceDim < targetRank; ++sourceDim) {\n      const sourceScale = sourceScales[sourceDim];\n      sum +=\n        transform[(targetRank + 1) * sourceDim + targetDim] *\n        oldBoxTransform[targetRank * inputRank + sourceDim] *\n        (sourceScale / targetScale);\n    }\n    newBoxTransform[inputRank * targetRank + targetDim] = sum;\n  }\n  return {\n    transform: newBoxTransform,\n    box,\n  };\n}\n\nfunction getTransformedBoundingBoxes(\n  inputSpace: CoordinateSpace,\n  transform: Float64Array,\n  outputScales: Float64Array,\n) {\n  return inputSpace.boundingBoxes.map((boundingBox) =>\n    transformBoundingBox(\n      boundingBox,\n      transform,\n      inputSpace.scales,\n      outputScales,\n    ),\n  );\n}\n\nexport function getOutputSpaceWithTransformedBoundingBoxes(\n  inputSpace: CoordinateSpace,\n  transform: Float64Array,\n  oldOutputSpace: CoordinateSpace,\n) {\n  const newSpace = makeCoordinateSpace({\n    valid: inputSpace.valid,\n    rank: oldOutputSpace.rank,\n    ids: oldOutputSpace.ids,\n    names: oldOutputSpace.names,\n    timestamps: oldOutputSpace.timestamps,\n    scales: oldOutputSpace.scales,\n    units: oldOutputSpace.units,\n    boundingBoxes: getTransformedBoundingBoxes(\n      inputSpace,\n      transform,\n      oldOutputSpace.scales,\n    ),\n    coordinateArrays: oldOutputSpace.coordinateArrays,\n  });\n  if (coordinateSpacesEqual(newSpace, oldOutputSpace)) return oldOutputSpace;\n  return newSpace;\n}\n\nexport function isValidDimensionName(\n  name: string,\n  allowNumericalNames = false,\n) {\n  if (allowNumericalNames) {\n    const n = Number(name);\n    if (Number.isInteger(n) && n >= 0) return true;\n  }\n  return name.match(/^[a-zA-Z][a-zA-Z_0-9]*['^]?$/) !== null;\n}\n\nexport function validateDimensionNames(\n  names: string[],\n  allowNumericalNames = false,\n) {\n  const seenNames = new Set<string>();\n  for (const name of names) {\n    if (!isValidDimensionName(name, allowNumericalNames)) return false;\n    if (seenNames.has(name)) return false;\n    seenNames.add(name);\n  }\n  return true;\n}\n\nexport function getDimensionNameValidity(names: readonly string[]): boolean[] {\n  const rank = names.length;\n  const isValid = new Array<boolean>(rank);\n  isValid.fill(true);\n  for (let i = 0; i < rank; ++i) {\n    const name = names[i];\n    if (!isValidDimensionName(name)) {\n      isValid[i] = false;\n      continue;\n    }\n    const otherIndex = names.indexOf(name, i + 1);\n    if (otherIndex !== -1) {\n      isValid[i] = false;\n      isValid[otherIndex] = false;\n    }\n  }\n  return isValid;\n}\n\nexport function isLocalDimension(name: string) {\n  return name.endsWith(\"'\");\n}\n\nexport function isLocalOrChannelDimension(name: string) {\n  return name.endsWith(\"'\") || name.endsWith(\"^\");\n}\n\nexport function isChannelDimension(name: string) {\n  return name.endsWith(\"^\");\n}\n\nexport function isGlobalDimension(name: string) {\n  return !isLocalOrChannelDimension(name);\n}\n\nexport function convertTransformOutputScales(\n  existingTransform: Float64Array,\n  existingOutputScales: Float64Array,\n  newOutputScales: Float64Array,\n) {\n  const newTransform = new Float64Array(existingTransform);\n  const rank = existingOutputScales.length;\n  const baseIndex = (rank + 1) * rank;\n  for (let i = 0; i < rank; ++i) {\n    newTransform[baseIndex + i] *= existingOutputScales[i] / newOutputScales[i];\n  }\n  return newTransform;\n}\n\nfunction isTransformDerivableFromDefault(\n  defaultTransform: Float64Array,\n  defaultRank: number,\n  defaultOutputScales: Float64Array,\n  newTransform: Float64Array,\n  newRank: number,\n  newOutputScales: Float64Array,\n) {\n  // Verify that matched linear portion is equal.\n  if (\n    !matrix.equal(\n      defaultTransform,\n      defaultRank + 1,\n      newTransform,\n      newRank + 1,\n      defaultRank,\n      defaultRank,\n    )\n  )\n    return false;\n\n  // Verify that common translation is equivalent.\n  for (let i = 0; i < defaultRank; ++i) {\n    const aValue = defaultTransform[(defaultRank + 1) * defaultRank + i];\n    const bValue = newTransform[(newRank + 1) * newRank + i];\n    if (aValue * (defaultOutputScales[i] / newOutputScales[i]) !== bValue)\n      return false;\n  }\n\n  // Verify that extended translation is 0.\n  for (let i = defaultRank; i < newRank; ++i) {\n    if (newTransform[(newRank + 1) * newRank + i] !== 0) return false;\n  }\n\n  // Verify that extended linear portion is identity.\n  for (let i = defaultRank; i < newRank; ++i) {\n    for (let j = 0; j < defaultRank; ++j) {\n      if (newTransform[(newRank + 1) * j + i] !== 0) return false;\n    }\n    for (let j = 0; j < newRank; ++j) {\n      const coeff = newTransform[(newRank + 1) * i + j];\n      if (i === j) {\n        if (coeff !== 1) return false;\n      } else {\n        if (coeff !== 0) return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport function makeDimensionNameUnique(\n  name: string,\n  existingNames: readonly string[],\n) {\n  if (!existingNames.includes(name)) return name;\n  const [, prefix, suffix] = name.match(/^([^']*)('?)$/)!;\n  for (let i = 0; ; ++i) {\n    const newName = `${prefix}${i}${suffix}`;\n    if (!existingNames.includes(newName)) return newName;\n  }\n}\n\nexport function remapTransformInputSpace(\n  old: CoordinateSpaceTransform,\n  inputSpace: CoordinateSpace,\n): CoordinateSpaceTransform {\n  const { inputSpace: oldInputSpace, transform: oldTransform } = old;\n  const { ids: oldInputDimensionIds, rank: oldRank } = oldInputSpace;\n  const {\n    rank: newRank,\n    names: newInputDimensionNames,\n    units: newInputUnits,\n    scales: newInputScales,\n  } = inputSpace;\n  const removedOldInputIndices = new Array(oldRank);\n  removedOldInputIndices.fill(true);\n  const addedInputDimensionIndices: number[] = [];\n  const newToOldInputDimensionIndices: number[] = inputSpace.ids.map(\n    (id, i) => {\n      const oldIndex = oldInputDimensionIds.indexOf(id);\n      if (oldIndex !== -1) {\n        removedOldInputIndices[oldIndex] = false;\n      } else {\n        addedInputDimensionIndices.push(i);\n      }\n      return oldIndex;\n    },\n  );\n  const { outputSpace: oldOutputSpace } = old;\n  const {\n    names: oldOutputDimensionNames,\n    units: oldOutputUnits,\n    scales: oldOutputScales,\n    ids: oldOutputDimensionIds,\n    timestamps: oldOutputTimestamps,\n    coordinateArrays: oldOutputCoordinateArrays,\n  } = oldOutputSpace;\n  // For now just use a simple mapping.\n  const removedOldOutputIndices = removedOldInputIndices;\n  const outputDimensionNames: string[] = [];\n  const outputUnits: string[] = [];\n  const outputScales = new Float64Array(newRank);\n  const outputDimensionIds: DimensionId[] = [];\n  const outputDimensionTimestamps: number[] = [];\n  const outputCoordinateArrays = new Array<CoordinateArray | undefined>(\n    newRank,\n  );\n  let newOutputDim = 0;\n  const newTransform = new Float64Array((newRank + 1) ** 2);\n  newTransform[newTransform.length - 1] = 1;\n  for (let oldOutputDim = 0; oldOutputDim < oldRank; ++oldOutputDim) {\n    if (removedOldOutputIndices[oldOutputDim]) continue;\n    outputDimensionNames[newOutputDim] = oldOutputDimensionNames[oldOutputDim];\n    outputDimensionIds[newOutputDim] = oldOutputDimensionIds[oldOutputDim];\n    outputUnits[newOutputDim] = oldOutputUnits[oldOutputDim];\n    outputScales[newOutputDim] = oldOutputScales[oldOutputDim];\n    outputDimensionTimestamps[newOutputDim] = oldOutputTimestamps[oldOutputDim];\n    outputCoordinateArrays[newOutputDim] =\n      oldOutputCoordinateArrays[oldOutputDim];\n    for (let newInputDim = 0; newInputDim < newRank; ++newInputDim) {\n      const oldInputDim = newToOldInputDimensionIndices[newInputDim];\n      if (oldInputDim === -1) continue;\n      newTransform[newInputDim * (newRank + 1) + newOutputDim] =\n        oldTransform[oldInputDim * (oldRank + 1) + oldOutputDim];\n    }\n    newTransform[newRank * (newRank + 1) + newOutputDim] =\n      oldTransform[oldRank * (oldRank + 1) + oldOutputDim];\n    ++newOutputDim;\n  }\n  for (const newInputDim of addedInputDimensionIndices) {\n    outputDimensionIds[newOutputDim] = newDimensionId();\n    outputDimensionNames[newOutputDim] = makeDimensionNameUnique(\n      newInputDimensionNames[newInputDim],\n      outputDimensionNames,\n    );\n    outputScales[newOutputDim] = newInputScales[newInputDim];\n    outputUnits[newOutputDim] = newInputUnits[newInputDim];\n    newTransform[newInputDim * (newRank + 1) + newOutputDim] = 1;\n    ++newOutputDim;\n  }\n  const outputSpace = makeCoordinateSpace({\n    valid: inputSpace.valid,\n    rank: newRank,\n    names: outputDimensionNames,\n    ids: outputDimensionIds,\n    timestamps: outputDimensionTimestamps,\n    units: outputUnits,\n    scales: outputScales,\n    boundingBoxes: getTransformedBoundingBoxes(\n      inputSpace,\n      newTransform,\n      outputScales,\n    ),\n    coordinateArrays: outputCoordinateArrays,\n  });\n  return {\n    rank: newRank,\n    sourceRank: old.sourceRank,\n    inputSpace,\n    outputSpace,\n    transform: newTransform,\n  };\n}\n\nfunction normalizeCoordinateSpaceTransform(value: CoordinateSpaceTransform) {\n  const outputSpace = getOutputSpaceWithTransformedBoundingBoxes(\n    value.inputSpace,\n    value.transform,\n    value.outputSpace,\n  );\n  if (outputSpace === value.outputSpace) return value;\n  return {\n    rank: value.rank,\n    sourceRank: value.sourceRank,\n    inputSpace: value.inputSpace,\n    transform: value.transform,\n    outputSpace,\n  };\n}\n\nexport class WatchableCoordinateSpaceTransform\n  implements Trackable, WatchableValueInterface<CoordinateSpaceTransform>\n{\n  private value_: CoordinateSpaceTransform | undefined = undefined;\n  readonly outputSpace: WatchableValueInterface<CoordinateSpace>;\n  readonly inputSpace: WatchableValueInterface<CoordinateSpace>;\n  changed = new NullarySignal();\n  private inputSpaceChanged = new NullarySignal();\n  readonly defaultTransform: CoordinateSpaceTransform;\n\n  constructor(\n    defaultTransform: CoordinateSpaceTransform,\n    public readonly mutableSourceRank: boolean = false,\n  ) {\n    this.defaultTransform = normalizeCoordinateSpaceTransform(defaultTransform);\n    const self = this;\n    this.outputSpace = {\n      changed: self.changed,\n      get value() {\n        return self.value.outputSpace;\n      },\n      set value(newOutputSpace: CoordinateSpace) {\n        const { value } = self;\n        if (coordinateSpacesEqual(value.outputSpace, newOutputSpace)) return;\n        if (value.rank !== newOutputSpace.rank) return;\n        const transform = convertTransformOutputScales(\n          value.transform,\n          value.outputSpace.scales,\n          newOutputSpace.scales,\n        );\n        self.value_ = {\n          sourceRank: value.sourceRank,\n          rank: value.rank,\n          inputSpace: value.inputSpace,\n          outputSpace: getOutputSpaceWithTransformedBoundingBoxes(\n            value.inputSpace,\n            transform,\n            newOutputSpace,\n          ),\n          transform,\n        };\n        self.changed.dispatch();\n      },\n    };\n    this.inputSpace = {\n      changed: self.inputSpaceChanged,\n      get value() {\n        return self.value.inputSpace;\n      },\n      set value(newInputSpace: CoordinateSpace) {\n        const { value } = self;\n        if (coordinateSpacesEqual(value.inputSpace, newInputSpace)) return;\n        self.value_ = remapTransformInputSpace(value, newInputSpace);\n        self.inputSpaceChanged.dispatch();\n        self.changed.dispatch();\n      },\n    };\n  }\n\n  set value(value: CoordinateSpaceTransform) {\n    const existingValue = this.value;\n    if (value === existingValue) return;\n    this.value_ = normalizeCoordinateSpaceTransform(value);\n    if (value.inputSpace !== existingValue.inputSpace) {\n      this.inputSpaceChanged.dispatch();\n    }\n    this.changed.dispatch();\n  }\n\n  get value(): CoordinateSpaceTransform {\n    let { value_: value } = this;\n    if (value === undefined) {\n      value = this.value_ = this.defaultTransform;\n    }\n    return value;\n  }\n\n  reset() {\n    if (this.value_ === this.defaultTransform) return;\n    this.value_ = this.defaultTransform;\n    this.inputSpaceChanged.dispatch();\n    this.changed.dispatch();\n  }\n\n  get defaultInputSpace() {\n    return this.defaultTransform.inputSpace;\n  }\n\n  get spec(): Readonly<CoordinateTransformSpecification> | undefined {\n    const { value } = this;\n    const { rank, transform, inputSpace, outputSpace, sourceRank } = value;\n    const { defaultTransform, mutableSourceRank } = this;\n    const {\n      inputSpace: defaultInputSpace,\n      rank: defaultRank,\n      transform: defaultTransformMatrix,\n      outputSpace: defaultOutputSpace,\n    } = defaultTransform;\n    const { units, scales } = inputSpace;\n    const inputSpaceSame =\n      sourceRank === rank &&\n      arraysEqual(\n        scales,\n        mutableSourceRank ? outputSpace.scales : defaultInputSpace.scales,\n      ) &&\n      arraysEqual(\n        units,\n        mutableSourceRank ? outputSpace.units : defaultInputSpace.units,\n      );\n    const transformSame = isTransformDerivableFromDefault(\n      defaultTransformMatrix,\n      defaultRank,\n      defaultOutputSpace.scales,\n      transform,\n      rank,\n      outputSpace.scales,\n    );\n    const outputNamesSame = arraysEqual(\n      defaultOutputSpace.names,\n      outputSpace.names,\n    );\n    if (transformSame && outputNamesSame && inputSpaceSame) {\n      return undefined;\n    }\n    return {\n      sourceRank,\n      transform: transformSame ? undefined : transform,\n      outputSpace: value.outputSpace,\n      inputSpace: inputSpaceSame ? undefined : inputSpace,\n    };\n  }\n\n  set transform(transform: Float64Array) {\n    const { value } = this;\n    const { inputSpace } = value;\n    this.value_ = {\n      rank: value.rank,\n      sourceRank: value.sourceRank,\n      inputSpace,\n      transform,\n      outputSpace: getOutputSpaceWithTransformedBoundingBoxes(\n        inputSpace,\n        transform,\n        value.outputSpace,\n      ),\n    };\n    this.changed.dispatch();\n  }\n\n  set spec(spec: Readonly<CoordinateTransformSpecification> | undefined) {\n    if (spec === undefined) {\n      this.reset();\n      return;\n    }\n    if (this.mutableSourceRank) {\n      const origInputSpace = spec.inputSpace || spec.outputSpace;\n      const rank = origInputSpace.rank;\n      const inputSpace = makeCoordinateSpace({\n        rank,\n        names: origInputSpace.names.map((_, i) => `${i}`),\n        units: origInputSpace.units,\n        scales: origInputSpace.scales,\n        coordinateArrays: origInputSpace.coordinateArrays,\n      });\n      this.value = {\n        rank,\n        transform:\n          spec.transform || matrix.createIdentity(Float64Array, rank + 1),\n        sourceRank: spec.sourceRank,\n        outputSpace: spec.outputSpace,\n        inputSpace,\n      };\n      return;\n    }\n    const {\n      inputSpace: defaultInputSpace,\n      sourceRank: defaultSourceRank,\n      outputSpace: defaultOutputSpace,\n      transform: defaultTransformMatrix,\n      rank: defaultRank,\n    } = this.defaultTransform;\n    const {\n      inputSpace: specInputSpace,\n      sourceRank: specSourceRank,\n      outputSpace: specOutputSpace,\n      transform: specTransformMatrix,\n    } = spec;\n    const specRank = spec.outputSpace.rank;\n    const defaultInputNames = defaultInputSpace.names;\n    const specInputNames =\n      specInputSpace !== undefined ? specInputSpace.names : defaultInputNames;\n    const newToSpecDimensionIndices = new Array<number>(defaultSourceRank);\n    for (let defaultDim = 0; defaultDim < defaultSourceRank; ++defaultDim) {\n      let specDim = specInputNames.indexOf(defaultInputNames[defaultDim]);\n      if (specDim >= specSourceRank) specDim = -1;\n      newToSpecDimensionIndices[defaultDim] = specDim;\n    }\n    const newRank = specRank - specSourceRank + defaultSourceRank;\n    for (let i = specSourceRank; i < specRank; ++i) {\n      newToSpecDimensionIndices[defaultSourceRank + i - specSourceRank] = i;\n    }\n    const newInputScales = new Float64Array(newRank);\n    const newInputCoordinateArrays = new Array<CoordinateArray | undefined>(\n      newRank,\n    );\n    const newInputUnits: string[] = [];\n    for (let newDim = 0; newDim < defaultSourceRank; ++newDim) {\n      const specDim = newToSpecDimensionIndices[newDim];\n      if (specDim === -1 || specInputSpace === undefined) {\n        newInputScales[newDim] = defaultInputSpace.scales[newDim];\n        newInputUnits[newDim] = defaultInputSpace.units[newDim];\n        newInputCoordinateArrays[newDim] =\n          defaultInputSpace.coordinateArrays[newDim];\n      } else {\n        newInputScales[newDim] = specInputSpace.scales[specDim];\n        newInputUnits[newDim] = specInputSpace.units[specDim];\n        newInputCoordinateArrays[newDim] = mergeOptionalCoordinateArrays([\n          defaultInputSpace.coordinateArrays[newDim],\n          specInputSpace.coordinateArrays[specDim],\n        ]);\n      }\n    }\n    const specInputOrOutputSpace = specInputSpace || specOutputSpace;\n    const newInputNames = defaultInputNames.slice(0, defaultSourceRank);\n    const newOutputNames = defaultOutputSpace.names.slice(0, defaultSourceRank);\n    const newOutputCoordinateArrays = defaultOutputSpace.coordinateArrays.slice(\n      0,\n      defaultSourceRank,\n    );\n    const newOutputScales = new Float64Array(newRank);\n    const newOutputUnits: string[] = [];\n    for (let newDim = 0; newDim < newRank; ++newDim) {\n      const specDim = newToSpecDimensionIndices[newDim];\n      if (specDim === -1) {\n        newOutputScales[newDim] = defaultOutputSpace.scales[newDim];\n        newOutputUnits[newDim] = defaultOutputSpace.units[newDim];\n        newOutputCoordinateArrays[newDim] =\n          defaultOutputSpace.coordinateArrays[newDim];\n      } else {\n        newOutputNames[newDim] = specOutputSpace.names[specDim];\n        newOutputUnits[newDim] = specOutputSpace.units[specDim];\n        newOutputScales[newDim] = specOutputSpace.scales[specDim];\n        newOutputCoordinateArrays[newDim] =\n          specOutputSpace.coordinateArrays[specDim];\n      }\n    }\n    if (!validateDimensionNames(newOutputNames)) {\n      // Spec is incompatible, ignore it.\n      this.reset();\n      return;\n    }\n    // Handle singleton dimensions.\n    for (let newDim = defaultSourceRank; newDim < newRank; ++newDim) {\n      const specDim = newDim - defaultSourceRank + specSourceRank;\n      newInputScales[newDim] = specInputOrOutputSpace.scales[specDim];\n      newInputUnits[newDim] = specInputOrOutputSpace.units[specDim];\n      newInputNames[newDim] = `${newDim}`;\n    }\n\n    const newTransform = new Float64Array((newRank + 1) ** 2);\n    newTransform[newTransform.length - 1] = 1;\n    for (let newRow = 0; newRow < newRank; ++newRow) {\n      const specRow = newToSpecDimensionIndices[newRow];\n      let value: number;\n      if (specRow === -1 || specTransformMatrix === undefined) {\n        if (newRow >= defaultSourceRank) {\n          value = 0;\n        } else {\n          value =\n            defaultTransformMatrix[defaultRank * (defaultRank + 1) + newRow] *\n            (defaultOutputSpace.scales[newRow] / newOutputScales[newRow]);\n        }\n      } else {\n        value = specTransformMatrix[specRank * (specRank + 1) + specRow];\n      }\n      newTransform[newRank * (newRank + 1) + newRow] = value;\n      for (let newCol = 0; newCol < newRank; ++newCol) {\n        const specCol = newToSpecDimensionIndices[newCol];\n        let value: number;\n        if ((specRow === -1) !== (specCol === -1)) {\n          value = 0;\n        } else if (specRow === -1 || specTransformMatrix === undefined) {\n          if (specRow >= defaultSourceRank || specCol >= defaultSourceRank) {\n            value = specRow === specCol ? 1 : 0;\n          } else {\n            value = defaultTransformMatrix[newCol * (defaultRank + 1) + newRow];\n          }\n        } else {\n          value = specTransformMatrix[specCol * (specRank + 1) + specRow];\n        }\n        newTransform[newCol * (newRank + 1) + newRow] = value;\n      }\n    }\n    const boundingBoxes = defaultInputSpace.boundingBoxes.map((boundingBox) =>\n      extendTransformedBoundingBoxUpToRank(boundingBox, defaultRank, newRank),\n    );\n    for (let i = defaultSourceRank; i < newRank; ++i) {\n      boundingBoxes.push(makeSingletonDimTransformedBoundingBox(newRank, i));\n    }\n    // Propagate coordinate arrays from input dimensions to output dimensions.\n    for (let outputDim = 0; outputDim < newRank; ++outputDim) {\n      // Check if this output dimension is identity mapped from a single input dimension.\n      const translation = newTransform[newRank * (newRank + 1) + outputDim];\n      if (translation !== 0) continue;\n      let singleInputDim: number | undefined | null = undefined;\n      for (let inputDim = 0; inputDim < newRank; ++inputDim) {\n        const factor = newTransform[inputDim * (newRank + 1) + outputDim];\n        if (factor === 0) continue;\n        if (factor === 1) {\n          if (singleInputDim === undefined) {\n            // First input dimension that maps to this output dimension.\n            singleInputDim = inputDim;\n          } else {\n            // Multiple input dimensions map to this output dimension.\n            singleInputDim = null;\n            break;\n          }\n        } else {\n          // Non-identity mapping.\n          singleInputDim = null;\n          break;\n        }\n      }\n      if (singleInputDim == null) continue;\n      let coordinateArray = newInputCoordinateArrays[singleInputDim];\n      if (coordinateArray === undefined) continue;\n      if (coordinateArray.explicit) {\n        coordinateArray = { ...coordinateArray, explicit: false };\n      }\n      newOutputCoordinateArrays[outputDim] = mergeOptionalCoordinateArrays([\n        coordinateArray,\n        newOutputCoordinateArrays[outputDim],\n      ]);\n    }\n    this.value = {\n      rank: newRank,\n      transform: newTransform,\n      sourceRank: defaultSourceRank,\n      outputSpace: makeCoordinateSpace({\n        rank: newRank,\n        names: newOutputNames,\n        scales: newOutputScales,\n        units: newOutputUnits,\n        coordinateArrays: newOutputCoordinateArrays,\n      }),\n      inputSpace: makeCoordinateSpace({\n        rank: newRank,\n        names: newInputNames,\n        scales: newInputScales,\n        units: newInputUnits,\n        coordinateArrays: newInputCoordinateArrays,\n        boundingBoxes,\n      }),\n    };\n  }\n\n  toJSON() {\n    return coordinateTransformSpecificationToJson(this.spec);\n  }\n\n  restoreState(obj: unknown) {\n    this.spec = coordinateTransformSpecificationFromJson(obj);\n  }\n}\n\nexport function expectDimensionName(\n  obj: unknown,\n  allowNumericalNames = false,\n): string {\n  const name = verifyString(obj);\n  if (!isValidDimensionName(name, allowNumericalNames)) {\n    throw new Error(`Invalid dimension name: ${JSON.stringify(name)}`);\n  }\n  return name;\n}\n\nexport function dimensionNamesFromJson(obj: any, allowNumericalNames = false) {\n  const dimensions = parseArray(obj, (x) =>\n    expectDimensionName(x, allowNumericalNames),\n  );\n  if (!validateDimensionNames(dimensions, allowNumericalNames)) {\n    throw new Error(`Invalid dimensions: ${JSON.stringify(dimensions)}`);\n  }\n  return dimensions;\n}\n\ninterface BoundCoordinateSpace {\n  space: WatchableValueInterface<CoordinateSpace>;\n  prevValue: CoordinateSpace | undefined;\n  mappedDimensionIds: (DimensionId | undefined)[];\n}\n\nexport class CoordinateSpaceCombiner {\n  private bindings = new Set<BoundCoordinateSpace>();\n\n  private retainCount = 0;\n\n  private prevCombined: CoordinateSpace | undefined;\n\n  dimensionRefCounts = new Map<string, number>();\n\n  getRenameValidity(newNames: readonly string[]): boolean[] {\n    const existingNames = this.combined.value.names;\n    const validity = getDimensionNameValidity(newNames);\n    const rank = newNames.length;\n    for (let i = 0; i < rank; ++i) {\n      if (!validity[i]) continue;\n      const newName = newNames[i];\n      if (existingNames.includes(newName)) continue;\n      let valid = true;\n      for (const binding of this.bindings) {\n        const otherNames = binding.space.value.names;\n        if (otherNames.includes(newName)) {\n          valid = false;\n          break;\n        }\n      }\n      validity[i] = valid;\n    }\n    return validity;\n  }\n\n  private includeDimensionPredicate_: (name: string) => boolean;\n\n  get includeDimensionPredicate() {\n    return this.includeDimensionPredicate_;\n  }\n  set includeDimensionPredicate(value: (name: string) => boolean) {\n    this.includeDimensionPredicate_ = value;\n    this.update();\n  }\n\n  constructor(\n    public combined: WatchableValueInterface<CoordinateSpace>,\n    includeDimensionPredicate: (name: string) => boolean,\n  ) {\n    this.includeDimensionPredicate_ = includeDimensionPredicate;\n    this.prevCombined = this.combined.value;\n  }\n\n  private update() {\n    const { combined, bindings } = this;\n    const retainExisting = this.retainCount > 0 ? 1 : 0;\n    if (bindings.size === 0 && !retainExisting) {\n      combined.value = emptyInvalidCoordinateSpace;\n      return;\n    }\n    const include = this.includeDimensionPredicate_;\n    const existing = combined.value;\n    let mergedNames = Array.from(existing.names);\n    let mergedUnits = Array.from(existing.units);\n    let mergedScales = Array.from(existing.scales);\n    let mergedIds = Array.from(existing.ids);\n    let mergedTimestamps = Array.from(existing.timestamps);\n    let dimensionRefs: number[] = existing.names.map(() =>\n      retainExisting ? 1 : 0,\n    );\n    const bindingCombinedIndices: (number | undefined)[][] = [];\n    let valid = false;\n    for (const binding of bindings) {\n      const {\n        space: { value: space },\n        prevValue,\n        mappedDimensionIds,\n      } = binding;\n      valid = valid || space.valid;\n      const { names, units, scales, ids, timestamps } = space;\n      const newMappedDimensionIds: (DimensionId | undefined)[] = [];\n      const combinedIndices: (number | undefined)[] = [];\n      bindingCombinedIndices.push(combinedIndices);\n      binding.mappedDimensionIds = newMappedDimensionIds;\n      binding.prevValue = space;\n      const rank = names.length;\n      for (let i = 0; i < rank; ++i) {\n        const name = names[i];\n        if (!include(name)) continue;\n        if (prevValue !== undefined) {\n          const id = ids[i];\n          const prevIndex = prevValue.ids.indexOf(id);\n          if (prevIndex !== -1) {\n            const combinedId = mappedDimensionIds[prevIndex];\n            if (combinedId !== undefined) {\n              const combinedIndex = mergedIds.indexOf(combinedId);\n              if (combinedIndex !== -1) {\n                newMappedDimensionIds[i] = combinedId;\n                ++dimensionRefs[combinedIndex];\n                combinedIndices[i] = combinedIndex;\n                const timestamp = timestamps[i];\n                if (\n                  timestamp !== undefined &&\n                  !(timestamp <= mergedTimestamps[combinedIndex])\n                ) {\n                  mergedNames[combinedIndex] = name;\n                  mergedScales[combinedIndex] = scales[i];\n                  mergedUnits[combinedIndex] = units[i];\n                  mergedTimestamps[combinedIndex] = timestamp;\n                }\n                continue;\n              }\n            }\n          }\n        }\n        let combinedIndex = mergedNames.indexOf(name);\n        if (combinedIndex !== -1) {\n          newMappedDimensionIds[i] = mergedIds[combinedIndex];\n          ++dimensionRefs[combinedIndex];\n          combinedIndices[i] = combinedIndex;\n          continue;\n        }\n        combinedIndex = mergedNames.length;\n        combinedIndices[i] = combinedIndex;\n        dimensionRefs[combinedIndex] = 1 + retainExisting;\n        mergedNames[combinedIndex] = name;\n        mergedUnits[combinedIndex] = units[i];\n        mergedScales[combinedIndex] = scales[i];\n        mergedTimestamps[combinedIndex] = timestamps[i];\n        const combinedId = newDimensionId();\n        mergedIds[combinedIndex] = combinedId;\n        newMappedDimensionIds[i] = combinedId;\n      }\n    }\n    // Propagate names, units, and scales back\n    const { dimensionRefCounts } = this;\n    dimensionRefCounts.clear();\n    let bindingIndex = 0;\n    let newRank = mergedNames.length;\n    for (const binding of bindings) {\n      const {\n        space: { value: space },\n      } = binding;\n      const combinedIndices = bindingCombinedIndices[bindingIndex++];\n      const { rank } = space;\n      const names = Array.from(space.names);\n      const timestamps = Array.from(space.timestamps);\n      const scales = Float64Array.from(space.scales);\n      const units = Array.from(space.units);\n      for (let i = 0; i < rank; ++i) {\n        const combinedIndex = combinedIndices[i];\n        if (combinedIndex === undefined) continue;\n        units[i] = mergedUnits[combinedIndex];\n        scales[i] = mergedScales[combinedIndex];\n        timestamps[i] = mergedTimestamps[combinedIndex];\n        names[i] = mergedNames[combinedIndex];\n      }\n      for (const name of names) {\n        let count = dimensionRefCounts.get(name);\n        if (count === undefined) {\n          count = 1;\n        } else {\n          ++count;\n        }\n        dimensionRefCounts.set(name, count);\n      }\n      if (\n        !arraysEqual(units, space.units) ||\n        !arraysEqual(scales, space.scales) ||\n        !arraysEqual(names, space.names) ||\n        !arraysEqual(timestamps, space.timestamps)\n      ) {\n        const newSpace = makeCoordinateSpace({\n          valid: space.valid,\n          ids: space.ids,\n          scales,\n          units,\n          names,\n          timestamps,\n          boundingBoxes: space.boundingBoxes,\n          coordinateArrays: space.coordinateArrays,\n        });\n        binding.prevValue = newSpace;\n        binding.space.value = newSpace;\n      }\n    }\n\n    {\n      for (let i = 0; i < newRank; ++i) {\n        if (!include(mergedNames[i])) {\n          dimensionRefs[i] = 0;\n        }\n      }\n      const hasRefs = (_: any, i: number) => dimensionRefs[i] !== 0;\n      mergedNames = mergedNames.filter(hasRefs);\n      mergedUnits = mergedUnits.filter(hasRefs);\n      mergedScales = mergedScales.filter(hasRefs);\n      mergedIds = mergedIds.filter(hasRefs);\n      mergedTimestamps = mergedTimestamps.filter(hasRefs);\n      dimensionRefs = dimensionRefs.filter(hasRefs);\n      newRank = mergedNames.length;\n    }\n\n    const mergedBoundingBoxes: TransformedBoundingBox[] = [];\n    const allCoordinateArrays = new Array<CoordinateArray[] | undefined>(\n      newRank,\n    );\n    // Include any explicit coordinate arrays from `existing`.\n    for (let i = 0, existingRank = existing.rank; i < existingRank; ++i) {\n      const coordinateArray = existing.coordinateArrays[i];\n      if (!coordinateArray?.explicit) continue;\n      const newDim = mergedIds.indexOf(existing.ids[i]);\n      if (newDim === -1) continue;\n      allCoordinateArrays[newDim] = [coordinateArray];\n    }\n    for (const binding of bindings) {\n      const {\n        space: { value: space },\n      } = binding;\n      const { rank, boundingBoxes, coordinateArrays } = space;\n      const newDims = space.names.map((x) => mergedNames.indexOf(x));\n      for (const oldBoundingBox of boundingBoxes) {\n        mergedBoundingBoxes.push(\n          extendTransformedBoundingBox(oldBoundingBox, newRank, newDims),\n        );\n      }\n      for (let i = 0; i < rank; ++i) {\n        const coordinateArray = coordinateArrays[i];\n        if (coordinateArray === undefined) continue;\n        const newDim = newDims[i];\n        const mergedList = allCoordinateArrays[newDim];\n        if (mergedList === undefined) {\n          allCoordinateArrays[newDim] = [coordinateArray];\n        } else {\n          mergedList.push(coordinateArray);\n        }\n      }\n    }\n    const mergedCoordinateArrays = new Array<CoordinateArray | undefined>(\n      newRank,\n    );\n    for (let i = 0; i < newRank; ++i) {\n      const mergedList = allCoordinateArrays[i];\n      if (mergedList === undefined) continue;\n      mergedCoordinateArrays[i] = mergeCoordinateArrays(mergedList);\n    }\n    const newCombined = makeCoordinateSpace({\n      valid,\n      ids: mergedIds,\n      names: mergedNames,\n      units: mergedUnits,\n      scales: new Float64Array(mergedScales),\n      boundingBoxes: mergedBoundingBoxes,\n      coordinateArrays: mergedCoordinateArrays,\n    });\n    if (retainExisting) {\n      for (let i = 0; i < newRank; ++i) {\n        --dimensionRefs[i];\n      }\n    }\n    if (!coordinateSpacesEqual(existing, newCombined)) {\n      this.prevCombined = newCombined;\n      combined.value = newCombined;\n    }\n  }\n\n  private handleCombinedChanged = () => {\n    if (this.combined.value === this.prevCombined) return;\n    this.update();\n  };\n\n  retain() {\n    ++this.retainCount;\n    return () => {\n      if (--this.retainCount === 0) {\n        this.update();\n      }\n    };\n  }\n\n  bind(space: WatchableValueInterface<CoordinateSpace>) {\n    const binding = { space, mappedDimensionIds: [], prevValue: undefined };\n    const { bindings } = this;\n    if (bindings.size === 0) {\n      this.combined.changed.add(this.handleCombinedChanged);\n    }\n    bindings.add(binding);\n\n    const changedDisposer = space.changed.add(() => {\n      if (space.value === binding.prevValue) return;\n      this.update();\n    });\n    const disposer = () => {\n      changedDisposer();\n      const { bindings } = this;\n      bindings.delete(binding);\n      if (bindings.size === 0) {\n        this.combined.changed.remove(this.handleCombinedChanged);\n      }\n      this.update();\n    };\n    this.update();\n    return disposer;\n  }\n}\n\nexport function homogeneousTransformSubmatrix<T extends TypedArray>(\n  arrayConstructor: { new (n: number): T },\n  oldTransform: TypedArray,\n  oldRank: number,\n  oldRows: readonly number[],\n  oldCols: readonly number[],\n): T {\n  const newRank = oldCols.length;\n  const newTransform = new arrayConstructor((newRank + 1) ** 2);\n  newTransform[newTransform.length - 1] = 1;\n  for (let newRow = 0; newRow < newRank; ++newRow) {\n    const oldRow = oldRows[newRow];\n    newTransform[(newRank + 1) * newRank + newRow] =\n      oldTransform[(oldRank + 1) * oldRank + oldRow];\n    for (let newCol = 0; newCol < newRank; ++newCol) {\n      const oldCol = oldCols[newCol];\n      newTransform[(newRank + 1) * newCol + newRow] =\n        oldTransform[(oldRank + 1) * oldCol + oldRow];\n    }\n  }\n  return newTransform;\n}\n\nexport interface CoordinateTransformSpecification {\n  sourceRank: number;\n  transform: Float64Array | undefined;\n  inputSpace: CoordinateSpace | undefined;\n  outputSpace: CoordinateSpace;\n}\n\nexport function coordinateTransformSpecificationFromLegacyJson(\n  obj: unknown,\n): CoordinateTransformSpecification | undefined {\n  if (obj === undefined) return undefined;\n  const transform = new Float64Array(16);\n  if (Array.isArray(obj)) {\n    if (obj.length === 16) {\n      for (let i = 0; i < 4; ++i) {\n        for (let j = 0; j < 4; ++j) {\n          transform[i * 4 + j] = verifyFiniteFloat(obj[j * 4 + i]);\n        }\n      }\n    } else {\n      expectArray(obj, 4);\n      for (let i = 0; i < 4; ++i) {\n        const row = expectArray(obj[i], 4);\n        for (let j = 0; j < 4; ++j) {\n          transform[j * 4 + i] = verifyFiniteFloat(row[j]);\n        }\n      }\n    }\n  } else {\n    verifyObject(obj);\n    const rotation = quat.create();\n    const translation = vec3.create();\n    const scale = vec3.fromValues(1, 1, 1);\n    verifyOptionalObjectProperty(obj, \"rotation\", (x) => {\n      parseFiniteVec(rotation, x);\n      quat.normalize(rotation, rotation);\n    });\n    verifyOptionalObjectProperty(obj, \"translation\", (x) => {\n      parseFiniteVec(translation, x);\n    });\n    verifyOptionalObjectProperty(obj, \"scale\", (x) => {\n      parseFiniteVec(scale, x);\n    });\n    const tempMat4 = mat4.create();\n    mat4.fromRotationTranslationScale(tempMat4, rotation, translation, scale);\n    transform.set(tempMat4);\n  }\n  return {\n    sourceRank: 3,\n    transform,\n    outputSpace: makeCoordinateSpace({\n      valid: true,\n      names: [\"x\", \"y\", \"z\"],\n      units: [\"m\", \"m\", \"m\"],\n      scales: Float64Array.of(1e-9, 1e-9, 1e-9),\n    }),\n    inputSpace: undefined,\n  };\n}\n\nexport function coordinateTransformSpecificationFromJson(\n  j: unknown,\n): CoordinateTransformSpecification | undefined {\n  if (j === undefined) return undefined;\n  const obj = verifyObject(j);\n  const outputSpace = verifyObjectProperty(\n    obj,\n    \"outputDimensions\",\n    coordinateSpaceFromJson,\n  );\n  const rank = outputSpace.rank;\n  const sourceRank = verifyObjectProperty(obj, \"sourceRank\", (rankObj) => {\n    if (rankObj === undefined) return rank;\n    if (!Number.isInteger(rankObj) || rankObj < 0 || rankObj > rank) {\n      throw new Error(\n        `Expected integer in range [0, ${rank}] but received: ${JSON.stringify(\n          rankObj,\n        )}`,\n      );\n    }\n    return rankObj as number;\n  });\n  const inputSpace = verifyOptionalObjectProperty(\n    obj,\n    \"inputDimensions\",\n    (inputSpaceObj) => {\n      const space = coordinateSpaceFromJson(inputSpaceObj, true);\n      if (space.rank !== rank) {\n        throw new Error(\n          `Expected rank of ${rank}, but received rank of: ${space.rank}`,\n        );\n      }\n      return space;\n    },\n  );\n  const transform = verifyOptionalObjectProperty(obj, \"matrix\", (x) => {\n    const transform = new Float64Array((rank + 1) ** 2);\n    const a = expectArray(x, rank);\n    transform[transform.length - 1] = 1;\n    for (let i = 0; i < rank; ++i) {\n      try {\n        const row = expectArray(a[i], rank + 1);\n        for (let j = 0; j <= rank; ++j) {\n          transform[(rank + 1) * j + i] = verifyFiniteFloat(row[j]);\n        }\n      } catch (e) {\n        throw new Error(`Error in row ${i}: ${e.message}`);\n      }\n    }\n    return transform;\n  });\n  return { transform, outputSpace, inputSpace, sourceRank };\n}\n\nexport function coordinateTransformSpecificationToJson(\n  spec: CoordinateTransformSpecification | undefined,\n) {\n  if (spec === undefined) return undefined;\n  const { transform, outputSpace, inputSpace, sourceRank } = spec;\n  let m: number[][] | undefined;\n  const rank = outputSpace.rank;\n  if (transform !== undefined) {\n    m = [];\n    for (let i = 0; i < rank; ++i) {\n      const row: number[] = [];\n      m[i] = row;\n      for (let j = 0; j <= rank; ++j) {\n        row[j] = transform[(rank + 1) * j + i];\n      }\n    }\n  }\n  return {\n    sourceRank: sourceRank === rank ? undefined : sourceRank,\n    matrix: m,\n    outputDimensions: coordinateSpaceToJson(outputSpace),\n    inputDimensions:\n      inputSpace === undefined ? undefined : coordinateSpaceToJson(inputSpace),\n  };\n}\n\nexport function permuteTransformedBoundingBox(\n  boundingBox: TransformedBoundingBox,\n  newToOld: readonly number[],\n  oldOutputRank: number,\n): TransformedBoundingBox | undefined {\n  const { box, transform } = boundingBox;\n  const inputRank = boundingBox.box.lowerBounds.length;\n  const outputRank = newToOld.length;\n  const newTransform = new Float64Array((inputRank + 1) * outputRank);\n  matrix.permuteRows(\n    newTransform,\n    outputRank,\n    transform,\n    oldOutputRank,\n    newToOld,\n    inputRank + 1,\n  );\n  if (newTransform.every((x) => x === 0)) return undefined;\n  return {\n    transform: newTransform,\n    box,\n  };\n}\n\nexport function permuteCoordinateSpace(\n  existing: CoordinateSpace,\n  newToOld: readonly number[],\n) {\n  const { ids, names, scales, units, timestamps, coordinateArrays } = existing;\n  return makeCoordinateSpace({\n    rank: newToOld.length,\n    valid: existing.valid,\n    ids: newToOld.map((i) => ids[i]),\n    names: newToOld.map((i) => names[i]),\n    timestamps: newToOld.map((i) => timestamps[i]),\n    scales: Float64Array.from(newToOld, (i) => scales[i]),\n    units: newToOld.map((i) => units[i]),\n    coordinateArrays: newToOld.map((i) => coordinateArrays[i]),\n    boundingBoxes: existing.boundingBoxes\n      .map((b) => permuteTransformedBoundingBox(b, newToOld, existing.rank))\n      .filter((b) => b !== undefined) as TransformedBoundingBox[],\n  });\n}\n\nexport function insertDimensionAt(\n  existing: CoordinateSpace,\n  targetIndex: number,\n  sourceIndex: number,\n) {\n  if (targetIndex === sourceIndex) return existing;\n  return permuteCoordinateSpace(\n    existing,\n    getInsertPermutation(existing.rank, sourceIndex, targetIndex),\n  );\n}\n\nexport function getInferredOutputScale(\n  transform: CoordinateSpaceTransform,\n  outputDim: number,\n): { scale: number; unit: string } | undefined {\n  const { transform: transformMatrix, rank } = transform;\n  const inputDims = getDependentTransformInputDimensions(\n    transformMatrix,\n    rank,\n    [outputDim],\n  );\n  if (inputDims.length !== 1) return undefined;\n  const [inputDim] = inputDims;\n  const coeff = Math.abs(transformMatrix[(rank + 1) * inputDim + outputDim]);\n  const { inputSpace } = transform;\n  return {\n    scale: inputSpace.scales[inputDim] * coeff,\n    unit: inputSpace.units[inputDim],\n  };\n}\n\nexport function getDefaultInputScale(\n  transform: WatchableCoordinateSpaceTransform,\n  inputDim: number,\n): { scale: number; unit: string } | undefined {\n  const { scales: defaultScales, units: defaultUnits } =\n    transform.defaultInputSpace;\n  return inputDim < defaultScales.length\n    ? { scale: defaultScales[inputDim], unit: defaultUnits[inputDim] }\n    : undefined;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Defines a generic interface for a simple state tracking mechanism.\n */\n\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { verifyObject, verifyOptionalObjectProperty } from \"#src/util/json.js\";\nimport type { NullaryReadonlySignal } from \"#src/util/signal.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\n\nexport interface JsonRestorable {\n  restoreState: (x: any) => void;\n}\n\nexport function optionallyRestoreFromJsonMember(\n  obj: any,\n  member: string,\n  restorable: JsonRestorable,\n) {\n  verifyOptionalObjectProperty(obj, member, (x) => restorable.restoreState(x));\n}\n\nexport interface Trackable extends JsonRestorable {\n  restoreState: (x: any) => void;\n  reset: () => void;\n  changed: NullaryReadonlySignal;\n  toJSON: () => any;\n}\n\nexport class CompoundTrackable extends RefCounted implements Trackable {\n  children = new Map<string, Trackable>();\n  changed = new NullarySignal();\n\n  add(key: string, value: Trackable): () => void {\n    const { children } = this;\n    if (children.has(key)) {\n      throw new Error(`Key ${JSON.stringify(key)} already registered.`);\n    }\n    this.children.set(key, value);\n    value.changed.add(this.changed.dispatch);\n    this.changed.dispatch();\n    return () => {\n      this.remove(key);\n    };\n  }\n\n  remove(key: string): void {\n    const { children } = this;\n    if (children.has(key)) {\n      throw new Error(`Key ${JSON.stringify(key)} not registered.`);\n    }\n    const value = children.get(key)!;\n    this.children.delete(key);\n    value.changed.remove(this.changed.dispatch);\n    this.changed.dispatch();\n  }\n\n  disposed() {\n    const { changed } = this;\n    for (const value of this.children.values()) {\n      value.changed.remove(changed.dispatch);\n    }\n    this.children = <any>undefined;\n    super.disposed();\n  }\n\n  toJSON() {\n    const result = this.baseJSON();\n    for (const [key, value] of this.children) {\n      result[key] = value.toJSON();\n    }\n    return result;\n  }\n\n  baseJSON() {\n    return <{ [key: string]: any }>{};\n  }\n\n  reset() {\n    for (const value of this.children.values()) {\n      value.reset();\n    }\n  }\n\n  restoreState(x: any) {\n    verifyObject(x);\n    for (const [key, value] of this.children) {\n      try {\n        if (Object.prototype.hasOwnProperty.call(x, key)) {\n          const subValue = x[key];\n          if (subValue === undefined) {\n            continue;\n          }\n          value.restoreState(subValue);\n        }\n      } catch (restoreError) {\n        throw new Error(\n          `Error restoring property ${JSON.stringify(key)}: ${\n            restoreError.message\n          }`,\n        );\n      }\n    }\n  }\n}\n\nexport class PersistentCompoundTrackable extends CompoundTrackable {\n  lastState: { [key: string]: any } = {};\n\n  restoreState(x: any) {\n    verifyObject(x);\n    this.lastState = x;\n    super.restoreState(x);\n  }\n\n  reset() {\n    this.lastState = {};\n    super.reset();\n  }\n\n  baseJSON() {\n    const result = Object.assign(super.baseJSON(), this.lastState);\n    for (const key of this.children.keys()) {\n      delete result[key];\n    }\n    return result;\n  }\n\n  toJSON() {\n    const result = super.toJSON();\n    this.lastState = result;\n    return result;\n  }\n  add(key: string, value: Trackable) {\n    const result = super.add(key, value);\n    const existingValue = this.lastState[key];\n    if (existingValue !== undefined) {\n      value.reset();\n      value.restoreState(existingValue);\n    }\n    return result;\n  }\n}\n\n/**\n * Cache used by getCachedJson.\n */\nconst jsonCache = new WeakMap<Trackable, { value: any; generation: number }>();\n\n/**\n * Returns a JSON representation of a Trackable object.\n *\n * Recursively caches the result, such that it is only necessary to traverse the changed portions of\n * the object.\n *\n * The returned value must not be modified.\n */\nexport function getCachedJson(root: Trackable): {\n  value: any;\n  generation: number;\n} {\n  let cacheState = jsonCache.get(root);\n  const generation = root.changed.count;\n  if (cacheState !== undefined) {\n    if (cacheState.generation === generation) {\n      return cacheState;\n    }\n  }\n  let value: any;\n  if (root instanceof CompoundTrackable) {\n    value = root.baseJSON();\n    for (const [k, v] of root.children) {\n      value[k] = getCachedJson(v).value;\n    }\n  } else {\n    value = root.toJSON();\n  }\n  if (cacheState === undefined) {\n    cacheState = { generation, value };\n    jsonCache.set(root, cacheState);\n  } else {\n    cacheState.generation = generation;\n    cacheState.value = value;\n  }\n  return cacheState;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debounce } from \"lodash-es\";\n\nimport type { FrameNumberCounter } from \"#src/chunk_manager/frontend.js\";\nimport { TrackableValue } from \"#src/trackable_value.js\";\nimport { animationFrameDebounce } from \"#src/util/animation_frame_debounce.js\";\nimport type { Borrowed } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { FramerateMonitor } from \"#src/util/framerate.js\";\nimport type { mat4 } from \"#src/util/geom.js\";\nimport { parseFixedLengthArray, verifyFloat01 } from \"#src/util/json.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\nimport type { WatchableVisibilityPriority } from \"#src/visibility_priority/frontend.js\";\nimport type { GL } from \"#src/webgl/context.js\";\nimport { initializeWebGL } from \"#src/webgl/context.js\";\n\nconst DELAY_AFTER_CONTINUOUS_CAMERA_MOTION_MS = 300;\n\nexport class RenderViewport {\n  // Width of visible portion of panel in canvas pixels.\n  width = 0;\n\n  // Height of visible portion of panel in canvas pixels.\n  height = 0;\n\n  // Width in canvas pixels, including portions outside of the canvas (i.e. outside the \"viewport\"\n  // window).\n  logicalWidth = 0;\n\n  // Height in canvas pixels, including portions outside of the canvas (i.e. outside the \"viewport\"\n  // window).\n  logicalHeight = 0;\n\n  // Left edge of visible region within full (logical) panel, as fraction in [0, 1].\n  visibleLeftFraction = 0;\n\n  // Top edge of visible region within full (logical) panel, as fraction in [0, 1].\n  visibleTopFraction = 0;\n\n  // Fraction of logical width that is visible, equal to `widthInCanvasPixels / logicalWidth`.\n  visibleWidthFraction = 0;\n\n  // Fraction of logical height that is visible, equal to `heightInCanvasPixels / logicalHeight`.\n  visibleHeightFraction = 0;\n}\n\nexport function applyRenderViewportToProjectionMatrix(\n  viewport: RenderViewport,\n  projectionMatrix: mat4,\n) {\n  const xScale = 1 / viewport.visibleWidthFraction;\n  const yScale = 1 / viewport.visibleHeightFraction;\n  const xOffset = -1 - (-1 + 2 * viewport.visibleLeftFraction) * xScale;\n  let yOffset = -1 - (-1 + 2 * viewport.visibleTopFraction) * yScale;\n  yOffset = -yOffset;\n  projectionMatrix[0] =\n    projectionMatrix[0] * xScale + projectionMatrix[3] * xOffset;\n  projectionMatrix[4] =\n    projectionMatrix[4] * xScale + projectionMatrix[7] * xOffset;\n  projectionMatrix[8] =\n    projectionMatrix[8] * xScale + projectionMatrix[11] * xOffset;\n  projectionMatrix[12] =\n    projectionMatrix[12] * xScale + projectionMatrix[15] * xOffset;\n\n  projectionMatrix[1] =\n    projectionMatrix[1] * yScale + projectionMatrix[3] * yOffset;\n  projectionMatrix[5] =\n    projectionMatrix[5] * yScale + projectionMatrix[7] * yOffset;\n  projectionMatrix[9] =\n    projectionMatrix[9] * yScale + projectionMatrix[11] * yOffset;\n  projectionMatrix[13] =\n    projectionMatrix[13] * yScale + projectionMatrix[15] * yOffset;\n}\n\nexport function renderViewportsEqual(a: RenderViewport, b: RenderViewport) {\n  return (\n    a.width === b.width &&\n    a.height === b.height &&\n    a.logicalWidth === b.logicalWidth &&\n    a.logicalHeight === b.logicalHeight &&\n    a.visibleLeftFraction === b.visibleLeftFraction &&\n    a.visibleTopFraction === b.visibleTopFraction\n  );\n}\n\nexport abstract class RenderedPanel extends RefCounted {\n  gl: GL;\n\n  // Generation used to check whether the following bounds-related fields are up to date.\n  boundsGeneration = -1;\n\n  // Offset of visible portion of panel in canvas pixels from left side of canvas.\n  canvasRelativeClippedLeft = 0;\n\n  // Offset of visible portion of panel in canvas pixels from top of canvas.\n  canvasRelativeClippedTop = 0;\n\n  canvasRelativeLogicalLeft = 0;\n  canvasRelativeLogicalTop = 0;\n\n  renderViewport = new RenderViewport();\n\n  private monitorState: PanelMonitorState = { isIntersecting: true };\n\n  constructor(\n    public context: Borrowed<DisplayContext>,\n    public element: HTMLElement,\n    public visibility: WatchableVisibilityPriority,\n  ) {\n    super();\n    this.gl = context.gl;\n    context.addPanel(this);\n  }\n\n  scheduleRedraw() {\n    if (this.visible) {\n      this.context.scheduleRedraw();\n    }\n  }\n\n  abstract isReady(): boolean;\n\n  ensureBoundsUpdated() {\n    const { context } = this;\n    context.ensureBoundsUpdated();\n    const { boundsGeneration } = context;\n    if (boundsGeneration === this.boundsGeneration) return;\n    this.boundsGeneration = boundsGeneration;\n    const { element } = this;\n    const clientRect = element.getBoundingClientRect();\n    context.ensureMonitorPanel(element, this.monitorState, clientRect);\n    const root = context.container;\n    const canvasRect = context.canvasRect!;\n    const { canvas } = context;\n    const { width: canvasPixelWidth, height: canvasPixelHeight } = canvas;\n    const screenToCanvasPixelScaleX = canvasPixelWidth / canvasRect.width;\n    const screenToCanvasPixelScaleY = canvasPixelHeight / canvasRect.height;\n    // Logical bounding rectangle in canvas/WebGL pixels (which may be a different size than screen\n    // pixels when using a fixed canvas size via the Python integration).\n    const canvasLeft = canvasRect.left;\n    const canvasTop = canvasRect.top;\n    const logicalLeft = (this.canvasRelativeLogicalLeft = Math.round(\n      (clientRect.left - canvasLeft) * screenToCanvasPixelScaleX +\n        element.clientLeft,\n    ));\n    const logicalTop = (this.canvasRelativeLogicalTop = Math.round(\n      (clientRect.top - canvasTop) * screenToCanvasPixelScaleY +\n        element.clientTop,\n    ));\n    const logicalWidth = element.clientWidth;\n    const logicalHeight = element.clientHeight;\n    const logicalRight = logicalLeft + logicalWidth;\n    const logicalBottom = logicalTop + logicalHeight;\n    // Clipped bounding rectangle in canvas/WebGL pixels.  The clipped bounding rectangle is the\n    // portion actually visible and overlapping the canvas.\n    let clippedTop = logicalTop;\n    let clippedLeft = logicalLeft;\n    let clippedRight = logicalRight;\n    let clippedBottom = logicalBottom;\n    for (\n      let parent = element.parentElement;\n      parent !== null && parent !== root;\n      parent = parent.parentElement\n    ) {\n      const rect = parent.getBoundingClientRect();\n      if (\n        rect.x === 0 &&\n        rect.y === 0 &&\n        rect.width === 0 &&\n        rect.height === 0\n      ) {\n        // Assume this is a `display: contents;` element.\n        continue;\n      }\n      clippedLeft = Math.max(\n        clippedLeft,\n        (rect.left - canvasLeft) * screenToCanvasPixelScaleX,\n      );\n      clippedTop = Math.max(\n        clippedTop,\n        (rect.top - canvasTop) * screenToCanvasPixelScaleY,\n      );\n      clippedRight = Math.min(\n        clippedRight,\n        (rect.right - canvasLeft) * screenToCanvasPixelScaleX,\n      );\n      clippedBottom = Math.min(\n        clippedBottom,\n        (rect.bottom - canvasTop) * screenToCanvasPixelScaleY,\n      );\n    }\n    clippedTop = this.canvasRelativeClippedTop = Math.round(\n      Math.max(clippedTop, 0),\n    );\n    clippedLeft = this.canvasRelativeClippedLeft = Math.round(\n      Math.max(clippedLeft, 0),\n    );\n    clippedRight = Math.round(Math.min(clippedRight, canvasPixelWidth));\n    clippedBottom = Math.round(Math.min(clippedBottom, canvasPixelHeight));\n    const viewport = this.renderViewport;\n    const clippedWidth = (viewport.width = Math.max(\n      0,\n      clippedRight - clippedLeft,\n    ));\n    const clippedHeight = (viewport.height = Math.max(\n      0,\n      clippedBottom - clippedTop,\n    ));\n    viewport.logicalWidth = logicalWidth;\n    viewport.logicalHeight = logicalHeight;\n    viewport.visibleLeftFraction = (clippedLeft - logicalLeft) / logicalWidth;\n    viewport.visibleTopFraction = (clippedTop - logicalTop) / logicalHeight;\n    viewport.visibleWidthFraction = clippedWidth / logicalWidth;\n    viewport.visibleHeightFraction = clippedHeight / logicalHeight;\n  }\n\n  // Sets the viewport to the clipped viewport.  Any drawing must take\n  // `visible{Left,Top,Width,Height}Fraction` into account.  setGLClippedViewport() {\n  setGLClippedViewport() {\n    const {\n      gl,\n      canvasRelativeClippedTop,\n      canvasRelativeClippedLeft,\n      renderViewport: { width, height },\n    } = this;\n    const bottom = canvasRelativeClippedTop + height;\n    gl.enable(WebGL2RenderingContext.SCISSOR_TEST);\n    const glBottom = this.context.canvas.height - bottom;\n    gl.viewport(canvasRelativeClippedLeft, glBottom, width, height);\n    gl.scissor(canvasRelativeClippedLeft, glBottom, width, height);\n  }\n\n  // Sets the viewport to the logical viewport, using the scissor test to constrain drawing to the\n  // clipped viewport.  Drawing does not need to take `visible{Left,Top,Width,Height}Fraction` into\n  // account.\n  setGLLogicalViewport() {\n    const {\n      gl,\n      renderViewport: { width, height, logicalWidth, logicalHeight },\n    } = this;\n    const canvasHeight = this.context.canvas.height;\n    gl.enable(WebGL2RenderingContext.SCISSOR_TEST);\n    gl.viewport(\n      this.canvasRelativeLogicalLeft,\n      canvasHeight - (this.canvasRelativeLogicalTop + logicalHeight),\n      logicalWidth,\n      logicalHeight,\n    );\n    gl.scissor(\n      this.canvasRelativeClippedLeft,\n      canvasHeight - (this.canvasRelativeClippedTop + height),\n      width,\n      height,\n    );\n  }\n\n  abstract draw(): void;\n\n  disposed() {\n    this.context.unmonitorPanel(this.element, this.monitorState);\n    this.context.removePanel(this);\n    super.disposed();\n  }\n\n  get visible() {\n    return this.visibility.visible;\n  }\n\n  getDepthArray(): Float32Array | undefined {\n    return undefined;\n  }\n\n  get shouldDraw() {\n    if (!this.visible) return false;\n    const { element } = this;\n    if (\n      element.clientWidth === 0 ||\n      element.clientHeight === 0 ||\n      element.offsetWidth === 0 ||\n      element.offsetHeight === 0\n    ) {\n      // Skip drawing if the panel has zero client area.\n      return false;\n    }\n    return true;\n  }\n\n  // Returns a number that determine the order in which panels are drawn. This is used by CdfPanel\n  // to ensure it is drawn after other panels that update the histogram.\n  //\n  // A higher number -> later draw.\n  get drawOrder() {\n    return 0;\n  }\n}\n\nexport abstract class IndirectRenderedPanel extends RenderedPanel {\n  canvas = document.createElement(\"canvas\");\n  canvasRenderingContext = this.canvas.getContext(\"2d\");\n  constructor(\n    context: Borrowed<DisplayContext>,\n    element: HTMLElement,\n    visibility: WatchableVisibilityPriority,\n  ) {\n    super(context, element, visibility);\n    const { canvas } = this;\n    element.appendChild(canvas);\n    element.style.position = \"relative\";\n    canvas.style.position = \"absolute\";\n    canvas.style.left = \"0\";\n    canvas.style.right = \"0\";\n    canvas.style.top = \"0\";\n    canvas.style.bottom = \"0\";\n  }\n\n  abstract drawIndirect(): void;\n\n  draw() {\n    this.drawIndirect();\n    const { renderViewport, canvas } = this;\n    const { logicalWidth, logicalHeight } = renderViewport;\n    canvas.width = logicalWidth;\n    canvas.height = logicalHeight;\n    const { canvasRenderingContext } = this;\n    canvasRenderingContext?.drawImage(\n      this.context.canvas,\n      this.canvasRelativeLogicalLeft,\n      this.canvasRelativeLogicalTop,\n      logicalWidth,\n      logicalHeight,\n      0,\n      0,\n      logicalWidth,\n      logicalHeight,\n    );\n  }\n}\n\n// Specifies a rectangular sub-region of the full viewer area to actually be rendered on the canvas.\n// This is used by the Python integration to produce large screenshots by tiling multiple\n// screenshots.\n//\n// The value is: `[left, top, width, height]` where all values are in [0, 1].\nexport class TrackableWindowedViewport extends TrackableValue<Float64Array> {\n  constructor() {\n    super(Float64Array.of(0, 0, 1, 1), (obj) =>\n      parseFixedLengthArray(new Float64Array(4), obj, verifyFloat01),\n    );\n  }\n  toJSON() {\n    const { value } = this;\n    const [left, top, width, height] = value;\n    if (left === 0 && top === 0 && width === 1 && height === 1)\n      return undefined;\n    return Array.from(value);\n  }\n}\n\n// Size/position monitoring state for a single panel.\ninterface PanelMonitorState {\n  // Intersection observer used to detect movement of a panel.  The root element is always the root\n  // container element.\n  intersectionObserver?: IntersectionObserver;\n\n  // Margin within the root element chosen to exactly match the bounds\n  // of the panel element when the IntersectionObserver was created.\n  // When the bounds of either the root element or the panel element\n  // have possibly changed, the new margin is computed and compared to\n  // this value.  This is stored separately, rather than just relying\n  // on `intersectionObserver?.rootMargin`, to avoid spuriously change\n  // detections due to normalization that the browser may do.\n  intersectionObserverMargin?: string;\n\n  // Indicates that the element is intersecting the viewport at all. If `true`,\n  // then the intersection observer margin is set normally to detect any\n  // changes. If `false`, then the intersection observer margin is set to cover\n  // the entire viewport in order to detect when the panel becomes visible\n  // again.\n  isIntersecting: boolean;\n\n  // Indicates that the panel element was added to the resize observer.\n  addedToResizeObserver?: boolean;\n}\n\nexport class DisplayContext extends RefCounted implements FrameNumberCounter {\n  canvas = document.createElement(\"canvas\");\n  gl: GL;\n  updateStarted = new NullarySignal();\n  updateFinished = new NullarySignal();\n  continuousCameraMotionStarted = new NullarySignal();\n  continuousCameraMotionFinished = new NullarySignal();\n  changed = this.updateFinished;\n  panels = new Set<RenderedPanel>();\n  canvasRect: DOMRect | undefined;\n  rootRect: DOMRect | undefined;\n  resizeGeneration = 0;\n  boundsGeneration = -1;\n  force3DHistogramForAutoRange = false;\n  private framerateMonitor = new FramerateMonitor();\n\n  private continuousCameraMotionInProgress = false;\n\n  // Panels ordered by `drawOrder`.  If length is 0, needs to be recomputed.\n  private orderedPanels: RenderedPanel[] = [];\n\n  /**\n   * Unique number of the next frame.  Incremented once each time a frame is drawn.\n   */\n  frameNumber = 0;\n\n  resizeCallback = () => {\n    ++this.resizeGeneration;\n    this.scheduleRedraw();\n  };\n\n  ensureMonitorPanel(\n    element: HTMLElement,\n    state: PanelMonitorState,\n    elementClientRect: DOMRect,\n  ) {\n    if (!state.addedToResizeObserver) {\n      this.resizeObserver.observe(element);\n      state.addedToResizeObserver = true;\n    }\n    let margin: string;\n    if (state.isIntersecting) {\n      const rootRect = this.rootRect!;\n      const marginTop = rootRect.top - elementClientRect.top;\n      const marginLeft = rootRect.left - elementClientRect.left;\n      const marginRight = elementClientRect.right - rootRect.right;\n      const marginBottom = elementClientRect.bottom - rootRect.bottom;\n      margin = `${marginTop}px ${marginRight}px ${marginBottom}px ${marginLeft}px`;\n    } else {\n      margin = \"\";\n    }\n    if (state.intersectionObserverMargin !== margin) {\n      state.intersectionObserverMargin = margin;\n      state.intersectionObserver?.disconnect();\n      const thresholds = new Array(101);\n      for (let i = 0; i <= 100; ++i) {\n        thresholds[i] = 0.01 * i;\n      }\n      const intersectionObserver = (state.intersectionObserver =\n        new IntersectionObserver(\n          (entries) => {\n            const lastEntry = entries[entries.length - 1];\n            state.isIntersecting = lastEntry.isIntersecting;\n            this.resizeCallback();\n          },\n          {\n            root: this.container,\n            rootMargin: margin,\n            threshold: thresholds,\n          },\n        ));\n      intersectionObserver.observe(element);\n    }\n  }\n\n  unmonitorPanel(element: HTMLElement, state: PanelMonitorState) {\n    if (state.addedToResizeObserver) {\n      this.resizeObserver.unobserve(element);\n    }\n    state.intersectionObserver?.disconnect();\n  }\n\n  private resizeObserver = new ResizeObserver(this.resizeCallback);\n\n  private debouncedEndContinuousCameraMotion = this.registerCancellable(\n    debounce(() => {\n      this.continuousCameraMotionInProgress = false;\n      this.continuousCameraMotionFinished.dispatch();\n    }, DELAY_AFTER_CONTINUOUS_CAMERA_MOTION_MS),\n  );\n\n  flagContinuousCameraMotion() {\n    if (!this.continuousCameraMotionInProgress) {\n      this.continuousCameraMotionStarted.dispatch();\n    }\n    this.continuousCameraMotionInProgress = true;\n    this.debouncedEndContinuousCameraMotion();\n  }\n\n  get isContinuousCameraMotionInProgress() {\n    return this.continuousCameraMotionInProgress;\n  }\n\n  constructor(public container: HTMLElement) {\n    super();\n    const { canvas, resizeObserver } = this;\n    container.style.position = \"relative\";\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0px\";\n    canvas.style.left = \"0px\";\n    canvas.style.width = \"100%\";\n    canvas.style.height = \"100%\";\n    canvas.style.zIndex = \"0\";\n    resizeObserver.observe(canvas);\n    container.appendChild(canvas);\n    this.registerEventListener(\n      canvas,\n      \"webglcontextlost\",\n      (event: WebGLContextEvent) => {\n        console.log(`Lost WebGL context: ${event.statusMessage}`);\n        // Wait for context to be regained.\n        event.preventDefault();\n      },\n    );\n    this.registerEventListener(canvas, \"webglcontextrestored\", () => {\n      console.log(\"WebGL context restored\");\n      // Simply reload Neuroglancer.\n      window.location.reload();\n    });\n    this.gl = initializeWebGL(canvas);\n  }\n\n  applyWindowedViewportToElement(element: HTMLElement, value: Float64Array) {\n    // These values specify the position of the canvas relative to the viewer.  However, we will\n    // actually leave the canvas in place (such that it still fills the browser window) and move\n    // the viewer.\n    const [left, top, width, height] = value;\n    const totalWidth = 1 / width;\n    const totalHeight = 1 / height;\n    element.style.position = \"absolute\";\n    element.style.top = `${-totalHeight * top * 100}%`;\n    element.style.left = `${-totalWidth * left * 100}%`;\n    element.style.width = `${totalWidth * 100}%`;\n    element.style.height = `${totalHeight * 100}%`;\n    ++this.resizeGeneration;\n    this.scheduleRedraw();\n  }\n\n  isReady() {\n    for (const panel of this.panels) {\n      if (!panel.visible) {\n        continue;\n      }\n      if (!panel.isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns a child element that overlays the canvas.\n   */\n  makeCanvasOverlayElement() {\n    const element = document.createElement(\"div\");\n    element.style.position = \"absolute\";\n    element.style.top = \"0px\";\n    element.style.left = \"0px\";\n    element.style.width = \"100%\";\n    element.style.height = \"100%\";\n    element.style.zIndex = \"2\";\n    this.container.appendChild(element);\n    return element;\n  }\n\n  disposed() {\n    this.orderedPanels.length = 0;\n    this.resizeObserver.disconnect();\n  }\n\n  addPanel(panel: Borrowed<RenderedPanel>) {\n    this.panels.add(panel);\n    this.orderedPanels.length = 0;\n    ++this.resizeGeneration;\n    this.scheduleRedraw();\n  }\n\n  removePanel(panel: Borrowed<RenderedPanel>) {\n    this.panels.delete(panel);\n    this.orderedPanels.length = 0;\n    ++this.resizeGeneration;\n    this.scheduleRedraw();\n  }\n\n  readonly scheduleRedraw = this.registerCancellable(\n    animationFrameDebounce(() => this.draw()),\n  );\n\n  ensureBoundsUpdated() {\n    const { resizeGeneration } = this;\n    if (this.boundsGeneration === resizeGeneration) return;\n    const { canvas } = this;\n    canvas.width = canvas.offsetWidth;\n    canvas.height = canvas.offsetHeight;\n    this.canvasRect = canvas.getBoundingClientRect();\n    this.rootRect = this.container.getBoundingClientRect();\n    this.boundsGeneration = resizeGeneration;\n  }\n\n  draw() {\n    ++this.frameNumber;\n    this.updateStarted.dispatch();\n    const gl = this.gl;\n    const ext = this.framerateMonitor.getTimingExtension(gl);\n    this.framerateMonitor.startFrameTimeQuery(gl, ext, this.frameNumber);\n    this.ensureBoundsUpdated();\n    this.gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    const { orderedPanels, panels } = this;\n    if (orderedPanels.length !== panels.size) {\n      orderedPanels.push(...panels);\n      orderedPanels.sort((a, b) => a.drawOrder - b.drawOrder);\n    }\n    for (const panel of orderedPanels) {\n      if (!panel.shouldDraw) continue;\n      panel.ensureBoundsUpdated();\n      const { renderViewport } = panel;\n      if (renderViewport.width === 0 || renderViewport.height === 0) continue;\n      panel.draw();\n    }\n\n    // Ensure the alpha buffer is set to 1.\n    gl.disable(gl.SCISSOR_TEST);\n    this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n    this.gl.colorMask(false, false, false, true);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    this.gl.colorMask(true, true, true, true);\n    this.updateFinished.dispatch();\n    this.framerateMonitor.endLastTimeQuery(gl, ext);\n    this.framerateMonitor.grabAnyFinishedQueryResults(gl);\n  }\n\n  getDepthArray(): Float32Array {\n    const { width, height } = this.canvas;\n    const depthArray = new Float32Array(width * height);\n    for (const panel of this.panels) {\n      if (!panel.shouldDraw) continue;\n      const panelDepthArray = panel.getDepthArray();\n      if (panelDepthArray === undefined) continue;\n      const {\n        canvasRelativeClippedTop,\n        canvasRelativeClippedLeft,\n        renderViewport: { width, height },\n      } = panel;\n      for (let y = 0; y < height; ++y) {\n        const panelDepthArrayOffset = (height - 1 - y) * width;\n        depthArray.set(\n          panelDepthArray.subarray(\n            panelDepthArrayOffset,\n            panelDepthArrayOffset + width,\n          ),\n          (canvasRelativeClippedTop + y) * width + canvasRelativeClippedLeft,\n        );\n      }\n    }\n    return depthArray;\n  }\n\n  getLastFrameTimesInMs(numberOfFrames: number = 10) {\n    return this.framerateMonitor.getLastFrameTimesInMs(numberOfFrames);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  CoordinateSpace,\n  CoordinateSpaceTransform,\n} from \"#src/coordinate_transform.js\";\nimport {\n  emptyValidCoordinateSpace,\n  homogeneousTransformSubmatrix,\n} from \"#src/coordinate_transform.js\";\nimport type { DisplayDimensionRenderInfo } from \"#src/navigation_state.js\";\nimport type {\n  CachedWatchableValue,\n  WatchableValueInterface,\n} from \"#src/trackable_value.js\";\nimport {\n  constantWatchableValue,\n  makeCachedDerivedWatchableValue,\n} from \"#src/trackable_value.js\";\nimport { arraysEqual, scatterUpdate } from \"#src/util/array.js\";\nimport type { ValueOrError } from \"#src/util/error.js\";\nimport type { vec3 } from \"#src/util/geom.js\";\nimport { mat4, getDependentTransformInputDimensions } from \"#src/util/geom.js\";\nimport * as matrix from \"#src/util/matrix.js\";\nimport * as vector from \"#src/util/vector.js\";\nimport { prod } from \"#src/util/vector.js\";\n\n/**\n * Specifies coordinate transform information for a RenderLayer.\n */\nexport interface RenderLayerTransform {\n  /**\n   * Rank of chunk/model/layer subspace used by this RenderLayer, including any additional `[0,1)`\n   * padding dimensions.\n   */\n  rank: number;\n\n  /**\n   * Rank of chunk/model/layer space, excluding any padding dimensions.\n   */\n  unpaddedRank: number;\n\n  /**\n   * Specifies for each local user layer dimension the corresponding \"render layer\" dimension.  A\n   * value of `-1` indicates there is no corresponding \"render layer\" dimension.  The combined\n   * values of `localToRenderLayerDimensions` and `globalToRenderLayerDimensions` that are not `-1`\n   * must be distinct and partition `[0, ..., rank)`, where `rank` is the rank of the \"model\"\n   * coordinate space.\n   */\n  localToRenderLayerDimensions: readonly number[];\n\n  /**\n   * Specifies for each global dimension the corresponding \"render layer\" dimension.  A value of\n   * `-1` indicates there is no corresponding \"render layer\" dimension.\n   */\n  globalToRenderLayerDimensions: readonly number[];\n\n  /**\n   * Specifies for each channel dimension the corresponding \"render layer\" dimension.  A value of\n   * `-1` indicates there is no corresponding \"render layer\" dimension.\n   */\n  channelToRenderLayerDimensions: readonly number[];\n\n  channelToModelDimensions: readonly number[];\n\n  channelSpaceShape: Uint32Array;\n\n  /**\n   * Homogeneous transform from \"model\" coordinate space to \"render layer\" coordinate space.\n   */\n  modelToRenderLayerTransform: Float32Array;\n\n  modelDimensionNames: readonly string[];\n  layerDimensionNames: readonly string[];\n}\n\nexport interface ChannelSpace {\n  channelCoordinateSpace: CoordinateSpace;\n  // Shape of multi-dimensional channel space.\n  shape: Uint32Array;\n  // Total number of channels, equal to product of `shape`.\n  numChannels: number;\n  // Row-major array of shape `[count, rank]` specifying the coordinates for each flattened channel.\n  // Channels are ordered in Fortran order.\n  coordinates: Uint32Array;\n}\n\nexport const zeroRankChannelSpace: ChannelSpace = {\n  channelCoordinateSpace: emptyValidCoordinateSpace,\n  shape: new Uint32Array(0),\n  numChannels: 1,\n  coordinates: new Uint32Array(0),\n};\n\nexport function getChannelSpace(\n  channelCoordinateSpace: CoordinateSpace,\n): ChannelSpace {\n  const { rank } = channelCoordinateSpace;\n  const {\n    bounds: { lowerBounds, upperBounds },\n  } = channelCoordinateSpace;\n  if (lowerBounds.some((x) => x !== 0)) {\n    throw new Error(\"Lower bounds of channel coordinate space must all be 0\");\n  }\n  if (upperBounds.some((x) => !Number.isInteger(x) || x <= 0 || x >= 2 ** 32)) {\n    throw new Error(\n      \"Upper bounds of channel coordinate space must all be positive integers\",\n    );\n  }\n  const shape = new Uint32Array(upperBounds);\n  const numChannels = prod(shape);\n  const coordinates = new Uint32Array(numChannels * rank);\n  for (let flatIndex = 0; flatIndex < numChannels; ++flatIndex) {\n    let remainder = flatIndex;\n    for (let dim = 0; dim < rank; ++dim) {\n      const coordinate = remainder % shape[dim];\n      remainder = (remainder - coordinate) / shape[dim];\n      coordinates[flatIndex * rank + dim] = coordinate;\n    }\n  }\n  return { channelCoordinateSpace, shape, numChannels, coordinates };\n}\n\nexport type RenderLayerTransformOrError = ValueOrError<RenderLayerTransform>;\nexport type WatchableRenderLayerTransform =\n  WatchableValueInterface<RenderLayerTransformOrError>;\n\nfunction scaleTransformSubmatrix(\n  transform: Float32Array,\n  rank: number,\n  baseInputSpace: CoordinateSpace,\n  inputToBaseDimensions: readonly number[],\n  baseOutputSpace: CoordinateSpace,\n  baseToOutputDimensions: readonly number[],\n) {\n  const { scales: baseInputScales } = baseInputSpace;\n  const { scales: baseOutputScales, rank: baseOutputRank } = baseOutputSpace;\n  const stride = rank + 1;\n  for (let baseOutputDim = 0; baseOutputDim < baseOutputRank; ++baseOutputDim) {\n    const outputDim = baseToOutputDimensions[baseOutputDim];\n    if (outputDim === -1) continue;\n    const baseOutputScale = baseOutputScales[baseOutputDim];\n    for (let inputDim = 0; inputDim < rank; ++inputDim) {\n      const baseInputDim = inputToBaseDimensions[inputDim];\n      const baseInputScale = baseInputScales[baseInputDim];\n      transform[stride * inputDim + outputDim] *=\n        baseInputScale / baseOutputScale;\n    }\n  }\n}\n\nexport function getRenderLayerTransform(\n  globalCoordinateSpace: CoordinateSpace,\n  localCoordinateSpace: CoordinateSpace,\n  modelToLayerTransform: CoordinateSpaceTransform,\n  subsourceEntry:\n    | {\n        subsourceToModelSubspaceTransform: Float32Array;\n        modelSubspaceDimensionIndices: readonly number[];\n      }\n    | undefined,\n  channelCoordinateSpace: CoordinateSpace = emptyValidCoordinateSpace,\n): RenderLayerTransformOrError {\n  const {\n    inputSpace: modelSpace,\n    rank: fullRank,\n    sourceRank,\n    outputSpace: layerSpace,\n    transform: oldTransform,\n  } = modelToLayerTransform;\n  const { names: modelDimensionNames } = modelSpace;\n  const { names: transformOutputDimensions } = layerSpace;\n  let requiredInputDims: number[];\n  if (subsourceEntry !== undefined) {\n    requiredInputDims = Array.from(\n      subsourceEntry.modelSubspaceDimensionIndices,\n    );\n  } else {\n    requiredInputDims = [];\n    for (let i = 0; i < sourceRank; ++i) {\n      requiredInputDims[i] = i;\n    }\n  }\n  const unpaddedRank = requiredInputDims.length;\n  for (let i = sourceRank; i < fullRank; ++i) {\n    requiredInputDims.push(i);\n  }\n  const requiredOutputDims = getDependentTransformInputDimensions(\n    modelToLayerTransform.transform,\n    fullRank,\n    requiredInputDims,\n    true,\n  );\n  const subspaceRank = requiredInputDims.length;\n  const modelSubspaceDimensionNames = requiredInputDims.map(\n    (i) => modelDimensionNames[i] || `${i}`,\n  );\n  const layerSubspaceDimensionNames = requiredOutputDims.map(\n    (i) => transformOutputDimensions[i],\n  );\n  if (subspaceRank !== requiredOutputDims.length) {\n    return {\n      error:\n        \"Rank mismatch between model subspace dimensions (\" +\n        modelSubspaceDimensionNames.join(\", \") +\n        \") and corresponding layer/global dimensions (\" +\n        layerSubspaceDimensionNames.join(\", \") +\n        \")\",\n    };\n  }\n  let newTransform = homogeneousTransformSubmatrix(\n    Float32Array,\n    oldTransform,\n    fullRank,\n    requiredOutputDims,\n    requiredInputDims,\n  );\n  const renderLayerDimensions = requiredOutputDims.map(\n    (i) => transformOutputDimensions[i],\n  );\n  const localToRenderLayerDimensions = localCoordinateSpace.names.map((x) =>\n    renderLayerDimensions.indexOf(x),\n  );\n  const globalToRenderLayerDimensions = globalCoordinateSpace.names.map((x) =>\n    renderLayerDimensions.indexOf(x),\n  );\n  scaleTransformSubmatrix(\n    newTransform,\n    subspaceRank,\n    modelSpace,\n    requiredInputDims,\n    globalCoordinateSpace,\n    globalToRenderLayerDimensions,\n  );\n  scaleTransformSubmatrix(\n    newTransform,\n    subspaceRank,\n    modelSpace,\n    requiredInputDims,\n    localCoordinateSpace,\n    localToRenderLayerDimensions,\n  );\n  const channelToRenderLayerDimensions = channelCoordinateSpace.names.map((x) =>\n    renderLayerDimensions.indexOf(x),\n  );\n  scaleTransformSubmatrix(\n    newTransform,\n    subspaceRank,\n    modelSpace,\n    requiredInputDims,\n    channelCoordinateSpace,\n    channelToRenderLayerDimensions,\n  );\n  const channelToModelSubspaceDimensions: number[] = [];\n  const channelRank = channelCoordinateSpace.rank;\n  if (subsourceEntry !== undefined) {\n    let { subsourceToModelSubspaceTransform } = subsourceEntry;\n    if (unpaddedRank !== subspaceRank) {\n      subsourceToModelSubspaceTransform = matrix.extendHomogeneousTransform(\n        new Float32Array((subspaceRank + 1) ** 2),\n        subspaceRank,\n        subsourceToModelSubspaceTransform,\n        unpaddedRank,\n      );\n    }\n    newTransform = matrix.multiply(\n      new Float32Array((subspaceRank + 1) ** 2),\n      subspaceRank + 1,\n      newTransform,\n      subspaceRank + 1,\n      subsourceToModelSubspaceTransform,\n      subspaceRank + 1,\n      subspaceRank + 1,\n      subspaceRank + 1,\n      subspaceRank + 1,\n    ) as Float32Array<ArrayBuffer>;\n  }\n  const channelSpaceShape = new Uint32Array(channelRank);\n  const {\n    lowerBounds: channelLowerBounds,\n    upperBounds: channelUpperBounds,\n    voxelCenterAtIntegerCoordinates: channelVoxelCenterAtIntegerCoordinates,\n  } = channelCoordinateSpace.bounds;\n  for (let channelDim = 0; channelDim < channelRank; ++channelDim) {\n    let lower = channelLowerBounds[channelDim];\n    let upper = channelUpperBounds[channelDim];\n    if (channelVoxelCenterAtIntegerCoordinates[channelDim]) {\n      lower += 0.5;\n      upper += 0.5;\n    }\n    if (\n      lower !== 0 ||\n      !Number.isInteger(upper) ||\n      upper <= 0 ||\n      upper >= 2 ** 32\n    ) {\n      return {\n        error:\n          `Channel dimension ${channelCoordinateSpace.names[channelDim]} must have ` +\n          `lower bound of 0 and positive integer upper bound; current bounds are [${lower}, ${upper}]`,\n      };\n    }\n    channelSpaceShape[channelDim] = upper;\n    const layerDim = channelToRenderLayerDimensions[channelDim];\n    let correspondingModelSubspaceDim = -1;\n    if (layerDim !== -1) {\n      for (let chunkDim = 0; chunkDim < subspaceRank; ++chunkDim) {\n        const coeff = newTransform[layerDim + chunkDim * (subspaceRank + 1)];\n        if (coeff === 0) continue;\n        if (coeff !== 1 || correspondingModelSubspaceDim !== -1) {\n          return {\n            error:\n              `Channel dimension ${layerSubspaceDimensionNames[layerDim]} ` +\n              \"must map to a single source dimension\",\n          };\n        }\n        correspondingModelSubspaceDim = chunkDim;\n      }\n    }\n    channelToModelSubspaceDimensions[channelDim] =\n      correspondingModelSubspaceDim;\n  }\n  return {\n    rank: subspaceRank,\n    unpaddedRank,\n    modelDimensionNames: modelSubspaceDimensionNames,\n    layerDimensionNames: layerSubspaceDimensionNames,\n    localToRenderLayerDimensions,\n    globalToRenderLayerDimensions,\n    channelToRenderLayerDimensions,\n    modelToRenderLayerTransform: newTransform,\n    channelToModelDimensions: channelToModelSubspaceDimensions,\n    channelSpaceShape,\n  };\n}\n\nexport function renderLayerTransformsEqual(\n  a: RenderLayerTransformOrError,\n  b: RenderLayerTransformOrError,\n) {\n  if (a === b) return true;\n  if (a.error !== undefined || b.error !== undefined) return false;\n  return (\n    arraysEqual(a.modelDimensionNames, b.modelDimensionNames) &&\n    arraysEqual(a.layerDimensionNames, b.layerDimensionNames) &&\n    arraysEqual(\n      a.globalToRenderLayerDimensions,\n      b.globalToRenderLayerDimensions,\n    ) &&\n    arraysEqual(\n      a.localToRenderLayerDimensions,\n      b.localToRenderLayerDimensions,\n    ) &&\n    arraysEqual(\n      a.channelToRenderLayerDimensions,\n      b.channelToRenderLayerDimensions,\n    ) &&\n    arraysEqual(a.modelToRenderLayerTransform, b.modelToRenderLayerTransform) &&\n    arraysEqual(a.channelSpaceShape, b.channelSpaceShape)\n  );\n}\n\nexport function getWatchableRenderLayerTransform(\n  globalCoordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  localCoordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  modelToLayerTransform: WatchableValueInterface<CoordinateSpaceTransform>,\n  subsourceEntry:\n    | {\n        subsourceToModelSubspaceTransform: Float32Array;\n        modelSubspaceDimensionIndices: readonly number[];\n      }\n    | undefined,\n  channelCoordinateSpace?: WatchableValueInterface<CoordinateSpace | undefined>,\n): CachedWatchableValue<RenderLayerTransformOrError> {\n  return makeCachedDerivedWatchableValue(\n    (\n      globalCoordinateSpace: CoordinateSpace,\n      localCoordinateSpace: CoordinateSpace,\n      modelToLayerTransform: CoordinateSpaceTransform,\n      channelCoordinateSpace: CoordinateSpace | undefined,\n    ) =>\n      getRenderLayerTransform(\n        globalCoordinateSpace,\n        localCoordinateSpace,\n        modelToLayerTransform,\n        subsourceEntry,\n        channelCoordinateSpace,\n      ),\n    [\n      globalCoordinateSpace,\n      localCoordinateSpace,\n      modelToLayerTransform,\n      channelCoordinateSpace === undefined\n        ? constantWatchableValue(undefined)\n        : channelCoordinateSpace,\n    ],\n    renderLayerTransformsEqual,\n  );\n}\n\nexport interface LayerDisplayDimensionMapping {\n  /**\n   * List of indices of layer dimensions that correspond to display dimensions.\n   */\n  layerDisplayDimensionIndices: number[];\n\n  /**\n   * Maps each display dimension index to the corresponding layer dimension index, or `-1`.\n   */\n  displayToLayerDimensionIndices: number[];\n}\n\nexport interface ChunkChannelAccessParameters {\n  channelSpaceShape: Uint32Array;\n\n  /**\n   * Equal to the values in `channelToChunkDimensionIndices` not equal to `-1`.\n   */\n  chunkChannelDimensionIndices: readonly number[];\n\n  /**\n   * Product of `modelTransform.channelSpaceShape`.\n   */\n  numChannels: number;\n\n  /**\n   * Row-major array of shape `[numChannels, chunkChannelDimensionIndices.length]`, specifies the\n   * coordinates within the chunk channel dimensions corresponding to each flat channel index.\n   */\n  chunkChannelCoordinates: Uint32Array;\n}\n\nexport interface ChunkTransformParameters extends ChunkChannelAccessParameters {\n  modelTransform: RenderLayerTransform;\n  chunkToLayerTransform: Float32Array;\n  layerToChunkTransform: Float32Array;\n  chunkToLayerTransformDet: number;\n  /**\n   * Maps channel dimension indices in the layer channel coordinate space to the corresponding chunk\n   * dimension index, or `-1` if there is no correpsonding chunk dimension.\n   */\n  channelToChunkDimensionIndices: readonly number[];\n  combinedGlobalLocalToChunkTransform: Float32Array;\n  combinedGlobalLocalRank: number;\n  layerRank: number;\n}\n\nexport function layerToDisplayCoordinates(\n  displayPosition: vec3,\n  layerPosition: Float32Array,\n  modelTransform: RenderLayerTransform,\n  displayDimensionIndices: Int32Array,\n) {\n  const { globalToRenderLayerDimensions } = modelTransform;\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    let v = 0;\n    const globalDim = displayDimensionIndices[displayDim];\n    if (globalDim !== -1) {\n      const layerDim = globalToRenderLayerDimensions[globalDim];\n      if (layerDim !== -1) {\n        v = layerPosition[layerDim];\n      }\n    }\n    displayPosition[displayDim] = v;\n  }\n}\n\nexport function displayToLayerCoordinates(\n  layerPosition: Float32Array,\n  displayPosition: vec3,\n  modelTransform: RenderLayerTransform,\n  displayDimensionIndices: Int32Array,\n) {\n  const { globalToRenderLayerDimensions } = modelTransform;\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    const globalDim = displayDimensionIndices[displayDim];\n    if (globalDim !== -1) {\n      const layerDim = globalToRenderLayerDimensions[globalDim];\n      if (layerDim !== -1) {\n        layerPosition[layerDim] = displayPosition[displayDim];\n      }\n    }\n  }\n}\n\nexport function chunkToDisplayCoordinates(\n  displayPosition: vec3,\n  chunkPosition: Float32Array,\n  chunkTransform: ChunkTransformParameters,\n  displayDimensionIndices: Int32Array,\n): vec3 {\n  const { globalToRenderLayerDimensions } = chunkTransform.modelTransform;\n  const { layerRank, chunkToLayerTransform } = chunkTransform;\n  const stride = layerRank + 1;\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    let sum = 0;\n    const globalDim = displayDimensionIndices[displayDim];\n    if (globalDim !== -1) {\n      const layerDim = globalToRenderLayerDimensions[globalDim];\n      if (layerDim !== -1) {\n        sum = chunkToLayerTransform[stride * layerRank + layerDim];\n        for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {\n          sum +=\n            chunkToLayerTransform[stride * chunkDim + layerDim] *\n            chunkPosition[chunkDim];\n        }\n      }\n    }\n    displayPosition[displayDim] = sum;\n  }\n  return displayPosition;\n}\n\nexport interface ChunkDisplayTransformParameters {\n  modelTransform: RenderLayerTransform;\n  chunkTransform: ChunkTransformParameters;\n  displaySubspaceModelMatrix: mat4;\n  displaySubspaceInvModelMatrix: mat4;\n  chunkDisplayDimensionIndices: number[];\n  numChunkDisplayDims: number;\n}\n\nexport function getChunkTransformParameters(\n  modelTransform: RenderLayerTransform,\n  chunkToModelTransform?: Float32Array,\n): ChunkTransformParameters {\n  const layerRank = modelTransform.rank;\n  const unpaddedRank = modelTransform.unpaddedRank;\n  let chunkToLayerTransform: Float32Array;\n  if (unpaddedRank !== layerRank && chunkToModelTransform !== undefined) {\n    chunkToModelTransform = matrix.extendHomogeneousTransform(\n      new Float32Array((layerRank + 1) ** 2),\n      layerRank,\n      chunkToModelTransform,\n      unpaddedRank,\n    );\n  }\n  if (chunkToModelTransform !== undefined) {\n    chunkToLayerTransform = new Float32Array((layerRank + 1) * (layerRank + 1));\n    matrix.multiply(\n      chunkToLayerTransform,\n      layerRank + 1,\n      modelTransform.modelToRenderLayerTransform,\n      layerRank + 1,\n      chunkToModelTransform,\n      layerRank + 1,\n      layerRank + 1,\n      layerRank + 1,\n      layerRank + 1,\n    );\n  } else {\n    chunkToLayerTransform = modelTransform.modelToRenderLayerTransform;\n  }\n  const layerToChunkTransform = new Float32Array(\n    (layerRank + 1) * (layerRank + 1),\n  );\n  const det = matrix.inverse(\n    layerToChunkTransform,\n    layerRank + 1,\n    chunkToLayerTransform,\n    layerRank + 1,\n    layerRank + 1,\n  );\n  if (det === 0) {\n    throw new Error(\"Transform is singular\");\n  }\n  const {\n    globalToRenderLayerDimensions,\n    localToRenderLayerDimensions,\n    channelToRenderLayerDimensions,\n  } = modelTransform;\n  const globalRank = globalToRenderLayerDimensions.length;\n  const localRank = localToRenderLayerDimensions.length;\n  const combinedGlobalLocalRank = globalRank + localRank;\n\n  // Compute `combinedGlobalLocalToChunkTransform`.\n  const combinedGlobalLocalToChunkTransform = new Float32Array(\n    (combinedGlobalLocalRank + 1) * layerRank,\n  );\n  for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {\n    for (let globalDim = 0; globalDim < globalRank; ++globalDim) {\n      const layerDim = globalToRenderLayerDimensions[globalDim];\n      if (layerDim === -1) continue;\n      combinedGlobalLocalToChunkTransform[chunkDim + globalDim * layerRank] =\n        layerToChunkTransform[chunkDim + layerDim * (layerRank + 1)];\n    }\n    for (let localDim = 0; localDim < localRank; ++localDim) {\n      const layerDim = localToRenderLayerDimensions[localDim];\n      if (layerDim === -1) continue;\n      combinedGlobalLocalToChunkTransform[\n        chunkDim + (globalRank + localDim) * layerRank\n      ] = layerToChunkTransform[chunkDim + layerDim * (layerRank + 1)];\n    }\n    combinedGlobalLocalToChunkTransform[\n      chunkDim + combinedGlobalLocalRank * layerRank\n    ] = layerToChunkTransform[chunkDim + layerRank * (layerRank + 1)];\n  }\n\n  const channelRank = channelToRenderLayerDimensions.length;\n  const channelToChunkDimensionIndices = new Array<number>(channelRank);\n  const chunkChannelDimensionIndices: number[] = [];\n  for (let channelDim = 0; channelDim < channelRank; ++channelDim) {\n    const layerDim = channelToRenderLayerDimensions[channelDim];\n    let correspondingChunkDim = -1;\n    if (layerDim !== -1) {\n      for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {\n        const coeff =\n          chunkToLayerTransform[layerDim + chunkDim * (layerRank + 1)];\n        if (coeff === 0) continue;\n        if (coeff !== 1 || correspondingChunkDim !== -1) {\n          throw new Error(\n            `Channel dimension ${modelTransform.layerDimensionNames[layerDim]} ` +\n              \"must map with stride 1 to a single data chunk dimensions\",\n          );\n        }\n        correspondingChunkDim = chunkDim;\n      }\n      if (correspondingChunkDim !== -1) {\n        const offset =\n          chunkToLayerTransform[layerDim + layerRank * (layerRank + 1)];\n        if (offset !== 0 && offset !== -0.5) {\n          throw new Error(\n            `Channel dimension ${modelTransform.layerDimensionNames[layerDim]} ` +\n              `must have an offset of 0 in the chunk coordinate space; current offset is ${offset}`,\n          );\n        }\n        chunkChannelDimensionIndices.push(correspondingChunkDim);\n      }\n    }\n    channelToChunkDimensionIndices[channelDim] = correspondingChunkDim;\n  }\n  const { channelSpaceShape } = modelTransform;\n  const numChannels = vector.prod(channelSpaceShape);\n  const chunkChannelRank = chunkChannelDimensionIndices.length;\n  const chunkChannelCoordinates = new Uint32Array(\n    numChannels * chunkChannelRank,\n  );\n  for (let channelIndex = 0; channelIndex < numChannels; ++channelIndex) {\n    let remainder = channelIndex;\n    let chunkChannelDim = 0;\n    for (let channelDim = 0; channelDim < channelRank; ++channelDim) {\n      const coordinate = remainder % channelSpaceShape[channelDim];\n      remainder = (remainder - coordinate) / channelSpaceShape[channelDim];\n      const chunkDim = channelToChunkDimensionIndices[channelDim];\n      if (chunkDim !== -1) {\n        chunkChannelCoordinates[\n          channelIndex * chunkChannelRank + chunkChannelDim\n        ] = coordinate;\n        ++chunkChannelDim;\n      }\n    }\n  }\n  return {\n    layerRank: layerRank,\n    modelTransform,\n    chunkToLayerTransform,\n    layerToChunkTransform,\n    chunkToLayerTransformDet: det,\n    combinedGlobalLocalRank,\n    combinedGlobalLocalToChunkTransform,\n    channelToChunkDimensionIndices,\n    chunkChannelDimensionIndices,\n    numChannels,\n    chunkChannelCoordinates,\n    channelSpaceShape,\n  };\n}\n\nexport function getLayerDisplayDimensionMapping(\n  transform: RenderLayerTransform,\n  displayDimensionIndices: Int32Array,\n): LayerDisplayDimensionMapping {\n  const { globalToRenderLayerDimensions } = transform;\n\n  // List of layer dimension indices corresponding to global display dimensions.\n  const layerDisplayDimensionIndices: number[] = [];\n\n  // Maps global display dimension (in {0, 1, 2}) to the corresponding layer dimension index, or\n  // `-1`.\n  const displayToLayerDimensionIndices: number[] = [];\n\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    const globalDim = displayDimensionIndices[displayDim];\n    if (globalDim === -1) continue;\n    const layerDim = globalToRenderLayerDimensions[globalDim];\n    displayToLayerDimensionIndices.push(layerDim);\n    if (layerDim === -1) continue;\n    layerDisplayDimensionIndices.push(layerDim);\n  }\n  for (let i = displayToLayerDimensionIndices.length; i < 3; ++i) {\n    displayToLayerDimensionIndices[i] = -1;\n  }\n  return { layerDisplayDimensionIndices, displayToLayerDimensionIndices };\n}\n\nexport function getChunkDisplayTransformParameters(\n  chunkTransform: ChunkTransformParameters,\n  layerDisplayDimensionMapping: LayerDisplayDimensionMapping,\n): ChunkDisplayTransformParameters {\n  const { chunkToLayerTransform, modelTransform } = chunkTransform;\n  const rank = modelTransform.rank;\n  const { layerDisplayDimensionIndices, displayToLayerDimensionIndices } =\n    layerDisplayDimensionMapping;\n  const numLayerDisplayDims = layerDisplayDimensionIndices.length;\n  const chunkDisplayDimensionIndices = getDependentTransformInputDimensions(\n    chunkToLayerTransform,\n    rank,\n    layerDisplayDimensionIndices,\n  );\n  if (chunkDisplayDimensionIndices.length !== numLayerDisplayDims) {\n    const { modelDimensionNames, layerDimensionNames } = modelTransform;\n    throw new Error(\n      \"Rank mismatch between displayed layer dimensions \" +\n        `(${Array.from(\n          layerDisplayDimensionIndices,\n          (i) => layerDimensionNames[i],\n        ).join(\",\\u00a0\")}) ` +\n        \"and corresponding chunk dimensions \" +\n        `(${Array.from(\n          chunkDisplayDimensionIndices,\n          (i) => modelDimensionNames[i],\n        ).join(\",\\u00a0\")})`,\n    );\n  }\n  // Compute \"model matrix\" (transform from the displayed subspace of the chunk space) to the global\n  // display coordinate space.\n  const displaySubspaceModelMatrix = mat4.create();\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    const layerDim = displayToLayerDimensionIndices[displayDim];\n    if (layerDim === -1) continue;\n    for (\n      let chunkDisplayDimIndex = 0;\n      chunkDisplayDimIndex < numLayerDisplayDims;\n      ++chunkDisplayDimIndex\n    ) {\n      const chunkDim = chunkDisplayDimensionIndices[chunkDisplayDimIndex];\n      displaySubspaceModelMatrix[chunkDisplayDimIndex * 4 + displayDim] =\n        chunkToLayerTransform[chunkDim * (rank + 1) + layerDim];\n    }\n    displaySubspaceModelMatrix[12 + displayDim] =\n      chunkToLayerTransform[rank * (rank + 1) + layerDim];\n  }\n  const displaySubspaceInvModelMatrix = mat4.create();\n  mat4.invert(displaySubspaceInvModelMatrix, displaySubspaceModelMatrix);\n\n  for (let i = chunkDisplayDimensionIndices.length; i < 3; ++i) {\n    chunkDisplayDimensionIndices[i] = -1;\n  }\n  return {\n    modelTransform: chunkTransform.modelTransform,\n    chunkTransform,\n    displaySubspaceModelMatrix,\n    displaySubspaceInvModelMatrix,\n    chunkDisplayDimensionIndices,\n    numChunkDisplayDims: numLayerDisplayDims,\n  };\n}\n\nexport function getChunkPositionFromCombinedGlobalLocalPositions(\n  chunkPosition: Float32Array,\n  globalPosition: Float32Array,\n  localPosition: Float32Array,\n  layerRank: number,\n  combinedGlobalLocalToChunkTransform: Float32Array,\n) {\n  const globalRank = globalPosition.length;\n  const localRank = localPosition.length;\n  const rank = chunkPosition.length;\n  let valid = true;\n  for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {\n    let off = chunkDim;\n    let sum = 0;\n    for (let globalDim = 0; globalDim < globalRank; ++globalDim) {\n      sum +=\n        combinedGlobalLocalToChunkTransform[off + globalDim * layerRank] *\n        globalPosition[globalDim];\n    }\n    off += globalRank * layerRank;\n    for (let localDim = 0; localDim < localRank; ++localDim) {\n      sum +=\n        combinedGlobalLocalToChunkTransform[off + localDim * layerRank] *\n        localPosition[localDim];\n    }\n    sum += combinedGlobalLocalToChunkTransform[off + localRank * layerRank];\n    if (chunkDim < rank) {\n      chunkPosition[chunkDim] = sum;\n    } else {\n      // Handle clipping\n      if (sum < 0 || sum >= 1) {\n        valid = false;\n      }\n    }\n  }\n  return valid;\n}\n\nexport function getLayerPositionFromCombinedGlobalLocalPositions(\n  layerPosition: Float32Array,\n  globalPosition: Float32Array,\n  localPosition: Float32Array,\n  modelTransform: RenderLayerTransform,\n) {\n  scatterUpdate(\n    layerPosition,\n    globalPosition,\n    modelTransform.globalToRenderLayerDimensions,\n  );\n  scatterUpdate(\n    layerPosition,\n    localPosition,\n    modelTransform.localToRenderLayerDimensions,\n  );\n  return layerPosition;\n}\n\nexport function get3dModelToDisplaySpaceMatrix(\n  out: mat4,\n  displayDimensionRenderInfo: DisplayDimensionRenderInfo,\n  transform: RenderLayerTransform,\n) {\n  out.fill(0);\n  out[15] = 1;\n  let fullRank = true;\n  const { displayDimensionIndices } = displayDimensionRenderInfo;\n  const { globalToRenderLayerDimensions, modelToRenderLayerTransform } =\n    transform;\n  const layerRank = transform.rank;\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    const globalDim = displayDimensionIndices[displayDim];\n    if (globalDim === -1) {\n      fullRank = false;\n      continue;\n    }\n    const layerDim = globalToRenderLayerDimensions[globalDim];\n    if (layerDim === -1) {\n      fullRank = false;\n      continue;\n    }\n    out[displayDim + 12] =\n      modelToRenderLayerTransform[layerDim + layerRank * (layerRank + 1)];\n    for (let modelDim = 0; modelDim < 3; ++modelDim) {\n      out[displayDim + 4 * modelDim] =\n        modelToRenderLayerTransform[layerDim + (layerRank + 1) * modelDim];\n    }\n  }\n  if (!fullRank) {\n    const { globalDimensionNames } = displayDimensionRenderInfo;\n    const displayDimDesc = Array.from(\n      displayDimensionIndices.filter((i) => i !== -1),\n      (i) => globalDimensionNames[i],\n    ).join(\",\\u00a0\");\n    throw new Error(\n      `Transform from model dimensions (${transform.modelDimensionNames.join(\n        \",\\u00a0\",\n      )}) ` +\n        `to display dimensions (${displayDimDesc}) does not have full rank`,\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  validateDisplayDimensionRenderInfoProperty,\n  type DisplayDimensionRenderInfo,\n} from \"#src/navigation_state.js\";\nimport { ProjectionParameters } from \"#src/projection_parameters.js\";\nimport { getChunkPositionFromCombinedGlobalLocalPositions } from \"#src/render_coordinate_transform.js\";\nimport { ChunkLayout } from \"#src/sliceview/chunk_layout.js\";\nimport type {\n  WatchableValueChangeInterface,\n  WatchableValueInterface,\n} from \"#src/trackable_value.js\";\nimport { DATA_TYPE_BYTES, DataType } from \"#src/util/data_type.js\";\nimport type { Disposable } from \"#src/util/disposable.js\";\nimport {\n  getFrustrumPlanes,\n  getViewFrustrumDepthRange,\n  isAABBIntersectingPlane,\n  isAABBVisible,\n  mat4,\n  vec3,\n} from \"#src/util/geom.js\";\nimport * as matrix from \"#src/util/matrix.js\";\nimport * as vector from \"#src/util/vector.js\";\nimport { SharedObject } from \"#src/worker_rpc.js\";\n\nexport { DATA_TYPE_BYTES, DataType };\n\nconst DEBUG_VISIBLE_SOURCES = false;\nconst DEBUG_CHUNK_VISIBILITY = false;\n\nconst tempMat4 = mat4.create();\n\n/**\n * Average cross-sectional area contained within a chunk of the specified size and rotation.\n *\n * This is estimated by taking the total volume of the chunk and dividing it by the total length of\n * the chunk along the z axis.\n */\nexport function estimateSliceAreaPerChunk(\n  chunkLayout: ChunkLayout,\n  viewMatrix: mat4,\n) {\n  // Compute the length of the projection of the chunk along the z axis in view space.\n  //\n  // Each chunk dimension `i` can independently affect the z projection by the dot product of column\n  // `i` of `chunkLayout.transform` and row 2 of `viewMatrix`.\n  let viewZProjection = 0;\n  let chunkVolume = Math.abs(chunkLayout.detTransform);\n  const { transform, size } = chunkLayout;\n  for (let i = 0; i < 3; ++i) {\n    let sum = 0;\n    for (let j = 0; j < 3; ++j) {\n      sum += viewMatrix[j * 4 + 2] * transform[4 * i + j];\n    }\n    const s = size[i];\n    viewZProjection += Math.abs(sum) * s;\n    chunkVolume *= s;\n  }\n  return chunkVolume / viewZProjection;\n}\n\nexport interface MultiscaleVolumetricDataRenderLayer {\n  localPosition: WatchableValueInterface<Float32Array>;\n  renderScaleTarget: WatchableValueInterface<number>;\n}\n\nexport interface TransformedSource<\n  RLayer extends MultiscaleVolumetricDataRenderLayer = SliceViewRenderLayer,\n  Source extends SliceViewChunkSource = SliceViewChunkSource,\n> {\n  renderLayer: RLayer;\n\n  source: Source;\n\n  /**\n   * Approximate voxel size in each of the display dimensions.\n   */\n  effectiveVoxelSize: vec3;\n\n  chunkLayout: ChunkLayout;\n\n  /**\n   * Arrays of length `rank` specifying the clip bounds (in voxels) for dimensions not in\n   * `chunkDisplayDimensionIndices` and not channel dimensions.  The values for display/channel\n   * dimensions are set to -/+infinity.\n   */\n  nonDisplayLowerClipBound: Float32Array;\n  nonDisplayUpperClipBound: Float32Array;\n\n  /**\n   * Arrays of length `rank` specifying the clip bounds (in voxels) for all dimensions.\n   */\n  lowerClipBound: Float32Array;\n  upperClipBound: Float32Array;\n\n  // Lower clip bound (in voxels) in the \"display\" subspace of the chunk coordinate space.\n  lowerClipDisplayBound: vec3;\n  // Upper clip bound (in voxels) in the \"display\" subspace of the chunk coordinate space.\n  upperClipDisplayBound: vec3;\n\n  // Lower bound (in chunks) within the \"display\" subspace of the chunk coordinate space.\n  lowerChunkDisplayBound: vec3;\n  // Upper bound (in chunks) within the \"display\" subspace of the chunk coordinate space.\n  upperChunkDisplayBound: vec3;\n\n  /**\n   * Dimensions of the chunk corresponding to the 3 display dimensions of the slice view.\n   */\n  chunkDisplayDimensionIndices: number[];\n\n  /**\n   * Rank of \"layer\" space and the \"chunk clip\" space, which is >= rank of chunk space.\n   */\n  layerRank: number;\n\n  /**\n   * Transform from dimensions of layer space to dimensions of chunk space.\n   *\n   * Matrix has dimensions `(globalRank + localRank + 1) * layerRank`.\n   *\n   * Input space is `[global dimensions, local dimensions]`.  Output space is the \"chunk clip\"\n   * coordinate space, in units of voxels.\n   *\n   */\n  combinedGlobalLocalToChunkTransform: Float32Array;\n\n  /**\n   * Transform from non-display dimensions of layer space to non-display dimensions of chunk space.\n   *\n   * Same as `combinedGlobalLocalToChunkTransform`, except that rows corresponding to \"display\"\n   * chunk dimensions are all 0.\n   *\n   * Matrix has dimensions `(globalRank + localRank + 1) * layerRank`.\n   *\n   * Input space is `[global dimensions, local dimensions]`.  Output space is the \"chunk clip\"\n   * coordinate space, in units of voxels.\n   */\n  fixedLayerToChunkTransform: Float32Array;\n\n  /**\n   * When `computeVisibleChunks` invokes the `addChunk` callback, this is set to the position of the\n   * chunk.\n   */\n  curPositionInChunks: Float32Array;\n\n  fixedPositionWithinChunk: Uint32Array;\n}\n\nexport interface SliceViewRenderLayer {\n  /**\n   * Current position of non-global layer dimensions.\n   */\n  localPosition: WatchableValueInterface<Float32Array>;\n  renderScaleTarget: WatchableValueInterface<number>;\n\n  filterVisibleSources(\n    sliceView: SliceViewBase<SliceViewChunkSource, SliceViewRenderLayer>,\n    sources: readonly TransformedSource[],\n  ): Iterable<TransformedSource>;\n}\n\nfunction updateFixedCurPositionInChunks<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n>(\n  tsource: TransformedSource<RLayer, SliceViewChunkSource>,\n  globalPosition: Float32Array,\n  localPosition: Float32Array,\n): boolean {\n  const { curPositionInChunks, fixedPositionWithinChunk } = tsource;\n  const { nonDisplayLowerClipBound, nonDisplayUpperClipBound } = tsource;\n  const { rank, chunkDataSize } = tsource.source.spec;\n  if (\n    !getChunkPositionFromCombinedGlobalLocalPositions(\n      curPositionInChunks,\n      globalPosition,\n      localPosition,\n      tsource.layerRank,\n      tsource.fixedLayerToChunkTransform,\n    )\n  ) {\n    return false;\n  }\n  for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {\n    const x = curPositionInChunks[chunkDim];\n    if (\n      x < nonDisplayLowerClipBound[chunkDim] ||\n      x >= nonDisplayUpperClipBound[chunkDim]\n    ) {\n      if (DEBUG_VISIBLE_SOURCES) {\n        console.log(\n          \"excluding source\",\n          tsource,\n          `because of chunkDim=${chunkDim}, sum=${x}`,\n          nonDisplayLowerClipBound,\n          nonDisplayUpperClipBound,\n          tsource.fixedLayerToChunkTransform,\n        );\n      }\n      return false;\n    }\n    const chunkSize = chunkDataSize[chunkDim];\n    const chunk = (curPositionInChunks[chunkDim] = Math.floor(x / chunkSize));\n    fixedPositionWithinChunk[chunkDim] = x - chunk * chunkSize;\n  }\n  return true;\n}\n\nfunction pickBestAlternativeSource<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n  Source extends SliceViewChunkSource,\n  Transformed extends TransformedSource<RLayer, Source>,\n>(viewMatrix: mat4, alternatives: Transformed[]) {\n  const numAlternatives = alternatives.length;\n  let bestAlternativeIndex = 0;\n  if (DEBUG_VISIBLE_SOURCES) {\n    console.log(alternatives);\n  }\n  if (numAlternatives > 1) {\n    let bestSliceArea = 0;\n    for (\n      let alternativeIndex = 0;\n      alternativeIndex < numAlternatives;\n      ++alternativeIndex\n    ) {\n      const alternative = alternatives[alternativeIndex];\n      const { chunkLayout } = alternative;\n      const sliceArea = estimateSliceAreaPerChunk(chunkLayout, viewMatrix);\n      if (DEBUG_VISIBLE_SOURCES) {\n        console.log(\n          `chunksize = ${chunkLayout.size}, sliceArea = ${sliceArea}`,\n        );\n      }\n      if (sliceArea > bestSliceArea) {\n        bestSliceArea = sliceArea;\n        bestAlternativeIndex = alternativeIndex;\n      }\n    }\n  }\n  return bestAlternativeIndex;\n}\n\nexport interface VisibleLayerSources<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n  Source extends SliceViewChunkSource,\n  Transformed extends TransformedSource<RLayer, Source>,\n> {\n  allSources: Transformed[][];\n  visibleSources: Transformed[];\n  displayDimensionRenderInfo: DisplayDimensionRenderInfo;\n}\n\nconst tempChunkLayout = new ChunkLayout(vec3.create(), mat4.create(), 0);\n\nexport class SliceViewProjectionParameters extends ProjectionParameters {\n  /**\n   * Normal vector of cross section in (non-isotropic) global voxel coordinates.\n   */\n  viewportNormalInGlobalCoordinates = vec3.create();\n\n  /**\n   * Normal vector of cross section in isotropic global canonical voxel coordinates.\n   */\n  viewportNormalInCanonicalCoordinates = vec3.create();\n\n  centerDataPosition = vec3.create();\n\n  /**\n   * Size in physical units of a single pixel.\n   */\n  pixelSize = 0;\n}\n\nfunction visibleSourcesInvalidated(\n  oldValue: SliceViewProjectionParameters,\n  newValue: SliceViewProjectionParameters,\n) {\n  if (\n    oldValue.displayDimensionRenderInfo !== newValue.displayDimensionRenderInfo\n  ) {\n    return true;\n  }\n  if (oldValue.pixelSize !== newValue.pixelSize) return true;\n  const { viewMatrix: oldViewMatrix } = oldValue;\n  const { viewMatrix: newViewMatrix } = newValue;\n  for (let i = 0; i < 12; ++i) {\n    if (oldViewMatrix[i] !== newViewMatrix[i]) return true;\n  }\n  return false;\n}\n\nexport class SliceViewBase<\n  Source extends SliceViewChunkSource = SliceViewChunkSource,\n  RLayer extends SliceViewRenderLayer = SliceViewRenderLayer,\n  Transformed extends TransformedSource<RLayer, Source> = TransformedSource<\n    RLayer,\n    Source\n  >,\n> extends SharedObject {\n  visibleLayers = new Map<\n    RLayer,\n    VisibleLayerSources<RLayer, Source, Transformed>\n  >();\n  visibleSourcesStale = true;\n\n  constructor(\n    public projectionParameters: WatchableValueChangeInterface<SliceViewProjectionParameters>,\n  ) {\n    super();\n    this.registerDisposer(\n      projectionParameters.changed.add((oldValue, newValue) => {\n        if (visibleSourcesInvalidated(oldValue, newValue)) {\n          this.invalidateVisibleSources();\n        }\n        this.invalidateVisibleChunks();\n      }),\n    );\n  }\n\n  invalidateVisibleSources() {\n    this.visibleSourcesStale = true;\n  }\n\n  invalidateVisibleChunks() {}\n\n  /**\n   * Computes the list of sources to use for each visible layer, based on the\n   * current pixelSize.\n   */\n  updateVisibleSources() {\n    if (!this.visibleSourcesStale) {\n      return;\n    }\n    this.visibleSourcesStale = false;\n    const curDisplayDimensionRenderInfo =\n      this.projectionParameters.value.displayDimensionRenderInfo;\n\n    const { visibleLayers } = this;\n    for (const [renderLayer, visibleLayerSources] of visibleLayers) {\n      const { allSources, visibleSources } = visibleLayerSources;\n      visibleSources.length = 0;\n      if (\n        allSources.length === 0 ||\n        !validateDisplayDimensionRenderInfoProperty(\n          visibleLayerSources,\n          curDisplayDimensionRenderInfo,\n        )\n      ) {\n        continue;\n      }\n      const preferredOrientationIndex = pickBestAlternativeSource(\n        this.projectionParameters.value.viewMatrix,\n        allSources.map((x) => x[0]),\n      );\n\n      const sources = allSources[preferredOrientationIndex];\n\n      for (const source of renderLayer.filterVisibleSources(this, sources)) {\n        visibleSources.push(source as Transformed);\n      }\n      // Reverse visibleSources list since we added sources from coarsest to finest resolution, but\n      // we want them ordered from finest to coarsest.\n      visibleSources.reverse();\n      if (DEBUG_VISIBLE_SOURCES) {\n        console.log(\"visible sources chosen\", visibleSources);\n      }\n    }\n  }\n}\n\n/**\n * By default, choose a chunk size with at most 2^18 = 262144 voxels.\n */\nexport const DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 = 18;\n\n/**\n * Specifies common options for getNearIsotropicBlockSize and getTwoDimensionalBlockSize.\n */\nexport interface BaseChunkLayoutOptions {\n  /**\n   * Number of chunk dimensions.\n   */\n  rank: number;\n\n  /**\n   * This, together with upperVoxelBound, specifies the total volume dimensions, which serves as a\n   * bound on the maximum chunk size.  If not specified, defaults to a zero vector.\n   */\n  lowerVoxelBound?: Float32Array;\n\n  /**\n   * Upper voxel bound.  If not specified, the total volume dimensions are not used to bound the\n   * chunk size.\n   */\n  upperVoxelBound?: Float32Array;\n\n  /**\n   * Base 2 logarithm of the maximum number of voxels per chunk.  Defaults to\n   * DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2.\n   */\n  maxVoxelsPerChunkLog2?: number;\n\n  /**\n   * Linear (not affine) transformation matrix with `rank` columns and `displayRank` rows in\n   * column-major order.  Specifies the transformation from chunk space to an isotropic \"camera view\n   * space\".  Note that only relative scales of input dimensions are relevant, any rotations applied\n   * are irrelevant.\n   */\n  chunkToViewTransform: Float32Array;\n  displayRank: number;\n\n  minBlockSize?: Uint32Array;\n  maxBlockSize?: Uint32Array;\n}\n\nexport type GetNearIsotropicBlockSizeOptions = BaseChunkLayoutOptions;\n\n/**\n * Determines a near-isotropic (in camera view space) block size.  All dimensions will be\n * powers of 2, and will not exceed upperVoxelBound - lowerVoxelBound.  The total number of voxels\n * will not exceed maxVoxelsPerChunkLog2.\n */\nexport function getNearIsotropicBlockSize(\n  options: GetNearIsotropicBlockSizeOptions,\n): Uint32Array {\n  let {\n    rank,\n    upperVoxelBound,\n    maxVoxelsPerChunkLog2 = DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2,\n    chunkToViewTransform,\n    displayRank,\n    minBlockSize,\n    maxBlockSize,\n  } = options;\n\n  const { lowerVoxelBound = new Uint32Array(rank) } = options;\n\n  // Adjust voxelSize by effective scaling factor.\n  const effectiveVoxelSize = new Float32Array(rank);\n  for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {\n    let factor = 0;\n    for (let displayDim = 0; displayDim < displayRank; ++displayDim) {\n      const c = chunkToViewTransform[chunkDim * displayRank + displayDim];\n      factor += c * c;\n    }\n    effectiveVoxelSize[chunkDim] = Math.sqrt(factor);\n  }\n\n  const chunkDataSize = new Uint32Array(rank);\n  if (minBlockSize !== undefined) {\n    chunkDataSize.set(minBlockSize);\n  } else {\n    chunkDataSize.fill(1);\n  }\n  const chunkDataSizeUpperBound = new Array<number>(rank);\n  for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {\n    let bound = Number.POSITIVE_INFINITY;\n    if (effectiveVoxelSize[chunkDim] === 0) {\n      bound = chunkDataSize[chunkDim];\n    } else {\n      if (upperVoxelBound !== undefined) {\n        bound =\n          2 **\n          Math.floor(\n            Math.log2(upperVoxelBound[chunkDim] - lowerVoxelBound[chunkDim]),\n          );\n      }\n      if (maxBlockSize !== undefined) {\n        bound = Math.min(bound, maxBlockSize[chunkDim]);\n      }\n    }\n    chunkDataSizeUpperBound[chunkDim] = bound;\n  }\n\n  // Determine the dimension in which chunkDataSize should be increased.  This is the smallest\n  // dimension (in nanometers) that is < maxChunkDataSize (in voxels).\n  //\n  // Returns -1 if there is no such dimension.\n  function findNextDimension() {\n    let minSize = Infinity;\n    let minDimension = -1;\n    for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {\n      if (chunkDataSize[chunkDim] >= chunkDataSizeUpperBound[chunkDim]) {\n        continue;\n      }\n      const size = chunkDataSize[chunkDim] * effectiveVoxelSize[chunkDim];\n      if (size < minSize) {\n        minSize = size;\n        minDimension = chunkDim;\n      }\n    }\n    return minDimension;\n  }\n\n  maxVoxelsPerChunkLog2 -= Math.log2(vector.prod(chunkDataSize));\n  for (let i = 0; i < maxVoxelsPerChunkLog2; ++i) {\n    const nextDim = findNextDimension();\n    if (nextDim === -1) {\n      break;\n    }\n    chunkDataSize[nextDim] *= 2;\n  }\n  return chunkDataSize;\n}\n\n/**\n * Returns an array of [xy, yz, xz] 2-dimensional block sizes, where [x, y, z] refer to the view\n * dimensions.\n */\nexport function getTwoDimensionalBlockSizes(options: BaseChunkLayoutOptions) {\n  const chunkDataSizes: Uint32Array[] = [];\n  const { displayRank, chunkToViewTransform, rank } = options;\n  if (displayRank > 3) {\n    throw new Error(\"Unsupported view transform\");\n  }\n  if (displayRank < 3) {\n    return [getNearIsotropicBlockSize(options)];\n  }\n  for (let i = 0; i < 3; ++i) {\n    const excludedDim = (i + 2) % 3;\n    const restrictedTransform = new Float32Array(chunkToViewTransform);\n    for (let j = 0; j < rank; ++j) {\n      restrictedTransform[j * displayRank + excludedDim] = 0;\n    }\n    chunkDataSizes[i] = getNearIsotropicBlockSize({\n      ...options,\n      chunkToViewTransform: restrictedTransform,\n    });\n  }\n  return chunkDataSizes;\n}\n\nexport enum ChunkLayoutPreference {\n  /**\n   * Indicates that isotropic chunks are desired.\n   */\n  ISOTROPIC = 0,\n\n  /**\n   * Indicates that 2-D chunks are desired.\n   */\n  FLAT = 1,\n}\n\nexport interface SliceViewSourceOptions {\n  /**\n   * Transform from the multiscale source coordinate space to a \"view\" coordinate space that\n   * reflects the relative scales.  This is a *linear* (not affine) transformation matrix with\n   * `rank` columns and `displayRank` rows in column-major order, where `rank` is the rank of the\n   * multiscale source.\n   */\n  multiscaleToViewTransform: Float32Array;\n  displayRank: number;\n  modelChannelDimensionIndices: readonly number[];\n}\n\nexport function getCombinedTransform(\n  rank: number,\n  bToC: Float32Array,\n  aToB: Float32Array | undefined,\n) {\n  if (aToB === undefined) {\n    return bToC;\n  }\n  return matrix.multiply(\n    new Float32Array((rank + 1) * (rank + 1)),\n    rank + 1,\n    bToC,\n    rank + 1,\n    aToB,\n    rank + 1,\n    rank + 1,\n    rank + 1,\n    rank + 1,\n  );\n}\n\n/**\n * Specifies parameters for getChunkDataSizes.\n */\nexport interface ChunkLayoutOptions {\n  /**\n   * Chunk sizes in voxels.\n   */\n  chunkDataSizes?: Uint32Array[];\n\n  /**\n   * Preferred chunk layout, which determines chunk sizes to use if chunkDataSizes is not\n   * specified.\n   */\n  chunkLayoutPreference?: ChunkLayoutPreference;\n}\n\nexport function getChunkDataSizes(\n  options: ChunkLayoutOptions & BaseChunkLayoutOptions,\n) {\n  if (options.chunkDataSizes !== undefined) {\n    return options.chunkDataSizes;\n  }\n  const { chunkLayoutPreference = ChunkLayoutPreference.ISOTROPIC } = options;\n  switch (chunkLayoutPreference) {\n    case ChunkLayoutPreference.ISOTROPIC:\n      return [getNearIsotropicBlockSize(options)];\n    case ChunkLayoutPreference.FLAT:\n      return getTwoDimensionalBlockSizes(options);\n  }\n}\n\n/**\n * Generic specification for SliceView chunks specifying a layout and voxel size.\n */\nexport interface SliceViewChunkSpecification<\n  ChunkDataSize extends Uint32Array | Float32Array = Uint32Array | Float32Array,\n> {\n  rank: number;\n\n  /**\n   * Size of chunk in voxels.\n   */\n  chunkDataSize: ChunkDataSize;\n\n  /**\n   * All valid chunks are in the range [lowerChunkBound, upperChunkBound).\n   *\n   * These are specified in units of chunks (not voxels).\n   */\n  lowerChunkBound: Float32Array;\n  upperChunkBound: Float32Array;\n\n  lowerVoxelBound: Float32Array;\n  upperVoxelBound: Float32Array;\n}\n\nexport function makeSliceViewChunkSpecification<\n  ChunkDataSize extends Uint32Array | Float32Array,\n>(\n  options: SliceViewChunkSpecificationOptions<ChunkDataSize>,\n): SliceViewChunkSpecification<ChunkDataSize> {\n  const { rank, chunkDataSize, upperVoxelBound } = options;\n  const { lowerVoxelBound = new Float32Array(rank) } = options;\n  const lowerChunkBound = new Float32Array(rank);\n  const upperChunkBound = new Float32Array(rank);\n  for (let i = 0; i < rank; ++i) {\n    lowerChunkBound[i] = Math.floor(lowerVoxelBound[i] / chunkDataSize[i]);\n    upperChunkBound[i] = Math.floor(\n      (upperVoxelBound[i] - 1) / chunkDataSize[i] + 1,\n    );\n  }\n  return {\n    rank,\n    chunkDataSize,\n    lowerChunkBound,\n    upperChunkBound,\n    lowerVoxelBound,\n    upperVoxelBound,\n  };\n}\n\nexport function* filterVisibleSources(\n  sliceView: SliceViewBase,\n  renderLayer: SliceViewRenderLayer,\n  sources: readonly TransformedSource[],\n): Iterable<TransformedSource> {\n  // Increase pixel size by a small margin.\n  const pixelSize = sliceView.projectionParameters.value.pixelSize * 1.1;\n  // At the smallest scale, all alternative sources must have the same voxel size, which is\n  // considered to be the base voxel size.\n  const smallestVoxelSize = sources[0].effectiveVoxelSize;\n\n  const renderScaleTarget = renderLayer.renderScaleTarget.value;\n\n  /**\n   * Determines whether we should continue to look for a finer-resolution source *after* one\n   * with the specified voxelSize.\n   */\n  const canImproveOnVoxelSize = (voxelSize: vec3) => {\n    const targetSize = pixelSize * renderScaleTarget;\n    for (let i = 0; i < 3; ++i) {\n      const size = voxelSize[i];\n      // If size <= pixelSize, no need for improvement.\n      // If size === smallestVoxelSize, also no need for improvement.\n      if (size > targetSize && size > 1.01 * smallestVoxelSize[i]) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const improvesOnPrevVoxelSize = (voxelSize: vec3, prevVoxelSize: vec3) => {\n    const targetSize = pixelSize * renderScaleTarget;\n    for (let i = 0; i < 3; ++i) {\n      const size = voxelSize[i];\n      const prevSize = prevVoxelSize[i];\n      if (\n        Math.abs(targetSize - size) < Math.abs(targetSize - prevSize) &&\n        size < 1.01 * prevSize\n      ) {\n        return true;\n      }\n    }\n    return false;\n  };\n  let scaleIndex = sources.length - 1;\n  let prevVoxelSize: vec3 | undefined;\n  while (true) {\n    const transformedSource = sources[scaleIndex];\n    if (\n      prevVoxelSize !== undefined &&\n      !improvesOnPrevVoxelSize(\n        transformedSource.effectiveVoxelSize,\n        prevVoxelSize,\n      )\n    ) {\n      break;\n    }\n    yield transformedSource;\n\n    if (\n      scaleIndex === 0 ||\n      !canImproveOnVoxelSize(transformedSource.effectiveVoxelSize)\n    ) {\n      break;\n    }\n    prevVoxelSize = transformedSource.effectiveVoxelSize;\n    --scaleIndex;\n  }\n}\n\n/**\n * Common parameters for SliceView Chunks.\n */\nexport interface SliceViewChunkSpecificationBaseOptions {\n  rank: number;\n\n  /**\n   * If not specified, defaults to an all-zero vector.  This determines lowerChunkBound.  If this is\n   * not a multiple of chunkDataSize, then voxels at lower positions may still be requested.\n   */\n  lowerVoxelBound?: Float32Array;\n\n  /**\n   * Exclusive upper bound in \"chunk\" coordinate space, in voxels.  This determines upperChunkBound.\n   */\n  upperVoxelBound: Float32Array;\n}\n\nexport interface SliceViewChunkSpecificationOptions<\n  ChunkDataSize extends Uint32Array | Float32Array = Uint32Array | Float32Array,\n> extends SliceViewChunkSpecificationBaseOptions {\n  chunkDataSize: ChunkDataSize;\n}\n\nexport interface SliceViewChunkSource<\n  Spec extends SliceViewChunkSpecification = SliceViewChunkSpecification,\n> extends Disposable {\n  spec: Spec;\n}\n\nexport const SLICEVIEW_RPC_ID = \"SliceView\";\nexport const SLICEVIEW_RENDERLAYER_RPC_ID = \"sliceview/RenderLayer\";\nexport const SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID = \"SliceView.addVisibleLayer\";\nexport const SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID =\n  \"SliceView.removeVisibleLayer\";\nexport const SLICEVIEW_REQUEST_CHUNK_RPC_ID = \"ChunkManager.requestChunk\";\n\nconst tempVisibleVolumetricChunkLower = new Float32Array(3);\nconst tempVisibleVolumetricChunkUpper = new Float32Array(3);\nconst tempVisibleVolumetricModelViewProjection = mat4.create();\nconst tempVisibleVolumetricClippingPlanes = new Float32Array(24);\n\nfunction forEachVolumetricChunkWithinFrustrum<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n>(\n  clippingPlanes: Float32Array,\n  transformedSource: TransformedSource<RLayer>,\n  callback: (positionInChunks: vec3, clippingPlanes: Float32Array) => void,\n  predicate: (\n    xLower: number,\n    yLower: number,\n    zLower: number,\n    xUpper: number,\n    yUpper: number,\n    zUpper: number,\n    clippingPlanes: Float32Array,\n  ) => boolean,\n) {\n  const lower = tempVisibleVolumetricChunkLower;\n  const upper = tempVisibleVolumetricChunkUpper;\n  const { lowerChunkDisplayBound, upperChunkDisplayBound } = transformedSource;\n  for (let i = 0; i < 3; ++i) {\n    lower[i] = Math.max(lower[i], lowerChunkDisplayBound[i]);\n    upper[i] = Math.min(upper[i], upperChunkDisplayBound[i]);\n  }\n  const { curPositionInChunks, chunkDisplayDimensionIndices } =\n    transformedSource;\n\n  function recurse() {\n    if (\n      !predicate(\n        lower[0],\n        lower[1],\n        lower[2],\n        upper[0],\n        upper[1],\n        upper[2],\n        clippingPlanes,\n      )\n    ) {\n      return;\n    }\n\n    let splitDim = 0;\n    let splitSize = Math.max(0, upper[0] - lower[0]);\n    let volume = splitSize;\n    for (let i = 1; i < 3; ++i) {\n      const size = Math.max(0, upper[i] - lower[i]);\n      volume *= size;\n      if (size > splitSize) {\n        splitSize = size;\n        splitDim = i;\n      }\n    }\n    if (volume === 0) return;\n    if (volume === 1) {\n      curPositionInChunks[chunkDisplayDimensionIndices[0]] = lower[0];\n      curPositionInChunks[chunkDisplayDimensionIndices[1]] = lower[1];\n      curPositionInChunks[chunkDisplayDimensionIndices[2]] = lower[2];\n      callback(lower as vec3, clippingPlanes);\n      return;\n    }\n    const prevLower = lower[splitDim];\n    const prevUpper = upper[splitDim];\n    const splitPoint = Math.floor(0.5 * (prevLower + prevUpper));\n    upper[splitDim] = splitPoint;\n    recurse();\n    upper[splitDim] = prevUpper;\n    lower[splitDim] = splitPoint;\n    recurse();\n    lower[splitDim] = prevLower;\n  }\n  recurse();\n}\n\nexport function forEachVisibleVolumetricChunk<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n>(\n  projectionParameters: ProjectionParameters,\n  localPosition: Float32Array,\n  transformedSource: TransformedSource<RLayer>,\n  callback: (positionInChunks: vec3, clippingPlanes: Float32Array) => void,\n) {\n  if (\n    !updateFixedCurPositionInChunks(\n      transformedSource,\n      projectionParameters.globalPosition,\n      localPosition,\n    )\n  ) {\n    return;\n  }\n  const { size: chunkSize } = transformedSource.chunkLayout;\n  const modelViewProjection = mat4.multiply(\n    tempVisibleVolumetricModelViewProjection,\n    projectionParameters.viewProjectionMat,\n    transformedSource.chunkLayout.transform,\n  );\n  for (let i = 0; i < 3; ++i) {\n    const s = chunkSize[i];\n    for (let j = 0; j < 4; ++j) {\n      modelViewProjection[4 * i + j] *= s;\n    }\n  }\n\n  const clippingPlanes = tempVisibleVolumetricClippingPlanes;\n  getFrustrumPlanes(clippingPlanes, modelViewProjection);\n  const lower = tempVisibleVolumetricChunkLower;\n  const upper = tempVisibleVolumetricChunkUpper;\n  lower.fill(Number.NEGATIVE_INFINITY);\n  upper.fill(Number.POSITIVE_INFINITY);\n  forEachVolumetricChunkWithinFrustrum(\n    clippingPlanes,\n    transformedSource,\n    callback,\n    isAABBVisible,\n  );\n}\n\nexport function forEachPlaneIntersectingVolumetricChunk<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n>(\n  projectionParameters: ProjectionParameters,\n  localPosition: Float32Array,\n  transformedSource: TransformedSource<RLayer>,\n  chunkLayout: ChunkLayout,\n  callback: (positionInChunks: vec3) => void,\n) {\n  if (\n    !updateFixedCurPositionInChunks(\n      transformedSource,\n      projectionParameters.globalPosition,\n      localPosition,\n    )\n  ) {\n    return;\n  }\n  const { size: chunkSize } = chunkLayout;\n  const modelViewProjection = mat4.multiply(\n    tempVisibleVolumetricModelViewProjection,\n    projectionParameters.viewProjectionMat,\n    chunkLayout.transform,\n  );\n  for (let i = 0; i < 3; ++i) {\n    const s = chunkSize[i];\n    for (let j = 0; j < 4; ++j) {\n      modelViewProjection[4 * i + j] *= s;\n    }\n  }\n\n  const invModelViewProjection = tempMat4;\n  mat4.invert(invModelViewProjection, modelViewProjection);\n  const lower = tempVisibleVolumetricChunkLower;\n  const upper = tempVisibleVolumetricChunkUpper;\n  const epsilon = 1e-3;\n  for (let i = 0; i < 3; ++i) {\n    // Add small offset of `epsilon` voxels to bias towards the higher coordinate if very close to a\n    // voxel boundary.\n    const c = invModelViewProjection[12 + i] + epsilon / chunkSize[i];\n    const xCoeff = Math.abs(invModelViewProjection[i]);\n    const yCoeff = Math.abs(invModelViewProjection[4 + i]);\n    lower[i] = Math.floor(c - xCoeff - yCoeff);\n    upper[i] = Math.floor(c + xCoeff + yCoeff + 1);\n  }\n\n  const clippingPlanes = tempVisibleVolumetricClippingPlanes;\n  for (let i = 0; i < 3; ++i) {\n    const xCoeff = modelViewProjection[4 * i];\n    const yCoeff = modelViewProjection[4 * i + 1];\n    const zCoeff = modelViewProjection[4 * i + 2];\n    clippingPlanes[i] = xCoeff;\n    clippingPlanes[4 + i] = -xCoeff;\n    clippingPlanes[8 + i] = +yCoeff;\n    clippingPlanes[12 + i] = -yCoeff;\n    clippingPlanes[16 + i] = +zCoeff;\n    clippingPlanes[20 + i] = -zCoeff;\n  }\n  {\n    const i = 3;\n    const xCoeff = modelViewProjection[4 * i];\n    const yCoeff = modelViewProjection[4 * i + 1];\n    const zCoeff = modelViewProjection[4 * i + 2];\n    clippingPlanes[i] = 1 + xCoeff;\n    clippingPlanes[4 + i] = 1 - xCoeff;\n    clippingPlanes[8 + i] = 1 + yCoeff;\n    clippingPlanes[12 + i] = 1 - yCoeff;\n    clippingPlanes[16 + i] = zCoeff;\n    clippingPlanes[20 + i] = -zCoeff;\n  }\n  if (DEBUG_CHUNK_VISIBILITY) {\n    console.log(\"clippingPlanes\", clippingPlanes);\n    console.log(\"modelViewProjection\", modelViewProjection.join(\",\"));\n    console.log(`lower=${lower.join(\",\")}, upper=${upper.join(\",\")}`);\n  }\n  forEachVolumetricChunkWithinFrustrum(\n    clippingPlanes,\n    transformedSource,\n    callback,\n    isAABBIntersectingPlane,\n  );\n}\n\n/**\n * For chunk layouts with finiteRank < 3, returns an adjusted chunk layout where chunk 0 in each\n * non-finite dimension is guaranteed to cover the viewport.\n */\nexport function getNormalizedChunkLayout(\n  projectionParameters: ProjectionParameters,\n  chunkLayout: ChunkLayout,\n): ChunkLayout {\n  const { finiteRank } = chunkLayout;\n  if (finiteRank === 3) return chunkLayout;\n  tempChunkLayout.finiteRank = finiteRank;\n  vec3.copy(tempChunkLayout.size, chunkLayout.size);\n  const transform = mat4.copy(tempChunkLayout.transform, chunkLayout.transform);\n  const invTransform = mat4.copy(\n    tempChunkLayout.invTransform,\n    chunkLayout.invTransform,\n  );\n  tempChunkLayout.detTransform = chunkLayout.detTransform;\n  const { invViewMatrix, width, height } = projectionParameters;\n  const depth = getViewFrustrumDepthRange(projectionParameters.projectionMat);\n  for (let chunkRenderDim = finiteRank; chunkRenderDim < 3; ++chunkRenderDim) {\n    // we want to ensure chunk [0] fully covers the viewport\n    const offset = invViewMatrix[12 + chunkRenderDim];\n    let lower = offset;\n    let upper = offset;\n    const xc = Math.abs(invViewMatrix[chunkRenderDim] * width);\n    lower -= xc;\n    upper += xc;\n    const yc = Math.abs(invViewMatrix[chunkRenderDim + 4] * height);\n    lower -= yc;\n    upper += yc;\n    const zc = Math.abs(invViewMatrix[chunkRenderDim + 8] * depth);\n    lower -= zc;\n    upper += zc;\n    const scaleFactor = Math.max(1, upper - lower);\n    transform[12 + chunkRenderDim] = lower;\n    transform[5 * chunkRenderDim] = scaleFactor;\n  }\n  mat4.invert(invTransform, transform);\n  return tempChunkLayout;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Velocity estimation for prefetching using exponentially-weighted moving estimate of\n * univariate gaussian distribution of per-dimension velocities.\n *\n * Because changes to the global position are not continuous, we estimate the velocity itself using\n * an exponentially-weighted moving average over a relatively short time scale\n * `velocityHalfLifeMilliseconds`, and then estimate a mean and variance of these velocity estimates\n * using an expeonentially-weighted moving average over a longer time scale.\n */\n\nconst VELOCITY_HALF_LIFE_MS = 50;\nconst MODEL_HALF_LIFE_MS = 1000;\n\nexport class VelocityEstimator {\n  private lastTime = Number.NEGATIVE_INFINITY;\n  rank = 0;\n\n  private numSamples = 0;\n\n  // Previous position sampled.\n  private prevPosition = new Float32Array();\n\n  // Moving average of raw velocity over `velocityHalfLifeMilliseconds`.\n  private velocity = new Float32Array();\n\n  // Moving average of `velocity` estimate using `modelHalfLifeMilliseconds`.\n  mean = new Float32Array();\n  // Moving variance of `velocity` estimate using `modelHalfLifeMilliseconds`.\n  variance = new Float32Array();\n\n  constructor(\n    public velocityHalfLifeMilliseconds: number = VELOCITY_HALF_LIFE_MS,\n    public modelHalfLifeMilliseconds: number = MODEL_HALF_LIFE_MS,\n  ) {}\n\n  reset(rank: number) {\n    this.lastTime = Number.NEGATIVE_INFINITY;\n    this.rank = rank;\n    this.numSamples = 0;\n    this.velocity = new Float32Array(rank);\n    this.prevPosition = new Float32Array(rank);\n    this.mean = new Float32Array(rank);\n    this.variance = new Float32Array(rank);\n  }\n\n  addSample(position: Float32Array, time = Date.now()) {\n    const rank = position.length;\n    if (rank !== this.rank) {\n      this.reset(rank);\n    }\n\n    const numSamples = this.numSamples;\n    ++this.numSamples;\n\n    // Update `velocity` estimate.\n    if (this.numSamples === 0) {\n      this.prevPosition.set(position);\n      this.lastTime = time;\n      return;\n    }\n\n    const deltaT = time - this.lastTime;\n    this.lastTime = time;\n    const velocityAlpha =\n      1 - 2 ** -(deltaT / this.velocityHalfLifeMilliseconds);\n    const modelAlpha = 1 - 2 ** -(deltaT / this.modelHalfLifeMilliseconds);\n    const { velocity, prevPosition, mean, variance } = this;\n    for (let i = 0; i < rank; ++i) {\n      const curVelocitySample =\n        (position[i] - prevPosition[i]) / Math.max(deltaT, 1);\n      prevPosition[i] = position[i];\n      const prevVelocity = velocity[i];\n      const newVelocity = (velocity[i] =\n        prevVelocity + velocityAlpha * (curVelocitySample - prevVelocity));\n      if (numSamples === 1) {\n        mean[i] = newVelocity;\n      } else {\n        const meanPrev = mean[i];\n        const varPrev = variance[i];\n        const delta = newVelocity - meanPrev;\n        mean[i] = meanPrev + modelAlpha * delta;\n        variance[i] = (1 - modelAlpha) * (varPrev + modelAlpha * delta * delta);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ChunkRequester } from \"#src/chunk_manager/backend.js\";\nimport {\n  ChunkPriorityTier,\n  PREFETCH_PRIORITY_MULTIPLIER,\n} from \"#src/chunk_manager/base.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\n\n/**\n * Mixin for adding a visibility shared property to a ChunkRequester.  Calls\n * `this.chunkManager.scheduleUpdateChunkPriorities()` when visibility changes.\n */\nexport function withSharedVisibility<\n  T extends { new (...args: any[]): ChunkRequester },\n>(Base: T) {\n  return class extends Base {\n    visibility: SharedWatchableValue<number>;\n\n    constructor(...args: any[]) {\n      super(...args);\n      const rpc: RPC = args[0];\n      const options: any = args[1];\n      this.visibility = rpc.get(options.visibility);\n      this.registerDisposer(\n        this.visibility.changed.add(() =>\n          this.chunkManager.scheduleUpdateChunkPriorities(),\n        ),\n      );\n    }\n  };\n}\n\n/**\n * Computes the ChunkPriorityTier for the given `visibility` value.\n *\n * A value of `Number.POSITIVE_INFINITY` means `VISIBLE`.  Any other value means `PREFETCH`.\n */\nexport function getPriorityTier(visibility: number): ChunkPriorityTier {\n  return visibility === Number.POSITIVE_INFINITY\n    ? ChunkPriorityTier.VISIBLE\n    : ChunkPriorityTier.PREFETCH;\n}\n\n/**\n * Computes the base priority for the given `visibility` value.  If the value is\n * `Number.POSTIVE_INFINITY`, corresponding to actual visibility, the base priority is 0.\n * Otherwise, the value is interpreted as the prefetch priority (higher means higher priority), and\n * the base priority is equal to the product of this value and `PREFETCH_PRIORITY_MULTIPLIER`.\n */\nexport function getBasePriority(visibility: number): number {\n  return visibility === Number.POSITIVE_INFINITY\n    ? 0\n    : visibility * PREFETCH_PRIORITY_MULTIPLIER;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport \"#src/render_layer_backend.js\";\n\nimport type {\n  ChunkConstructor,\n  ChunkRenderLayerBackend,\n} from \"#src/chunk_manager/backend.js\";\nimport {\n  Chunk,\n  ChunkSource,\n  getNextMarkGeneration,\n  withChunkManager,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier, ChunkState } from \"#src/chunk_manager/base.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type {\n  MultiscaleVolumetricDataRenderLayer,\n  SliceViewChunkSource as SliceViewChunkSourceInterface,\n  SliceViewChunkSpecification,\n  SliceViewRenderLayer as SliceViewRenderLayerInterface,\n  TransformedSource,\n} from \"#src/sliceview/base.js\";\nimport {\n  filterVisibleSources,\n  forEachPlaneIntersectingVolumetricChunk,\n  getNormalizedChunkLayout,\n  SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID,\n  SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID,\n  SLICEVIEW_RENDERLAYER_RPC_ID,\n  SLICEVIEW_REQUEST_CHUNK_RPC_ID,\n  SLICEVIEW_RPC_ID,\n  SliceViewBase,\n} from \"#src/sliceview/base.js\";\nimport { ChunkLayout } from \"#src/sliceview/chunk_layout.js\";\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { raceWithAbort } from \"#src/util/abort.js\";\nimport { erf } from \"#src/util/erf.js\";\nimport { vec3, vec3Key } from \"#src/util/geom.js\";\nimport { VelocityEstimator } from \"#src/util/velocity_estimation.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC, RPCPromise } from \"#src/worker_rpc.js\";\nimport {\n  registerPromiseRPC,\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\nimport type { DisplayDimensionRenderInfo } from \"src/navigation_state\";\n\nexport const BASE_PRIORITY = -1e12;\nexport const SCALE_PRIORITY_MULTIPLIER = 1e9;\n\n// Temporary values used by SliceView.updateVisibleChunk\nconst tempChunkPosition = vec3.create();\nconst tempCenter = vec3.create();\nconst tempChunkSize = vec3.create();\n\nclass SliceViewCounterpartBase extends SliceViewBase<\n  SliceViewChunkSourceBackend,\n  SliceViewRenderLayerBackend\n> {\n  constructor(rpc: RPC, options: any) {\n    super(rpc.get(options.projectionParameters));\n    this.initializeSharedObject(rpc, options.id);\n  }\n}\n\nfunction disposeTransformedSources(\n  allSources: TransformedSource<\n    SliceViewRenderLayerBackend,\n    SliceViewChunkSourceBackend\n  >[][],\n) {\n  for (const scales of allSources) {\n    for (const tsource of scales) {\n      tsource.source.dispose();\n    }\n  }\n}\n\nconst SliceViewIntermediateBase = withSharedVisibility(\n  withChunkManager(SliceViewCounterpartBase),\n);\n@registerSharedObject(SLICEVIEW_RPC_ID)\nexport class SliceViewBackend extends SliceViewIntermediateBase {\n  velocityEstimator = new VelocityEstimator();\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateVisibleChunks();\n      }),\n    );\n    this.registerDisposer(\n      this.projectionParameters.changed.add(() => {\n        this.velocityEstimator.addSample(\n          this.projectionParameters.value.globalPosition,\n        );\n      }),\n    );\n  }\n\n  invalidateVisibleChunks() {\n    super.invalidateVisibleChunks();\n    this.chunkManager.scheduleUpdateChunkPriorities();\n  }\n\n  handleLayerChanged = () => {\n    this.chunkManager.scheduleUpdateChunkPriorities();\n  };\n\n  updateVisibleChunks() {\n    const projectionParameters = this.projectionParameters.value;\n    const chunkManager = this.chunkManager;\n    const visibility = this.visibility.value;\n    if (visibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    this.updateVisibleSources();\n    const { centerDataPosition } = projectionParameters;\n    const priorityTier = getPriorityTier(visibility);\n    let basePriority = getBasePriority(visibility);\n    basePriority += BASE_PRIORITY;\n\n    const localCenter = tempCenter;\n\n    const chunkSize = tempChunkSize;\n\n    const curVisibleChunks: SliceViewChunk[] = [];\n    this.velocityEstimator.addSample(\n      this.projectionParameters.value.globalPosition,\n    );\n    for (const [layer, visibleLayerSources] of this.visibleLayers) {\n      chunkManager.registerLayer(layer);\n      const { visibleSources } = visibleLayerSources;\n      for (\n        let i = 0, numVisibleSources = visibleSources.length;\n        i < numVisibleSources;\n        ++i\n      ) {\n        const tsource = visibleSources[i];\n        const prefetchOffsets = chunkManager.queueManager.enablePrefetch.value\n          ? getPrefetchChunkOffsets(this.velocityEstimator, tsource)\n          : [];\n        const { chunkLayout } = tsource;\n        chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);\n        const { size, finiteRank } = chunkLayout;\n        vec3.copy(chunkSize, size);\n        for (let i = finiteRank; i < 3; ++i) {\n          chunkSize[i] = 0;\n          localCenter[i] = 0;\n        }\n        const priorityIndex = i;\n        const sourceBasePriority =\n          basePriority + SCALE_PRIORITY_MULTIPLIER * priorityIndex;\n        curVisibleChunks.length = 0;\n        const curMarkGeneration = getNextMarkGeneration();\n        forEachPlaneIntersectingVolumetricChunk(\n          projectionParameters,\n          tsource.renderLayer.localPosition.value,\n          tsource,\n          getNormalizedChunkLayout(projectionParameters, tsource.chunkLayout),\n          (positionInChunks) => {\n            vec3.multiply(tempChunkPosition, positionInChunks, chunkSize);\n            const priority = -vec3.distance(localCenter, tempChunkPosition);\n            const { curPositionInChunks } = tsource;\n            const chunk = tsource.source.getChunk(curPositionInChunks);\n            chunkManager.requestChunk(\n              chunk,\n              priorityTier,\n              sourceBasePriority + priority,\n            );\n            ++layer.numVisibleChunksNeeded;\n            if (chunk.state === ChunkState.GPU_MEMORY) {\n              ++layer.numVisibleChunksAvailable;\n            }\n            curVisibleChunks.push(chunk);\n            // Mark visible chunks to avoid duplicate work when prefetching.  Once we hit a\n            // visible chunk, we don't continue prefetching in the same direction.\n            chunk.markGeneration = curMarkGeneration;\n          },\n        );\n        if (prefetchOffsets.length !== 0) {\n          const { curPositionInChunks } = tsource;\n          for (const visibleChunk of curVisibleChunks) {\n            curPositionInChunks.set(visibleChunk.chunkGridPosition);\n            for (let j = 0, length = prefetchOffsets.length; j < length; ) {\n              const chunkDim = prefetchOffsets[j];\n              const minChunk = prefetchOffsets[j + 2];\n              const maxChunk = prefetchOffsets[j + 3];\n              const newPriority = prefetchOffsets[j + 4];\n              const jumpOffset = prefetchOffsets[j + 5];\n              const oldIndex = curPositionInChunks[chunkDim];\n              const newIndex = oldIndex + prefetchOffsets[j + 1];\n              if (newIndex < minChunk || newIndex > maxChunk) {\n                j = jumpOffset;\n                continue;\n              }\n              curPositionInChunks[chunkDim] = newIndex;\n              const chunk = tsource.source.getChunk(curPositionInChunks);\n              curPositionInChunks[chunkDim] = oldIndex;\n              if (chunk.markGeneration === curMarkGeneration) {\n                j = jumpOffset;\n                continue;\n              }\n              chunkManager.requestChunk(\n                chunk,\n                ChunkPriorityTier.PREFETCH,\n                sourceBasePriority + newPriority,\n              );\n              ++layer.numPrefetchChunksNeeded;\n              if (chunk.state === ChunkState.GPU_MEMORY) {\n                ++layer.numPrefetchChunksAvailable;\n              }\n              j += PREFETCH_ENTRY_SIZE;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  removeVisibleLayer(layer: SliceViewRenderLayerBackend) {\n    const { visibleLayers } = this;\n    const layerInfo = visibleLayers.get(layer)!;\n    visibleLayers.delete(layer);\n    disposeTransformedSources(layerInfo.allSources);\n    layer.renderScaleTarget.changed.remove(this.invalidateVisibleSources);\n    layer.localPosition.changed.remove(this.handleLayerChanged);\n    this.invalidateVisibleSources();\n  }\n\n  addVisibleLayer(\n    layer: SliceViewRenderLayerBackend,\n    allSources: TransformedSource<\n      SliceViewRenderLayerBackend,\n      SliceViewChunkSourceBackend\n    >[][],\n    displayDimensionRenderInfo: DisplayDimensionRenderInfo,\n  ) {\n    let layerInfo = this.visibleLayers.get(layer);\n    if (layerInfo === undefined) {\n      layerInfo = {\n        allSources,\n        visibleSources: [],\n        displayDimensionRenderInfo: displayDimensionRenderInfo,\n      };\n      this.visibleLayers.set(layer, layerInfo);\n      layer.renderScaleTarget.changed.add(() =>\n        this.invalidateVisibleSources(),\n      );\n      layer.localPosition.changed.add(this.handleLayerChanged);\n    } else {\n      disposeTransformedSources(layerInfo.allSources);\n      layerInfo.allSources = allSources;\n      layerInfo.visibleSources.length = 0;\n      layerInfo.displayDimensionRenderInfo = displayDimensionRenderInfo;\n    }\n    this.invalidateVisibleSources();\n  }\n\n  disposed() {\n    for (const layer of this.visibleLayers.keys()) {\n      this.removeVisibleLayer(layer);\n    }\n    super.disposed();\n  }\n\n  invalidateVisibleSources() {\n    super.invalidateVisibleSources();\n    this.chunkManager.scheduleUpdateChunkPriorities();\n  }\n}\n\nexport function deserializeTransformedSources<\n  Source extends SliceViewChunkSourceBackend,\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n>(rpc: RPC, serializedSources: any[][], layer: any) {\n  const sources = serializedSources.map((scales) =>\n    scales.map((serializedSource): TransformedSource<RLayer, Source> => {\n      const source = rpc.getRef<Source>(serializedSource.source);\n      const chunkLayout = serializedSource.chunkLayout;\n      const { rank } = source.spec;\n      const tsource: TransformedSource<RLayer, Source> = {\n        renderLayer: layer,\n        source,\n        chunkLayout: ChunkLayout.fromObject(chunkLayout),\n        layerRank: serializedSource.layerRank,\n        nonDisplayLowerClipBound: serializedSource.nonDisplayLowerClipBound,\n        nonDisplayUpperClipBound: serializedSource.nonDisplayUpperClipBound,\n        lowerClipBound: serializedSource.lowerClipBound,\n        upperClipBound: serializedSource.upperClipBound,\n        lowerClipDisplayBound: serializedSource.lowerClipDisplayBound,\n        upperClipDisplayBound: serializedSource.upperClipDisplayBound,\n        lowerChunkDisplayBound: serializedSource.lowerChunkDisplayBound,\n        upperChunkDisplayBound: serializedSource.upperChunkDisplayBound,\n        effectiveVoxelSize: serializedSource.effectiveVoxelSize,\n        chunkDisplayDimensionIndices:\n          serializedSource.chunkDisplayDimensionIndices,\n        fixedLayerToChunkTransform: serializedSource.fixedLayerToChunkTransform,\n        combinedGlobalLocalToChunkTransform:\n          serializedSource.combinedGlobalLocalToChunkTransform,\n        curPositionInChunks: new Float32Array(rank),\n        fixedPositionWithinChunk: new Uint32Array(rank),\n      };\n      return tsource;\n    }),\n  );\n  return sources;\n}\nregisterRPC(SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID, function (x) {\n  const obj = <SliceViewBackend>this.get(x.id);\n  const layer = <SliceViewRenderLayerBackend>this.get(x.layerId);\n  const sources = deserializeTransformedSources<\n    SliceViewChunkSourceBackend,\n    SliceViewRenderLayerBackend\n  >(this, x.sources, layer);\n  obj.addVisibleLayer(layer, sources, x.displayDimensionRenderInfo);\n});\nregisterRPC(SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID, function (x) {\n  const obj = <SliceViewBackend>this.get(x.id);\n  const layer = <SliceViewRenderLayerBackend>this.get(x.layerId);\n  obj.removeVisibleLayer(layer);\n});\n\nexport class SliceViewChunk extends Chunk {\n  chunkGridPosition: Float32Array;\n  source: SliceViewChunkSourceBackend | null = null;\n\n  initializeVolumeChunk(key: string, chunkGridPosition: Float32Array) {\n    super.initialize(key);\n    this.chunkGridPosition = Float32Array.from(chunkGridPosition);\n  }\n\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    msg.chunkGridPosition = this.chunkGridPosition;\n  }\n\n  downloadSucceeded() {\n    super.downloadSucceeded();\n  }\n\n  freeSystemMemory() {}\n\n  toString() {\n    return this.source!.toString() + \":\" + vec3Key(this.chunkGridPosition);\n  }\n}\n\nexport interface SliceViewChunkSourceBackend<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Spec extends SliceViewChunkSpecification = SliceViewChunkSpecification,\n  ChunkType extends SliceViewChunk = SliceViewChunk,\n> {\n  // TODO(jbms): Move this declaration to the class definition below and declare abstract once\n  // TypeScript supports mixins with abstact classes.\n  getChunk(chunkGridPosition: vec3): ChunkType;\n\n  chunkConstructor: ChunkConstructor<SliceViewChunk>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class SliceViewChunkSourceBackend<\n    Spec extends SliceViewChunkSpecification = SliceViewChunkSpecification,\n    ChunkType extends SliceViewChunk = SliceViewChunk,\n  >\n  extends ChunkSource\n  implements SliceViewChunkSourceInterface\n{\n  spec: Spec;\n  declare chunks: Map<string, ChunkType>;\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.spec = options.spec;\n  }\n\n  getChunk(chunkGridPosition: Float32Array) {\n    const key = chunkGridPosition.join();\n    let chunk = this.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(this.chunkConstructor) as ChunkType;\n      chunk.initializeVolumeChunk(key, chunkGridPosition);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n}\n\n@registerSharedObject(SLICEVIEW_RENDERLAYER_RPC_ID)\nexport class SliceViewRenderLayerBackend\n  extends SharedObjectCounterpart\n  implements SliceViewRenderLayerInterface, ChunkRenderLayerBackend\n{\n  declare rpcId: number;\n  renderScaleTarget: SharedWatchableValue<number>;\n  localPosition: WatchableValueInterface<Float32Array>;\n\n  numVisibleChunksNeeded: number;\n  numVisibleChunksAvailable: number;\n  numPrefetchChunksNeeded: number;\n  numPrefetchChunksAvailable: number;\n  chunkManagerGeneration: number;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.renderScaleTarget = rpc.get(options.renderScaleTarget);\n    this.localPosition = rpc.get(options.localPosition);\n    this.numVisibleChunksNeeded = 0;\n    this.numVisibleChunksAvailable = 0;\n    this.numPrefetchChunksAvailable = 0;\n    this.numPrefetchChunksNeeded = 0;\n    this.chunkManagerGeneration = -1;\n  }\n\n  filterVisibleSources(\n    sliceView: SliceViewBase,\n    sources: readonly TransformedSource[],\n  ): Iterable<TransformedSource> {\n    return filterVisibleSources(sliceView, this, sources);\n  }\n}\n\nconst PREFETCH_MS = 2000;\nconst MAX_PREFETCH_VELOCITY = 0.1; // voxels per millisecond\nconst MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS = 32; // Maximum number of chunks to prefetch in a single direction.\n\n// If the probability under the model of needing a chunk within `PREFETCH_MS` is less than this\n// probability, skip prefetching it.\nconst PREFETCH_PROBABILITY_CUTOFF = 0.05;\n\nconst PREFETCH_ENTRY_SIZE = 6;\n\nfunction getPrefetchChunkOffsets(\n  velocityEstimator: VelocityEstimator,\n  tsource: TransformedSource,\n): number[] {\n  const offsets: number[] = [];\n  const globalRank = velocityEstimator.rank;\n  const { combinedGlobalLocalToChunkTransform, layerRank } = tsource;\n\n  const { rank: chunkRank, chunkDataSize } = tsource.source.spec;\n  const { mean: meanVec, variance: varianceVec } = velocityEstimator;\n  for (let chunkDim = 0; chunkDim < chunkRank; ++chunkDim) {\n    const isDisplayDimension =\n      tsource.chunkDisplayDimensionIndices.includes(chunkDim);\n    let mean = 0;\n    let variance = 0;\n    for (let globalDim = 0; globalDim < globalRank; ++globalDim) {\n      const meanValue = meanVec[globalDim];\n      const varianceValue = varianceVec[globalDim];\n      const coeff =\n        combinedGlobalLocalToChunkTransform[globalDim * layerRank + chunkDim];\n      mean += coeff * meanValue;\n      variance += coeff * coeff * varianceValue;\n    }\n    if (mean > MAX_PREFETCH_VELOCITY) {\n      continue;\n    }\n    const chunkSize = chunkDataSize[chunkDim];\n    const initialFraction = isDisplayDimension\n      ? 0\n      : tsource.fixedPositionWithinChunk[chunkDim] / chunkSize;\n    const adjustedMean = (mean / chunkSize) * PREFETCH_MS;\n    let adjustedStddevTimesSqrt2 =\n      (Math.sqrt(2 * variance) / chunkSize) * PREFETCH_MS;\n    if (Math.abs(adjustedMean) < 1e-3 && adjustedStddevTimesSqrt2 < 1e-3) {\n      continue;\n    }\n    adjustedStddevTimesSqrt2 = Math.max(1e-6, adjustedStddevTimesSqrt2);\n    const cdf = (x: number) =>\n      0.5 * (1 + erf((x - adjustedMean) / adjustedStddevTimesSqrt2));\n\n    const curChunk = tsource.curPositionInChunks[chunkDim];\n    const minChunk = Math.floor(tsource.lowerClipBound[chunkDim] / chunkSize);\n    const maxChunk =\n      Math.ceil(tsource.upperClipBound[chunkDim] / chunkSize) - 1;\n    let groupStart = offsets.length;\n    for (let i = 1; i <= MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS; ++i) {\n      if (!isDisplayDimension && curChunk + i > maxChunk) break;\n      const probability = 1 - cdf(i - initialFraction);\n      // Probability that chunk `curChunk + i` will be needed within `PREFETCH_MS`.\n      if (probability < PREFETCH_PROBABILITY_CUTOFF) break;\n      offsets.push(chunkDim, i, minChunk, maxChunk, probability, 0);\n    }\n    let newGroupStart = offsets.length;\n    for (\n      let i = groupStart, end = offsets.length;\n      i < end;\n      i += PREFETCH_ENTRY_SIZE\n    ) {\n      offsets[i + PREFETCH_ENTRY_SIZE - 1] = newGroupStart;\n    }\n    groupStart = newGroupStart;\n\n    for (let i = 1; i <= MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS; ++i) {\n      if (!isDisplayDimension && curChunk - i < minChunk) break;\n      const probability = cdf(-i + 1 - initialFraction);\n      // Probability that chunk `curChunk - i` will be needed within `PREFETCH_MS`.\n      if (probability < PREFETCH_PROBABILITY_CUTOFF) break;\n      offsets.push(chunkDim, -i, minChunk, maxChunk, probability, 0);\n    }\n    newGroupStart = offsets.length;\n    for (\n      let i = groupStart, end = offsets.length;\n      i < end;\n      i += PREFETCH_ENTRY_SIZE\n    ) {\n      offsets[i + PREFETCH_ENTRY_SIZE - 1] = newGroupStart;\n    }\n  }\n  return offsets;\n}\n\nregisterPromiseRPC(\n  SLICEVIEW_REQUEST_CHUNK_RPC_ID,\n  async function (\n    x: { this: RPC; source: number; chunkGridPosition: Float32Array },\n    abortSignal: AbortSignal,\n  ): RPCPromise<void> {\n    const source = this.get(x.source) as SliceViewChunkSourceBackend;\n    const { chunkManager } = source;\n    const chunk = source.getChunk(x.chunkGridPosition);\n    const key = chunk.key!;\n    if (chunk.state <= ChunkState.SYSTEM_MEMORY) {\n      // Already available on frontend.\n      return { value: undefined };\n    }\n    if (chunk.state === ChunkState.FAILED) {\n      // Already failed\n      throw chunk.error;\n    }\n    const disposeRecompute = chunkManager.recomputeChunkPriorities.add(() => {\n      chunkManager.requestChunk(\n        chunk,\n        ChunkPriorityTier.VISIBLE,\n        Number.POSITIVE_INFINITY,\n        ChunkState.SYSTEM_MEMORY,\n      );\n    });\n    chunkManager.scheduleUpdateChunkPriorities();\n    let listener: (chunk: Chunk) => void;\n    const promise = new Promise<void>((resolve, reject) => {\n      listener = (chunk) => {\n        if (chunk.state === ChunkState.FAILED) {\n          reject(chunk.error);\n          return;\n        }\n        if (chunk.state <= ChunkState.SYSTEM_MEMORY) {\n          resolve();\n        }\n      };\n    });\n    source.registerChunkListener(key, listener!);\n    try {\n      await raceWithAbort(promise, abortSignal);\n      return { value: undefined };\n    } finally {\n      source.unregisterChunkListener(key, listener!);\n      disposeRecompute();\n      chunkManager.scheduleUpdateChunkPriorities();\n    }\n  },\n);\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Simple implementation of the error function\n *\n * https://en.wikipedia.org/wiki/Error_function\n *\n * Precision is 2.5e-5\n */\nexport function erf(x: number) {\n  // Abramowitz and Stegun. Handbook of Mathematical Functions\n  // Formula 7.1.26\n  // http://people.math.sfu.ca/~cbm/aands/frameindex.htm\n  const a1 = 0.254829592;\n  const a2 = -0.284496736;\n  const a3 = 1.421413741;\n  const a4 = -1.453152027;\n  const a5 = 1.061405429;\n  const p = 0.3275911;\n\n  const t = 1 / (1 + p * Math.abs(x));\n  const y =\n    1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n  return Math.sign(x) * y;\n}\n","/**\n * @license\n * Copyright 2018 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Backend component of PerspectivePanel.  This allows the optional backend component of a\n * PerspectiveViewRenderLayer to set chunk priorities based on the state of the perspective panel.\n */\n\nimport { PERSPECTIVE_VIEW_RPC_ID } from \"#src/perspective_view/base.js\";\nimport type { ProjectionParameters } from \"#src/projection_parameters.js\";\nimport type { RenderedViewBackend } from \"#src/render_layer_backend.js\";\nimport { RenderLayerBackend } from \"#src/render_layer_backend.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\n@registerSharedObject(PERSPECTIVE_VIEW_RPC_ID)\nexport class PerspectiveViewBackend\n  extends SharedObjectCounterpart\n  implements RenderedViewBackend\n{\n  visibility: SharedWatchableValue<number>;\n  projectionParameters: SharedWatchableValue<ProjectionParameters>;\n  constructor(...args: any[]) {\n    super(...args);\n    const rpc: RPC = args[0];\n    const options: any = args[1];\n    this.visibility = rpc.get(options.visibility);\n    this.projectionParameters = rpc.get(options.projectionParameters);\n  }\n}\nexport class PerspectiveViewRenderLayerBackend<\n  AttachmentState = unknown,\n> extends RenderLayerBackend<PerspectiveViewBackend, AttachmentState> {}\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ProjectionParameters } from \"#src/projection_parameters.js\";\nimport type {\n  MultiscaleVolumetricDataRenderLayer,\n  TransformedSource,\n} from \"#src/sliceview/base.js\";\nimport { forEachVisibleVolumetricChunk } from \"#src/sliceview/base.js\";\nimport type { VolumeChunkSource } from \"#src/sliceview/volume/base.js\";\nimport type { vec3 } from \"#src/util/geom.js\";\nimport {\n  getViewFrustrumDepthRange,\n  mat3,\n  mat3FromMat4,\n  prod3,\n} from \"#src/util/geom.js\";\n\nexport const VOLUME_RENDERING_RENDER_LAYER_RPC_ID =\n  \"volume_rendering/VolumeRenderingRenderLayer\";\nexport const VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID =\n  \"volume_rendering/VolumeRenderingRenderLayer/update\";\n\nconst DEBUG_CHUNK_LEVEL = false;\n\nconst tempMat3 = mat3.create();\n// const tempMat4 = mat4.create();\n// const tempVisibleVolumetricClippingPlanes = new Float32Array(24);\n\nexport interface HistogramInformation {\n  spatialScales: Map<number, number>;\n  activeIndex: number;\n}\n\nexport function getVolumeRenderingNearFarBounds(\n  clippingPlanes: Float32Array,\n  displayLowerBound: Float32Array,\n  displayUpperBound: Float32Array,\n) {\n  let volumeMinZ = 0;\n  let volumeMaxZ = 0;\n  for (let i = 0; i < 3; ++i) {\n    const planeCoeff = clippingPlanes[16 + i];\n    const a = planeCoeff * displayLowerBound[i];\n    const b = planeCoeff * displayUpperBound[i];\n    volumeMinZ += Math.min(a, b);\n    volumeMaxZ += Math.max(a, b);\n  }\n  const near = -clippingPlanes[19];\n  const adjustedNear = Math.max(near, volumeMinZ);\n  const far = clippingPlanes[23];\n  const adjustedFar = Math.min(far, volumeMaxZ);\n  return { near, far, adjustedNear, adjustedFar };\n}\n\n// Returns target volume in \"world\" space.\n// function getTargetVolume(\n//     tsource: TransformedSource<MultiscaleVolumetricDataRenderLayer>,\n//     projectionParameters: ProjectionParameters) {\n//   const modelViewProjection = mat4.multiply(\n//       tempMat4, projectionParameters.viewProjectionMat, tsource.chunkLayout.transform);\n//   const clippingPlanes = tempVisibleVolumetricClippingPlanes;\n//   getFrustrumPlanes(clippingPlanes, modelViewProjection);\n//   const {near, far} = getVolumeRenderingNearFarBounds(\n//       clippingPlanes, tsource.lowerClipDisplayBound, tsource.upperClipDisplayBound);\n//   if (near === far) return -1;\n//   const depthRange = (far - near);\n//   const targetSpacing = depthRange / volumeRenderingDepthSamples;\n//   const targetVolume = targetSpacing ** 3;\n//   return targetVolume * tsource.chunkLayout.detTransform;\n// }\n\nexport function forEachVisibleVolumeRenderingChunk<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n  Source extends VolumeChunkSource,\n  Transformed extends TransformedSource<RLayer, Source>,\n>(\n  projectionParameters: ProjectionParameters,\n  localPosition: Float32Array,\n  volumeRenderingDepthSamples: number,\n  transformedSources: readonly Transformed[],\n  beginScale: (\n    source: Transformed,\n    index: number,\n    physicalSpacing: number,\n    optimalSamples: number,\n    clippingPlanes: Float32Array,\n    histogramInformation: HistogramInformation,\n  ) => void,\n  callback: (\n    source: Transformed,\n    index: number,\n    positionInChunks: vec3,\n  ) => void,\n) {\n  if (transformedSources.length === 0) return;\n  const { viewMatrix, projectionMat, displayDimensionRenderInfo } =\n    projectionParameters;\n  const { voxelPhysicalScales } = displayDimensionRenderInfo;\n  const canonicalToPhysicalScale = prod3(voxelPhysicalScales);\n\n  const depthRange = getViewFrustrumDepthRange(projectionMat);\n  // Target voxel spacing in view space\n  const targetViewSpacing = depthRange / volumeRenderingDepthSamples;\n  // Target voxel volume in view space.\n  const targetViewVolume = targetViewSpacing ** 3;\n  const viewDet = mat3.determinant(mat3FromMat4(tempMat3, viewMatrix));\n\n  // Target voxel volume in view space.\n  // const targetViewVolume = getTargetVolume(transformedSources[0], projectionParameters)\n  // *physicalSpacing viewDet;\n\n  const histogramInformation: HistogramInformation = {\n    spatialScales: new Map(),\n    activeIndex: -1,\n  };\n\n  // Returns volume of a single voxel of source `scaleIndex` in \"view\" space.\n  const getViewVolume = (scaleIndex: number) => {\n    const tsource = transformedSources[scaleIndex];\n    return Math.abs(tsource.chunkLayout.detTransform * viewDet);\n  };\n  // Index of high resolution source with voxel volume greater than `targetViewVolume`.\n  // This allows to find the highest resolution source that is not greatly under-sampled.\n  let bestScaleIndex = transformedSources.length - 1;\n  // Voxel volume in \"view\" space of source `bestScaleIndex`.\n  let bestViewVolume = getViewVolume(bestScaleIndex);\n  for (let scaleIndex = bestScaleIndex; scaleIndex >= 0; --scaleIndex) {\n    const viewVolume = getViewVolume(scaleIndex);\n    const physicalSpacing = Math.cbrt(\n      (viewVolume * canonicalToPhysicalScale) / viewDet,\n    );\n    const optimalSamples = depthRange / Math.cbrt(viewVolume);\n    histogramInformation.spatialScales.set(physicalSpacing, optimalSamples);\n    if (viewVolume - targetViewVolume >= 0) {\n      bestViewVolume = viewVolume;\n      bestScaleIndex = scaleIndex;\n    }\n    histogramInformation.activeIndex = bestScaleIndex;\n  }\n\n  if (DEBUG_CHUNK_LEVEL) {\n    console.log(transformedSources);\n    for (\n      let scaleIndex = 0;\n      scaleIndex < transformedSources.length;\n      ++scaleIndex\n    ) {\n      const viewVolume = getViewVolume(scaleIndex);\n      const desiredSamples = depthRange / Math.cbrt(viewVolume);\n      console.log(\n        `scaleIndex=${scaleIndex} viewVolume=${viewVolume} bestScaleIndex=${bestScaleIndex} actualViewVolume=${targetViewVolume}, desiredSamples=${desiredSamples}, difference=${\n          viewVolume - targetViewVolume\n        }`,\n      );\n    }\n  }\n\n  const physicalSpacing = Math.cbrt(\n    (bestViewVolume * canonicalToPhysicalScale) / viewDet,\n  );\n  const optimalSamples = depthRange / Math.cbrt(bestViewVolume);\n  let firstChunk = true;\n  const tsource = transformedSources[bestScaleIndex];\n  forEachVisibleVolumetricChunk(\n    projectionParameters,\n    localPosition,\n    tsource,\n    (positionInChunks, clippingPlanes) => {\n      if (firstChunk) {\n        beginScale(\n          tsource,\n          bestScaleIndex,\n          physicalSpacing,\n          optimalSamples,\n          clippingPlanes,\n          histogramInformation,\n        );\n        firstChunk = false;\n      }\n      callback(tsource, bestScaleIndex, positionInChunks);\n    },\n  );\n}\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { withChunkManager } from \"#src/chunk_manager/backend.js\";\nimport { ChunkState } from \"#src/chunk_manager/base.js\";\nimport {\n  type DisplayDimensionRenderInfo,\n  validateDisplayDimensionRenderInfoProperty,\n} from \"#src/navigation_state.js\";\nimport type {\n  RenderedViewBackend,\n  RenderLayerBackendAttachment,\n} from \"#src/render_layer_backend.js\";\nimport { RenderLayerBackend } from \"#src/render_layer_backend.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport {\n  BASE_PRIORITY,\n  deserializeTransformedSources,\n  SCALE_PRIORITY_MULTIPLIER,\n} from \"#src/sliceview/backend.js\";\nimport type { TransformedSource } from \"#src/sliceview/base.js\";\nimport type { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { vec3 } from \"#src/util/geom.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n} from \"#src/visibility_priority/backend.js\";\nimport {\n  forEachVisibleVolumeRenderingChunk,\n  VOLUME_RENDERING_RENDER_LAYER_RPC_ID,\n  VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID,\n} from \"#src/volume_rendering/base.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport { registerRPC, registerSharedObject } from \"#src/worker_rpc.js\";\n\ninterface VolumeRenderingRenderLayerAttachmentState {\n  displayDimensionRenderInfo: DisplayDimensionRenderInfo;\n  transformedSources: TransformedSource<\n    VolumeRenderingRenderLayerBackend,\n    VolumeChunkSource\n  >[][];\n}\n\nconst tempChunkPosition = vec3.create();\nconst tempCenter = vec3.create();\nconst tempChunkSize = vec3.create();\nconst tempCenterDataPosition = vec3.create();\n\n@registerSharedObject(VOLUME_RENDERING_RENDER_LAYER_RPC_ID)\nclass VolumeRenderingRenderLayerBackend extends withChunkManager(\n  RenderLayerBackend,\n) {\n  localPosition: SharedWatchableValue<Float32Array>;\n  // The render scale target for volume rendering is the number of depth samples\n  renderScaleTarget: SharedWatchableValue<number>;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.renderScaleTarget = rpc.get(options.renderScaleTarget);\n    this.localPosition = rpc.get(options.localPosition);\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    this.registerDisposer(\n      this.localPosition.changed.add(scheduleUpdateChunkPriorities),\n    );\n    this.registerDisposer(\n      this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() =>\n        this.recomputeChunkPriorities(),\n      ),\n    );\n  }\n\n  attach(\n    attachment: RenderLayerBackendAttachment<\n      RenderedViewBackend,\n      VolumeRenderingRenderLayerAttachmentState\n    >,\n  ) {\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    const { view } = attachment;\n    attachment.registerDisposer(scheduleUpdateChunkPriorities);\n    attachment.registerDisposer(\n      view.projectionParameters.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(\n      view.visibility.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.state = {\n      displayDimensionRenderInfo:\n        view.projectionParameters.value.displayDimensionRenderInfo,\n      transformedSources: [],\n    };\n  }\n\n  private recomputeChunkPriorities() {\n    for (const attachment of this.attachments.values()) {\n      const { view } = attachment;\n      const visibility = view.visibility.value;\n      if (visibility === Number.NEGATIVE_INFINITY) {\n        continue;\n      }\n      const state =\n        attachment.state as VolumeRenderingRenderLayerAttachmentState;\n      const { transformedSources } = state;\n\n      if (\n        transformedSources.length === 0 ||\n        !validateDisplayDimensionRenderInfoProperty(\n          state,\n          view.projectionParameters.value.displayDimensionRenderInfo,\n        )\n      ) {\n        continue;\n      }\n\n      const projectionParameters = view.projectionParameters.value;\n      const priorityTier = getPriorityTier(visibility);\n      let basePriority = getBasePriority(visibility);\n      basePriority += BASE_PRIORITY;\n      const localCenter = tempCenter;\n      const chunkSize = tempChunkSize;\n      const centerDataPosition = tempCenterDataPosition;\n      const {\n        globalPosition,\n        displayDimensionRenderInfo: { displayDimensionIndices },\n      } = projectionParameters;\n      for (let displayDim = 0; displayDim < 3; ++displayDim) {\n        const globalDim = displayDimensionIndices[displayDim];\n        centerDataPosition[displayDim] =\n          globalDim === -1 ? 0 : globalPosition[globalDim];\n      }\n      let sourceBasePriority: number;\n      const { chunkManager } = this;\n      chunkManager.registerLayer(this);\n      forEachVisibleVolumeRenderingChunk(\n        projectionParameters,\n        this.localPosition.value,\n        this.renderScaleTarget.value,\n        transformedSources[0],\n        (tsource, scaleIndex) => {\n          const { chunkLayout } = tsource;\n          chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);\n          const { size, finiteRank } = chunkLayout;\n          vec3.copy(chunkSize, size);\n          for (let i = finiteRank; i < 3; ++i) {\n            chunkSize[i] = 0;\n            localCenter[i] = 0;\n          }\n          const priorityIndex = transformedSources[0].length - 1 - scaleIndex;\n          sourceBasePriority =\n            basePriority + SCALE_PRIORITY_MULTIPLIER * priorityIndex;\n        },\n        (tsource, _, positionInChunks) => {\n          vec3.multiply(tempChunkPosition, positionInChunks, chunkSize);\n          const priority = -vec3.distance(localCenter, tempChunkPosition);\n          const chunk = tsource.source.getChunk(tsource.curPositionInChunks);\n          ++this.numVisibleChunksNeeded;\n          chunkManager.requestChunk(\n            chunk,\n            priorityTier,\n            sourceBasePriority + priority,\n          );\n          if (chunk.state === ChunkState.GPU_MEMORY) {\n            ++this.numVisibleChunksAvailable;\n          }\n        },\n      );\n    }\n  }\n}\nVolumeRenderingRenderLayerBackend;\n\nregisterRPC(VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, function (x) {\n  const view = this.get(x.view) as RenderedViewBackend;\n  const layer = this.get(x.layer) as VolumeRenderingRenderLayerBackend;\n  const attachment = layer.attachments.get(\n    view,\n  )! as RenderLayerBackendAttachment<\n    RenderedViewBackend,\n    VolumeRenderingRenderLayerAttachmentState\n  >;\n  attachment.state!.transformedSources = deserializeTransformedSources<\n    VolumeChunkSource,\n    VolumeRenderingRenderLayerBackend\n  >(this, x.sources, layer);\n  attachment.state!.displayDimensionRenderInfo = x.displayDimensionRenderInfo;\n  layer.chunkManager.scheduleUpdateChunkPriorities();\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ProjectionParameters } from \"#src/projection_parameters.js\";\nimport type {\n  MultiscaleVolumetricDataRenderLayer,\n  SliceViewChunkSource,\n  SliceViewChunkSpecification,\n  TransformedSource,\n} from \"#src/sliceview/base.js\";\nimport { forEachVisibleVolumetricChunk } from \"#src/sliceview/base.js\";\nimport {\n  getViewFrustrumVolume,\n  mat3,\n  mat3FromMat4,\n  prod3,\n} from \"#src/util/geom.js\";\n\nexport const ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID =\n  \"annotation.MetadataChunkSource\";\nexport const ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID =\n  \"annotation.GeometryChunkSource\";\nexport const ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID =\n  \"annotation.SubsetGeometryChunkSource\";\nexport const ANNOTATION_REFERENCE_ADD_RPC_ID = \"annotation.reference.add\";\nexport const ANNOTATION_REFERENCE_DELETE_RPC_ID = \"annotation.reference.delete\";\nexport const ANNOTATION_COMMIT_UPDATE_RPC_ID = \"annotation.commit\";\nexport const ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID = \"annotation.commit\";\n\nexport interface AnnotationGeometryChunkSpecification\n  extends SliceViewChunkSpecification {\n  /**\n   * Must equal the `chunkToMultiscaleTransform` in the `SliceViewSingleResolutionSource`.\n   */\n  chunkToMultiscaleTransform: Float32Array;\n\n  /**\n   * Specifies the maximum density of annotations provided by this chunk source, as `limit` per the\n   * chunk volume.  The higher the value, the sooner chunks from this source will be subsampled.  To\n   * disable subsampling completely, set `limit` to 0.\n   */\n  limit: number;\n}\n\nexport const ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID =\n  \"annotation/SpatiallyIndexedRenderLayer\";\nexport const ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID =\n  \"annotation/PerspectiveRenderLayer:updateSources\";\nexport const ANNOTATION_RENDER_LAYER_RPC_ID = \"annotation/RenderLayer\";\nexport const ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID =\n  \"annotation/RenderLayer.updateSegmentation\";\n\nconst tempMat3 = mat3.create();\n\nexport function forEachVisibleAnnotationChunk<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n  Source extends SliceViewChunkSource<AnnotationGeometryChunkSpecification>,\n  Transformed extends TransformedSource<RLayer, Source>,\n>(\n  projectionParameters: ProjectionParameters,\n  localPosition: Float32Array,\n  renderScaleTarget: number,\n  transformedSources: readonly Transformed[],\n  beginScale: (source: Transformed, index: number) => void,\n  callback: (\n    source: Transformed,\n    index: number,\n    drawFraction: number,\n    physicalSpacing: number,\n    pixelSpacing: number,\n  ) => void,\n) {\n  const {\n    displayDimensionRenderInfo,\n    viewMatrix,\n    projectionMat,\n    width,\n    height,\n  } = projectionParameters;\n  const { voxelPhysicalScales } = displayDimensionRenderInfo;\n  const viewDet = Math.abs(\n    mat3.determinant(mat3FromMat4(tempMat3, viewMatrix)),\n  );\n  const canonicalToPhysicalScale = prod3(voxelPhysicalScales);\n  const viewFrustrumVolume =\n    (getViewFrustrumVolume(projectionMat) / viewDet) * canonicalToPhysicalScale;\n\n  if (transformedSources.length === 0) return;\n  const baseSource = transformedSources[0];\n  let sourceVolume =\n    Math.abs(baseSource.chunkLayout.detTransform) * canonicalToPhysicalScale;\n  const { lowerClipDisplayBound, upperClipDisplayBound } = baseSource;\n  for (let i = 0; i < 3; ++i) {\n    sourceVolume *= upperClipDisplayBound[i] - lowerClipDisplayBound[i];\n  }\n\n  const effectiveVolume = Math.min(sourceVolume, viewFrustrumVolume);\n  const viewportArea = width * height;\n  const targetNumAnnotations = viewportArea / renderScaleTarget ** 2;\n  const physicalDensityTarget = targetNumAnnotations / effectiveVolume;\n\n  // Target density in annotations per physical volume.\n  let totalPhysicalDensity = 0;\n  for (\n    let scaleIndex = transformedSources.length - 1;\n    scaleIndex >= 0 && totalPhysicalDensity < physicalDensityTarget;\n    --scaleIndex\n  ) {\n    const transformedSource = transformedSources[scaleIndex];\n    const spec = transformedSource.source\n      .spec as AnnotationGeometryChunkSpecification;\n    const { chunkLayout } = transformedSource;\n    const physicalVolume =\n      prod3(chunkLayout.size) *\n      Math.abs(chunkLayout.detTransform) *\n      canonicalToPhysicalScale;\n    const { limit, rank } = spec;\n    const { nonDisplayLowerClipBound, nonDisplayUpperClipBound } =\n      transformedSource;\n    let sliceFraction = 1;\n    for (let i = 0; i < rank; ++i) {\n      const b = nonDisplayUpperClipBound[i] - nonDisplayLowerClipBound[i];\n      if (Number.isFinite(b)) sliceFraction /= b;\n    }\n    const physicalDensity = (limit * sliceFraction) / physicalVolume;\n\n    let firstChunk = true;\n    const newTotalPhysicalDensity = totalPhysicalDensity + physicalDensity;\n    const totalPhysicalSpacing = (1 / newTotalPhysicalDensity) ** (1 / 3);\n    const totalPixelSpacing = Math.sqrt(\n      viewportArea / (newTotalPhysicalDensity * effectiveVolume),\n    );\n    const desiredCount =\n      ((physicalDensityTarget - totalPhysicalDensity) * physicalVolume) /\n      sliceFraction;\n    const drawFraction = Math.min(1, desiredCount / spec.limit);\n    forEachVisibleVolumetricChunk(\n      projectionParameters,\n      localPosition,\n      transformedSource,\n      () => {\n        if (firstChunk) {\n          beginScale(transformedSource, scaleIndex);\n          firstChunk = false;\n        }\n        callback(\n          transformedSource,\n          scaleIndex,\n          drawFraction,\n          totalPhysicalSpacing,\n          totalPixelSpacing,\n        );\n      },\n    );\n    totalPhysicalDensity = newTotalPhysicalDensity;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Facilities for converting between strings and RGB/RGBA colors.\n */\n\nimport { WatchableValue } from \"#src/trackable_value.js\";\nimport { float32ToString } from \"#src/util/float32_to_string.js\";\nimport { vec3, vec4 } from \"#src/util/geom.js\";\nimport { hexEncodeByte } from \"#src/util/hex.js\";\n\n/**\n * Parse the serialization of a color.\n *\n * This is based on the definition here:\n * https://html.spec.whatwg.org/multipage/canvas.html#serialisation-of-a-color\n */\nexport function parseColorSerialization(x: string) {\n  const rgbaPattern =\n    /^rgba\\(([0-9]+), ([0-9]+), ([0-9]+), (0(?:\\.[0-9]+)?)\\)$/;\n  {\n    const m = x.match(rgbaPattern);\n    if (m !== null) {\n      return [\n        parseInt(m[1], 10),\n        parseInt(m[2], 10),\n        parseInt(m[3], 10),\n        parseFloat(m[4]),\n      ];\n    }\n  }\n  const hexPattern = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/;\n  {\n    const m = x.match(hexPattern);\n    if (m !== null) {\n      return [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 1.0];\n    }\n  }\n  throw new Error(`Invalid serialized color: ${JSON.stringify(x)}.`);\n}\n\nexport function parseRGBAColorSpecification(x: any) {\n  try {\n    if (typeof x !== \"string\") {\n      throw new Error(`Expected string, but received ${JSON.stringify(x)}.`);\n    }\n    const context = document.createElement(\"canvas\").getContext(\"2d\")!;\n    context.fillStyle = x;\n    const result = parseColorSerialization(context.fillStyle);\n    return vec4.fromValues(\n      result[0] / 255,\n      result[1] / 255,\n      result[2] / 255,\n      result[3],\n    );\n  } catch (parseError) {\n    throw new Error(\n      `Failed to parse color specification: ${parseError.message}`,\n    );\n  }\n}\n\nexport function parseRGBColorSpecification(x: any) {\n  const result = parseRGBAColorSpecification(x);\n  return <vec3>result.subarray(0, 3);\n}\n\n/**\n * Returns an integer formed by concatenating the channels of the input color vector.\n * Each channel is clamped to the range [0.0, 1.0] before being converted to 8 bits.\n * An RGB color is packed into 24 bits, and a RGBA into 32 bits.\n */\nexport function packColor(x: vec3 | vec4): number {\n  const size = x[3] === undefined ? 3 : 4;\n  let result = 0;\n  for (let i = 0; i < size; i++) {\n    // The \">>> 0\" ensures an unsigned value.\n    result =\n      ((result << 8) >>> 0) +\n      Math.min(255, Math.max(0, Math.round(x[size - 1 - i] * 255)));\n  }\n  return result;\n}\n\nexport function unpackRGB(value: number) {\n  return vec3.fromValues(\n    ((value >>> 0) & 0xff) / 255,\n    ((value >>> 8) & 0xff) / 255,\n    ((value >>> 16) & 0xff) / 255,\n  );\n}\n\nexport function unpackRGBA(value: number) {\n  return vec4.fromValues(\n    ((value >>> 0) & 0xff) / 255,\n    ((value >>> 8) & 0xff) / 255,\n    ((value >>> 16) & 0xff) / 255,\n    ((value >>> 24) & 0xff) / 255,\n  );\n}\n\nexport function serializeColor(x: vec3 | vec4) {\n  if (x[3] === undefined || x[3] === 1) {\n    let result = \"#\";\n    for (let i = 0; i < 3; ++i) {\n      result += hexEncodeByte(\n        Math.min(255, Math.max(0, Math.round(x[i] * 255))),\n      );\n    }\n    return result;\n  }\n  let result = \"rgba(\";\n  for (let i = 0; i < 3; ++i) {\n    if (i !== 0) {\n      result += \", \";\n    }\n    result += Math.min(255, Math.max(0, Math.round(x[i] * 255)));\n  }\n  result += `, ${float32ToString(x[3])})`;\n  return result;\n}\n\n// Converts an sRGB color component to the gamma-expanded (\"linear\") value.\nexport function srgbGammaExpand(value: number) {\n  return value <= 0.03928 ? value / 12.92 : ((value + 0.055) / 1.055) ** 2.4;\n}\n\n// Computes the relative luminance according to Web Content Accessibility Guidelines (WCAG) 2.0\n//\n// https://www.w3.org/TR/WCAG20/#relativeluminancedef\n//\n// @param color sRGB color\nexport function getRelativeLuminance(color: vec3 | vec4) {\n  const [r, g, b] = color;\n  return (\n    0.2126 * srgbGammaExpand(r) +\n    0.7152 * srgbGammaExpand(g) +\n    0.0722 * srgbGammaExpand(b)\n  );\n}\n\n// Determines whether a white background would provide higher contrast than a black background for\n// the given foreground color.\n//\n// This is determined according to the Web Content Accessibility Guidelines (WCAG) 2.0:\n// https://www.w3.org/TR/WCAG20/#contrast-ratiodef\n//\n// https://stackoverflow.com/a/3943023\nexport function useWhiteBackground(foregroundColor: vec3 | vec4) {\n  return getRelativeLuminance(foregroundColor) <= 0.179;\n}\n\nexport class TrackableRGB extends WatchableValue<vec3> {\n  constructor(public defaultValue: vec3) {\n    super(vec3.clone(defaultValue));\n  }\n  toString() {\n    return serializeColor(this.value);\n  }\n  toJSON() {\n    if (vec3.equals(this.value, this.defaultValue)) {\n      return undefined;\n    }\n    return serializeColor(this.value);\n  }\n  reset() {\n    this.value = vec3.clone(this.defaultValue);\n  }\n  restoreState(x: any) {\n    if (x === undefined) {\n      this.reset();\n      return;\n    }\n    const { value } = this;\n    const newValue = parseRGBColorSpecification(x);\n    if (!vec3.equals(value, newValue)) {\n      this.value = newValue;\n    }\n  }\n}\n\nexport class TrackableOptionalRGB extends WatchableValue<vec3 | undefined> {\n  constructor() {\n    super(undefined);\n  }\n  toJSON() {\n    const { value } = this;\n    if (value === undefined) return undefined;\n    return serializeColor(value);\n  }\n  reset() {\n    this.value = undefined;\n  }\n  restoreState(x: any) {\n    if (x === undefined) {\n      this.reset();\n      return;\n    }\n    const { value } = this;\n    const newValue = parseRGBColorSpecification(x);\n    if (value === undefined || !vec3.equals(value, newValue)) {\n      this.value = newValue;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function hexEncodeByte(x: number) {\n  return (\"0\" + x.toString(16)).slice(-2);\n}\n\nexport function hexEncode(arr: Uint8Array) {\n  return Array.prototype.map.call(arr, hexEncodeByte).join(\"\");\n}\n\nexport function hexDecode(x: string) {\n  if (!/^(?:[0-9a-fA-F]{2})*$/.test(x)) {\n    throw new Error(\"Invalid hex-encoded string\");\n  }\n  const length = x.length / 2;\n  const result = new Uint8Array(length);\n  for (let i = 0; i < length; ++i) {\n    result[i] = parseInt(x.substr(i * 2, 2), 16);\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright 2021 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Endianness, ENDIANNESS } from \"#src/util/endian.js\";\n\nconst denormMin = 2 ** -1074;\n\nconst float64Buf = new Float64Array(1);\nconst uint32Buf = new Uint32Array(float64Buf.buffer);\n\n// The following implementation is derived from:\n// https://github.com/scijs/nextafter/\n//\n// and is subject to the following license:\n//\n// The MIT License (MIT)\n//\n// Copyright (c) 2013 Mikola Lysenko\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Like the C standard library `nextafter` function, returns the next representable JavaScript\n// number (float64) after `x` in the direction of `y`.  Returns `y` if `x === y`.\nexport function nextAfterFloat64(x: number, y: number) {\n  if (Number.isNaN(x) || Number.isNaN(y)) return NaN;\n  if (x === y) return y;\n  if (x === 0) {\n    return y < 0 ? -denormMin : denormMin;\n  }\n  float64Buf[0] = x;\n  const lowIndex = ENDIANNESS === Endianness.LITTLE ? 0 : 1;\n  const highIndex = 1 - lowIndex;\n  if (y > x === x > 0) {\n    if (uint32Buf[lowIndex] === 0xffffffff) {\n      uint32Buf[lowIndex] = 0;\n      uint32Buf[highIndex] += 1;\n    } else {\n      uint32Buf[lowIndex] += 1;\n    }\n  } else {\n    if (uint32Buf[lowIndex] === 0) {\n      uint32Buf[lowIndex] = 0xffffffff;\n      uint32Buf[highIndex] -= 1;\n    } else {\n      uint32Buf[lowIndex] -= 1;\n    }\n  }\n  return float64Buf[0];\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TypedArray } from \"#src/util/array.js\";\n\nexport function getRandomHexString(numBits = 128) {\n  const numValues = Math.ceil(numBits / 32);\n  const data = new Uint32Array(numValues);\n  crypto.getRandomValues(data);\n  let s = \"\";\n  for (let i = 0; i < numValues; ++i) {\n    s += (\"00000000\" + data[i].toString(16)).slice(-8);\n  }\n  return s;\n}\n\n/**\n * Calls crypto.getRandomValues as many times as needed to fill array.\n */\nexport function getRandomValues<T extends TypedArray>(array: T): T {\n  const byteArray = new Uint8Array(\n    array.buffer,\n    array.byteOffset,\n    array.byteLength,\n  );\n  const blockSize = 65536;\n  for (let i = 0, length = byteArray.length; i < length; i += blockSize) {\n    crypto.getRandomValues(\n      byteArray.subarray(i, Math.min(length, i + blockSize)),\n    );\n  }\n  return array;\n}\n\nexport function getRandomUint32() {\n  const data = new Uint32Array(1);\n  crypto.getRandomValues(data);\n  return data[0];\n}\n","/**\n * @license\n * Copyright 2021 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataType } from \"#src/util/data_type.js\";\nimport { nextAfterFloat64 } from \"#src/util/float.js\";\nimport { parseFixedLengthArray } from \"#src/util/json.js\";\nimport { Uint64 } from \"#src/util/uint64.js\";\n\nexport type DataTypeInterval = [number, number] | [Uint64, Uint64];\n\nexport type UnknownDataTypeInterval = [number | Uint64, number | Uint64];\n\nexport const defaultDataTypeRange: Record<DataType, DataTypeInterval> = {\n  [DataType.UINT8]: [0, 0xff],\n  [DataType.INT8]: [-0x80, 0x7f],\n  [DataType.UINT16]: [0, 0xffff],\n  [DataType.INT16]: [-0x8000, 0x7fff],\n  [DataType.UINT32]: [0, 0xffffffff],\n  [DataType.INT32]: [-0x80000000, 0x7fffffff],\n  [DataType.UINT64]: [Uint64.ZERO, new Uint64(0xffffffff, 0xffffffff)],\n  [DataType.FLOAT32]: [0, 1],\n};\n\n/**\n * Compute inverse linear interpolation on the interval [0, 1].\n * @param range Values at start and end of interval.\n * @param value Value to interpolate at.\n * @returns Coordinate of interpolated point.\n */\nexport function computeInvlerp(\n  range: DataTypeInterval,\n  value: number | Uint64,\n): number {\n  if (typeof value === \"number\") {\n    const minValue = range[0] as number;\n    const maxValue = range[1] as number;\n    return (value - minValue) / (maxValue - minValue);\n  }\n  const minValue = range[0] as Uint64;\n  const maxValue = range[1] as Uint64;\n  let numerator: number;\n  if (Uint64.compare(value, minValue) < 0) {\n    numerator = -Uint64.subtract(tempUint64, minValue, value).toNumber();\n  } else {\n    numerator = Uint64.subtract(tempUint64, value, minValue).toNumber();\n  }\n  let denominator = Uint64.absDifference(\n    tempUint64,\n    maxValue,\n    minValue,\n  ).toNumber();\n  if (Uint64.compare(minValue, maxValue) > 0) denominator *= -1;\n  return numerator / denominator;\n}\n\n/**\n * Compute linear interpolation on the interval [0, 1].\n * @param range Values at start and end of interval.\n * @param dataType\n * @param value Coordinate to interpolate at.\n * @returns Interpolated value.\n */\nexport function computeLerp(\n  range: DataTypeInterval,\n  dataType: DataType,\n  value: number,\n): number | Uint64 {\n  if (typeof range[0] === \"number\") {\n    const minValue = range[0] as number;\n    const maxValue = range[1] as number;\n    let result = minValue * (1 - value) + maxValue * value;\n    if (dataType !== DataType.FLOAT32) {\n      const dataTypeRange = defaultDataTypeRange[dataType];\n      result = Math.round(result);\n      result = Math.max(dataTypeRange[0] as number, result);\n      result = Math.min(dataTypeRange[1] as number, result);\n    }\n    return result;\n  }\n  let minValue = range[0] as Uint64;\n  let maxValue = range[1] as Uint64;\n  if (Uint64.compare(minValue, maxValue) > 0) {\n    [minValue, maxValue] = [maxValue, minValue];\n    value = 1 - value;\n  }\n  const scalar = Uint64.subtract(tempUint64, maxValue, minValue).toNumber();\n  const result = new Uint64();\n  if (value <= 0) {\n    tempUint64.setFromNumber(scalar * -value);\n    Uint64.subtract(result, minValue, Uint64.min(tempUint64, minValue));\n  } else if (value >= 1) {\n    tempUint64.setFromNumber(scalar * (value - 1));\n    Uint64.add(result, maxValue, tempUint64);\n    if (Uint64.less(result, maxValue)) {\n      result.low = result.high = 0xffffffff;\n    }\n  } else {\n    tempUint64.setFromNumber(scalar * value);\n    Uint64.add(result, minValue, tempUint64);\n    if (Uint64.less(result, minValue)) {\n      result.low = result.high = 0xffffffff;\n    }\n  }\n  return result;\n}\n\nexport function clampToInterval(\n  range: DataTypeInterval,\n  value: number | Uint64,\n): number | Uint64 {\n  if (typeof value === \"number\") {\n    return Math.min(Math.max(range[0] as number, value), range[1] as number);\n  }\n  return Uint64.min(Uint64.max(range[0] as Uint64, value), range[1] as Uint64);\n}\n\nexport function getClampedInterval(\n  bounds: DataTypeInterval,\n  range: DataTypeInterval,\n): DataTypeInterval {\n  return [\n    clampToInterval(bounds, range[0]),\n    clampToInterval(bounds, range[1]),\n  ] as DataTypeInterval;\n}\n\n// Validates that the lower bound is <= the upper bound.\nexport function validateDataTypeInterval(\n  interval: DataTypeInterval,\n): DataTypeInterval {\n  if (dataTypeCompare(interval[0], interval[1]) <= 0) return interval;\n  throw new Error(`Invalid interval: [${interval[0]}, ${interval[1]}]`);\n}\n\n// Ensures the lower bound is <= the upper bound.\nexport function normalizeDataTypeInterval(\n  interval: DataTypeInterval,\n): DataTypeInterval {\n  if (dataTypeCompare(interval[0], interval[1]) <= 0) return interval;\n  return [interval[1], interval[0]] as DataTypeInterval;\n}\n\nexport function dataTypeCompare(a: number | Uint64, b: number | Uint64) {\n  if (typeof a === \"number\") {\n    return (a as number) - (b as number);\n  }\n  return Uint64.compare(a as Uint64, b as Uint64);\n}\n\nconst tempUint64 = new Uint64();\nconst temp2Uint64 = new Uint64();\n\nexport function getClosestEndpoint(\n  range: DataTypeInterval,\n  value: number | Uint64,\n): number {\n  if (typeof value === \"number\") {\n    return Math.abs(value - (range[0] as number)) <\n      Math.abs(value - (range[1] as number))\n      ? 0\n      : 1;\n  }\n  return Uint64.less(\n    Uint64.absDifference(tempUint64, range[0] as Uint64, value as Uint64),\n    Uint64.absDifference(temp2Uint64, range[1] as Uint64, value as Uint64),\n  )\n    ? 0\n    : 1;\n}\n\nexport function parseDataTypeValue(\n  dataType: DataType,\n  x: unknown,\n): number | Uint64 {\n  let s: string;\n  if (typeof x !== \"string\") {\n    s = \"\" + x;\n  } else {\n    s = x;\n  }\n  switch (dataType) {\n    case DataType.UINT64:\n      return Uint64.parseString(s);\n    case DataType.FLOAT32: {\n      const value = parseFloat(s);\n      if (!Number.isFinite(value)) {\n        throw new Error(`Invalid float32 value: ${JSON.stringify(s)}`);\n      }\n      return value;\n    }\n    default: {\n      const value = parseInt(s);\n      const dataTypeRange = defaultDataTypeRange[dataType];\n      if (\n        !Number.isInteger(value) ||\n        value < (dataTypeRange[0] as number) ||\n        value > (dataTypeRange[1] as number)\n      ) {\n        throw new Error(\n          `Invalid ${DataType[dataType].toLowerCase()} value: ${JSON.stringify(\n            s,\n          )}`,\n        );\n      }\n      return value;\n    }\n  }\n}\n\nexport function parseUnknownDataTypeValue(x: unknown): number | Uint64 {\n  if (typeof x === \"number\") return x;\n  if (typeof x === \"string\") {\n    const num64 = new Uint64();\n    const num = Number(x);\n    if (num64.tryParseString(x)) {\n      if (num.toString() === num64.toString()) {\n        return num;\n      }\n      return num64;\n    }\n    if (!Number.isFinite(num)) {\n      throw new Error(`Invalid value: ${JSON.stringify(x)}`);\n    }\n    return num;\n  }\n  throw new Error(`Invalid value: ${JSON.stringify(x)}`);\n}\n\nexport function parseDataTypeInterval(\n  obj: unknown,\n  dataType: DataType,\n): DataTypeInterval {\n  return parseFixedLengthArray(new Array(2), obj, (x) =>\n    parseDataTypeValue(dataType, x),\n  ) as DataTypeInterval;\n}\n\nexport function parseUnknownDataTypeInterval(\n  obj: unknown,\n): UnknownDataTypeInterval {\n  return parseFixedLengthArray(new Array(2), obj, (x) =>\n    parseUnknownDataTypeValue(x),\n  ) as UnknownDataTypeInterval;\n}\n\nexport function dataTypeIntervalEqual(\n  dataType: DataType,\n  a: DataTypeInterval,\n  b: DataTypeInterval,\n) {\n  if (dataType === DataType.UINT64) {\n    return (\n      Uint64.equal(a[0] as Uint64, b[0] as Uint64) &&\n      Uint64.equal(a[1] as Uint64, b[1] as Uint64)\n    );\n  }\n  return a[0] === b[0] && a[1] === b[1];\n}\n\nexport function dataTypeIntervalToJson(\n  range: DataTypeInterval,\n  dataType: DataType,\n  defaultRange = defaultDataTypeRange[dataType],\n) {\n  if (dataTypeIntervalEqual(dataType, range, defaultRange)) return undefined;\n  if (dataType === DataType.UINT64) {\n    return [range[0].toString(), range[1].toString()];\n  }\n  return range;\n}\n\nexport function dataTypeValueNextAfter(\n  dataType: DataType,\n  value: number | Uint64,\n  sign: 1 | -1,\n): number | Uint64 {\n  switch (dataType) {\n    case DataType.FLOAT32:\n      return nextAfterFloat64(value as number, sign * Infinity);\n    case DataType.UINT64: {\n      const v = value as Uint64;\n      if (sign === -1) {\n        if (v.low === 0 && v.high === 0) return v;\n        return Uint64.decrement(new Uint64(), v);\n      }\n      if (v.low === 0xffffffff && v.high === 0xffffffff) return v;\n      return Uint64.increment(new Uint64(), v);\n    }\n    default: {\n      const range = defaultDataTypeRange[dataType] as [number, number];\n      return Math.max(range[0], Math.min(range[1], (value as number) + sign));\n    }\n  }\n}\n\n// Returns the offset such that within the floating point range `[-offset, 1+offset]`, there is an\n// equal-sized interval corresponding to each number in `interval`.\n//\n// For dataType=FLOAT32, always returns 0.  For integer data types, returns:\n//\n//   0.5 / (1 + abs(interval[1] - interval[0]))\nexport function getIntervalBoundsEffectiveOffset(\n  dataType: DataType,\n  interval: DataTypeInterval,\n) {\n  switch (dataType) {\n    case DataType.FLOAT32:\n      return 0;\n    case DataType.UINT64:\n      return (\n        0.5 /\n        Uint64.absDifference(\n          tempUint64,\n          interval[0] as Uint64,\n          interval[1] as Uint64,\n        ).toNumber()\n      );\n    default:\n      return 0.5 / Math.abs((interval[0] as number) - (interval[1] as number));\n  }\n}\n\nexport function getIntervalBoundsEffectiveFraction(\n  dataType: DataType,\n  interval: DataTypeInterval,\n) {\n  switch (dataType) {\n    case DataType.FLOAT32:\n      return 1;\n    case DataType.UINT64: {\n      const diff = Uint64.absDifference(\n        tempUint64,\n        interval[0] as Uint64,\n        interval[1] as Uint64,\n      ).toNumber();\n      return diff / (diff + 1);\n    }\n    default: {\n      const diff = Math.abs((interval[0] as number) - (interval[1] as number));\n      return diff / (diff + 1);\n    }\n  }\n}\n\nexport function convertDataTypeInterval(\n  interval: UnknownDataTypeInterval | undefined,\n  dataType: DataType,\n): DataTypeInterval {\n  if (interval === undefined) {\n    return defaultDataTypeRange[dataType];\n  }\n  let [lower, upper] = interval;\n  if (dataType === DataType.UINT64) {\n    if (typeof lower === \"number\") {\n      lower = Uint64.fromNumber(lower);\n    }\n    if (typeof upper === \"number\") {\n      upper = Uint64.fromNumber(upper);\n    }\n    return [lower, upper];\n  }\n  // Ensure that neither lower nor upper is a `Uint64`.\n  if (typeof lower !== \"number\") {\n    lower = lower.toNumber();\n  }\n  if (typeof upper !== \"number\") {\n    upper = upper.toNumber();\n  }\n  if (dataType !== DataType.FLOAT32) {\n    lower = Math.round(lower);\n    upper = Math.round(upper);\n    const range = defaultDataTypeRange[dataType] as [number, number];\n    if (!Number.isFinite(lower)) {\n      lower = range[0];\n    } else {\n      lower = Math.min(Math.max(range[0], lower), range[1]);\n    }\n    if (!Number.isFinite(upper)) {\n      upper = range[1];\n    } else {\n      upper = Math.min(Math.max(range[0], upper), range[1]);\n    }\n  }\n  return [lower, upper];\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { VisibleSegmentEquivalencePolicy } from \"#src/segmentation_graph/segment_id.js\";\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { DisjointUint64Sets } from \"#src/util/disjoint_sets.js\";\nimport { parseArray } from \"#src/util/json.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\nimport { Uint64 } from \"#src/util/uint64.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nconst RPC_TYPE_ID = \"DisjointUint64Sets\";\nconst ADD_METHOD_ID = \"DisjointUint64Sets.add\";\nconst CLEAR_METHOD_ID = \"DisjointUint64Sets.clear\";\nconst HIGH_BIT_REPRESENTATIVE_CHANGED_ID =\n  \"DisjointUint64Sets.highBitRepresentativeChanged\";\nconst DELETE_SET_METHOD_ID = \"DisjointUint64Sets.deleteSet\";\n\n@registerSharedObject(RPC_TYPE_ID)\nexport class SharedDisjointUint64Sets\n  extends SharedObjectCounterpart\n  implements WatchableValueInterface<SharedDisjointUint64Sets>\n{\n  disjointSets = new DisjointUint64Sets();\n  changed = new NullarySignal();\n\n  /**\n   * For compatibility with `WatchableValueInterface`.\n   */\n  get value() {\n    return this;\n  }\n\n  static makeWithCounterpart(\n    rpc: RPC,\n    highBitRepresentative: WatchableValueInterface<VisibleSegmentEquivalencePolicy>,\n  ) {\n    const obj = new SharedDisjointUint64Sets();\n    obj.disjointSets.visibleSegmentEquivalencePolicy = highBitRepresentative;\n    obj.registerDisposer(\n      highBitRepresentative.changed.add(() => {\n        updateHighBitRepresentative(obj);\n      }),\n    );\n    obj.initializeCounterpart(rpc);\n    if (highBitRepresentative.value) {\n      updateHighBitRepresentative(obj);\n    }\n    return obj;\n  }\n\n  link(a: Uint64, b: Uint64) {\n    if (this.disjointSets.link(a, b)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(ADD_METHOD_ID, {\n          id: this.rpcId,\n          al: a.low,\n          ah: a.high,\n          bl: b.low,\n          bh: b.high,\n        });\n      }\n      this.changed.dispatch();\n      return true;\n    }\n    return false;\n  }\n\n  linkAll(ids: Uint64[]) {\n    for (let i = 1, length = ids.length; i < length; ++i) {\n      this.link(ids[0], ids[i]);\n    }\n  }\n\n  has(x: Uint64): boolean {\n    return this.disjointSets.has(x);\n  }\n\n  get(x: Uint64): Uint64 {\n    return this.disjointSets.get(x);\n  }\n\n  clear() {\n    if (this.disjointSets.clear()) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(CLEAR_METHOD_ID, { id: this.rpcId });\n      }\n      this.changed.dispatch();\n    }\n  }\n\n  setElements(a: Uint64) {\n    return this.disjointSets.setElements(a);\n  }\n\n  deleteSet(x: Uint64) {\n    if (this.disjointSets.deleteSet(x)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(DELETE_SET_METHOD_ID, {\n          id: this.rpcId,\n          l: x.low,\n          h: x.high,\n        });\n      }\n      this.changed.dispatch();\n    }\n  }\n\n  get size() {\n    return this.disjointSets.size;\n  }\n\n  toJSON() {\n    return this.disjointSets.toJSON();\n  }\n\n  /**\n   * Restores the state from a JSON representation.\n   */\n  restoreState(obj: any) {\n    if (obj !== undefined) {\n      const ids = [new Uint64(), new Uint64()];\n      parseArray(obj, (z) => {\n        parseArray(z, (s, index) => {\n          ids[index % 2].parseString(String(s), 10);\n          if (index !== 0) {\n            this.link(ids[0], ids[1]);\n          }\n        });\n      });\n    }\n  }\n\n  assignFrom(other: SharedDisjointUint64Sets | DisjointUint64Sets) {\n    this.clear();\n    if (other instanceof SharedDisjointUint64Sets) {\n      other = other.disjointSets;\n    }\n    for (const [a, b] of other) {\n      this.link(a, b);\n    }\n  }\n}\n\nconst tempA = new Uint64();\nconst tempB = new Uint64();\n\nregisterRPC(ADD_METHOD_ID, function (x) {\n  const obj = <SharedDisjointUint64Sets>this.get(x.id);\n  tempA.low = x.al;\n  tempA.high = x.ah;\n  tempB.low = x.bl;\n  tempB.high = x.bh;\n  if (obj.disjointSets.link(tempA, tempB)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(CLEAR_METHOD_ID, function (x) {\n  const obj = <SharedDisjointUint64Sets>this.get(x.id);\n  if (obj.disjointSets.clear()) {\n    obj.changed.dispatch();\n  }\n});\n\nfunction updateHighBitRepresentative(obj: SharedDisjointUint64Sets) {\n  obj.rpc!.invoke(HIGH_BIT_REPRESENTATIVE_CHANGED_ID, {\n    id: obj.rpcId,\n    value: obj.disjointSets.visibleSegmentEquivalencePolicy.value,\n  });\n}\n\nregisterRPC(HIGH_BIT_REPRESENTATIVE_CHANGED_ID, function (x) {\n  const obj = this.get(x.id) as SharedDisjointUint64Sets;\n  obj.disjointSets.visibleSegmentEquivalencePolicy.value = x.value;\n});\n\nregisterRPC(DELETE_SET_METHOD_ID, function (x) {\n  const obj = <SharedDisjointUint64Sets>this.get(x.id);\n  tempA.low = x.l;\n  tempA.high = x.h;\n  if (obj.disjointSets.deleteSet(tempA)) {\n    obj.changed.dispatch();\n  }\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { hashCombine } from \"#src/gpu_hash/hash_function.js\";\nimport { getRandomValues } from \"#src/util/random.js\";\nimport { Uint64 } from \"#src/util/uint64.js\";\n\nexport const NUM_ALTERNATIVES = 3;\n\n// For 3 hash functions, a DEFAULT_LOAD_FACTOR of 0.8 reliably avoids\n// expensive rehashing caused by unresolvable collisions.\nconst DEFAULT_LOAD_FACTOR = 0.8;\n\nconst DEBUG = false;\n\n// Key that needs to be inserted.  Temporary variables used during insert.  These can safely be\n// global because control never leaves functions defined in this module while these are in use.\nlet pendingLow = 0;\nlet pendingHigh = 0;\nlet backupPendingLow = 0;\nlet backupPendingHigh = 0;\n\nexport abstract class HashTableBase {\n  loadFactor = DEFAULT_LOAD_FACTOR;\n  size = 0;\n  table: Uint32Array;\n  tableSize: number;\n  emptyLow = 4294967295;\n  emptyHigh = 4294967295;\n  maxRehashAttempts = 5;\n  maxAttempts = 5;\n  capacity: number;\n\n  /**\n   * Number of uint32 elements per entry in hash table.\n   */\n  declare entryStride: number;\n\n  generation = 0;\n\n  mungedEmptyKey = -1;\n\n  constructor(\n    public hashSeeds = HashTableBase.generateHashSeeds(NUM_ALTERNATIVES),\n  ) {\n    // Minimum size must be greater than 2 * hashSeeds.length.  Otherwise, tableWithMungedEmptyKey\n    // may loop infinitely.\n    let initialSize = 8;\n    while (initialSize < 2 * hashSeeds.length) {\n      initialSize *= 2;\n    }\n    this.allocate(initialSize);\n  }\n\n  private updateHashFunctions(numHashes: number) {\n    this.hashSeeds = HashTableBase.generateHashSeeds(numHashes);\n    this.mungedEmptyKey = -1;\n  }\n\n  /**\n   * Invokes callback with a modified version of the hash table data array.\n   *\n   * Replaces all slots that appear to be valid entries for (emptyLow, emptyHigh), i.e. slots that\n   * contain (emptyLow, emptyHigh) and to which (emptyLow, emptyHigh) hashes, with (mungedEmptyKey,\n   * mungedEmptyKey).\n   *\n   * mungedEmptyKey is chosen to be a 32-bit value with the property that the 64-bit value\n   * (mungedEmptyKey, mungedEmptyKey) does not hash to any of the same slots as (emptyLow,\n   * emptyHigh).\n   *\n   * This allows the modified data array to be used for lookups without special casing the empty\n   * key.\n   */\n  tableWithMungedEmptyKey(callback: (table: Uint32Array) => void) {\n    const numHashes = this.hashSeeds.length;\n    const emptySlots = new Array<number>(numHashes);\n    for (let i = 0; i < numHashes; ++i) {\n      emptySlots[i] = this.getHash(i, this.emptyLow, this.emptyHigh);\n    }\n    let { mungedEmptyKey } = this;\n    if (mungedEmptyKey === -1) {\n      chooseMungedEmptyKey: while (true) {\n        mungedEmptyKey = (Math.random() * 0x1000000) >>> 0;\n        for (let i = 0; i < numHashes; ++i) {\n          const h = this.getHash(i, mungedEmptyKey, mungedEmptyKey);\n          for (let j = 0; j < numHashes; ++j) {\n            if (emptySlots[j] === h) {\n              continue chooseMungedEmptyKey;\n            }\n          }\n        }\n        this.mungedEmptyKey = mungedEmptyKey;\n        break;\n      }\n    }\n    const { table, emptyLow, emptyHigh } = this;\n    for (let i = 0; i < numHashes; ++i) {\n      const h = emptySlots[i];\n      if (table[h] === emptyLow && table[h + 1] === emptyHigh) {\n        table[h] = mungedEmptyKey;\n        table[h + 1] = mungedEmptyKey;\n      }\n    }\n    try {\n      callback(table);\n    } finally {\n      for (let i = 0; i < numHashes; ++i) {\n        const h = emptySlots[i];\n        if (table[h] === mungedEmptyKey && table[h + 1] === mungedEmptyKey) {\n          table[h] = emptyLow;\n          table[h + 1] = emptyHigh;\n        }\n      }\n    }\n  }\n\n  static generateHashSeeds(numAlternatives = NUM_ALTERNATIVES) {\n    return getRandomValues(new Uint32Array(numAlternatives));\n  }\n\n  getHash(hashIndex: number, low: number, high: number) {\n    let hash = this.hashSeeds[hashIndex];\n    hash = hashCombine(hash, low);\n    hash = hashCombine(hash, high);\n    return this.entryStride * (hash & (this.tableSize - 1));\n  }\n\n  /**\n   * Iterates over the Uint64 keys contained in the hash set.\n   *\n   * Creates a new Uint64 object at every iteration (otherwise spread and Array.from() fail)\n   */\n  *keys(): IterableIterator<Uint64> {\n    const { emptyLow, emptyHigh, entryStride } = this;\n    const { table } = this;\n    for (let i = 0, length = table.length; i < length; i += entryStride) {\n      const low = table[i];\n      const high = table[i + 1];\n      if (low !== emptyLow || high !== emptyHigh) {\n        yield new Uint64(low, high);\n      }\n    }\n  }\n\n  /**\n   * Iterates over the Uint64 keys contained in the hash set.\n   *\n   * The same temp value will be modified and yielded at every iteration.\n   */\n  *unsafeKeys(temp = new Uint64()): IterableIterator<Uint64> {\n    const { emptyLow, emptyHigh, entryStride } = this;\n    const { table } = this;\n    for (let i = 0, length = table.length; i < length; i += entryStride) {\n      const low = table[i];\n      const high = table[i + 1];\n      if (low !== emptyLow || high !== emptyHigh) {\n        temp.low = low;\n        temp.high = high;\n        yield temp;\n      }\n    }\n  }\n\n  indexOfPair(low: number, high: number) {\n    const { table, emptyLow, emptyHigh } = this;\n    if (low === emptyLow && high === emptyHigh) {\n      return -1;\n    }\n    for (let i = 0, numHashes = this.hashSeeds.length; i < numHashes; ++i) {\n      const h = this.getHash(i, low, high);\n      if (table[h] === low && table[h + 1] === high) {\n        return h;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the offset into the hash table of the specified element, or -1 if the element is not\n   * present.\n   */\n  indexOf(x: Uint64) {\n    return this.indexOfPair(x.low, x.high);\n  }\n\n  /**\n   * Changes the empty key to a value that is not equal to the current empty key and is not present\n   * in the table.\n   *\n   * This is called when an attempt is made to insert the empty key.\n   */\n  private chooseAnotherEmptyKey() {\n    const { emptyLow, emptyHigh, table, entryStride } = this;\n    let newLow: number;\n    let newHigh: number;\n    while (true) {\n      newLow = (Math.random() * 0x100000000) >>> 0;\n      newHigh = (Math.random() * 0x100000000) >>> 0;\n      if (newLow === emptyLow && newHigh === emptyHigh) {\n        continue;\n      }\n      if (this.hasPair(newLow, newHigh)) {\n        continue;\n      }\n      break;\n    }\n\n    this.emptyLow = newLow;\n    this.emptyHigh = newHigh;\n\n    // Replace empty keys in the table.\n    for (let h = 0, length = table.length; h < length; h += entryStride) {\n      if (table[h] === emptyLow && table[h + 1] === emptyHigh) {\n        table[h] = newLow;\n        table[h + 1] = newHigh;\n      }\n    }\n  }\n\n  /**\n   * Returns true iff the specified element is present.\n   */\n  has(x: Uint64) {\n    return this.indexOf(x) !== -1;\n  }\n\n  /**\n   * Returns true iff the specified element is present.\n   */\n  hasPair(low: number, high: number) {\n    return this.indexOfPair(low, high) !== -1;\n  }\n\n  delete(x: Uint64) {\n    const index = this.indexOf(x);\n    if (index !== -1) {\n      const { table } = this;\n      table[index] = this.emptyLow;\n      table[index + 1] = this.emptyHigh;\n      ++this.generation;\n      this.size--;\n      return true;\n    }\n    return false;\n  }\n\n  private clearTable() {\n    const { table, entryStride, emptyLow, emptyHigh } = this;\n    const length = table.length;\n\n    for (let h = 0; h < length; h += entryStride) {\n      table[h] = emptyLow;\n      table[h + 1] = emptyHigh;\n    }\n  }\n\n  clear() {\n    if (this.size === 0) {\n      return false;\n    }\n    this.size = 0;\n    ++this.generation;\n    this.clearTable();\n    return true;\n  }\n\n  reserve(x: number) {\n    if (x > this.capacity) {\n      this.backupPending();\n      this.grow(x);\n      this.restorePending();\n      return true;\n    }\n    return false;\n  }\n\n  protected swapPending(table: Uint32Array, offset: number) {\n    const tempLow = pendingLow;\n    const tempHigh = pendingHigh;\n    this.storePending(table, offset);\n    table[offset] = tempLow;\n    table[offset + 1] = tempHigh;\n  }\n\n  protected storePending(table: Uint32Array, offset: number) {\n    pendingLow = table[offset];\n    pendingHigh = table[offset + 1];\n  }\n\n  protected backupPending() {\n    backupPendingLow = pendingLow;\n    backupPendingHigh = pendingHigh;\n  }\n\n  protected restorePending() {\n    pendingLow = backupPendingLow;\n    pendingHigh = backupPendingHigh;\n  }\n\n  private tryToInsert() {\n    if (DEBUG) {\n      console.log(`tryToInsert: ${pendingLow}, ${pendingHigh}`);\n    }\n    let attempt = 0;\n    const { emptyLow, emptyHigh, maxAttempts, table } = this;\n    const numHashes = this.hashSeeds.length;\n\n    let tableIndex = Math.floor(Math.random() * numHashes);\n    while (true) {\n      const h = this.getHash(tableIndex, pendingLow, pendingHigh);\n      this.swapPending(table, h);\n      if (pendingLow === emptyLow && pendingHigh === emptyHigh) {\n        return true;\n      }\n      if (++attempt === maxAttempts) {\n        break;\n      }\n      tableIndex =\n        (tableIndex + Math.floor(Math.random() * (numHashes - 1)) + 1) %\n        numHashes;\n    }\n    return false;\n  }\n\n  private allocate(tableSize: number) {\n    this.tableSize = tableSize;\n    const { entryStride } = this;\n    this.table = new Uint32Array(tableSize * entryStride);\n    this.maxAttempts = tableSize;\n    this.clearTable();\n    this.capacity = tableSize * this.loadFactor;\n    this.mungedEmptyKey = -1;\n  }\n\n  private rehash(oldTable: Uint32Array, tableSize: number) {\n    if (DEBUG) {\n      console.log(\"rehash begin\");\n    }\n    this.allocate(tableSize);\n    this.updateHashFunctions(this.hashSeeds.length);\n    const { emptyLow, emptyHigh, entryStride } = this;\n    for (let h = 0, length = oldTable.length; h < length; h += entryStride) {\n      const low = oldTable[h];\n      const high = oldTable[h + 1];\n      if (low !== emptyLow || high !== emptyHigh) {\n        this.storePending(oldTable, h);\n        if (!this.tryToInsert()) {\n          if (DEBUG) {\n            console.log(\"rehash failed\");\n          }\n          return false;\n        }\n      }\n    }\n    if (DEBUG) {\n      console.log(\"rehash end\");\n    }\n    return true;\n  }\n\n  private grow(desiredTableSize: number) {\n    if (DEBUG) {\n      console.log(`grow: ${desiredTableSize}`);\n    }\n    const oldTable = this.table;\n    let { tableSize } = this;\n    while (tableSize < desiredTableSize) {\n      tableSize *= 2;\n    }\n    while (true) {\n      for (\n        let rehashAttempt = 0;\n        rehashAttempt < this.maxRehashAttempts;\n        ++rehashAttempt\n      ) {\n        if (this.rehash(oldTable, tableSize)) {\n          if (DEBUG) {\n            console.log(\"grow end\");\n          }\n          return;\n        }\n      }\n      tableSize *= 2;\n    }\n  }\n\n  protected insertInternal() {\n    ++this.generation;\n\n    if (pendingLow === this.emptyLow && pendingHigh === this.emptyHigh) {\n      this.chooseAnotherEmptyKey();\n    }\n\n    if (++this.size > this.capacity) {\n      this.backupPending();\n      this.grow(this.tableSize * 2);\n      this.restorePending();\n    }\n\n    while (!this.tryToInsert()) {\n      this.backupPending();\n      this.grow(this.tableSize);\n      this.restorePending();\n    }\n  }\n}\n\nexport class HashSetUint64 extends HashTableBase {\n  add(x: Uint64) {\n    const { low, high } = x;\n    if (this.hasPair(low, high)) {\n      return false;\n    }\n    if (DEBUG) {\n      console.log(`add: ${low},${high}`);\n    }\n    pendingLow = low;\n    pendingHigh = high;\n    this.insertInternal();\n    return true;\n  }\n\n  /**\n   * Iterates over the keys.\n   * Creates a new Uint64 object at every iteration (otherwise spread and Array.from() fail)\n   */\n  [Symbol.iterator]() {\n    return this.unsafeKeys();\n  }\n}\nHashSetUint64.prototype.entryStride = 2;\n\n// Value that needs to be inserted.  Temporary variables used during insert.  These can safely be\n// global because control never leaves functions defined in this module while these are in use.\nlet pendingValueLow = 0;\nlet pendingValueHigh = 0;\nlet backupPendingValueLow = 0;\nlet backupPendingValueHigh = 0;\n\nexport class HashMapUint64 extends HashTableBase {\n  set(key: Uint64, value: Uint64) {\n    const { low, high } = key;\n    if (this.hasPair(low, high)) {\n      return false;\n    }\n    if (DEBUG) {\n      console.log(`add: ${low},${high} -> ${value.low},${value.high}`);\n    }\n    pendingLow = low;\n    pendingHigh = high;\n    pendingValueLow = value.low;\n    pendingValueHigh = value.high;\n    this.insertInternal();\n    return true;\n  }\n\n  get(key: Uint64, value: Uint64): boolean {\n    const h = this.indexOf(key);\n    if (h === -1) {\n      return false;\n    }\n    const { table } = this;\n    value.low = table[h + 2];\n    value.high = table[h + 3];\n    return true;\n  }\n\n  protected swapPending(table: Uint32Array, offset: number) {\n    const tempLow = pendingValueLow;\n    const tempHigh = pendingValueHigh;\n    super.swapPending(table, offset);\n    table[offset + 2] = tempLow;\n    table[offset + 3] = tempHigh;\n  }\n\n  protected storePending(table: Uint32Array, offset: number) {\n    super.storePending(table, offset);\n    pendingValueLow = table[offset + 2];\n    pendingValueHigh = table[offset + 3];\n  }\n\n  protected backupPending() {\n    super.backupPending();\n    backupPendingValueLow = pendingValueLow;\n    backupPendingValueHigh = pendingValueHigh;\n  }\n\n  protected restorePending() {\n    super.restorePending();\n    pendingValueLow = backupPendingValueLow;\n    pendingValueHigh = backupPendingValueHigh;\n  }\n\n  /**\n   * Iterates over entries.  The same temporary value will be modified and yielded at every\n   * iteration.\n   */\n  [Symbol.iterator]() {\n    return this.unsafeEntries();\n  }\n\n  /**\n   * Iterates over entries.\n   * Creates new Uint64 objects at every iteration (otherwise spread and Array.from() fail)\n   */\n  *entries() {\n    const { emptyLow, emptyHigh, entryStride } = this;\n    const { table } = this;\n    for (let i = 0, length = table.length; i < length; i += entryStride) {\n      const low = table[i];\n      const high = table[i + 1];\n      if (low !== emptyLow || high !== emptyHigh) {\n        const key = new Uint64(low, high);\n        const value = new Uint64(table[i + 2], table[i + 3]);\n        yield [key, value];\n      }\n    }\n  }\n\n  /**\n   * Iterates over entries.  The same temporary value will be modified and yielded at every\n   * iteration.\n   */\n  *unsafeEntries(temp: [Uint64, Uint64] = [new Uint64(), new Uint64()]) {\n    const { emptyLow, emptyHigh, entryStride } = this;\n    const { table } = this;\n    const [key, value] = temp;\n    for (let i = 0, length = table.length; i < length; i += entryStride) {\n      const low = table[i];\n      const high = table[i + 1];\n      if (low !== emptyLow || high !== emptyHigh) {\n        key.low = low;\n        key.high = high;\n        value.low = table[i + 2];\n        value.high = table[i + 3];\n        yield temp;\n      }\n    }\n  }\n}\nHashMapUint64.prototype.entryStride = 4;\n","/**\n * @license\n * This work is a derivative of the Google Neuroglancer project,\n * Copyright 2016 Google Inc.\n * The Derivative Work is covered by\n * Copyright 2019 Howard Hughes Medical Institute\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HashMapUint64 } from \"#src/gpu_hash/hash_table.js\";\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { Signal } from \"#src/util/signal.js\";\nimport type { Uint64 } from \"#src/util/uint64.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\n@registerSharedObject(\"Uint64Map\")\nexport class Uint64Map\n  extends SharedObjectCounterpart\n  implements WatchableValueInterface<Uint64Map>\n{\n  hashTable = new HashMapUint64();\n  changed = new Signal<(x: Uint64 | null, add: boolean) => void>();\n\n  get value() {\n    return this;\n  }\n\n  static makeWithCounterpart(rpc: RPC) {\n    const obj = new Uint64Map();\n    obj.initializeCounterpart(rpc);\n    return obj;\n  }\n\n  set_(key: Uint64, value: Uint64) {\n    return this.hashTable.set(key, value);\n  }\n\n  set(key: Uint64, value: Uint64) {\n    if (this.set_(key, value)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Map.set\", { id: this.rpcId, key: key, value: value });\n      }\n      this.changed.dispatch(key, true);\n    }\n  }\n\n  has(key: Uint64) {\n    return this.hashTable.has(key);\n  }\n\n  get(key: Uint64, value: Uint64): boolean {\n    return this.hashTable.get(key, value);\n  }\n\n  [Symbol.iterator]() {\n    return this.hashTable.entries();\n  }\n\n  unsafeEntries() {\n    return this.hashTable.unsafeEntries();\n  }\n\n  delete_(key: Uint64) {\n    return this.hashTable.delete(key);\n  }\n\n  delete(key: Uint64) {\n    if (this.delete_(key)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Map.delete\", { id: this.rpcId, key: key });\n      }\n      this.changed.dispatch(key, false);\n    }\n  }\n\n  get size() {\n    return this.hashTable.size;\n  }\n\n  assignFrom(other: Uint64Map) {\n    this.clear();\n    for (const [key, value] of other.unsafeEntries()) {\n      this.set(key, value);\n    }\n  }\n\n  clear() {\n    if (this.hashTable.clear()) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Map.clear\", { id: this.rpcId });\n      }\n      this.changed.dispatch(null, false);\n    }\n  }\n\n  toJSON() {\n    const result: { [key: string]: string } = {};\n    for (const [key, value] of this.hashTable.unsafeEntries()) {\n      result[key.toString()] = value.toString();\n    }\n    return result;\n  }\n}\n\nregisterRPC(\"Uint64Map.set\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.set_(x.key, x.value)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(\"Uint64Map.delete\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.delete_(x.key)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(\"Uint64Map.clear\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.hashTable.clear()) {\n    obj.changed.dispatch();\n  }\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HashSetUint64 } from \"#src/gpu_hash/hash_table.js\";\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { Signal } from \"#src/util/signal.js\";\nimport type { Uint64 } from \"#src/util/uint64.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\n@registerSharedObject(\"Uint64Set\")\nexport class Uint64Set\n  extends SharedObjectCounterpart\n  implements WatchableValueInterface<Uint64Set>\n{\n  hashTable = new HashSetUint64();\n  changed = new Signal<(x: Uint64 | Uint64[] | null, add: boolean) => void>();\n\n  get value() {\n    return this;\n  }\n\n  static makeWithCounterpart(rpc: RPC) {\n    const obj = new Uint64Set();\n    obj.initializeCounterpart(rpc);\n    return obj;\n  }\n\n  set(x: Uint64 | Uint64[], value: boolean) {\n    if (!value) {\n      this.delete(x);\n    } else {\n      this.add(x);\n    }\n  }\n\n  reserve_(x: number) {\n    return this.hashTable.reserve(x);\n  }\n\n  reserve(x: number) {\n    if (this.reserve_(x)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Set.reserve\", { id: this.rpcId, value: x });\n      }\n    }\n  }\n\n  add_(x: Uint64[]) {\n    let changed = false;\n    for (const v of x) {\n      changed = this.hashTable.add(v) || changed;\n    }\n    return changed;\n  }\n\n  add(x: Uint64 | Uint64[]) {\n    const tmp = Array<Uint64>().concat(x);\n    if (this.add_(tmp)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Set.add\", { id: this.rpcId, value: tmp });\n      }\n      this.changed.dispatch(x, true);\n    }\n  }\n\n  has(x: Uint64) {\n    return this.hashTable.has(x);\n  }\n\n  [Symbol.iterator]() {\n    return this.hashTable.keys();\n  }\n\n  unsafeKeys() {\n    return this.hashTable.unsafeKeys();\n  }\n\n  delete_(x: Uint64[]) {\n    let changed = false;\n    for (const v of x) {\n      changed = this.hashTable.delete(v) || changed;\n    }\n    return changed;\n  }\n\n  delete(x: Uint64 | Uint64[]) {\n    const tmp = Array<Uint64>().concat(x);\n    if (this.delete_(Array<Uint64>().concat(x))) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Set.delete\", { id: this.rpcId, value: tmp });\n      }\n      this.changed.dispatch(x, false);\n    }\n  }\n\n  get size() {\n    return this.hashTable.size;\n  }\n\n  clear() {\n    if (this.hashTable.clear()) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Set.clear\", { id: this.rpcId });\n      }\n      this.changed.dispatch(null, false);\n    }\n  }\n\n  toJSON() {\n    const result = new Array<string>();\n    for (const id of this.unsafeKeys()) {\n      result.push(id.toString());\n    }\n    // Need to sort entries, otherwise serialization changes every time.\n    result.sort();\n    return result;\n  }\n\n  assignFrom(other: Uint64Set) {\n    this.clear();\n    for (const key of other.unsafeKeys()) {\n      this.add(key);\n    }\n  }\n}\n\nregisterRPC(\"Uint64Set.reserve\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.reserve_(x.value)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(\"Uint64Set.add\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.add_(x.value)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(\"Uint64Set.delete\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.delete_(x.value)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(\"Uint64Set.clear\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.hashTable.clear()) {\n    obj.changed.dispatch();\n  }\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VisibleSegmentEquivalencePolicy } from \"#src/segmentation_graph/segment_id.js\";\nimport type { SharedDisjointUint64Sets } from \"#src/shared_disjoint_sets.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { WatchableValue } from \"#src/trackable_value.js\";\nimport type { Uint64OrderedSet } from \"#src/uint64_ordered_set.js\";\nimport type { Uint64Set } from \"#src/uint64_set.js\";\nimport type { RefCounted } from \"#src/util/disposable.js\";\nimport type { Uint64 } from \"#src/util/uint64.js\";\n\nexport interface VisibleSegmentsState {\n  timestamp: WatchableValue<number | undefined>;\n  visibleSegments: Uint64Set;\n  selectedSegments: Uint64OrderedSet;\n  segmentEquivalences: SharedDisjointUint64Sets;\n\n  // Specifies a temporary/alternative set of segments/equivalences to use for display purposes,\n  // used for previewing a merge/split.\n  temporaryVisibleSegments: Uint64Set;\n  temporarySegmentEquivalences: SharedDisjointUint64Sets;\n  useTemporaryVisibleSegments: SharedWatchableValue<boolean>;\n  useTemporarySegmentEquivalences: SharedWatchableValue<boolean>;\n}\n\nexport const VISIBLE_SEGMENTS_STATE_PROPERTIES = [\n  \"visibleSegments\",\n  \"segmentEquivalences\",\n  \"temporaryVisibleSegments\",\n  \"temporarySegmentEquivalences\",\n  \"useTemporaryVisibleSegments\",\n  \"useTemporarySegmentEquivalences\",\n] as const;\n\nexport function onVisibleSegmentsStateChanged(\n  context: RefCounted,\n  state: VisibleSegmentsState,\n  callback: () => void,\n) {\n  context.registerDisposer(state.visibleSegments.changed.add(callback));\n  context.registerDisposer(state.segmentEquivalences.changed.add(callback));\n}\n\nexport function onTemporaryVisibleSegmentsStateChanged(\n  context: RefCounted,\n  state: VisibleSegmentsState,\n  callback: () => void,\n) {\n  context.registerDisposer(\n    state.temporaryVisibleSegments.changed.add(callback),\n  );\n  context.registerDisposer(\n    state.temporarySegmentEquivalences.changed.add(callback),\n  );\n  context.registerDisposer(\n    state.useTemporaryVisibleSegments.changed.add(callback),\n  );\n  context.registerDisposer(\n    state.useTemporarySegmentEquivalences.changed.add(callback),\n  );\n}\n\n/**\n * Returns a string key for identifying a uint64 object id.  This is faster than\n * Uint64.prototype.toString().\n */\nexport function getObjectKey(objectId: Uint64): string {\n  return `${objectId.low},${objectId.high}`;\n}\n\nfunction isHighBitSegment(segmentId: Uint64): boolean {\n  return segmentId.high >>> 31 ? true : false;\n}\n\nexport function getVisibleSegments(state: VisibleSegmentsState) {\n  return state.useTemporaryVisibleSegments.value\n    ? state.temporaryVisibleSegments\n    : state.visibleSegments;\n}\n\nexport function getSegmentEquivalences(state: VisibleSegmentsState) {\n  return state.useTemporarySegmentEquivalences.value\n    ? state.temporarySegmentEquivalences\n    : state.segmentEquivalences;\n}\n\nexport function forEachVisibleSegment(\n  state: VisibleSegmentsState,\n  callback: (objectId: Uint64, rootObjectId: Uint64) => void,\n) {\n  const visibleSegments = getVisibleSegments(state);\n  const segmentEquivalences = getSegmentEquivalences(state);\n  const equivalencePolicy =\n    segmentEquivalences.disjointSets.visibleSegmentEquivalencePolicy.value;\n  for (const rootObjectId of visibleSegments.unsafeKeys()) {\n    if (\n      equivalencePolicy &\n      VisibleSegmentEquivalencePolicy.NONREPRESENTATIVE_EXCLUDED\n    ) {\n      const rootObjectId2 = segmentEquivalences.get(rootObjectId);\n      callback(rootObjectId, rootObjectId2);\n    } else {\n      // TODO(jbms): Remove this check if logic is added to ensure that it always holds.\n      if (!segmentEquivalences.disjointSets.isMinElement(rootObjectId)) {\n        continue;\n      }\n      for (const objectId of segmentEquivalences.setElements(rootObjectId)) {\n        if (\n          equivalencePolicy &\n            VisibleSegmentEquivalencePolicy.REPRESENTATIVE_EXCLUDED &&\n          equivalencePolicy &\n            VisibleSegmentEquivalencePolicy.MAX_REPRESENTATIVE &&\n          isHighBitSegment(objectId)\n        ) {\n          continue;\n        }\n        callback(objectId, rootObjectId);\n      }\n    }\n  }\n}\n\nexport interface IndexedSegmentProperty {\n  id: string;\n  type: \"string\";\n  description: string | undefined;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Import to register the shared object types.\nimport \"#src/shared_disjoint_sets.js\";\nimport \"#src/uint64_map.js\";\nimport \"#src/uint64_set.js\";\n\nimport type { ChunkRequester } from \"#src/chunk_manager/backend.js\";\nimport { ChunkSource } from \"#src/chunk_manager/backend.js\";\nimport type { RenderLayerTransformOrError } from \"#src/render_coordinate_transform.js\";\nimport type {\n  IndexedSegmentProperty,\n  VisibleSegmentsState,\n} from \"#src/segmentation_display_state/base.js\";\nimport {\n  VISIBLE_SEGMENTS_STATE_PROPERTIES,\n  onTemporaryVisibleSegmentsStateChanged,\n  onVisibleSegmentsStateChanged,\n} from \"#src/segmentation_display_state/base.js\";\nimport type { SharedDisjointUint64Sets } from \"#src/shared_disjoint_sets.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { WatchableValue } from \"#src/trackable_value.js\";\nimport type { Uint64OrderedSet } from \"#src/uint64_ordered_set.js\";\nimport type { Uint64Set } from \"#src/uint64_set.js\";\nimport type { AnyConstructor } from \"#src/util/mixin.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\n\nexport function receiveVisibleSegmentsState(\n  rpc: RPC,\n  options: any,\n  target: VisibleSegmentsState = {} as VisibleSegmentsState,\n): VisibleSegmentsState {\n  // No need to increase the reference count of these properties since our owner will hold a\n  // reference to their owners.\n  for (const property of VISIBLE_SEGMENTS_STATE_PROPERTIES) {\n    target[property] = rpc.get(options[property]);\n  }\n  return target;\n}\n\nexport const withSegmentationLayerBackendState = <\n  TBase extends AnyConstructor<ChunkRequester>,\n>(\n  Base: TBase,\n) =>\n  class SegmentationLayerState extends Base implements VisibleSegmentsState {\n    timestamp: WatchableValue<number | undefined>;\n    visibleSegments: Uint64Set;\n    selectedSegments: Uint64OrderedSet;\n    segmentEquivalences: SharedDisjointUint64Sets;\n    temporaryVisibleSegments: Uint64Set;\n    temporarySegmentEquivalences: SharedDisjointUint64Sets;\n    useTemporaryVisibleSegments: SharedWatchableValue<boolean>;\n    useTemporarySegmentEquivalences: SharedWatchableValue<boolean>;\n    transform: SharedWatchableValue<RenderLayerTransformOrError>;\n    renderScaleTarget: SharedWatchableValue<number>;\n    constructor(...args: any[]) {\n      const [rpc, options] = args as [RPC, any];\n      super(rpc, options);\n      receiveVisibleSegmentsState(rpc, options, this);\n      this.transform = rpc.get(options.transform);\n      this.renderScaleTarget = rpc.get(options.renderScaleTarget);\n\n      const scheduleUpdateChunkPriorities = () => {\n        this.chunkManager.scheduleUpdateChunkPriorities();\n      };\n      onTemporaryVisibleSegmentsStateChanged(\n        this,\n        this,\n        scheduleUpdateChunkPriorities,\n      );\n      onVisibleSegmentsStateChanged(this, this, scheduleUpdateChunkPriorities);\n      this.registerDisposer(\n        this.transform.changed.add(scheduleUpdateChunkPriorities),\n      );\n      this.registerDisposer(\n        this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities),\n      );\n    }\n  };\n\nexport class IndexedSegmentPropertySourceBackend extends ChunkSource {\n  properties: readonly Readonly<IndexedSegmentProperty>[];\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.properties = options.properties;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { AnnotationGeometryChunkSpecification } from \"#src/annotation/base.js\";\nimport {\n  ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID,\n  ANNOTATION_COMMIT_UPDATE_RPC_ID,\n  ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID,\n  ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID,\n  ANNOTATION_REFERENCE_ADD_RPC_ID,\n  ANNOTATION_REFERENCE_DELETE_RPC_ID,\n  ANNOTATION_RENDER_LAYER_RPC_ID,\n  ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID,\n  ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID,\n  ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID,\n  forEachVisibleAnnotationChunk,\n} from \"#src/annotation/base.js\";\nimport type {\n  Annotation,\n  AnnotationId,\n  SerializedAnnotations,\n} from \"#src/annotation/index.js\";\nimport { fixAnnotationAfterStructuredCloning } from \"#src/annotation/index.js\";\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport {\n  Chunk,\n  ChunkRenderLayerBackend,\n  ChunkSource,\n  withChunkManager,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier, ChunkState } from \"#src/chunk_manager/base.js\";\nimport type { DisplayDimensionRenderInfo } from \"#src/navigation_state.js\";\nimport { validateDisplayDimensionRenderInfoProperty } from \"#src/navigation_state.js\";\nimport type {\n  RenderedViewBackend,\n  RenderLayerBackendAttachment,\n} from \"#src/render_layer_backend.js\";\nimport { RenderLayerBackend } from \"#src/render_layer_backend.js\";\nimport { receiveVisibleSegmentsState } from \"#src/segmentation_display_state/backend.js\";\nimport type { VisibleSegmentsState } from \"#src/segmentation_display_state/base.js\";\nimport {\n  forEachVisibleSegment,\n  getObjectKey,\n  onTemporaryVisibleSegmentsStateChanged,\n  onVisibleSegmentsStateChanged,\n} from \"#src/segmentation_display_state/base.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport {\n  deserializeTransformedSources,\n  SCALE_PRIORITY_MULTIPLIER,\n  SliceViewChunk,\n  SliceViewChunkSourceBackend,\n} from \"#src/sliceview/backend.js\";\nimport type { TransformedSource } from \"#src/sliceview/base.js\";\nimport { registerNested, WatchableValue } from \"#src/trackable_value.js\";\nimport type { Borrowed } from \"#src/util/disposable.js\";\nimport type { Uint64 } from \"#src/util/uint64.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nconst ANNOTATION_METADATA_CHUNK_PRIORITY = 200;\nconst ANNOTATION_SEGMENT_FILTERED_CHUNK_PRIORITY = 60;\n\nexport class AnnotationMetadataChunk extends Chunk {\n  annotation: Annotation | undefined | null;\n  freeSystemMemory() {\n    this.annotation = undefined;\n  }\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    msg.annotation = this.annotation;\n  }\n  downloadSucceeded() {\n    this.systemMemoryBytes = this.gpuMemoryBytes = 0;\n    super.downloadSucceeded();\n  }\n}\n\nexport class AnnotationGeometryData implements SerializedAnnotations {\n  data: Uint8Array<ArrayBuffer>;\n  typeToOffset: number[];\n  typeToIds: string[][];\n  typeToIdMaps: Map<string, number>[];\n\n  serialize(msg: any, transfers: any[]) {\n    msg.data = this.data;\n    msg.typeToOffset = this.typeToOffset;\n    msg.typeToIds = this.typeToIds;\n    msg.typeToIdMaps = this.typeToIdMaps;\n    transfers.push(this.data.buffer);\n  }\n\n  get numBytes() {\n    return this.data.byteLength;\n  }\n}\n\nfunction GeometryChunkMixin<TBase extends { new (...args: any[]): Chunk }>(\n  Base: TBase,\n) {\n  class C extends Base {\n    data: AnnotationGeometryData | undefined;\n    serialize(msg: any, transfers: any[]) {\n      super.serialize(msg, transfers);\n      const { data } = this;\n      if (data !== undefined) {\n        data.serialize(msg, transfers);\n        this.data = undefined;\n      }\n    }\n\n    downloadSucceeded() {\n      const { data } = this;\n      this.systemMemoryBytes = this.gpuMemoryBytes =\n        data === undefined ? 0 : data.numBytes;\n      super.downloadSucceeded();\n    }\n\n    freeSystemMemory() {\n      this.data = undefined;\n    }\n  }\n  return C;\n}\n\nexport class AnnotationGeometryChunk extends GeometryChunkMixin(\n  SliceViewChunk,\n) {\n  declare source: AnnotationGeometryChunkSourceBackend;\n}\n\nexport class AnnotationSubsetGeometryChunk extends GeometryChunkMixin(Chunk) {\n  declare source: AnnotationSubsetGeometryChunkSource;\n  objectId: Uint64;\n}\n\n@registerSharedObject(ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID)\nclass AnnotationMetadataChunkSource extends ChunkSource {\n  parent: Borrowed<AnnotationSource> | undefined = undefined;\n  getChunk(id: string) {\n    const { chunks } = this;\n    let chunk = chunks.get(id);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(AnnotationMetadataChunk);\n      chunk.initialize(id);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n\n  download(chunk: AnnotationMetadataChunk, abortSignal: AbortSignal) {\n    return this.parent!.downloadMetadata(chunk, abortSignal);\n  }\n}\n\nexport class AnnotationGeometryChunkSourceBackend extends SliceViewChunkSourceBackend<\n  AnnotationGeometryChunkSpecification,\n  AnnotationGeometryChunk\n> {\n  parent: Borrowed<AnnotationSource>;\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.parent = rpc.get(options.parent);\n  }\n}\nAnnotationGeometryChunkSourceBackend.prototype.chunkConstructor =\n  AnnotationGeometryChunk;\n\n@registerSharedObject(ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID)\nclass AnnotationSubsetGeometryChunkSource extends ChunkSource {\n  parent: Borrowed<AnnotationSource> | undefined = undefined;\n  declare chunks: Map<string, AnnotationSubsetGeometryChunk>;\n  relationshipIndex: number;\n  getChunk(objectId: Uint64) {\n    const key = getObjectKey(objectId);\n    const { chunks } = this;\n    let chunk = chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(AnnotationSubsetGeometryChunk);\n      chunk.initialize(key);\n      chunk.objectId = objectId.clone();\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n  download(chunk: AnnotationSubsetGeometryChunk, abortSignal: AbortSignal) {\n    return this.parent!.downloadSegmentFilteredGeometry(\n      chunk,\n      this.relationshipIndex,\n      abortSignal,\n    );\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface AnnotationSource {\n  // TODO(jbms): Move this declaration to class definition below and declare abstract once\n  // TypeScript supports mixins with abstract classes.\n  downloadMetadata(\n    chunk: AnnotationMetadataChunk,\n    abortSignal: AbortSignal,\n  ): Promise<void>;\n  downloadSegmentFilteredGeometry(\n    chunk: AnnotationSubsetGeometryChunk,\n    relationshipIndex: number,\n    abortSignal: AbortSignal,\n  ): Promise<void>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class AnnotationSource extends SharedObjectCounterpart {\n  references = new Set<AnnotationId>();\n  chunkManager: Borrowed<ChunkManager>;\n  metadataChunkSource: AnnotationMetadataChunkSource;\n  segmentFilteredSources: AnnotationSubsetGeometryChunkSource[];\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    const chunkManager = (this.chunkManager = <ChunkManager>(\n      rpc.get(options.chunkManager)\n    ));\n    const metadataChunkSource = (this.metadataChunkSource =\n      this.registerDisposer(\n        rpc.getRef<AnnotationMetadataChunkSource>(options.metadataChunkSource),\n      ));\n    this.segmentFilteredSources = (options.segmentFilteredSource as any[]).map(\n      (x, i) => {\n        const source = this.registerDisposer(\n          rpc.getRef<AnnotationSubsetGeometryChunkSource>(x),\n        );\n        source.parent = this;\n        source.relationshipIndex = i;\n        return source;\n      },\n    );\n    metadataChunkSource.parent = this;\n    this.registerDisposer(\n      chunkManager.recomputeChunkPriorities.add(() =>\n        this.recomputeChunkPriorities(),\n      ),\n    );\n  }\n\n  private recomputeChunkPriorities() {\n    const { chunkManager, metadataChunkSource } = this;\n    for (const id of this.references) {\n      chunkManager.requestChunk(\n        metadataChunkSource.getChunk(id),\n        ChunkPriorityTier.VISIBLE,\n        ANNOTATION_METADATA_CHUNK_PRIORITY,\n      );\n    }\n  }\n\n  add(annotation: Annotation): Promise<AnnotationId> {\n    annotation;\n    throw new Error(\"Not implemented\");\n  }\n  delete(id: AnnotationId): Promise<void> {\n    id;\n    throw new Error(\"Not implemented\");\n  }\n  update(id: AnnotationId, newAnnotation: Annotation): Promise<void> {\n    id;\n    newAnnotation;\n    throw new Error(\"Not implemented\");\n  }\n}\n\nregisterRPC(ANNOTATION_REFERENCE_ADD_RPC_ID, function (x: any) {\n  const obj = <AnnotationSource>this.get(x.id);\n  obj.references.add(x.annotation);\n  obj.chunkManager.scheduleUpdateChunkPriorities();\n});\n\nregisterRPC(ANNOTATION_REFERENCE_DELETE_RPC_ID, function (x: any) {\n  const obj = <AnnotationSource>this.get(x.id);\n  obj.references.delete(x.annotation);\n  obj.chunkManager.scheduleUpdateChunkPriorities();\n});\n\nregisterRPC(ANNOTATION_COMMIT_UPDATE_RPC_ID, function (x: any) {\n  const obj = <AnnotationSource>this.get(x.id);\n  const annotationId: AnnotationId | undefined = x.annotationId;\n  const newAnnotation: Annotation | null = fixAnnotationAfterStructuredCloning(\n    x.newAnnotation,\n  );\n\n  let promise: Promise<Annotation | null>;\n  if (annotationId === undefined) {\n    promise = obj.add(newAnnotation!).then((id) => ({ ...newAnnotation!, id }));\n  } else if (newAnnotation === null) {\n    promise = obj.delete(annotationId).then(() => null);\n  } else {\n    promise = obj.update(annotationId, newAnnotation).then(() => newAnnotation);\n  }\n  // FIXME: Handle new chunks requested prior to update but not yet sent to frontend.\n  promise.then(\n    (result) => {\n      if (!obj.wasDisposed) {\n        this.invoke(ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, {\n          id: obj.rpcId,\n          annotationId: annotationId || newAnnotation!.id,\n          newAnnotation: result,\n        });\n      }\n    },\n    (error: Error) => {\n      if (!obj.wasDisposed) {\n        this.invoke(ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, {\n          id: obj.rpcId,\n          annotationId: annotationId || newAnnotation?.id,\n          error: error.message,\n        });\n      }\n    },\n  );\n});\n\ninterface AnnotationRenderLayerAttachmentState {\n  displayDimensionRenderInfo: DisplayDimensionRenderInfo;\n  transformedSources: TransformedSource<\n    AnnotationSpatiallyIndexedRenderLayerBackend,\n    AnnotationGeometryChunkSourceBackend\n  >[][];\n}\n\n@registerSharedObject(ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID)\nclass AnnotationSpatiallyIndexedRenderLayerBackend extends withChunkManager(\n  RenderLayerBackend,\n) {\n  localPosition: SharedWatchableValue<Float32Array>;\n  renderScaleTarget: SharedWatchableValue<number>;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.renderScaleTarget = rpc.get(options.renderScaleTarget);\n    this.localPosition = rpc.get(options.localPosition);\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    this.registerDisposer(\n      this.localPosition.changed.add(scheduleUpdateChunkPriorities),\n    );\n    this.registerDisposer(\n      this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() =>\n        this.recomputeChunkPriorities(),\n      ),\n    );\n  }\n\n  attach(\n    attachment: RenderLayerBackendAttachment<\n      RenderedViewBackend,\n      AnnotationRenderLayerAttachmentState\n    >,\n  ) {\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    const { view } = attachment;\n    attachment.registerDisposer(scheduleUpdateChunkPriorities);\n    attachment.registerDisposer(\n      view.projectionParameters.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(\n      view.visibility.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.state = {\n      displayDimensionRenderInfo:\n        view.projectionParameters.value.displayDimensionRenderInfo,\n      transformedSources: [],\n    };\n  }\n\n  private recomputeChunkPriorities() {\n    this.chunkManager.registerLayer(this);\n    for (const attachment of this.attachments.values()) {\n      const { view } = attachment;\n      const visibility = view.visibility.value;\n      if (visibility === Number.NEGATIVE_INFINITY) {\n        continue;\n      }\n      const attachmentState =\n        attachment.state! as AnnotationRenderLayerAttachmentState;\n      const { transformedSources } = attachmentState;\n      if (\n        transformedSources.length === 0 ||\n        !validateDisplayDimensionRenderInfoProperty(\n          attachmentState,\n          view.projectionParameters.value.displayDimensionRenderInfo,\n        )\n      ) {\n        continue;\n      }\n      const priorityTier = getPriorityTier(visibility);\n      const basePriority = getBasePriority(visibility);\n\n      const projectionParameters = view.projectionParameters.value;\n\n      const { chunkManager } = this;\n      forEachVisibleAnnotationChunk(\n        projectionParameters,\n        this.localPosition.value,\n        this.renderScaleTarget.value,\n        transformedSources[0],\n        () => {},\n        (tsource, scaleIndex) => {\n          const chunk = (\n            tsource.source as AnnotationGeometryChunkSourceBackend\n          ).getChunk(tsource.curPositionInChunks);\n          ++this.numVisibleChunksNeeded;\n          // FIXME: calculate priority\n          if (chunk.state === ChunkState.GPU_MEMORY) {\n            ++this.numVisibleChunksAvailable;\n          }\n          const priority = 0;\n          chunkManager.requestChunk(\n            chunk,\n            priorityTier,\n            basePriority + priority + SCALE_PRIORITY_MULTIPLIER * scaleIndex,\n          );\n        },\n      );\n    }\n  }\n}\nAnnotationSpatiallyIndexedRenderLayerBackend;\n\nregisterRPC(\n  ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID,\n  function (x) {\n    const view = this.get(x.view) as RenderedViewBackend;\n    const layer = this.get(\n      x.layer,\n    ) as AnnotationSpatiallyIndexedRenderLayerBackend;\n    const attachment = layer.attachments.get(\n      view,\n    )! as RenderLayerBackendAttachment<\n      RenderedViewBackend,\n      AnnotationRenderLayerAttachmentState\n    >;\n    attachment.state!.transformedSources = deserializeTransformedSources<\n      AnnotationGeometryChunkSourceBackend,\n      AnnotationSpatiallyIndexedRenderLayerBackend\n    >(this, x.sources, layer);\n    attachment.state!.displayDimensionRenderInfo = x.displayDimensionRenderInfo;\n    layer.chunkManager.scheduleUpdateChunkPriorities();\n  },\n);\n\ntype AnnotationLayerSegmentationState = VisibleSegmentsState | undefined | null;\n\n@registerSharedObject(ANNOTATION_RENDER_LAYER_RPC_ID)\nclass AnnotationLayerSharedObjectCounterpart extends withSharedVisibility(\n  withChunkManager(ChunkRenderLayerBackend),\n) {\n  source: AnnotationSource;\n\n  segmentationStates: WatchableValue<\n    AnnotationLayerSegmentationState[] | undefined\n  >;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = rpc.get(options.source);\n    this.segmentationStates = new WatchableValue(\n      this.getSegmentationState(options.segmentationStates),\n    );\n\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    this.registerDisposer(\n      registerNested((context, states) => {\n        if (states === undefined) return;\n        for (const state of states) {\n          if (state == null) continue;\n          onVisibleSegmentsStateChanged(\n            context,\n            state,\n            scheduleUpdateChunkPriorities,\n          );\n          onTemporaryVisibleSegmentsStateChanged(\n            context,\n            state,\n            scheduleUpdateChunkPriorities,\n          );\n        }\n        scheduleUpdateChunkPriorities();\n      }, this.segmentationStates),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() =>\n        this.recomputeChunkPriorities(),\n      ),\n    );\n  }\n\n  private recomputeChunkPriorities() {\n    const visibility = this.visibility.value;\n    if (visibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    const {\n      segmentationStates: { value: states },\n      source: { segmentFilteredSources },\n    } = this;\n    if (states === undefined) return;\n    const { chunkManager } = this;\n    chunkManager.registerLayer(this);\n    const numRelationships = states.length;\n    for (let i = 0; i < numRelationships; ++i) {\n      const state = states[i];\n      if (state == null) {\n        continue;\n      }\n      const priorityTier = getPriorityTier(visibility);\n      const basePriority = getBasePriority(visibility);\n      const source = segmentFilteredSources[i];\n      forEachVisibleSegment(state, (objectId) => {\n        const chunk = source.getChunk(objectId);\n        ++this.numVisibleChunksNeeded;\n        if (chunk.state === ChunkState.GPU_MEMORY) {\n          ++this.numVisibleChunksAvailable;\n        }\n        chunkManager.requestChunk(\n          chunk,\n          priorityTier,\n          basePriority + ANNOTATION_SEGMENT_FILTERED_CHUNK_PRIORITY,\n        );\n      });\n    }\n  }\n\n  getSegmentationState(\n    msg: any[] | undefined,\n  ): AnnotationLayerSegmentationState[] | undefined {\n    if (msg === undefined) return undefined;\n    return msg.map((x) => {\n      if (x == null) {\n        return x as undefined | null;\n      }\n      return receiveVisibleSegmentsState(this.rpc!, x);\n    });\n  }\n}\nAnnotationLayerSharedObjectCounterpart;\n\nregisterRPC(ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID, function (x) {\n  const obj = <AnnotationLayerSharedObjectCounterpart>this.get(x.id);\n  obj.segmentationStates.value = obj.getSegmentationState(x.segmentationStates);\n});\n","/**\n * @license\n * Copyright 2017 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Defines a CredentialsProvider that forwards requests to a SharedCredentialsProvider on\n * another thread.\n */\n\nimport type {\n  CredentialsProvider,\n  CredentialsWithGeneration,\n  MaybeOptionalCredentialsProvider,\n} from \"#src/credentials_provider/index.js\";\nimport { makeCachedCredentialsGetter } from \"#src/credentials_provider/index.js\";\nimport {\n  CREDENTIALS_PROVIDER_GET_RPC_ID,\n  CREDENTIALS_PROVIDER_RPC_ID,\n} from \"#src/credentials_provider/shared_common.js\";\nimport {\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\n@registerSharedObject(CREDENTIALS_PROVIDER_RPC_ID)\nexport class SharedCredentialsProviderCounterpart<Credentials>\n  extends SharedObjectCounterpart\n  implements CredentialsProvider<Credentials>\n{\n  get = makeCachedCredentialsGetter(\n    (\n      invalidCredentials?: CredentialsWithGeneration<Credentials>,\n      abortSignal?: AbortSignal,\n    ): Promise<CredentialsWithGeneration<Credentials>> =>\n      this.rpc!.promiseInvoke(\n        CREDENTIALS_PROVIDER_GET_RPC_ID,\n        { providerId: this.rpcId, invalidCredentials: invalidCredentials },\n        abortSignal,\n      ),\n  );\n}\n\nexport function WithSharedCredentialsProviderCounterpart<Credentials>() {\n  return <TBase extends { new (...args: any[]): SharedObjectCounterpart }>(\n    Base: TBase,\n  ) =>\n    class extends Base {\n      credentialsProvider: MaybeOptionalCredentialsProvider<Credentials>;\n      constructor(...args: any[]) {\n        super(...args);\n        const options = args[1];\n        this.credentialsProvider = this.rpc!.getOptionalRef<\n          SharedCredentialsProviderCounterpart<Exclude<Credentials, undefined>>\n        >(options.credentialsProvider) as any;\n      }\n    };\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Uint64 } from \"#src/util/uint64.js\";\n\nexport class HttpError extends Error {\n  url: string;\n  status: number;\n  statusText: string;\n  response?: Response;\n\n  constructor(\n    url: string,\n    status: number,\n    statusText: string,\n    response?: Response,\n  ) {\n    let message = `Fetching ${JSON.stringify(\n      url,\n    )} resulted in HTTP error ${status}`;\n    if (statusText) {\n      message += `: ${statusText}`;\n    }\n    message += \".\";\n    super(message);\n    this.name = \"HttpError\";\n    this.message = message;\n    this.url = url;\n    this.status = status;\n    this.statusText = statusText;\n    if (response) {\n      this.response = response;\n    }\n  }\n\n  static fromResponse(response: Response) {\n    return new HttpError(\n      response.url,\n      response.status,\n      response.statusText,\n      response,\n    );\n  }\n\n  static fromRequestError(input: RequestInfo, error: unknown) {\n    if (error instanceof TypeError) {\n      let url: string;\n      if (typeof input === \"string\") {\n        url = input;\n      } else {\n        url = input.url;\n      }\n      return new HttpError(url, 0, \"Network or CORS error\");\n    }\n    return error;\n  }\n}\n\nconst maxAttempts = 32;\nconst minDelayMilliseconds = 500;\nconst maxDelayMilliseconds = 10000;\n\nexport function pickDelay(attemptNumber: number): number {\n  // If `attemptNumber == 0`, delay is a random number of milliseconds between\n  // `[minDelayMilliseconds, minDelayMilliseconds*2]`.  The lower and upper bounds of the interval\n  // double with each successive attempt, up to the limit of\n  // `[maxDelayMilliseconds/2,maxDelayMilliseconds]`.\n  return (\n    Math.min(\n      2 ** attemptNumber * minDelayMilliseconds,\n      maxDelayMilliseconds / 2,\n    ) *\n    (1 + Math.random())\n  );\n}\n\n/**\n * Issues a `fetch` request.\n *\n * If the request fails due to an HTTP status outside `[200, 300)`, throws an `HttpError`.  If the\n * request fails due to a network or CORS restriction, throws an `HttpError` with a `status` of `0`.\n *\n * If the request fails due to a transient error (429, 503, 504), retry.\n */\nexport async function fetchOk(\n  input: RequestInfo,\n  init?: RequestInit,\n): Promise<Response> {\n  for (let requestAttempt = 0; ; ) {\n    init?.signal?.throwIfAborted();\n    let response: Response;\n    try {\n      response = await fetch(input, init);\n    } catch (error) {\n      throw HttpError.fromRequestError(input, error);\n    }\n    if (!response.ok) {\n      const { status } = response;\n      if (status === 429 || status === 503 || status === 504) {\n        // 429: Too Many Requests.  Retry.\n        // 503: Service unavailable.  Retry.\n        // 504: Gateway timeout.  Can occur if the server takes too long to reply.  Retry.\n        if (++requestAttempt !== maxAttempts) {\n          await new Promise((resolve) =>\n            setTimeout(resolve, pickDelay(requestAttempt - 1)),\n          );\n          continue;\n        }\n      }\n      throw HttpError.fromResponse(response);\n    }\n    return response;\n  }\n}\n\nconst tempUint64 = new Uint64();\n\nexport function getByteRangeHeader(\n  startOffset: Uint64 | number,\n  endOffset: Uint64 | number,\n) {\n  let endOffsetStr: string;\n  if (typeof endOffset === \"number\") {\n    endOffsetStr = `${endOffset - 1}`;\n  } else {\n    Uint64.decrement(tempUint64, endOffset);\n    endOffsetStr = tempUint64.toString();\n  }\n  return { Range: `bytes=${startOffset}-${endOffsetStr}` };\n}\n\nexport function parseUrl(url: string): {\n  protocol: string;\n  host: string;\n  path: string;\n} {\n  const urlProtocolPattern = /^([^:/]+):\\/\\/([^/]+)((?:\\/.*)?)$/;\n  const match = url.match(urlProtocolPattern);\n  if (match === null) {\n    throw new Error(`Invalid URL: ${JSON.stringify(url)}`);\n  }\n  return { protocol: match[1], host: match[2], path: match[3] };\n}\n\nexport function isNotFoundError(e: any) {\n  if (!(e instanceof HttpError)) return false;\n  // Treat CORS errors (0) or 403 as not found.  S3 returns 403 if the file does not exist because\n  // permissions are per-file.\n  return e.status === 0 || e.status === 403 || e.status === 404;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  CredentialsProvider,\n  CredentialsWithGeneration,\n} from \"#src/credentials_provider/index.js\";\nimport { fetchOk, HttpError, pickDelay } from \"#src/util/http_request.js\";\n\nconst maxCredentialsAttempts = 3;\n\nexport async function fetchWithCredentials<Credentials>(\n  credentialsProvider: CredentialsProvider<Credentials>,\n  input: RequestInfo | ((credentials: Credentials) => RequestInfo),\n  init: RequestInit,\n  applyCredentials: (\n    credentials: Credentials,\n    requestInit: RequestInit,\n  ) => RequestInit,\n  errorHandler: (\n    httpError: HttpError,\n    credentials: Credentials,\n  ) => \"refresh\" | Promise<\"refresh\">,\n): Promise<Response> {\n  let credentials: CredentialsWithGeneration<Credentials> | undefined;\n  for (let credentialsAttempt = 0; ; ) {\n    init.signal?.throwIfAborted();\n    if (credentialsAttempt > 1) {\n      // Don't delay on the first attempt, and also don't delay on the second attempt, since if the\n      // credentials have expired and there is no problem on the server there is no reason to delay\n      // requesting new credentials.\n      await new Promise((resolve) =>\n        setTimeout(resolve, pickDelay(credentialsAttempt - 2)),\n      );\n    }\n    credentials = await credentialsProvider.get(\n      credentials,\n      init.signal ?? undefined,\n    );\n    try {\n      return await fetchOk(\n        typeof input === \"function\" ? input(credentials.credentials) : input,\n        applyCredentials(credentials.credentials, init),\n      );\n    } catch (error) {\n      if (error instanceof HttpError) {\n        if (\n          (await errorHandler(error, credentials.credentials)) === \"refresh\"\n        ) {\n          if (++credentialsAttempt === maxCredentialsAttempts) throw error;\n          continue;\n        }\n      }\n      throw error;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fetchWithCredentials } from \"#src/credentials_provider/http_request.js\";\nimport type { CredentialsProvider } from \"#src/credentials_provider/index.js\";\nimport { fetchOk } from \"#src/util/http_request.js\";\n\nexport type BossToken = string;\n\n/**\n * Key used for retrieving the CredentialsProvider from a CredentialsManager.\n */\nexport const credentialsKey = \"boss\";\n\nexport async function fetchWithBossCredentials(\n  credentialsProvider: CredentialsProvider<BossToken>,\n  input: RequestInfo,\n  init: RequestInit,\n): Promise<Response> {\n  return fetchOk(input, init).catch((error) => {\n    if (\n      error.status !== 500 &&\n      error.status !== 401 &&\n      error.status !== 403 &&\n      error.status !== 504\n    ) {\n      // Prevent an infinite loop of error = 0 where the request\n      // has been cancelled\n      throw error;\n    }\n    return fetchWithCredentials(\n      credentialsProvider,\n      input,\n      init,\n      (credentials) => {\n        const headers = new Headers(init.headers);\n        headers.set(\"Authorization\", `Bearer ${credentials}`);\n        return { ...init, headers };\n      },\n      (error) => {\n        const { status } = error;\n        if (status === 403 || status === 401) {\n          // Authorization needed.  Retry with refreshed token.\n          return \"refresh\";\n        }\n        throw error;\n      },\n    );\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Conversion from independent triangles to triangle strips.\n *\n * http://www.codercorner.com/Strips.htm\n */\n\nimport { hashCombine } from \"#src/gpu_hash/hash_function.js\";\nimport type { MeshVertexIndices } from \"#src/mesh/base.js\";\n\nconst DEBUG_TIMING = false;\n\n/**\n * Sorts the vertex indices for each triangle in ascending order.\n *\n * This ensures later edge comparisons can be done more efficiently.  This can reverse face\n * orientations, which would normally be a problem, but since we render all faces as double-sided it\n * isn't an issue.\n */\nfunction normalizeTriangleVertexOrder(indices: MeshVertexIndices) {\n  let maxVertex = 0;\n  for (let i = 0, length = indices.length; i < length; i += 3) {\n    let a = indices[i];\n    let b = indices[i + 1];\n    let c = indices[i + 2];\n    let t: number;\n    if (a > b) {\n      t = a;\n      a = b;\n      b = t;\n    }\n    if (b > c) {\n      t = b;\n      b = c;\n      c = t;\n    }\n    if (a > b) {\n      t = a;\n      a = b;\n      b = t;\n    }\n    indices[i] = a;\n    indices[i + 1] = b;\n    indices[i + 2] = c;\n    if (c > maxVertex) maxVertex = c;\n  }\n  return maxVertex;\n}\n\nlet collisions = 0;\nfunction hashTableInsert(\n  table: Uint32Array,\n  numBuckets: number,\n  value: number,\n  emptyValue: number,\n  hashCode: number,\n  equals: (x: number) => boolean,\n) {\n  const mask = (numBuckets - 1) >>> 0;\n  let bucket = (hashCode & mask) >>> 0;\n  for (let probe = 0; ; ++probe) {\n    const x = table[bucket];\n    if (x === emptyValue) {\n      table[bucket] = value;\n      return value;\n    }\n    if (equals(x)) {\n      return x;\n    }\n    ++collisions;\n    bucket = ((bucket + probe + 1) & mask) >>> 0;\n  }\n}\n\nfunction hashEdge(a: number, b: number) {\n  return hashCombine(hashCombine(0, a), b);\n}\n\n// edgeIndex: 0, 1, 2\n// vertexA:   0  0  1   <-  bit 1\n// vertexB:   1  2  2   <-  1 + bit 1  of (edgeIndex + 1)\n// vertexC:   2  1  0   <-  2 - edgeIndex\n\n// BC         2  2  1\n// BC flipped 0  1  1\n// AC         1  0  0\n// AC flipped 0  0  1\n\n// Lookup table, where the 3 bits starting at (edgeIndex * 3 + flipped * 12) specify the new value\n// of `edgeIndexAndFlipped`.\nconst nextEdgeTable = 0b1_00_0_00_0_01_000_1_01_1_10_0_10;\n\n/**\n * Computes the edge index and flipped state in a triangle strip for the next edge after the given\n * edge.\n *\n * @param edgeIndexAndFlipped Bits 0,1 specify the `edgeIndex` in the range `[0, 2]` corresponding\n *     to the last edge that was traversed.  Bit 2 specifies the `flipped` state.  If `flipped` is\n *     equal to 0, the last two emitted vertices are B and C relative to `edgeIndex`.  If `flipped`\n *     is equal to 1, the last two emitted vertices are A and C relative to `edgeIndex`.\n * @returns The next `edgeIndexAndFlipped` value specifying `nextEdgeIndex` and `nextFlipped`.  If\n *     `flipped == 0`, `nextEdgeIndex` corresponds to the B-C edge relative to `edgeIndex`; if\n *     `flipped == 1`, `nextEdgeIndex` correspond to the A-C edge relative to `edgeIndex`.  The\n *     `nextFlipped` value is equal to 1 iff `vertexCIndex(edgeIndex) ==\n *     vertexAIndex(nextEdgeIndex)`.\n */\nexport function getNextEdge(edgeIndexAndFlipped: number) {\n  return (nextEdgeTable >>> (edgeIndexAndFlipped * 3)) & 7;\n}\n\nexport function getBaseIndex(entry: number) {\n  return (entry >>> 2) * 3;\n}\n\nexport function getEdgeIndex(entry: number) {\n  return entry & 3;\n}\n\n/**\n * Computes the first vertex offset for the given edge.\n *\n * @returns `[0, 0, 1][edgeIndex]`\n */\nexport function vertexAIndex(edgeIndex: number) {\n  return edgeIndex >>> 1;\n}\n\n/**\n * Computes the second vertex offset for the given edge.\n *\n * @returns `[1, 2, 2][edgeIndex]`\n */\nexport function vertexBIndex(edgeIndex: number) {\n  return 1 + ((edgeIndex + 1) >>> 1);\n}\n\n/**\n * Computes the opposite vertex offset for the given edge.\n *\n * @returns `[2, 1, 0][edgeIndex]`\n */\nexport function vertexCIndex(edgeIndex: number) {\n  return 2 - edgeIndex;\n}\n\nexport function getEdgeMapSize(numIndices: number) {\n  const numEdges = numIndices;\n\n  // Choose quadratic probing hash table size to be the smallest power of 2 greater than `numEdges`.\n  const edgeMapSize = 2 ** Math.ceil(Math.log2(numEdges));\n  return edgeMapSize * 4;\n}\n\nfunction computeTriangleAdjacencies(\n  triangleAdjacencies: Uint32Array,\n  indices: MeshVertexIndices,\n  edgeMap: Uint32Array,\n): Uint32Array {\n  const numTriangles = indices.length / 3;\n  // Row-major array of shape `[numTriangles, 3]` specifying the triangles adjacent to each\n  // triangle.  The triangle index `i` corresponds to elements `[i * 3, (i + 1) * 3)` of the\n  // `indices` array.  For each triangle, columns 0 to 2 are the indices of the triangles adjacent\n  // to edge 0-1, edge 0-2, and edge 1-2, respectively.\n\n  const edgeMapSize = edgeMap.length;\n  const emptyEntry = 0xffffffff;\n  triangleAdjacencies.fill(emptyEntry);\n  edgeMap.fill(emptyEntry);\n\n  // Insert edges\n  for (let triangle = 0; triangle < numTriangles; ++triangle) {\n    const baseIndex = triangle * 3;\n    for (let edgeIndex = 0; edgeIndex < 3; ++edgeIndex) {\n      const vertexA0 = indices[baseIndex + vertexAIndex(edgeIndex)];\n      const vertexB0 = indices[baseIndex + vertexBIndex(edgeIndex)];\n      const newEntry = (triangle << 2) | edgeIndex;\n      const existingEntry = hashTableInsert(\n        edgeMap,\n        edgeMapSize,\n        newEntry,\n        emptyEntry,\n        hashEdge(vertexA0, vertexB0),\n        (x) => {\n          const otherBaseIndex = getBaseIndex(x);\n          const otherEdgeIndex = getEdgeIndex(x);\n          const vertexA1 =\n            indices[otherBaseIndex + vertexAIndex(otherEdgeIndex)];\n          const vertexB1 =\n            indices[otherBaseIndex + vertexBIndex(otherEdgeIndex)];\n          // console.log('checking equality', vertexA0, vertexA1, vertexB0, vertexB1);\n          return vertexA0 === vertexA1 && vertexB0 === vertexB1;\n        },\n      );\n      if (existingEntry !== newEntry) {\n        const otherBaseIndex = getBaseIndex(existingEntry);\n        const otherEdgeIndex = getEdgeIndex(existingEntry);\n        triangleAdjacencies[otherBaseIndex + otherEdgeIndex] = newEntry;\n        triangleAdjacencies[baseIndex + edgeIndex] = existingEntry;\n      }\n    }\n  }\n\n  return triangleAdjacencies;\n}\n\nfunction emitTriangleStrips(\n  indices: MeshVertexIndices,\n  triangleAdjacencies: Uint32Array,\n  output: MeshVertexIndices,\n  outputIndex: number,\n): number {\n  const invalidVertex = ~0 >>> (32 - 8 * output.BYTES_PER_ELEMENT);\n  const numIndices = indices.length;\n  const numTriangles = numIndices / 3;\n  const emptyEntry = 0xffffffff;\n\n  // Extract strips\n  startNewStrip: for (let triangle = 0; triangle < numTriangles; ++triangle) {\n    let baseIndex = triangle * 3;\n    if (indices[baseIndex] === invalidVertex) {\n      // Triangle was already emitted.\n      continue;\n    }\n    for (let edgeIndex = 0; edgeIndex < 3; ++edgeIndex) {\n      let entry = triangleAdjacencies[baseIndex + edgeIndex];\n      if (entry === emptyEntry) continue;\n      let otherBaseIndex = getBaseIndex(entry);\n      if (indices[otherBaseIndex] === invalidVertex) continue;\n      const otherEdgeIndex = getEdgeIndex(entry);\n      output[outputIndex++] = indices[baseIndex + vertexCIndex(edgeIndex)];\n      output[outputIndex++] = indices[baseIndex + vertexAIndex(edgeIndex)];\n      output[outputIndex++] = indices[baseIndex + vertexBIndex(edgeIndex)];\n\n      let edgeIndexAndFlipped = otherEdgeIndex;\n\n      while (true) {\n        indices[baseIndex] = invalidVertex;\n        baseIndex = otherBaseIndex;\n        output[outputIndex++] =\n          indices[baseIndex + vertexCIndex(edgeIndexAndFlipped & 3)];\n\n        edgeIndexAndFlipped = getNextEdge(edgeIndexAndFlipped);\n\n        entry = triangleAdjacencies[baseIndex + (edgeIndexAndFlipped & 3)];\n        if (\n          entry === emptyEntry ||\n          indices[(otherBaseIndex = getBaseIndex(entry))] === invalidVertex\n        ) {\n          // console.log(stripLength);\n          // End of strip.  Emit restart index.\n          output[outputIndex++] = invalidVertex;\n          indices[baseIndex] = invalidVertex;\n          continue startNewStrip;\n        }\n        edgeIndexAndFlipped = getEdgeIndex(entry) | (edgeIndexAndFlipped & 4);\n      }\n    }\n    // Emit isolated triangle.\n    output[outputIndex++] = indices[baseIndex];\n    output[outputIndex++] = indices[baseIndex + 1];\n    output[outputIndex++] = indices[baseIndex + 2];\n    indices[baseIndex] = invalidVertex;\n    output[outputIndex++] = invalidVertex;\n  }\n  return outputIndex;\n}\n\nexport function computeTriangleStrips<T extends MeshVertexIndices>(\n  indices: T,\n  subChunkOffsets?: Uint32Array,\n): MeshVertexIndices {\n  if (indices.length === 0) return indices;\n  collisions = 0;\n  if (subChunkOffsets === undefined) {\n    subChunkOffsets = Uint32Array.of(0, indices.length);\n  }\n  let adjacenciesElapsed = 0;\n  let emitElapsed = 0;\n  let startTime = 0;\n  let midTime = 0;\n  let endTime = 0;\n\n  const maxVertexIndex = normalizeTriangleVertexOrder(indices);\n  const outputBufferSize = (indices.length / 3) * 4;\n  const output =\n    maxVertexIndex >= 65535\n      ? new Uint32Array(outputBufferSize)\n      : new Uint16Array(outputBufferSize);\n  let outputIndex = 0;\n\n  let maxSubChunkIndices = 0;\n  const numSubChunks = subChunkOffsets.length - 1;\n  for (let subChunk = 0; subChunk < numSubChunks; ++subChunk) {\n    maxSubChunkIndices = Math.max(\n      maxSubChunkIndices,\n      subChunkOffsets[subChunk + 1] - subChunkOffsets[subChunk],\n    );\n  }\n\n  const triangleAdjacencies = new Uint32Array(maxSubChunkIndices);\n  const edgeMap = new Uint32Array(getEdgeMapSize(maxSubChunkIndices));\n\n  let subChunkOffset = subChunkOffsets[0];\n  for (let subChunk = 0; subChunk < numSubChunks; ++subChunk) {\n    subChunkOffsets[subChunk] = outputIndex;\n    const subChunkEnd = subChunkOffsets[subChunk + 1];\n    const subIndices = indices.subarray(subChunkOffset, subChunkEnd);\n    if (DEBUG_TIMING) startTime = Date.now();\n    computeTriangleAdjacencies(triangleAdjacencies, subIndices, edgeMap);\n    if (DEBUG_TIMING) midTime = Date.now();\n    outputIndex = emitTriangleStrips(\n      subIndices,\n      triangleAdjacencies,\n      output,\n      outputIndex,\n    );\n    if (DEBUG_TIMING) {\n      endTime = Date.now();\n      adjacenciesElapsed += midTime - startTime;\n      emitElapsed += endTime - midTime;\n    }\n    subChunkOffset = subChunkEnd;\n  }\n  --outputIndex;\n  subChunkOffsets[numSubChunks] = outputIndex;\n  const shrunkOutput: T = new (output.constructor as any)(outputIndex);\n  shrunkOutput.set(output.subarray(0, outputIndex));\n  if (DEBUG_TIMING) {\n    console.log(\n      `reduced from ${indices.byteLength}(${indices.BYTES_PER_ELEMENT}) -> ${shrunkOutput.byteLength}(${shrunkOutput.BYTES_PER_ELEMENT}): adj=${adjacenciesElapsed}, emit=${emitElapsed}, ${collisions}/${indices.length} collisions`,\n    );\n  }\n  return shrunkOutput;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TypedArray } from \"#src/util/array.js\";\nimport type { Uint64 } from \"#src/util/uint64.js\";\n\nexport function getOctreeChildIndex(x: number, y: number, z: number) {\n  return (x & 1) | ((y << 1) & 2) | ((z << 2) & 4);\n}\n\n/**\n * Decodes a \"compressed\" 3-d morton index.\n *\n * Decoded bit `i` of `x`, `y`, and `z` is at bit `i + min(i, yBits) + min(i, zBits)`, `i + min(i +\n * 1, xBits) + min(i, zBits)`, and `i + min(i + 1, xBits) + min(i + 1, zBits)` of `zindex`,\n * respectively, for `i` in `[0, xBits)`, `[0, yBits)`, `[0, zBits)`, respectively.\n */\nexport function decodeZIndexCompressed(\n  zindex: Uint64,\n  xBits: number,\n  yBits: number,\n  zBits: number,\n): Uint32Array {\n  const maxCoordBits = Math.max(xBits, yBits, zBits);\n  let inputBit = 0;\n  let inputValue = zindex.low;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  for (let coordBit = 0; coordBit < maxCoordBits; ++coordBit) {\n    if (coordBit < xBits) {\n      const bit = (inputValue >>> inputBit) & 1;\n      x |= bit << coordBit;\n      if (inputBit === 31) {\n        inputBit = 0;\n        inputValue = zindex.high;\n      } else {\n        ++inputBit;\n      }\n    }\n    if (coordBit < yBits) {\n      const bit = (inputValue >>> inputBit) & 1;\n      y |= bit << coordBit;\n      if (inputBit === 31) {\n        inputBit = 0;\n        inputValue = zindex.high;\n      } else {\n        ++inputBit;\n      }\n    }\n    if (coordBit < zBits) {\n      const bit = (inputValue >>> inputBit) & 1;\n      z |= bit << coordBit;\n      if (inputBit === 31) {\n        inputBit = 0;\n        inputValue = zindex.high;\n      } else {\n        ++inputBit;\n      }\n    }\n  }\n  return Uint32Array.of(x, y, z);\n}\n\nexport function encodeZIndexCompressed3d(\n  zindex: Uint64,\n  xBits: number,\n  yBits: number,\n  zBits: number,\n  x: number,\n  y: number,\n  z: number,\n): Uint64 {\n  const maxBits = Math.max(xBits, yBits, zBits);\n  let outputBit = 0;\n  let outputNum = 0;\n  let isHigh = false;\n  function writeBit(b: number): void {\n    outputNum |= (b & 1) << outputBit;\n    if (++outputBit === 32) {\n      zindex.low = outputNum >>> 0;\n      outputNum = 0;\n      outputBit = 0;\n      isHigh = true;\n    }\n  }\n  for (let bit = 0; bit < maxBits; ++bit) {\n    if (bit < xBits) {\n      writeBit((x >> bit) & 1);\n    }\n    if (bit < yBits) {\n      writeBit((y >> bit) & 1);\n    }\n    if (bit < zBits) {\n      writeBit((z >> bit) & 1);\n    }\n  }\n  if (isHigh) {\n    zindex.high = outputNum >>> 0;\n  } else {\n    zindex.high = 0;\n    zindex.low = outputNum >>> 0;\n  }\n  return zindex;\n}\n\nexport function encodeZIndexCompressed(\n  zindex: Uint64,\n  position: TypedArray,\n  shape: TypedArray,\n): Uint64 {\n  let outputBit = 0;\n  const rank = position.length;\n  let outputNum = 0;\n  let isHigh = false;\n  function writeBit(b: number): void {\n    outputNum |= (b & 1) << outputBit;\n    if (++outputBit === 32) {\n      zindex.low = outputNum >>> 0;\n      outputNum = 0;\n      outputBit = 0;\n      isHigh = true;\n    }\n  }\n\n  for (let bit = 0; bit < 32; ++bit) {\n    for (let dim = 0; dim < rank; ++dim) {\n      if ((shape[dim] - 1) >>> bit) {\n        writeBit(position[dim] >>> bit);\n      }\n    }\n  }\n  if (isHigh) {\n    zindex.high = outputNum >>> 0;\n  } else {\n    zindex.high = 0;\n    zindex.low = outputNum >>> 0;\n  }\n  return zindex;\n}\n\nfunction lessMsb(a: number, b: number) {\n  return a < b && a < (a ^ b);\n}\n\n/**\n * Returns `true` if `(x0, y0, z0)` occurs before `(x1, y1, z1)` in Z-curve order.\n */\nexport function zorder3LessThan(\n  x0: number,\n  y0: number,\n  z0: number,\n  x1: number,\n  y1: number,\n  z1: number,\n): boolean {\n  let mostSignificant0 = z0;\n  let mostSignificant1 = z1;\n\n  if (lessMsb(mostSignificant0 ^ mostSignificant1, y0 ^ y1)) {\n    mostSignificant0 = y0;\n    mostSignificant1 = y1;\n  }\n\n  if (lessMsb(mostSignificant0 ^ mostSignificant1, x0 ^ x1)) {\n    mostSignificant0 = x0;\n    mostSignificant1 = x1;\n  }\n\n  return mostSignificant0 < mostSignificant1;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Chunk,\n  ChunkSource,\n  withChunkManager,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier, ChunkState } from \"#src/chunk_manager/base.js\";\nimport type {\n  EncodedMeshData,\n  EncodedVertexPositions,\n  MeshVertexIndices,\n  MultiscaleFragmentFormat,\n} from \"#src/mesh/base.js\";\nimport {\n  FRAGMENT_SOURCE_RPC_ID,\n  MESH_LAYER_RPC_ID,\n  MULTISCALE_FRAGMENT_SOURCE_RPC_ID,\n  MULTISCALE_MESH_LAYER_RPC_ID,\n  VertexPositionFormat,\n} from \"#src/mesh/base.js\";\nimport type { MultiscaleMeshManifest } from \"#src/mesh/multiscale.js\";\nimport { getDesiredMultiscaleMeshChunks } from \"#src/mesh/multiscale.js\";\nimport { computeTriangleStrips } from \"#src/mesh/triangle_strips.js\";\nimport type { PerspectiveViewBackend } from \"#src/perspective_view/backend.js\";\nimport { PerspectiveViewRenderLayerBackend } from \"#src/perspective_view/backend.js\";\nimport { get3dModelToDisplaySpaceMatrix } from \"#src/render_coordinate_transform.js\";\nimport type { RenderLayerBackendAttachment } from \"#src/render_layer_backend.js\";\nimport { withSegmentationLayerBackendState } from \"#src/segmentation_display_state/backend.js\";\nimport {\n  getObjectKey,\n  forEachVisibleSegment,\n} from \"#src/segmentation_display_state/base.js\";\nimport type { Endianness } from \"#src/util/endian.js\";\nimport { convertEndian32 } from \"#src/util/endian.js\";\nimport { getFrustrumPlanes, mat4, vec3 } from \"#src/util/geom.js\";\nimport {\n  verifyObject,\n  verifyObjectProperty,\n  verifyStringArray,\n} from \"#src/util/json.js\";\nimport { Uint64 } from \"#src/util/uint64.js\";\nimport { zorder3LessThan } from \"#src/util/zorder.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nconst MESH_OBJECT_MANIFEST_CHUNK_PRIORITY = 100;\nconst MESH_OBJECT_FRAGMENT_CHUNK_PRIORITY = 50;\n\nconst CONVERT_TO_TRIANGLE_STRIPS = false;\n\nexport type FragmentId = string;\n\n// Chunk that contains the list of fragments that make up a single object.\nexport class ManifestChunk extends Chunk {\n  objectId = new Uint64();\n  fragmentIds: FragmentId[] | null;\n  // We can't save a reference to objectId, because it may be a temporary\n  // object.\n  initializeManifestChunk(key: string, objectId: Uint64) {\n    super.initialize(key);\n    this.objectId.assign(objectId);\n  }\n\n  freeSystemMemory() {\n    this.fragmentIds = null;\n  }\n\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    msg.fragmentIds = this.fragmentIds;\n  }\n\n  downloadSucceeded() {\n    // We can't easily determine the memory usage of the JSON manifest.  Just use 100 bytes as a\n    // default value.\n    this.systemMemoryBytes = 100;\n    this.gpuMemoryBytes = 0;\n    super.downloadSucceeded();\n    if (this.priorityTier < ChunkPriorityTier.RECENT) {\n      this.source!.chunkManager.scheduleUpdateChunkPriorities();\n    }\n  }\n\n  toString() {\n    return this.objectId.toString();\n  }\n}\n\nexport interface RawMeshData {\n  vertexPositions: Float32Array | Uint32Array;\n  indices: MeshVertexIndices;\n}\n\nexport interface RawPartitionedMeshData extends RawMeshData {\n  subChunkOffsets: Uint32Array;\n}\n\nfunction serializeMeshData(data: EncodedMeshData, msg: any, transfers: any[]) {\n  const { vertexPositions, indices, vertexNormals, strips } = data;\n  msg.vertexPositions = vertexPositions;\n  msg.indices = indices;\n  msg.strips = strips;\n  msg.vertexNormals = vertexNormals;\n  const vertexPositionsBuffer = vertexPositions!.buffer;\n  transfers.push(vertexPositionsBuffer);\n  const indicesBuffer = indices!.buffer;\n  if (indicesBuffer !== vertexPositionsBuffer) {\n    transfers.push(indicesBuffer);\n  }\n  transfers.push(vertexNormals!.buffer);\n}\n\nfunction getMeshDataSize(data: EncodedMeshData) {\n  const { vertexPositions, indices, vertexNormals } = data;\n  return (\n    vertexPositions!.byteLength +\n    indices!.byteLength +\n    vertexNormals!.byteLength\n  );\n}\n\n/**\n * Chunk that contains the mesh for a single fragment of a single object.\n */\nexport class FragmentChunk extends Chunk {\n  manifestChunk: ManifestChunk | null = null;\n  fragmentId: FragmentId | null = null;\n  meshData: EncodedMeshData | null = null;\n  initializeFragmentChunk(\n    key: string,\n    manifestChunk: ManifestChunk,\n    fragmentId: FragmentId,\n  ) {\n    super.initialize(key);\n    this.manifestChunk = manifestChunk;\n    this.fragmentId = fragmentId;\n  }\n  freeSystemMemory() {\n    this.manifestChunk = null;\n    this.meshData = null;\n    this.fragmentId = null;\n  }\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    serializeMeshData(this.meshData!, msg, transfers);\n    this.meshData = null;\n  }\n  downloadSucceeded() {\n    this.systemMemoryBytes = this.gpuMemoryBytes = getMeshDataSize(\n      this.meshData!,\n    );\n    super.downloadSucceeded();\n  }\n}\n\n/**\n * Assigns chunk.fragmentKeys to response[keysPropertyName].\n *\n * Verifies that response[keysPropertyName] is an array of strings.\n */\nexport function decodeJsonManifestChunk(\n  chunk: ManifestChunk,\n  response: any,\n  keysPropertyName: string,\n) {\n  verifyObject(response);\n  chunk.fragmentIds = verifyObjectProperty(\n    response,\n    keysPropertyName,\n    verifyStringArray,\n  );\n}\n\n/**\n * Computes normal vectors for each vertex of a triangular mesh.\n *\n * The normal vector for each triangle with vertices (v0, v1, v2) is computed as the (normalized)\n * cross product of (v1 - v0, v2 - v1).  The normal vector for each vertex is obtained by averaging\n * the normal vector of each of the triangles that contains it.\n *\n * @param positions The vertex positions in [x0, y0, z0, x1, y1, z1, ...] format.\n * @param indices The indices of the triangle vertices.  Each triplet of consecutive values\n *     specifies a triangle.\n */\nexport function computeVertexNormals(\n  positions: Float32Array | Uint8Array | Uint16Array | Uint32Array,\n  indices: Uint8Array | Uint16Array | Uint32Array,\n) {\n  const faceNormal = vec3.create();\n  const v1v0 = vec3.create();\n  const v2v1 = vec3.create();\n  const vertexNormals = new Float32Array(positions.length);\n  const numIndices = indices.length;\n  for (let i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i] * 3;\n    const i1 = indices[i + 1] * 3;\n    const i2 = indices[i + 2] * 3;\n    for (let j = 0; j < 3; ++j) {\n      v1v0[j] = positions[i1 + j] - positions[i0 + j];\n      v2v1[j] = positions[i2 + j] - positions[i1 + j];\n    }\n    vec3.cross(faceNormal, v1v0, v2v1);\n    vec3.normalize(faceNormal, faceNormal);\n\n    for (let k = 0; k < 3; ++k) {\n      const index = indices[i + k];\n      const offset = index * 3;\n      for (let j = 0; j < 3; ++j) {\n        vertexNormals[offset + j] += faceNormal[j];\n      }\n    }\n  }\n  // Normalize all vertex normals.\n  const numVertices = vertexNormals.length;\n  for (let i = 0; i < numVertices; i += 3) {\n    const vec = <vec3>vertexNormals.subarray(i, i + 3);\n    vec3.normalize(vec, vec);\n  }\n  return vertexNormals;\n}\n\n/**\n * Converts a floating-point number in the range `[-1, 1]` to an integer in the range `[-127, 127]`.\n */\nfunction snorm8(x: number) {\n  return Math.min(Math.max(-127, x * 127 + 0.5), 127) >>> 0;\n}\n\nfunction signNotZero(x: number) {\n  return x < 0 ? -1 : 1;\n}\n\n/**\n * Encodes normal vectors represented as 3x32-bit floating vectors into a 2x8-bit octahedron\n * representation.\n *\n * Zina H. Cigolle, Sam Donow, Daniel Evangelakos, Michael Mara, Morgan McGuire, and Quirin Meyer,\n * Survey of Efficient Representations for Independent Unit Vectors, Journal of Computer Graphics\n * Techniques (JCGT), vol. 3, no. 2, 1-30, 2014\n *\n * Available online http://jcgt.org/published/0003/02/01/\n *\n * @param out[out] Row-major array of shape `[n, 2]` set to octahedron representation.\n * @param normals[in] Row-major array of shape `[n, 3]` specifying unit normal vectors.\n */\nexport function encodeNormals32fx3ToOctahedron8x2(\n  out: Uint8Array,\n  normals: Float32Array,\n) {\n  const length = normals.length;\n  let outIndex = 0;\n  for (let i = 0; i < length; i += 3) {\n    const x = normals[i];\n    const y = normals[i + 1];\n    const z = normals[i + 2];\n\n    const invL1Norm = 1 / (Math.abs(x) + Math.abs(y) + Math.abs(z));\n\n    if (z < 0) {\n      out[outIndex] = snorm8((1 - Math.abs(y * invL1Norm)) * signNotZero(x));\n      out[outIndex + 1] = snorm8(\n        (1 - Math.abs(x * invL1Norm)) * signNotZero(y),\n      );\n    } else {\n      out[outIndex] = snorm8(x * invL1Norm);\n      out[outIndex + 1] = snorm8(y * invL1Norm);\n    }\n    outIndex += 2;\n  }\n}\n\n/**\n * Extracts vertex positions and indices of the specified endianness from `data'.\n *\n * The vertexByteOffset specifies the byte offset into `data' of the start of the vertex position\n * data.  The vertex data must consist of verticesPerPrimitive * numVertices 32-bit float values.\n *\n * If indexByteOffset is not specified, it defaults to the end of the vertex position data.  If\n * numPrimitives is not specified, it is assumed that the index data continues until the end of the\n * array.\n */\nexport function decodeVertexPositionsAndIndices(\n  verticesPerPrimitive: number,\n  data: ArrayBuffer,\n  endianness: Endianness,\n  vertexByteOffset: number,\n  numVertices: number,\n  indexByteOffset?: number,\n  numPrimitives?: number,\n): RawMeshData {\n  const vertexPositions = new Float32Array(\n    data,\n    vertexByteOffset,\n    numVertices * 3,\n  );\n  convertEndian32(vertexPositions, endianness);\n\n  if (indexByteOffset === undefined) {\n    indexByteOffset = vertexByteOffset + 12 * numVertices;\n  }\n\n  let numIndices: number | undefined;\n  if (numPrimitives !== undefined) {\n    numIndices = numPrimitives * verticesPerPrimitive;\n  }\n\n  // For compatibility with Firefox, length argument must not be undefined.\n  const indices =\n    numIndices === undefined\n      ? new Uint32Array(data, indexByteOffset)\n      : new Uint32Array(data, indexByteOffset, numIndices);\n  if (indices.length % verticesPerPrimitive !== 0) {\n    throw new Error(\n      `Number of indices is not a multiple of ${verticesPerPrimitive}: ${indices.length}.`,\n    );\n  }\n  convertEndian32(indices, endianness);\n\n  return { vertexPositions, indices };\n}\n\n/**\n * Extracts vertex positions and triangle vertex indices of the specified endianness from `data'.\n *\n * Vertex normals are computed.\n *\n * See decodeVertexPositionsAndIndices above.\n */\nexport function decodeTriangleVertexPositionsAndIndices(\n  data: ArrayBuffer,\n  endianness: Endianness,\n  vertexByteOffset: number,\n  numVertices: number,\n  indexByteOffset?: number,\n  numTriangles?: number,\n) {\n  return decodeVertexPositionsAndIndices(\n    /*verticesPerPrimitive=*/ 3,\n    data,\n    endianness,\n    vertexByteOffset,\n    numVertices,\n    indexByteOffset,\n    numTriangles,\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface MeshSource {\n  // TODO(jbms): Move this declaration to class definition below and declare abstract once\n  // TypeScript supports mixins with abstract classes.\n  downloadFragment(\n    chunk: FragmentChunk,\n    abortSignal: AbortSignal,\n  ): Promise<void>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class MeshSource extends ChunkSource {\n  fragmentSource: FragmentSource;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    const fragmentSource = (this.fragmentSource = this.registerDisposer(\n      rpc.getRef<FragmentSource>(options.fragmentSource),\n    ));\n    fragmentSource.meshSource = this;\n  }\n\n  getChunk(objectId: Uint64) {\n    const key = getObjectKey(objectId);\n    let chunk = <ManifestChunk>this.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(ManifestChunk);\n      chunk.initializeManifestChunk(key, objectId);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n\n  getFragmentKey(objectKey: string | null, fragmentId: string) {\n    return { key: `${objectKey}/${fragmentId}`, fragmentId: fragmentId };\n  }\n\n  getFragmentChunk(manifestChunk: ManifestChunk, fragmentId: FragmentId) {\n    const fragmentSource = this.fragmentSource;\n    const { key: fragmentKey, fragmentId: parsedFragmentId } =\n      this.getFragmentKey(manifestChunk.key, fragmentId);\n    let chunk = <FragmentChunk>fragmentSource.chunks.get(fragmentKey);\n    if (chunk === undefined) {\n      chunk = fragmentSource.getNewChunk_(FragmentChunk);\n      chunk.initializeFragmentChunk(\n        fragmentKey,\n        manifestChunk,\n        parsedFragmentId,\n      );\n      fragmentSource.addChunk(chunk);\n    }\n    return chunk;\n  }\n}\n\n@registerSharedObject(FRAGMENT_SOURCE_RPC_ID)\nexport class FragmentSource extends ChunkSource {\n  meshSource: MeshSource | null = null;\n  download(chunk: FragmentChunk, abortSignal: AbortSignal) {\n    return this.meshSource!.downloadFragment(chunk, abortSignal);\n  }\n}\n\n@registerSharedObject(MESH_LAYER_RPC_ID)\nexport class MeshLayer extends withSegmentationLayerBackendState(\n  withSharedVisibility(withChunkManager(PerspectiveViewRenderLayerBackend)),\n) {\n  source: MeshSource;\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = this.registerDisposer(rpc.getRef<MeshSource>(options.source));\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateChunkPriorities();\n      }),\n    );\n  }\n\n  attach(attachment: RenderLayerBackendAttachment<PerspectiveViewBackend>) {\n    const scheduleUpdateChunkPriorities = () => {\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    };\n    const { view } = attachment;\n    attachment.registerDisposer(\n      view.visibility.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(scheduleUpdateChunkPriorities);\n    scheduleUpdateChunkPriorities();\n  }\n\n  private updateChunkPriorities() {\n    const visibility = this.visibility.value;\n    if (visibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    this.chunkManager.registerLayer(this);\n    const priorityTier = getPriorityTier(visibility);\n    const basePriority = getBasePriority(visibility);\n    const { source, chunkManager } = this;\n    forEachVisibleSegment(this, (objectId) => {\n      const manifestChunk = source.getChunk(objectId);\n      ++this.numVisibleChunksNeeded;\n      chunkManager.requestChunk(\n        manifestChunk,\n        priorityTier,\n        basePriority + MESH_OBJECT_MANIFEST_CHUNK_PRIORITY,\n      );\n      const state = manifestChunk.state;\n      if (\n        state === ChunkState.SYSTEM_MEMORY_WORKER ||\n        state === ChunkState.SYSTEM_MEMORY ||\n        state === ChunkState.GPU_MEMORY\n      ) {\n        ++this.numVisibleChunksAvailable;\n        for (const fragmentId of manifestChunk.fragmentIds!) {\n          const fragmentChunk = source.getFragmentChunk(\n            manifestChunk,\n            fragmentId,\n          );\n          ++this.numVisibleChunksNeeded;\n          chunkManager.requestChunk(\n            fragmentChunk,\n            priorityTier,\n            basePriority + MESH_OBJECT_FRAGMENT_CHUNK_PRIORITY,\n          );\n          if (fragmentChunk.state === ChunkState.GPU_MEMORY) {\n            ++this.numVisibleChunksAvailable;\n          }\n        }\n      }\n    });\n  }\n}\n\n// Chunk that contains the list of fragments that make up a single object.\nexport class MultiscaleManifestChunk extends Chunk {\n  objectId = new Uint64();\n  manifest: MultiscaleMeshManifest | undefined;\n  // We can't save a reference to objectId, because it may be a temporary\n  // object.\n  initializeManifestChunk(key: string, objectId: Uint64) {\n    super.initialize(key);\n    this.objectId.assign(objectId);\n  }\n\n  freeSystemMemory() {\n    this.manifest = undefined;\n  }\n\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    msg.manifest = this.manifest;\n  }\n\n  downloadSucceeded() {\n    this.systemMemoryBytes = this.manifest!.octree.byteLength;\n    this.gpuMemoryBytes = 0;\n    super.downloadSucceeded();\n    if (this.priorityTier < ChunkPriorityTier.RECENT) {\n      this.source!.chunkManager.scheduleUpdateChunkPriorities();\n    }\n  }\n\n  toString() {\n    return this.objectId.toString();\n  }\n}\n\n/**\n * Chunk that contains the mesh for a single fragment of a single object.\n */\nexport class MultiscaleFragmentChunk extends Chunk {\n  subChunkOffsets: Uint32Array | null = null;\n  meshData: EncodedMeshData | null = null;\n  lod = 0;\n  chunkIndex = 0;\n  manifestChunk: MultiscaleManifestChunk | null = null;\n  freeSystemMemory() {\n    this.meshData = this.subChunkOffsets = null;\n  }\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    serializeMeshData(this.meshData!, msg, transfers);\n    const { subChunkOffsets } = this;\n    msg.subChunkOffsets = subChunkOffsets;\n    transfers.push(subChunkOffsets!.buffer);\n    this.meshData = this.subChunkOffsets = null;\n  }\n  downloadSucceeded() {\n    const { subChunkOffsets } = this;\n    this.systemMemoryBytes = this.gpuMemoryBytes = getMeshDataSize(\n      this.meshData!,\n    );\n    this.systemMemoryBytes += subChunkOffsets!.byteLength;\n    super.downloadSucceeded();\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface MultiscaleMeshSource {\n  // TODO(jbms): Move this declaration to class definition below and declare abstract once\n  // TypeScript supports mixins with abstract classes.\n  downloadFragment(\n    chunk: MultiscaleFragmentChunk,\n    abortSignal: AbortSignal,\n  ): Promise<void>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class MultiscaleMeshSource extends ChunkSource {\n  fragmentSource: MultiscaleFragmentSource;\n  format: MultiscaleFragmentFormat;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    const fragmentSource = (this.fragmentSource = this.registerDisposer(\n      rpc.getRef<MultiscaleFragmentSource>(options.fragmentSource),\n    ));\n    this.format = options.format;\n    fragmentSource.meshSource = this;\n  }\n\n  getChunk(objectId: Uint64) {\n    const key = getObjectKey(objectId);\n    let chunk = <MultiscaleManifestChunk>this.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(MultiscaleManifestChunk);\n      chunk.initializeManifestChunk(key, objectId);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n\n  getFragmentChunk(\n    manifestChunk: MultiscaleManifestChunk,\n    lod: number,\n    chunkIndex: number,\n  ) {\n    const key = `${manifestChunk.key}/${lod}:${chunkIndex}`;\n    const fragmentSource = this.fragmentSource;\n    let chunk = <MultiscaleFragmentChunk>fragmentSource.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = fragmentSource.getNewChunk_(MultiscaleFragmentChunk);\n      chunk.initialize(key);\n      chunk.lod = lod;\n      chunk.chunkIndex = chunkIndex;\n      chunk.manifestChunk = manifestChunk;\n      fragmentSource.addChunk(chunk);\n    }\n    return chunk;\n  }\n}\n\n@registerSharedObject(MULTISCALE_FRAGMENT_SOURCE_RPC_ID)\nexport class MultiscaleFragmentSource extends ChunkSource {\n  meshSource: MultiscaleMeshSource | null = null;\n  download(chunk: MultiscaleFragmentChunk, abortSignal: AbortSignal) {\n    return this.meshSource!.downloadFragment(chunk, abortSignal);\n  }\n}\n\nconst tempModelMatrix = mat4.create();\n\n@registerSharedObject(MULTISCALE_MESH_LAYER_RPC_ID)\nexport class MultiscaleMeshLayer extends withSegmentationLayerBackendState(\n  withSharedVisibility(withChunkManager(PerspectiveViewRenderLayerBackend)),\n) {\n  source: MultiscaleMeshSource;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = this.registerDisposer(\n      rpc.getRef<MultiscaleMeshSource>(options.source),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateChunkPriorities();\n      }),\n    );\n  }\n\n  attach(attachment: RenderLayerBackendAttachment<PerspectiveViewBackend>) {\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    const { view } = attachment;\n    attachment.registerDisposer(\n      view.projectionParameters.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(\n      view.visibility.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(scheduleUpdateChunkPriorities);\n    scheduleUpdateChunkPriorities();\n  }\n\n  private updateChunkPriorities() {\n    const maxVisibility = this.visibility.value;\n    if (maxVisibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    const {\n      transform: { value: transform },\n    } = this;\n    if (transform.error !== undefined) return;\n    const manifestChunks = new Array<MultiscaleManifestChunk>();\n    this.chunkManager.registerLayer(this);\n    {\n      const priorityTier = getPriorityTier(maxVisibility);\n      const basePriority = getBasePriority(maxVisibility);\n      const { source, chunkManager } = this;\n      forEachVisibleSegment(this, (objectId) => {\n        const manifestChunk = source.getChunk(objectId);\n        ++this.numVisibleChunksNeeded;\n        chunkManager.requestChunk(\n          manifestChunk,\n          priorityTier,\n          basePriority + MESH_OBJECT_MANIFEST_CHUNK_PRIORITY,\n        );\n        const state = manifestChunk.state;\n        if (\n          state === ChunkState.SYSTEM_MEMORY_WORKER ||\n          state === ChunkState.SYSTEM_MEMORY ||\n          state === ChunkState.GPU_MEMORY\n        ) {\n          manifestChunks.push(manifestChunk);\n          ++this.numVisibleChunksAvailable;\n        }\n      });\n    }\n    if (manifestChunks.length === 0) return;\n    const { source, chunkManager } = this;\n    for (const { view } of this.attachments.values()) {\n      const visibility = view.visibility.value;\n      if (visibility === Number.NEGATIVE_INFINITY) {\n        continue;\n      }\n      const priorityTier = getPriorityTier(visibility);\n      const basePriority = getBasePriority(visibility);\n      const projectionParameters = view.projectionParameters.value;\n      const modelViewProjectionMatrix = tempModelMatrix;\n      try {\n        get3dModelToDisplaySpaceMatrix(\n          modelViewProjectionMatrix,\n          projectionParameters.displayDimensionRenderInfo,\n          transform,\n        );\n      } catch {\n        continue;\n      }\n      mat4.multiply(\n        modelViewProjectionMatrix,\n        projectionParameters.viewProjectionMat,\n        modelViewProjectionMatrix,\n      );\n      const clippingPlanes = getFrustrumPlanes(\n        new Float32Array(24),\n        modelViewProjectionMatrix,\n      );\n      const detailCutoff = this.renderScaleTarget.value;\n      for (const manifestChunk of manifestChunks) {\n        const maxLod = manifestChunk.manifest!.lodScales.length - 1;\n        getDesiredMultiscaleMeshChunks(\n          manifestChunk.manifest!,\n          modelViewProjectionMatrix,\n          clippingPlanes,\n          detailCutoff,\n          projectionParameters.width,\n          projectionParameters.height,\n          (lod, chunkIndex, _renderScale, empty) => {\n            if (empty) return;\n            const fragmentChunk = source.getFragmentChunk(\n              manifestChunk,\n              lod,\n              chunkIndex,\n            );\n            ++this.numVisibleChunksNeeded;\n            chunkManager.requestChunk(\n              fragmentChunk,\n              priorityTier,\n              basePriority + MESH_OBJECT_FRAGMENT_CHUNK_PRIORITY - maxLod + lod,\n            );\n            if (fragmentChunk.state === ChunkState.GPU_MEMORY) {\n              ++this.numVisibleChunksAvailable;\n            }\n          },\n        );\n      }\n    }\n  }\n}\n\nfunction convertMeshData(\n  data: RawMeshData & { subChunkOffsets?: Uint32Array },\n  vertexPositionFormat: VertexPositionFormat,\n): EncodedMeshData {\n  const normals = computeVertexNormals(data.vertexPositions, data.indices);\n  const encodedNormals = new Uint8Array((normals.length / 3) * 2);\n  encodeNormals32fx3ToOctahedron8x2(encodedNormals, normals);\n  let encodedIndices: MeshVertexIndices;\n  let strips: boolean;\n  if (CONVERT_TO_TRIANGLE_STRIPS) {\n    encodedIndices = computeTriangleStrips(data.indices, data.subChunkOffsets);\n    strips = true;\n  } else {\n    if (\n      data.indices.BYTES_PER_ELEMENT === 4 &&\n      data.vertexPositions.length / 3 < 65535\n    ) {\n      encodedIndices = new Uint16Array(data.indices.length);\n      encodedIndices.set(data.indices);\n    } else {\n      encodedIndices = data.indices;\n    }\n    strips = false;\n  }\n  let encodedVertexPositions: EncodedVertexPositions;\n  if (vertexPositionFormat === VertexPositionFormat.uint10) {\n    const vertexPositions = data.vertexPositions;\n    const numVertices = vertexPositions.length / 3;\n    encodedVertexPositions = new Uint32Array(numVertices);\n    for (\n      let inputIndex = 0, outputIndex = 0;\n      outputIndex < numVertices;\n      inputIndex += 3, ++outputIndex\n    ) {\n      encodedVertexPositions[outputIndex] =\n        (vertexPositions[inputIndex] & 1023) |\n        ((vertexPositions[inputIndex + 1] & 1023) << 10) |\n        ((vertexPositions[inputIndex + 2] & 1023) << 20);\n    }\n  } else if (vertexPositionFormat === VertexPositionFormat.uint16) {\n    const vertexPositions = data.vertexPositions;\n    if (vertexPositions.BYTES_PER_ELEMENT === 2) {\n      encodedVertexPositions = vertexPositions;\n    } else {\n      encodedVertexPositions = new Uint16Array(vertexPositions.length);\n      encodedVertexPositions.set(vertexPositions);\n    }\n  } else {\n    encodedVertexPositions = data.vertexPositions as Float32Array;\n  }\n  return {\n    vertexPositions: encodedVertexPositions,\n    vertexNormals: encodedNormals,\n    indices: encodedIndices,\n    strips,\n  };\n}\n\nexport function assignMeshFragmentData(\n  chunk: FragmentChunk,\n  data: RawMeshData,\n  vertexPositionFormat: VertexPositionFormat = VertexPositionFormat.float32,\n) {\n  chunk.meshData = convertMeshData(data, vertexPositionFormat);\n}\n\nexport function assignMultiscaleMeshFragmentData(\n  chunk: MultiscaleFragmentChunk,\n  data: RawPartitionedMeshData,\n  vertexPositionFormat: VertexPositionFormat,\n) {\n  chunk.meshData = convertMeshData(data, vertexPositionFormat);\n  chunk.subChunkOffsets = data.subChunkOffsets;\n}\n\nexport function generateHigherOctreeLevel(\n  octree: Uint32Array,\n  priorStart: number,\n  priorEnd: number,\n): number {\n  let curEnd = priorEnd;\n  for (let i = 0; i < 3; ++i) {\n    octree[curEnd * 5 + i] = octree[priorStart * 5 + i] >>> 1;\n  }\n  octree[curEnd * 5 + 3] = priorStart;\n  for (let i = priorStart + 1; i < priorEnd; ++i) {\n    const x = octree[i * 5] >>> 1;\n    const y = octree[i * 5 + 1] >>> 1;\n    const z = octree[i * 5 + 2] >>> 1;\n    if (\n      x !== octree[curEnd * 5] ||\n      y !== octree[curEnd * 5 + 1] ||\n      z !== octree[curEnd * 5 + 2]\n    ) {\n      octree[curEnd * 5 + 4] = i;\n      ++curEnd;\n      octree[curEnd * 5] = x;\n      octree[curEnd * 5 + 1] = y;\n      octree[curEnd * 5 + 2] = z;\n      octree[curEnd * 5 + 3] = i;\n    }\n  }\n  octree[curEnd * 5 + 4] = priorEnd;\n  ++curEnd;\n  return curEnd;\n}\n\nexport function computeOctreeChildOffsets(\n  octree: Uint32Array,\n  childStart: number,\n  childEnd: number,\n  parentEnd: number,\n) {\n  let childNode = childStart;\n  for (let parentNode = childEnd; parentNode < parentEnd; ++parentNode) {\n    const parentX = octree[parentNode * 5];\n    const parentY = octree[parentNode * 5 + 1];\n    const parentZ = octree[parentNode * 5 + 2];\n    while (childNode < childEnd) {\n      const childX = octree[childNode * 5] >>> 1;\n      const childY = octree[childNode * 5 + 1] >>> 1;\n      const childZ = octree[childNode * 5 + 2] >>> 1;\n      if (!zorder3LessThan(childX, childY, childZ, parentX, parentY, parentZ)) {\n        break;\n      }\n      ++childNode;\n    }\n    octree[parentNode * 5 + 3] = childNode;\n    while (childNode < childEnd) {\n      const childX = octree[childNode * 5] >>> 1;\n      const childY = octree[childNode * 5 + 1] >>> 1;\n      const childZ = octree[childNode * 5 + 2] >>> 1;\n      if (childX !== parentX || childY !== parentY || childZ !== parentZ) {\n        break;\n      }\n      ++childNode;\n    }\n    octree[parentNode * 5 + 4] += childNode;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { mat4, vec3 } from \"#src/util/geom.js\";\nimport { isAABBVisible } from \"#src/util/geom.js\";\nimport { getOctreeChildIndex } from \"#src/util/zorder.js\";\n\nconst DEBUG_CHUNKS_TO_DRAW = false;\n\nexport interface MultiscaleMeshManifest {\n  /**\n   * Size of finest-resolution (base) chunk in object coordinates.\n   */\n  chunkShape: vec3;\n\n  /**\n   * Starting corner position of (0, 0, 0) chunk in object coordinates.\n   */\n  chunkGridSpatialOrigin: vec3;\n\n  /**\n   * Axis-aligned bounding box lower bound of object in object coordinates to use for clipping and\n   * level-of-detail calculations.\n   */\n  clipLowerBound: vec3;\n\n  /**\n   * Axis-aligned bounding box upper bound of object in object coordinates to use for clipping and\n   * level-of-detail calculations.\n   */\n  clipUpperBound: vec3;\n\n  /**\n   * Specifies the number of levels of detail (as `lodScales.length`), and the resolution in object\n   * coordinates for each level of detail.  If `lodScales[lod] === 0`, then level-of-detail `lod`\n   * does not exist.\n   *\n   * Level of detail `0` is the finest resolution.\n   *\n   * The non-zero values must be non-decreasing.\n   *\n   * For each chunk, the chosen `lod` is the largest value such that\n   * `lodScales[lod] <= detailCutoff * pixelSize`, where `pixelSize` is the maximum spatial distance\n   * spanned by a single viewport pixel within the projected image of the chunk.\n   */\n  lodScales: Float32Array;\n\n  /**\n   * C order `[numLods, 3]` array specifying the xyz vertex position offset in object coordinates\n   * for each level of detail.\n   */\n  vertexOffsets: Float32Array;\n\n  /**\n   * Row-major `[n, 5]` array where each row is of the form `[x, y, z, start, end_and_empty]`, where\n   * `x`, `y`, and `z` are the chunk grid coordinates of the entry at a particular level of detail.\n   * Row `n-1` corresponds to level of detail `lodScales.length - 1`, the root of the octree.  Given\n   * a row corresponding to an octree node at level of detail `lod`, bits `start` specifies the row\n   * number of the first child octree node at level of detail `lod-1`, and bits `[0,30]` of\n   * `end_and_empty` specify one past the row number of the last child octree node.  Bit `31` of\n   * `end_and_empty` is set to `1` if the mesh for the octree node is empty and should not be\n   * requested/rendered.\n   */\n  octree: Uint32Array;\n}\n\n/**\n * @param detailCutoff Factor by which the spatial resolution of the mesh may be worse than the\n *     spatial resolution of a single viewport pixel.  For example, a value of 10 means that if a\n *     given portion of the object will be rendered such that a pixel corresponds to 50 nm, then a\n *     mesh level of detail down to 500 nm will be requested for that portion of the object.\n */\nexport function getDesiredMultiscaleMeshChunks(\n  manifest: MultiscaleMeshManifest,\n  modelViewProjection: mat4,\n  clippingPlanes: Float32Array,\n  detailCutoff: number,\n  viewportWidth: number,\n  viewportHeight: number,\n  callback: (\n    lod: number,\n    row: number,\n    renderScale: number,\n    empty: number,\n  ) => void,\n) {\n  const { octree, lodScales, chunkGridSpatialOrigin, chunkShape } = manifest;\n  const maxLod = lodScales.length - 1;\n  const m00 = modelViewProjection[0];\n  const m01 = modelViewProjection[4];\n  const m02 = modelViewProjection[8];\n  const m10 = modelViewProjection[1];\n  const m11 = modelViewProjection[5];\n  const m12 = modelViewProjection[9];\n  const m30 = modelViewProjection[3];\n  const m31 = modelViewProjection[7];\n  const m32 = modelViewProjection[11];\n  const m33 = modelViewProjection[15];\n\n  const minWXcoeff = m30 > 0 ? 0 : 1;\n  const minWYcoeff = m31 > 0 ? 0 : 1;\n  const minWZcoeff = m32 > 0 ? 0 : 1;\n\n  const nearA = clippingPlanes[4 * 4];\n  const nearB = clippingPlanes[4 * 4 + 1];\n  const nearC = clippingPlanes[4 * 4 + 2];\n  const nearD = clippingPlanes[4 * 4 + 3];\n\n  function getPointW(x: number, y: number, z: number) {\n    return m30 * x + m31 * y + m32 * z + m33;\n  }\n\n  function getBoxW(\n    xLower: number,\n    yLower: number,\n    zLower: number,\n    xUpper: number,\n    yUpper: number,\n    zUpper: number,\n  ) {\n    return getPointW(\n      xLower + minWXcoeff * (xUpper - xLower),\n      yLower + minWYcoeff * (yUpper - yLower),\n      zLower + minWZcoeff * (zUpper - zLower),\n    );\n  }\n\n  /**\n   * Minimum value of w within clipping frustrum (under the assumption that the minimum value occurs\n   * on the near clipping plane).\n   */\n  const minWClip = getPointW(-nearD * nearA, -nearD * nearB, -nearD * nearC);\n\n  const objectXLower = manifest.clipLowerBound[0];\n  const objectYLower = manifest.clipLowerBound[1];\n  const objectZLower = manifest.clipLowerBound[2];\n  const objectXUpper = manifest.clipUpperBound[0];\n  const objectYUpper = manifest.clipUpperBound[1];\n  const objectZUpper = manifest.clipUpperBound[2];\n\n  const xScale = Math.sqrt(\n    (m00 * viewportWidth) ** 2 + (m10 * viewportHeight) ** 2,\n  );\n  const yScale = Math.sqrt(\n    (m01 * viewportWidth) ** 2 + (m11 * viewportHeight) ** 2,\n  );\n  const zScale = Math.sqrt(\n    (m02 * viewportWidth) ** 2 + (m12 * viewportHeight) ** 2,\n  );\n\n  const scaleFactor = Math.max(xScale, yScale, zScale);\n\n  function handleChunk(lod: number, row: number, priorLodScale: number) {\n    const size = 1 << lod;\n    const rowOffset = row * 5;\n    const gridX = octree[rowOffset];\n    const gridY = octree[rowOffset + 1];\n    const gridZ = octree[rowOffset + 2];\n    const childBegin = octree[rowOffset + 3];\n    const childEndAndEmpty = octree[rowOffset + 4];\n    let xLower = gridX * size * chunkShape[0] + chunkGridSpatialOrigin[0];\n    let yLower = gridY * size * chunkShape[1] + chunkGridSpatialOrigin[1];\n    let zLower = gridZ * size * chunkShape[2] + chunkGridSpatialOrigin[2];\n    let xUpper = xLower + size * chunkShape[0];\n    let yUpper = yLower + size * chunkShape[1];\n    let zUpper = zLower + size * chunkShape[2];\n    xLower = Math.max(xLower, objectXLower);\n    yLower = Math.max(yLower, objectYLower);\n    zLower = Math.max(zLower, objectZLower);\n    xUpper = Math.min(xUpper, objectXUpper);\n    yUpper = Math.min(yUpper, objectYUpper);\n    zUpper = Math.min(zUpper, objectZUpper);\n\n    if (\n      isAABBVisible(\n        xLower,\n        yLower,\n        zLower,\n        xUpper,\n        yUpper,\n        zUpper,\n        clippingPlanes,\n      )\n    ) {\n      const minW = Math.max(\n        minWClip,\n        getBoxW(xLower, yLower, zLower, xUpper, yUpper, zUpper),\n      );\n      const pixelSize = minW / scaleFactor;\n\n      if (priorLodScale === 0 || pixelSize * detailCutoff < priorLodScale) {\n        const lodScale = lodScales[lod];\n        if (lodScale !== 0) {\n          callback(lod, row, lodScale / pixelSize, childEndAndEmpty >>> 31);\n        }\n\n        if (\n          lod > 0 &&\n          (lodScale === 0 || pixelSize * detailCutoff < lodScale)\n        ) {\n          const nextPriorLodScale = lodScale === 0 ? priorLodScale : lodScale;\n          const childEnd = (childEndAndEmpty & 0x7fffffff) >>> 0;\n          for (let childRow = childBegin; childRow < childEnd; ++childRow) {\n            handleChunk(lod - 1, childRow, nextPriorLodScale);\n          }\n        }\n      }\n    }\n  }\n  handleChunk(maxLod, octree.length / 5 - 1, 0);\n}\n\nexport function getMultiscaleChunksToDraw(\n  manifest: MultiscaleMeshManifest,\n  modelViewProjection: mat4,\n  clippingPlanes: Float32Array,\n  detailCutoff: number,\n  viewportWidth: number,\n  viewportHeight: number,\n  hasChunk: (lod: number, row: number, renderScale: number) => boolean,\n  callback: (\n    lod: number,\n    row: number,\n    subChunkBegin: number,\n    subChunkEnd: number,\n    renderScale: number,\n  ) => void,\n) {\n  const { lodScales } = manifest;\n  let maxLod = 0;\n  while (maxLod + 1 < lodScales.length && lodScales[maxLod + 1] !== 0) {\n    ++maxLod;\n  }\n\n  const stackEntryStride = 3;\n\n  // [row, parentSubChunkIndex, renderScale]\n  const stack: number[] = [];\n  let stackDepth = 0;\n  let priorSubChunkIndex = 0;\n  function emitChunksUpTo(targetStackIndex: number, subChunkIndex: number) {\n    if (DEBUG_CHUNKS_TO_DRAW) {\n      console.log(\n        `emitChunksUpTo: stackDepth=${stackDepth}, targetStackIndex=${targetStackIndex}, subChunkIndex=${subChunkIndex}, priorSubChunkIndex=${priorSubChunkIndex}`,\n      );\n    }\n    while (true) {\n      if (stackDepth === 0) return;\n\n      // Finish last chunk of last (finest) lod.\n      const stackIndex = stackDepth - 1;\n      const entryLod = maxLod - stackIndex;\n      const entryRow = stack[stackIndex * stackEntryStride];\n      const numSubChunks = entryLod === 0 ? 1 : 8;\n      const entrySubChunkIndex = stack[stackIndex * stackEntryStride + 1];\n      const entryRenderScale = stack[stackIndex * stackEntryStride + 2];\n      if (targetStackIndex === stackDepth) {\n        const endSubChunk = subChunkIndex & (numSubChunks - 1);\n\n        if (priorSubChunkIndex !== endSubChunk && entryRow !== -1) {\n          if (DEBUG_CHUNKS_TO_DRAW) {\n            console.log(\n              `  drawing chunk because priorSubChunkIndex (${priorSubChunkIndex}) != endSubChunk (${endSubChunk})`,\n            );\n          }\n          callback(\n            entryLod,\n            entryRow,\n            priorSubChunkIndex,\n            endSubChunk,\n            entryRenderScale,\n          );\n        }\n        priorSubChunkIndex = endSubChunk + 1;\n        return;\n      }\n      if (priorSubChunkIndex !== numSubChunks && entryRow !== -1) {\n        callback(\n          entryLod,\n          entryRow,\n          priorSubChunkIndex,\n          numSubChunks,\n          entryRenderScale,\n        );\n      }\n      priorSubChunkIndex = entrySubChunkIndex + 1;\n      --stackDepth;\n    }\n  }\n\n  let priorMissingLod = 0;\n  if (DEBUG_CHUNKS_TO_DRAW) {\n    console.log(\"\");\n    console.log(\"Starting to draw\");\n  }\n  const { octree } = manifest;\n  getDesiredMultiscaleMeshChunks(\n    manifest,\n    modelViewProjection,\n    clippingPlanes,\n    detailCutoff,\n    viewportWidth,\n    viewportHeight,\n    (lod, row, renderScale, empty) => {\n      if (!empty && !hasChunk(lod, row, renderScale)) {\n        priorMissingLod = Math.max(lod, priorMissingLod);\n        return;\n      }\n      if (lod < priorMissingLod) {\n        // A parent chunk (containing chunk at coarser level-of-detail) is missing.  We can't draw\n        // chunks at this level-of-detail because we would not be able to fill in gaps.\n        return;\n      }\n      priorMissingLod = 0;\n      const rowOffset = row * 5;\n      const x = octree[rowOffset];\n      const y = octree[rowOffset + 1];\n      const z = octree[rowOffset + 2];\n      const subChunkIndex = getOctreeChildIndex(x, y, z);\n      const stackIndex = maxLod - lod;\n      emitChunksUpTo(stackIndex, subChunkIndex);\n      const stackOffset = stackIndex * stackEntryStride;\n      stack[stackOffset] = empty ? -1 : row;\n      stack[stackOffset + 1] = subChunkIndex;\n      stack[stackOffset + 2] = renderScale;\n      if (DEBUG_CHUNKS_TO_DRAW) {\n        console.log(\n          `Adding to stack: lod=${lod}, row=${stack[stackOffset]}, subChunkIndex=${subChunkIndex}`,\n        );\n      }\n      priorSubChunkIndex = 0;\n      stackDepth = stackIndex + 1;\n    },\n  );\n\n  emitChunksUpTo(0, 0);\n}\n\nexport function validateOctree(octree: Uint32Array) {\n  if (octree.length % 5 !== 0) {\n    throw new Error(\"Invalid length\");\n  }\n  const numNodes = octree.length / 5;\n  const seenNodes = new Set<number>();\n  function exploreNode(node: number) {\n    if (seenNodes.has(node)) {\n      throw new Error(\"Previously seen node\");\n    }\n    seenNodes.add(node);\n    if (node < 0 || node >= numNodes) {\n      throw new Error(\"Invalid node reference\");\n    }\n    const x = octree[node * 5];\n    const y = octree[node * 5 + 1];\n    const z = octree[node * 5 + 2];\n    const beginChild = octree[node * 5 + 3];\n    const endChild = octree[node * 5 + 4];\n    if (\n      beginChild < 0 ||\n      endChild < 0 ||\n      endChild < beginChild ||\n      endChild > numNodes ||\n      beginChild + 8 < endChild\n    ) {\n      throw new Error(\"Invalid child references\");\n    }\n    for (let child = beginChild; child < endChild; ++child) {\n      const childX = octree[child * 5];\n      const childY = octree[child * 5 + 1];\n      const childZ = octree[child * 5 + 2];\n      if (childX >>> 1 !== x || childY >>> 1 !== y || childZ >>> 1 !== z) {\n        throw new Error(\"invalid child\");\n      }\n      exploreNode(child);\n    }\n  }\n  if (numNodes === 0) return;\n  exploreNode(numNodes - 1);\n  if (seenNodes.size !== numNodes) {\n    throw new Error(\"Orphan nodes in octree\");\n  }\n}\n\nexport function getMultiscaleFragmentKey(\n  objectKey: string,\n  lod: number,\n  chunkIndex: number,\n) {\n  return `${objectKey}/${lod}:${chunkIndex}`;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Interface for defining transcode operations.\n */\n\nexport interface AsyncComputationSpec<Signature extends (...args: any) => any> {\n  id: string;\n  t?: Signature;\n}\n\n/**\n * Declares an asynchronous operation.\n */\nexport function asyncComputation<Signature extends (...args: any) => any>(\n  id: string,\n): AsyncComputationSpec<Signature> {\n  return { id };\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const encodeCompressedSegmentationUint32 = asyncComputation<\n  (\n    rawData: Uint32Array,\n    shape: ArrayLike<number>,\n    blockSize: ArrayLike<number>,\n  ) => Uint32Array\n>(\"encodeCompressedSegmentationUint32\");\n\nexport const encodeCompressedSegmentationUint64 = asyncComputation<\n  (\n    rawData: Uint32Array,\n    shape: ArrayLike<number>,\n    blockSize: ArrayLike<number>,\n  ) => Uint32Array\n>(\"encodeCompressedSegmentationUint64\");\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { AsyncComputationSpec } from \"#src/async_computation/index.js\";\n\nlet numWorkers = 0;\nconst freeWorkers: Worker[] = [];\nconst pendingTasks = new Map<\n  number,\n  { msg: any; transfer: Transferable[] | undefined; cleanup?: () => void }\n>();\nconst tasks = new Map<\n  number,\n  {\n    resolve: (value: any) => void;\n    reject: (error: any) => void;\n  }\n>();\n// On Safari, `navigator.hardwareConcurrency` is not defined.\nconst maxWorkers =\n  typeof navigator.hardwareConcurrency === \"undefined\"\n    ? 4\n    : Math.min(12, navigator.hardwareConcurrency);\nlet nextTaskId = 0;\n\nfunction returnWorker(worker: Worker) {\n  for (const [id, task] of pendingTasks) {\n    pendingTasks.delete(id);\n    task.cleanup?.();\n    worker.postMessage(task.msg, task.transfer as Transferable[]);\n    return;\n  }\n  freeWorkers.push(worker);\n}\n\nfunction launchWorker() {\n  ++numWorkers;\n  // Note: For compatibility with multiple bundlers, a browser-compatible URL\n  // must be used with `new URL`, which means a Node.js subpath import like\n  // \"#src/async_computation.bundle.js\" cannot be used.\n  const worker = new Worker(\n    /* webpackChunkName: \"neuroglancer_async_computation\" */\n    new URL(\"../async_computation.bundle.js\", import.meta.url),\n    { type: \"module\" },\n  );\n  let ready = false;\n  worker.onmessage = (msg) => {\n    // First message indicates worker is ready.\n    if (!ready) {\n      ready = true;\n      returnWorker(worker);\n      return;\n    }\n    const { id, value, error } = msg.data as {\n      id: number;\n      value?: any;\n      error?: string;\n    };\n    returnWorker(worker);\n    const callbacks = tasks.get(id)!;\n    tasks.delete(id);\n    if (callbacks === undefined) return;\n    if (error !== undefined) {\n      callbacks.reject(new Error(error));\n    } else {\n      callbacks.resolve(value);\n    }\n  };\n}\n\nexport function requestAsyncComputation<\n  Signature extends (...args: any) => any,\n>(\n  request: AsyncComputationSpec<Signature>,\n  abortSignal: AbortSignal | undefined,\n  transfer: Transferable[] | undefined,\n  ...args: Parameters<Signature>\n): Promise<ReturnType<Signature>> {\n  const id = nextTaskId++;\n  const msg = { t: request.id, id, args: args };\n\n  abortSignal?.throwIfAborted();\n\n  const promise = new Promise<ReturnType<Signature>>((resolve, reject) => {\n    tasks.set(id, { resolve, reject });\n  });\n\n  if (freeWorkers.length !== 0) {\n    freeWorkers.pop()!.postMessage(msg, transfer as Transferable[]);\n  } else {\n    let cleanup: (() => void) | undefined;\n    if (abortSignal !== undefined) {\n      function abortHandler() {\n        pendingTasks.delete(id);\n        const task = tasks.get(id)!;\n        tasks.delete(id);\n        task.reject(abortSignal!.reason);\n      }\n      abortSignal.addEventListener(\"abort\", abortHandler, { once: true });\n      cleanup = () => {\n        abortSignal.removeEventListener(\"abort\", abortHandler);\n      };\n    }\n    pendingTasks.set(id, { msg, transfer, cleanup });\n    if (tasks.size > numWorkers && numWorkers < maxWorkers) {\n      launchWorker();\n    }\n  }\n\n  return promise;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Converts raw data volumes to the appropriate format required by the frontend.\n */\n\nimport {\n  encodeCompressedSegmentationUint32,\n  encodeCompressedSegmentationUint64,\n} from \"#src/async_computation/encode_compressed_segmentation_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { DataType } from \"#src/sliceview/base.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\n\nexport async function postProcessRawData(\n  chunk: VolumeChunk,\n  abortSignal: AbortSignal,\n  data: ArrayBufferView,\n) {\n  const { spec } = chunk.source!;\n  if (spec.compressedSegmentationBlockSize !== undefined) {\n    const { dataType } = spec;\n    const chunkDataSize = chunk.chunkDataSize!;\n    const shape = [\n      chunkDataSize[0],\n      chunkDataSize[1],\n      chunkDataSize[2],\n      chunkDataSize[3] || 1,\n    ];\n    switch (dataType) {\n      case DataType.UINT32:\n        chunk.data = await requestAsyncComputation(\n          encodeCompressedSegmentationUint32,\n          abortSignal,\n          [data.buffer],\n          data as Uint32Array,\n          shape,\n          spec.compressedSegmentationBlockSize,\n        );\n        break;\n      case DataType.UINT64:\n        chunk.data = await requestAsyncComputation(\n          encodeCompressedSegmentationUint64,\n          abortSignal,\n          [data.buffer],\n          data as Uint32Array,\n          shape,\n          spec.compressedSegmentationBlockSize,\n        );\n        break;\n      default:\n        throw new Error(\n          `Unsupported data type for compressed segmentation: ${DataType[dataType]}`,\n        );\n    }\n  } else {\n    chunk.data = data;\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Detects gzip format based on the 2 magic bytes at the start.\n */\nexport function isGzipFormat(data: ArrayBufferView) {\n  const view = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  return view.length > 2 && view[0] === 0x1f && view[1] === 0x8b;\n}\n\nexport async function decodeGzip(\n  data: ArrayBuffer | ArrayBufferView,\n  format: CompressionFormat,\n  abortSignal?: AbortSignal,\n) {\n  try {\n    const decompressedStream = new Response(data).body!.pipeThrough(\n      new DecompressionStream(format),\n      { signal: abortSignal },\n    );\n    return await new Response(decompressedStream).arrayBuffer();\n  } catch {\n    abortSignal?.throwIfAborted();\n    throw new Error(`Failed to decode ${format}`);\n  }\n}\n\n/**\n * Decompress `data` if it is in gzip format, otherwise just return it.\n */\nexport async function maybeDecompressGzip(data: ArrayBuffer | ArrayBufferView) {\n  let byteView: Uint8Array;\n  if (data instanceof ArrayBuffer) {\n    byteView = new Uint8Array(data);\n  } else {\n    byteView = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  }\n  if (isGzipFormat(byteView)) {\n    return new Uint8Array(await decodeGzip(byteView, \"gzip\"));\n  }\n  return byteView;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Support for parsing NumPy dtype strings.\n */\n\nimport { DataType } from \"#src/util/data_type.js\";\nimport { Endianness } from \"#src/util/endian.js\";\n\nexport interface NumpyDtype {\n  dataType: DataType;\n  endianness: Endianness;\n}\n\nconst supportedDataTypes = new Map<string, NumpyDtype>();\nsupportedDataTypes.set(\"|u1\", {\n  endianness: Endianness.LITTLE,\n  dataType: DataType.UINT8,\n});\nsupportedDataTypes.set(\"|i1\", {\n  endianness: Endianness.LITTLE,\n  dataType: DataType.INT8,\n});\nfor (const [endiannessChar, endianness] of <[string, Endianness][]>[\n  [\"<\", Endianness.LITTLE],\n  [\">\", Endianness.BIG],\n]) {\n  // For now, treat both signed and unsigned integer types as unsigned.\n  for (const typeChar of [\"u\", \"i\"]) {\n    supportedDataTypes.set(`${endiannessChar}${typeChar}8`, {\n      endianness,\n      dataType: DataType.UINT64,\n    });\n  }\n  supportedDataTypes.set(`${endiannessChar}u2`, {\n    endianness,\n    dataType: DataType.UINT16,\n  });\n\n  supportedDataTypes.set(`${endiannessChar}i2`, {\n    endianness,\n    dataType: DataType.INT16,\n  });\n\n  supportedDataTypes.set(`${endiannessChar}u4`, {\n    endianness,\n    dataType: DataType.UINT32,\n  });\n\n  supportedDataTypes.set(`${endiannessChar}i4`, {\n    endianness,\n    dataType: DataType.INT32,\n  });\n\n  supportedDataTypes.set(`${endiannessChar}f4`, {\n    endianness,\n    dataType: DataType.FLOAT32,\n  });\n}\n\nexport function parseNumpyDtype(typestr: unknown): NumpyDtype {\n  const dtype = supportedDataTypes.get(typestr as any);\n  if (dtype === undefined) {\n    throw new Error(`Unsupported numpy data type: ${JSON.stringify(typestr)}`);\n  }\n  return dtype;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Basic support for parsing the Python Numpy 'npy' serialization format.\n *\n * See http://docs.scipy.org/doc/numpy-dev/neps/npy-format.html\n */\n\nimport type { TypedArray } from \"#src/util/array.js\";\nimport type { DataType } from \"#src/util/data_type.js\";\nimport {\n  DATA_TYPE_ARRAY_CONSTRUCTOR,\n  DATA_TYPE_BYTES,\n  DATA_TYPE_JAVASCRIPT_ELEMENTS_PER_ARRAY_ELEMENT,\n} from \"#src/util/data_type.js\";\nimport { convertEndian } from \"#src/util/endian.js\";\nimport { pythonLiteralParse } from \"#src/util/json.js\";\nimport { parseNumpyDtype } from \"#src/util/numpy_dtype.js\";\n\nexport class NumpyArray {\n  constructor(\n    public data: TypedArray,\n    public shape: number[],\n    public dataType: DataType,\n    public fortranOrder: boolean,\n  ) {}\n}\n\nexport function parseNpy(x: Uint8Array) {\n  // Verify 6-byte magic sequence: 147, 78, 85, 77, 80, 89\n  if (\n    x[0] !== 147 ||\n    x[1] !== 78 ||\n    x[2] !== 85 ||\n    x[3] !== 77 ||\n    x[4] !== 80 ||\n    x[5] !== 89\n  ) {\n    throw new Error(\"Data does not match npy format.\");\n  }\n  const majorVersion = x[6];\n  const minorVersion = x[7];\n  if (majorVersion !== 1 || minorVersion !== 0) {\n    throw new Error(`Unsupported npy version ${majorVersion}.${minorVersion}`);\n  }\n  const dv = new DataView(x.buffer, x.byteOffset, x.byteLength);\n  const headerLength = dv.getUint16(8, /*littleEndian=*/ true);\n  const header = new TextDecoder(\"utf-8\").decode(\n    x.subarray(10, headerLength + 10),\n  );\n  let headerObject: any;\n  const dataOffset = headerLength + 10;\n  try {\n    headerObject = pythonLiteralParse(header);\n  } catch (e) {\n    throw new Error(`Failed to parse npy header: ${e}`);\n  }\n  const dtype = headerObject.descr;\n  const shape = headerObject.shape;\n  let numElements = 1;\n  if (!Array.isArray(shape)) {\n    throw new Error(\"Invalid shape ${JSON.stringify(shape)}\");\n  }\n  for (const dim of shape) {\n    if (typeof dim !== \"number\") {\n      throw new Error(\"Invalid shape ${JSON.stringify(shape)}\");\n    }\n    numElements *= dim;\n  }\n  const { dataType, endianness } = parseNumpyDtype(dtype);\n  const bytesPerElement = DATA_TYPE_BYTES[dataType];\n  const javascriptElementsPerArrayElement =\n    DATA_TYPE_JAVASCRIPT_ELEMENTS_PER_ARRAY_ELEMENT[dataType];\n  const arrayConstructor = DATA_TYPE_ARRAY_CONSTRUCTOR[dataType];\n  const javascriptElements = javascriptElementsPerArrayElement * numElements;\n  if (bytesPerElement * numElements + dataOffset !== x.byteLength) {\n    throw new Error(\"Expected length does not match length of data\");\n  }\n  const data = new arrayConstructor(\n    x.buffer,\n    x.byteOffset + dataOffset,\n    javascriptElements,\n  );\n  convertEndian(data, endianness, bytesPerElement);\n  return new NumpyArray(\n    data,\n    shape,\n    dataType,\n    headerObject.fortran_order === true,\n  );\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This decodes the BOSS (https://github.com/jhuapl-boss/) NPZ format, which is the Python\n * NPY binary format with zlib encoding.\n *\n * This is NOT the same as the Python NPZ format, which is a ZIP file containing multiple files\n * (each corresponding to a different variable) in NPY binary format.\n */\n\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport { DataType } from \"#src/sliceview/base.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { vec3Key } from \"#src/util/geom.js\";\nimport { decodeGzip } from \"#src/util/gzip.js\";\nimport { parseNpy } from \"#src/util/npy.js\";\n\nexport async function decodeBossNpzChunk(\n  chunk: VolumeChunk,\n  abortSignal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  const parseResult = parseNpy(\n    new Uint8Array(await decodeGzip(response, \"deflate\")),\n  );\n  const chunkDataSize = chunk.chunkDataSize!;\n  const source = chunk.source!;\n  const { shape } = parseResult;\n  if (\n    shape.length !== 3 ||\n    shape[0] !== chunkDataSize[2] ||\n    shape[1] !== chunkDataSize[1] ||\n    shape[2] !== chunkDataSize[0]\n  ) {\n    throw new Error(\n      `Shape ${JSON.stringify(shape)} does not match chunkDataSize ${vec3Key(\n        chunkDataSize,\n      )}`,\n    );\n  }\n  const parsedDataType = parseResult.dataType;\n  const { spec } = source;\n  if (parsedDataType !== spec.dataType) {\n    throw new Error(\n      `Data type ${\n        DataType[parsedDataType]\n      } does not match expected data type ${DataType[spec.dataType]}`,\n    );\n  }\n  await postProcessRawData(chunk, abortSignal, parseResult.data);\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { DecodedImage } from \"#src/async_computation/decode_png_request.js\";\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const decodeJpeg = asyncComputation<\n  (\n    data: Uint8Array<ArrayBuffer>,\n    width: number | undefined,\n    height: number | undefined,\n    // Expected width * height\n    area: number | undefined,\n    numComponents: number | undefined,\n    convertToGrayscale: boolean,\n  ) => DecodedImage\n>(\"decodeJpeg\");\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeJpeg } from \"#src/async_computation/decode_jpeg_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\n\nexport async function decodeJpegChunk(\n  chunk: VolumeChunk,\n  abortSignal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  const chunkDataSize = chunk.chunkDataSize!;\n  const { uint8Array: decoded } = await requestAsyncComputation(\n    decodeJpeg,\n    abortSignal,\n    [response],\n    new Uint8Array(response),\n    undefined,\n    undefined,\n    chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2],\n    chunkDataSize[3] || 1,\n    false,\n  );\n  await postProcessRawData(chunk, abortSignal, decoded);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Chunk } from \"#src/chunk_manager/backend.js\";\nimport {\n  SliceViewChunk,\n  SliceViewChunkSourceBackend,\n} from \"#src/sliceview/backend.js\";\nimport type {\n  DataType,\n  SliceViewChunkSpecification,\n} from \"#src/sliceview/base.js\";\nimport type {\n  VolumeChunkSource as VolumeChunkSourceInterface,\n  VolumeChunkSpecification,\n} from \"#src/sliceview/volume/base.js\";\nimport type { vec3 } from \"#src/util/geom.js\";\nimport * as vector from \"#src/util/vector.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\n\nexport class VolumeChunk extends SliceViewChunk {\n  source: VolumeChunkSource | null = null;\n  data: ArrayBufferView | null;\n  chunkDataSize: Uint32Array | null;\n\n  initializeVolumeChunk(key: string, chunkGridPosition: vec3) {\n    super.initializeVolumeChunk(key, chunkGridPosition);\n    this.chunkDataSize = null;\n    this.data = null;\n  }\n\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    const chunkDataSize = this.chunkDataSize;\n    if (chunkDataSize !== this.source!.spec.chunkDataSize) {\n      msg.chunkDataSize = chunkDataSize;\n    }\n    const data = (msg.data = this.data);\n    if (data !== null) {\n      transfers.push(data!.buffer);\n    }\n    this.data = null;\n  }\n\n  downloadSucceeded() {\n    this.systemMemoryBytes = this.gpuMemoryBytes = this.data?.byteLength ?? 0;\n    super.downloadSucceeded();\n  }\n\n  freeSystemMemory() {\n    this.data = null;\n  }\n}\n\ninterface ChunkWithGridPositionAndDataSize extends Chunk {\n  chunkGridPosition: Float32Array;\n  chunkDataSize: Uint32Array | null;\n}\n\ninterface SliceViewChunkSpecWithOffsetAndDatatype\n  extends SliceViewChunkSpecification<Uint32Array> {\n  baseVoxelOffset: Float32Array;\n  dataType: DataType;\n}\n\ninterface ChunkSourceForChunkBounds {\n  spec: SliceViewChunkSpecWithOffsetAndDatatype;\n  tempChunkDataSize: Uint32Array;\n  tempChunkPosition: Float32Array;\n}\n\n/**\n * Helper function for computing the voxel bounds of a chunk based on its chunkGridPosition.\n *\n * This assumes that the grid of chunk positions starts at this.baseVoxelOffset.  Chunks are\n * clipped to lie within upperVoxelBound, but are not clipped to lie within lowerVoxelBound.  (The\n * frontend code currently cannot handle chunks clipped at their lower corner, and the chunk\n * layout can generally be chosen so that lowerVoxelBound lies on a chunk boundary.)\n *\n * This sets chunk.chunkDataSize to a copy of the returned chunkDataSize if it differs from\n * source.spec.chunkDataSize; otherwise, it is set to source.spec.chunkDataSize.\n *\n * @returns A globally-allocated Vec3 containing the chunk corner position in voxel coordinates.\n * The returned Vec3 will be invalidated by any subsequent call to this method, even on a\n * different VolumeChunkSource instance.\n */\nexport function computeChunkBounds(\n  source: ChunkSourceForChunkBounds,\n  chunk: ChunkWithGridPositionAndDataSize,\n) {\n  const { spec, tempChunkDataSize, tempChunkPosition } = source;\n  const { upperVoxelBound, rank, baseVoxelOffset } = spec;\n\n  const origChunkDataSize = spec.chunkDataSize;\n  const newChunkDataSize = tempChunkDataSize;\n\n  // Chunk start position in voxel coordinates.\n  const chunkPosition = vector.multiply(\n    tempChunkPosition,\n    chunk.chunkGridPosition,\n    origChunkDataSize,\n  );\n\n  // Specifies whether the chunk only partially fits within the data bounds.\n  let partial = false;\n  for (let i = 0; i < rank; ++i) {\n    const upper = Math.min(\n      upperVoxelBound[i],\n      chunkPosition[i] + origChunkDataSize[i],\n    );\n    const size = (newChunkDataSize[i] = upper - chunkPosition[i]);\n    if (size !== origChunkDataSize[i]) {\n      partial = true;\n    }\n  }\n\n  vector.add(chunkPosition, chunkPosition, baseVoxelOffset);\n\n  if (partial) {\n    chunk.chunkDataSize = Uint32Array.from(newChunkDataSize);\n  } else {\n    chunk.chunkDataSize = origChunkDataSize;\n  }\n\n  return chunkPosition;\n}\n\nexport class VolumeChunkSource\n  extends SliceViewChunkSourceBackend\n  implements VolumeChunkSourceInterface\n{\n  declare spec: VolumeChunkSpecification;\n  tempChunkDataSize: Uint32Array;\n  tempChunkPosition: Float32Array;\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    const rank = this.spec.rank;\n    this.tempChunkDataSize = new Uint32Array(rank);\n    this.tempChunkPosition = new Float32Array(rank);\n  }\n\n  computeChunkBounds(chunk: VolumeChunk) {\n    return computeChunkBounds(this, chunk);\n  }\n}\nVolumeChunkSource.prototype.chunkConstructor = VolumeChunk;\n","/**\n * @license\n * Copyright 2017 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport type { ChunkSourceParametersConstructor } from \"#src/chunk_manager/base.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport type { BossToken } from \"#src/datasource/boss/api.js\";\nimport { fetchWithBossCredentials } from \"#src/datasource/boss/api.js\";\nimport {\n  MeshSourceParameters,\n  VolumeChunkSourceParameters,\n} from \"#src/datasource/boss/base.js\";\nimport type { FragmentChunk, ManifestChunk } from \"#src/mesh/backend.js\";\nimport {\n  assignMeshFragmentData,\n  decodeJsonManifestChunk,\n  decodeTriangleVertexPositionsAndIndices,\n  MeshSource,\n} from \"#src/mesh/backend.js\";\nimport { decodeBossNpzChunk } from \"#src/sliceview/backend_chunk_decoders/bossNpz.js\";\nimport type { ChunkDecoder } from \"#src/sliceview/backend_chunk_decoders/index.js\";\nimport { decodeJpegChunk } from \"#src/sliceview/backend_chunk_decoders/jpeg.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport type { SharedObject } from \"#src/worker_rpc.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nconst chunkDecoders = new Map<string, ChunkDecoder>();\nchunkDecoders.set(\"npz\", decodeBossNpzChunk);\nchunkDecoders.set(\"jpeg\", decodeJpegChunk);\n\nconst acceptHeaders = new Map<string, string>();\nacceptHeaders.set(\"npz\", \"application/npygz\");\nacceptHeaders.set(\"jpeg\", \"image/jpeg\");\n\nfunction BossSource<\n  Parameters,\n  TBase extends { new (...args: any[]): SharedObject },\n>(\n  Base: TBase,\n  parametersConstructor: ChunkSourceParametersConstructor<Parameters>,\n) {\n  return WithParameters(\n    WithSharedCredentialsProviderCounterpart<BossToken>()(Base),\n    parametersConstructor,\n  );\n}\n\n@registerSharedObject()\nexport class BossVolumeChunkSource extends BossSource(\n  VolumeChunkSource,\n  VolumeChunkSourceParameters,\n) {\n  chunkDecoder = chunkDecoders.get(this.parameters.encoding)!;\n\n  async download(chunk: VolumeChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    let url = `${parameters.baseUrl}/latest/cutout/${parameters.collection}/${parameters.experiment}/${parameters.channel}/${parameters.resolution}`;\n    {\n      // chunkPosition must not be captured, since it will be invalidated by the next call to\n      // computeChunkBounds.\n      const chunkPosition = this.computeChunkBounds(chunk);\n      const chunkDataSize = chunk.chunkDataSize!;\n      for (let i = 0; i < 3; ++i) {\n        url += `/${chunkPosition[i]}:${chunkPosition[i] + chunkDataSize[i]}`;\n      }\n    }\n    url += \"/\";\n\n    if (parameters.window !== undefined) {\n      url += `?window=${parameters.window[0]},${parameters.window[1]}`;\n    }\n    const response = await fetchWithBossCredentials(\n      this.credentialsProvider,\n      url,\n      {\n        signal: abortSignal,\n        headers: { Accept: acceptHeaders.get(parameters.encoding)! },\n      },\n    );\n    await this.chunkDecoder(chunk, abortSignal, await response.arrayBuffer());\n  }\n}\n\nfunction decodeManifestChunk(chunk: ManifestChunk, response: any) {\n  return decodeJsonManifestChunk(chunk, response, \"fragments\");\n}\n\nfunction decodeFragmentChunk(chunk: FragmentChunk, response: ArrayBuffer) {\n  const dv = new DataView(response);\n  const numVertices = dv.getUint32(0, true);\n  assignMeshFragmentData(\n    chunk,\n    decodeTriangleVertexPositionsAndIndices(\n      response,\n      Endianness.LITTLE,\n      /*vertexByteOffset=*/ 4,\n      numVertices,\n    ),\n  );\n}\n\n@registerSharedObject()\nexport class BossMeshSource extends BossSource(\n  MeshSource,\n  MeshSourceParameters,\n) {\n  download(chunk: ManifestChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    return fetchWithBossCredentials(\n      this.credentialsProvider,\n      `${parameters.baseUrl}${chunk.objectId}`,\n      { signal: abortSignal },\n    )\n      .then((response) => response.arrayBuffer())\n      .then((response) => decodeManifestChunk(chunk, response));\n  }\n\n  downloadFragment(chunk: FragmentChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    return fetchWithBossCredentials(\n      this.credentialsProvider,\n      `${parameters.baseUrl}${chunk.fragmentId}`,\n      { signal: abortSignal },\n    )\n      .then((response) => response.arrayBuffer())\n      .then((response) => decodeFragmentChunk(chunk, response));\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fetchWithCredentials } from \"#src/credentials_provider/http_request.js\";\nimport type { CredentialsProvider } from \"#src/credentials_provider/index.js\";\nimport { fetchOk } from \"#src/util/http_request.js\";\n\n/**\n * OAuth2 token\n */\nexport interface OAuth2Credentials {\n  tokenType: string;\n  accessToken: string;\n  email?: string;\n}\n\nexport function fetchWithOAuth2Credentials(\n  credentialsProvider: CredentialsProvider<OAuth2Credentials> | undefined,\n  input: RequestInfo,\n  init: RequestInit,\n): Promise<Response> {\n  if (credentialsProvider === undefined) {\n    return fetchOk(input, init);\n  }\n  return fetchWithCredentials(\n    credentialsProvider,\n    input,\n    init,\n    (credentials, init) => {\n      if (!credentials.accessToken) return init;\n      const headers = new Headers(init.headers);\n      headers.set(\n        \"Authorization\",\n        `${credentials.tokenType} ${credentials.accessToken}`,\n      );\n      return { ...init, headers };\n    },\n    credentialsProvider.errorHandler!,\n  );\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { CredentialsProvider } from \"#src/credentials_provider/index.js\";\nimport type { OAuth2Credentials } from \"#src/credentials_provider/oauth2.js\";\nimport { fetchWithOAuth2Credentials } from \"#src/credentials_provider/oauth2.js\";\n\nexport type { OAuth2Credentials };\n\nexport type BrainmapsCredentialsProvider =\n  CredentialsProvider<OAuth2Credentials>;\n\n/**\n * Key used for retrieving the CredentialsProvider from a CredentialsManager.\n */\nexport const credentialsKey = \"google-brainmaps\";\n\nexport interface BrainmapsInstance {\n  description: string;\n  /**\n   * One or more server URLs to use to connect to the instance.\n   */\n  serverUrl: string;\n}\n\n/**\n * API-related interfaces.\n */\n\nexport interface ChangeSpecPayload {\n  change_stack_id?: string;\n  time_stamp?: number;\n  skip_equivalences?: boolean;\n}\n\nexport interface ChangeStackAwarePayload {\n  change_spec?: ChangeSpecPayload;\n}\n\nexport interface GeometryPayload {\n  corner: string;\n  size: string;\n  scale: number;\n}\n\nexport interface GeometryAwarePayload {\n  geometry: GeometryPayload;\n}\n\nexport interface ImageFormatOptionsPayload {\n  image_format?: \"AUTO\" | \"JPEG\" | \"PNG\" | \"JSON\";\n  jpeg_quality?: number;\n  compressed_segmentation_block_size?: string;\n}\n\nexport interface SubvolumePayload\n  extends ChangeStackAwarePayload,\n    GeometryAwarePayload {\n  image_format_options?: ImageFormatOptionsPayload;\n  subvolume_format?: \"RAW\" | \"SINGLE_IMAGE\";\n}\n\nexport interface SkeletonPayload extends ChangeStackAwarePayload {\n  object_id: string;\n}\n\nexport interface MeshFragmentPayload extends ChangeStackAwarePayload {\n  fragment_key: string;\n  object_id: string;\n}\n\nexport interface BatchMeshFragment {\n  object_id: string;\n  fragment_keys: string[];\n}\n\nexport interface BatchMeshFragmentPayload {\n  volume_id: string;\n  mesh_name: string;\n  batches: BatchMeshFragment[];\n}\n\nexport interface HttpCall {\n  method: \"GET\" | \"POST\";\n  path: string;\n  payload?: string;\n  signal?: AbortSignal;\n}\n\nexport function makeRequest(\n  instance: BrainmapsInstance,\n  credentialsProvider: BrainmapsCredentialsProvider,\n  httpCall: HttpCall,\n): Promise<Response> {\n  return fetchWithOAuth2Credentials(\n    credentialsProvider,\n    `${instance.serverUrl}${httpCall.path}`,\n    {\n      signal: httpCall.signal,\n      method: httpCall.method,\n      body: httpCall.payload,\n    },\n  );\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Chunk,\n  ChunkRenderLayerBackend,\n  ChunkSource,\n  withChunkManager,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkState } from \"#src/chunk_manager/base.js\";\nimport { decodeVertexPositionsAndIndices } from \"#src/mesh/backend.js\";\nimport { withSegmentationLayerBackendState } from \"#src/segmentation_display_state/backend.js\";\nimport {\n  forEachVisibleSegment,\n  getObjectKey,\n} from \"#src/segmentation_display_state/base.js\";\nimport { SKELETON_LAYER_RPC_ID } from \"#src/skeleton/base.js\";\nimport type { TypedArray } from \"#src/util/array.js\";\nimport type { Endianness } from \"#src/util/endian.js\";\nimport { Uint64 } from \"#src/util/uint64.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nconst SKELETON_CHUNK_PRIORITY = 60;\n\n// Chunk that contains the skeleton of a single object.\nexport class SkeletonChunk extends Chunk {\n  objectId = new Uint64();\n  vertexPositions: Float32Array | null = null;\n  vertexAttributes: TypedArray[] | null = null;\n  indices: Uint32Array | null = null;\n\n  initializeSkeletonChunk(key: string, objectId: Uint64) {\n    super.initialize(key);\n    this.objectId.assign(objectId);\n  }\n  freeSystemMemory() {\n    this.vertexPositions = this.indices = null;\n  }\n\n  private getVertexAttributeBytes() {\n    let total = this.vertexPositions!.byteLength;\n    const { vertexAttributes } = this;\n    if (vertexAttributes != null) {\n      vertexAttributes.forEach((a) => {\n        total += a.byteLength;\n      });\n    }\n    return total;\n  }\n\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    const vertexPositions = this.vertexPositions!;\n    const indices = this.indices!;\n    msg.numVertices = vertexPositions.length / 3;\n    msg.indices = indices;\n    transfers.push(indices.buffer);\n\n    const { vertexAttributes } = this;\n    if (vertexAttributes != null && vertexAttributes.length > 0) {\n      const vertexData = new Uint8Array(this.getVertexAttributeBytes());\n      vertexData.set(\n        new Uint8Array(\n          vertexPositions.buffer,\n          vertexPositions.byteOffset,\n          vertexPositions.byteLength,\n        ),\n      );\n      const vertexAttributeOffsets = (msg.vertexAttributeOffsets =\n        new Uint32Array(vertexAttributes.length + 1));\n      vertexAttributeOffsets[0] = 0;\n      let offset = vertexPositions.byteLength;\n      vertexAttributes.forEach((a, i) => {\n        vertexAttributeOffsets[i + 1] = offset;\n        vertexData.set(\n          new Uint8Array(a.buffer, a.byteOffset, a.byteLength),\n          offset,\n        );\n        offset += a.byteLength;\n      });\n      transfers.push(vertexData.buffer);\n      msg.vertexAttributes = vertexData;\n    } else {\n      msg.vertexAttributes = new Uint8Array(\n        vertexPositions.buffer,\n        vertexPositions.byteOffset,\n        vertexPositions.byteLength,\n      );\n      msg.vertexAttributeOffsets = Uint32Array.of(0);\n      if (vertexPositions.buffer !== transfers[0]) {\n        transfers.push(vertexPositions.buffer);\n      }\n    }\n    this.vertexPositions = this.indices = this.vertexAttributes = null;\n  }\n  downloadSucceeded() {\n    this.systemMemoryBytes = this.gpuMemoryBytes =\n      this.indices!.byteLength + this.getVertexAttributeBytes();\n    super.downloadSucceeded();\n  }\n}\n\nexport class SkeletonSource extends ChunkSource {\n  declare chunks: Map<string, SkeletonChunk>;\n  getChunk(objectId: Uint64) {\n    const key = getObjectKey(objectId);\n    let chunk = this.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(SkeletonChunk);\n      chunk.initializeSkeletonChunk(key, objectId);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n}\n\n@registerSharedObject(SKELETON_LAYER_RPC_ID)\nexport class SkeletonLayer extends withSegmentationLayerBackendState(\n  withSharedVisibility(withChunkManager(ChunkRenderLayerBackend)),\n) {\n  source: SkeletonSource;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = this.registerDisposer(\n      rpc.getRef<SkeletonSource>(options.source),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateChunkPriorities();\n      }),\n    );\n  }\n\n  private updateChunkPriorities() {\n    const visibility = this.visibility.value;\n    if (visibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    this.chunkManager.registerLayer(this);\n    const priorityTier = getPriorityTier(visibility);\n    const basePriority = getBasePriority(visibility);\n    const { source, chunkManager } = this;\n    forEachVisibleSegment(this, (objectId) => {\n      const chunk = source.getChunk(objectId);\n      ++this.numVisibleChunksNeeded;\n      if (chunk.state === ChunkState.GPU_MEMORY) {\n        ++this.numVisibleChunksAvailable;\n      }\n      chunkManager.requestChunk(\n        chunk,\n        priorityTier,\n        basePriority + SKELETON_CHUNK_PRIORITY,\n      );\n    });\n  }\n}\n\n/**\n * Extracts vertex positions and edge vertex indices of the specified endianness from `data'.\n *\n * See documentation of decodeVertexPositionsAndIndices.\n */\nexport function decodeSkeletonVertexPositionsAndIndices(\n  chunk: SkeletonChunk,\n  data: ArrayBuffer,\n  endianness: Endianness,\n  vertexByteOffset: number,\n  numVertices: number,\n  indexByteOffset?: number,\n  numEdges?: number,\n) {\n  const meshData = decodeVertexPositionsAndIndices(\n    /*verticesPerPrimitive=*/ 2,\n    data,\n    endianness,\n    vertexByteOffset,\n    numVertices,\n    indexByteOffset,\n    numEdges,\n  );\n  chunk.vertexPositions = meshData.vertexPositions as Float32Array;\n  chunk.indices = meshData.indices as Uint32Array;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\n\nexport async function decodeCompressedSegmentationChunk(\n  chunk: VolumeChunk,\n  abortSignal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  abortSignal;\n  chunk.data = new Uint32Array(response);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { DATA_TYPE_BYTES, makeDataTypeArrayView } from \"#src/util/data_type.js\";\nimport type { Endianness } from \"#src/util/endian.js\";\nimport { convertEndian, ENDIANNESS } from \"#src/util/endian.js\";\nimport * as vector from \"#src/util/vector.js\";\n\nexport async function decodeRawChunk(\n  chunk: VolumeChunk,\n  abortSignal: AbortSignal,\n  response: ArrayBuffer,\n  endianness: Endianness = ENDIANNESS,\n  byteOffset = 0,\n  byteLength: number = response.byteLength,\n) {\n  abortSignal;\n  const { spec } = chunk.source!;\n  const { dataType } = spec;\n  const numElements = vector.prod(chunk.chunkDataSize!);\n  const bytesPerElement = DATA_TYPE_BYTES[dataType];\n  const expectedBytes = numElements * bytesPerElement;\n  if (expectedBytes !== byteLength) {\n    throw new Error(\n      `Raw-format chunk is ${byteLength} bytes, ` +\n        `but ${numElements} * ${bytesPerElement} = ${expectedBytes} bytes are expected.`,\n    );\n  }\n  const data = makeDataTypeArrayView(\n    dataType,\n    response,\n    byteOffset,\n    byteLength,\n  );\n  convertEndian(data, endianness, bytesPerElement);\n  await postProcessRawData(chunk, abortSignal, data);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AnnotationGeometryChunk,\n  AnnotationMetadataChunk,\n  AnnotationSubsetGeometryChunk,\n} from \"#src/annotation/backend.js\";\nimport {\n  AnnotationGeometryChunkSourceBackend,\n  AnnotationGeometryData,\n  AnnotationSource,\n} from \"#src/annotation/backend.js\";\nimport type { Annotation, AnnotationId } from \"#src/annotation/index.js\";\nimport {\n  AnnotationSerializer,\n  AnnotationType,\n  makeAnnotationPropertySerializers,\n} from \"#src/annotation/index.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport type { ChunkSourceParametersConstructor } from \"#src/chunk_manager/base.js\";\nimport type { CredentialsProvider } from \"#src/credentials_provider/index.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport type {\n  BatchMeshFragment,\n  BatchMeshFragmentPayload,\n  BrainmapsInstance,\n  ChangeStackAwarePayload,\n  OAuth2Credentials,\n  SkeletonPayload,\n  SubvolumePayload,\n} from \"#src/datasource/brainmaps/api.js\";\nimport { makeRequest } from \"#src/datasource/brainmaps/api.js\";\nimport type { ChangeSpec } from \"#src/datasource/brainmaps/base.js\";\nimport {\n  AnnotationSourceParameters,\n  AnnotationSpatialIndexSourceParameters,\n  MeshSourceParameters,\n  MultiscaleMeshSourceParameters,\n  SkeletonSourceParameters,\n  VolumeChunkEncoding,\n  VolumeSourceParameters,\n} from \"#src/datasource/brainmaps/base.js\";\nimport type {\n  FragmentChunk,\n  ManifestChunk,\n  MultiscaleFragmentChunk,\n  MultiscaleManifestChunk,\n} from \"#src/mesh/backend.js\";\nimport {\n  assignMeshFragmentData,\n  assignMultiscaleMeshFragmentData,\n  generateHigherOctreeLevel,\n  MeshSource,\n  MultiscaleMeshSource,\n} from \"#src/mesh/backend.js\";\nimport { VertexPositionFormat } from \"#src/mesh/base.js\";\nimport type { MultiscaleMeshManifest } from \"#src/mesh/multiscale.js\";\nimport type { SkeletonChunk } from \"#src/skeleton/backend.js\";\nimport {\n  decodeSkeletonVertexPositionsAndIndices,\n  SkeletonSource,\n} from \"#src/skeleton/backend.js\";\nimport { decodeCompressedSegmentationChunk } from \"#src/sliceview/backend_chunk_decoders/compressed_segmentation.js\";\nimport { decodeJpegChunk } from \"#src/sliceview/backend_chunk_decoders/jpeg.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { convertEndian32, Endianness } from \"#src/util/endian.js\";\nimport { kInfinityVec, kZeroVec, vec3, vec3Key } from \"#src/util/geom.js\";\nimport {\n  parseArray,\n  parseFixedLengthArray,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalString,\n  verifyString,\n  verifyStringArray,\n} from \"#src/util/json.js\";\nimport { defaultStringCompare } from \"#src/util/string.js\";\nimport { Uint64 } from \"#src/util/uint64.js\";\nimport * as vector from \"#src/util/vector.js\";\nimport {\n  decodeZIndexCompressed,\n  encodeZIndexCompressed3d,\n  getOctreeChildIndex,\n  zorder3LessThan,\n} from \"#src/util/zorder.js\";\nimport type { SharedObject } from \"#src/worker_rpc.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nconst CHUNK_DECODERS = new Map([\n  [VolumeChunkEncoding.RAW, decodeRawChunk],\n  [VolumeChunkEncoding.JPEG, decodeJpegChunk],\n  [\n    VolumeChunkEncoding.COMPRESSED_SEGMENTATION,\n    decodeCompressedSegmentationChunk,\n  ],\n]);\n\nfunction applyChangeStack(\n  changeStack: ChangeSpec | undefined,\n  payload: ChangeStackAwarePayload,\n) {\n  if (!changeStack) {\n    return;\n  }\n  payload.change_spec = {\n    change_stack_id: changeStack.changeStackId,\n  };\n  if (changeStack.timeStamp) {\n    payload.change_spec.time_stamp = changeStack.timeStamp;\n  }\n  if (changeStack.skipEquivalences) {\n    payload.change_spec.skip_equivalences = changeStack.skipEquivalences;\n  }\n}\n\nfunction BrainmapsSource<\n  Parameters,\n  TBase extends { new (...args: any[]): SharedObject },\n>(\n  Base: TBase,\n  parametersConstructor: ChunkSourceParametersConstructor<Parameters>,\n) {\n  return WithParameters(\n    WithSharedCredentialsProviderCounterpart<OAuth2Credentials>()(Base),\n    parametersConstructor,\n  );\n}\n\nconst tempUint64 = new Uint64();\n\n@registerSharedObject()\nexport class BrainmapsVolumeChunkSource extends BrainmapsSource(\n  VolumeChunkSource,\n  VolumeSourceParameters,\n) {\n  chunkDecoder = CHUNK_DECODERS.get(this.parameters.encoding)!;\n\n  private applyEncodingParams(payload: SubvolumePayload) {\n    const { encoding } = this.parameters;\n    switch (encoding) {\n      case VolumeChunkEncoding.RAW:\n        payload.subvolume_format = \"RAW\";\n        break;\n      case VolumeChunkEncoding.JPEG:\n        payload.subvolume_format = \"SINGLE_IMAGE\";\n        payload.image_format_options = {\n          image_format: \"JPEG\",\n          jpeg_quality: this.parameters.jpegQuality!,\n        };\n        return;\n      case VolumeChunkEncoding.COMPRESSED_SEGMENTATION:\n        payload.subvolume_format = \"RAW\";\n        payload.image_format_options = {\n          compressed_segmentation_block_size: vec3Key(\n            this.spec.compressedSegmentationBlockSize!,\n          ),\n        };\n        break;\n      default:\n        throw new Error(`Invalid encoding: ${encoding}`);\n    }\n  }\n\n  async download(chunk: VolumeChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n\n    // chunkPosition must not be captured, since it will be invalidated by the next call to\n    // computeChunkBounds.\n    const chunkPosition = this.computeChunkBounds(chunk);\n    const chunkDataSize = chunk.chunkDataSize!;\n    const path = `/v1/volumes/${parameters.volumeId}/subvolume:binary`;\n\n    const payload: SubvolumePayload = {\n      geometry: {\n        corner: vec3Key(chunkPosition),\n        size: vec3Key(chunkDataSize),\n        scale: parameters.scaleIndex,\n      },\n    };\n\n    this.applyEncodingParams(payload);\n    applyChangeStack(parameters.changeSpec, payload);\n\n    const response = await makeRequest(\n      parameters.instance,\n      this.credentialsProvider,\n      {\n        method: \"POST\",\n        payload: JSON.stringify(payload),\n        path,\n        signal: abortSignal,\n      },\n    );\n    await this.chunkDecoder(chunk, abortSignal, await response.arrayBuffer());\n  }\n}\n\nfunction getFragmentCorner(\n  fragmentId: string,\n  xBits: number,\n  yBits: number,\n  zBits: number,\n): Uint32Array {\n  const id = new Uint64();\n  if (!id.tryParseString(fragmentId, 16)) {\n    throw new Error(\n      `Couldn't parse fragmentId ${fragmentId} as hex-encoded Uint64`,\n    );\n  }\n  return decodeZIndexCompressed(id, xBits, yBits, zBits);\n}\n\ninterface BrainmapsMultiscaleManifestChunk extends MultiscaleManifestChunk {\n  fragmentSupervoxelIds: { fragmentId: string; supervoxelIds: string[] }[];\n}\n\nfunction decodeMultiscaleManifestChunk(\n  chunk: BrainmapsMultiscaleManifestChunk,\n  response: any,\n) {\n  verifyObject(response);\n  const source = chunk.source as BrainmapsMultiscaleMeshSource;\n  const fragmentKeys = verifyObjectProperty(\n    response,\n    \"fragmentKey\",\n    verifyStringArray,\n  );\n  const supervoxelIds = verifyObjectProperty(\n    response,\n    \"supervoxelId\",\n    verifyStringArray,\n  );\n  const length = fragmentKeys.length;\n  if (length !== supervoxelIds.length) {\n    throw new Error(\n      \"Expected fragmentKey and supervoxelId arrays to have the same length.\",\n    );\n  }\n  const fragmentSupervoxelIds = new Map<string, string[]>();\n  fragmentKeys.forEach((fragmentId, i) => {\n    let ids = fragmentSupervoxelIds.get(fragmentId);\n    if (ids === undefined) {\n      ids = [];\n      fragmentSupervoxelIds.set(fragmentId, ids);\n    }\n    ids.push(supervoxelIds[i]);\n  });\n  const { chunkShape } = source.parameters.info;\n  const gridShape = source.parameters.info.lods[0].gridShape;\n  const xBits = Math.ceil(Math.log2(gridShape[0]));\n  const yBits = Math.ceil(Math.log2(gridShape[1]));\n  const zBits = Math.ceil(Math.log2(gridShape[2]));\n  const fragmentIdAndCorners = Array.from(fragmentSupervoxelIds.entries()).map(\n    ([id, supervoxelIds]) => ({\n      fragmentId: id,\n      corner: getFragmentCorner(id, xBits, yBits, zBits),\n      supervoxelIds,\n    }),\n  );\n  fragmentIdAndCorners.sort((a, b) => {\n    return zorder3LessThan(\n      a.corner[0],\n      a.corner[1],\n      a.corner[2],\n      b.corner[0],\n      b.corner[1],\n      b.corner[2],\n    )\n      ? -1\n      : 1;\n  });\n  let clipLowerBound: vec3;\n  let clipUpperBound: vec3;\n  let minNumLods = 0;\n  let octree: Uint32Array;\n  if (length === 0) {\n    clipLowerBound = clipUpperBound = kZeroVec;\n    octree = Uint32Array.of(0, 0, 0, 0, 0x80000000);\n  } else {\n    const minCoord = vec3.clone(kInfinityVec);\n    const maxCoord = vec3.clone(kZeroVec);\n    fragmentIdAndCorners.forEach((x) => {\n      const { corner } = x;\n      for (let i = 0; i < 3; ++i) {\n        minCoord[i] = Math.min(minCoord[i], corner[i]);\n        maxCoord[i] = Math.max(maxCoord[i], corner[i]);\n      }\n    });\n    minNumLods = 1;\n    while (\n      maxCoord[0] >>> (minNumLods - 1) !== minCoord[0] >>> (minNumLods - 1) ||\n      maxCoord[1] >>> (minNumLods - 1) !== minCoord[1] >>> (minNumLods - 1) ||\n      maxCoord[2] >>> (minNumLods - 1) !== minCoord[2] >>> (minNumLods - 1)\n    ) {\n      ++minNumLods;\n    }\n    clipLowerBound = vec3.multiply(minCoord, minCoord, chunkShape);\n    clipUpperBound = vec3.add(\n      maxCoord,\n      vec3.multiply(maxCoord, maxCoord, chunkShape),\n      chunkShape,\n    );\n  }\n  const { lods } = source.parameters.info;\n  const lodScales = new Float32Array(Math.max(lods.length, minNumLods));\n  for (let lodIndex = 0; lodIndex < lods.length; ++lodIndex) {\n    lodScales[lodIndex] = lods[lodIndex].scale;\n  }\n\n  if (length !== 0) {\n    const octreeTemp = new Uint32Array(\n      fragmentIdAndCorners.length * lodScales.length * 5,\n    );\n    fragmentIdAndCorners.forEach((x, i) => {\n      octreeTemp.set(x.corner, i * 5);\n      octreeTemp[i * 5] = x.corner[0];\n    });\n    let priorStart = 0;\n    let priorEnd = fragmentIdAndCorners.length;\n    for (let lod = 1; lod < lodScales.length; ++lod) {\n      const curEnd = generateHigherOctreeLevel(\n        octreeTemp,\n        priorStart,\n        priorEnd,\n      );\n      priorStart = priorEnd;\n      priorEnd = curEnd;\n    }\n    octree = octreeTemp.slice(0, priorEnd * 5);\n  }\n\n  const manifest: MultiscaleMeshManifest = {\n    chunkShape,\n    chunkGridSpatialOrigin: kZeroVec,\n    clipLowerBound,\n    clipUpperBound,\n    octree: octree!,\n    lodScales: lodScales,\n    vertexOffsets: new Float32Array(lodScales.length * 3),\n  };\n  chunk.manifest = manifest;\n  chunk.fragmentSupervoxelIds = fragmentIdAndCorners;\n}\n\nconst maxMeshBatchSize = 255;\n\ninterface BatchMeshResponseFragment {\n  fullKey: string;\n  buffer: ArrayBuffer;\n  verticesOffset: number;\n  indicesOffset: number;\n  numVertices: number;\n  numIndices: number;\n}\n\nfunction decodeBatchMeshResponse(\n  response: ArrayBuffer,\n  callback: (fragment: BatchMeshResponseFragment) => void,\n) {\n  const length = response.byteLength;\n  let index = 0;\n  const dataView = new DataView(response);\n  const headerSize =\n    /*object id*/ 8 +\n    /*fragment key length*/ 8 +\n    /*num vertices*/ 8 +\n    /*num triangles*/ 8;\n  while (index < length) {\n    if (index + headerSize > length) {\n      throw new Error(\"Invalid batch mesh fragment response.\");\n    }\n    const objectIdLow = dataView.getUint32(index, /*littleEndian=*/ true);\n    const objectIdHigh = dataView.getUint32(index + 4, /*littleEndian=*/ true);\n    const objectIdString = new Uint64(objectIdLow, objectIdHigh).toString();\n    const prefix = objectIdString + \"\\0\";\n    index += 8;\n    const fragmentKeyLength = dataView.getUint32(index, /*littleEndian=*/ true);\n    const fragmentKeyLengthHigh = dataView.getUint32(\n      index + 4,\n      /*littleEndian=*/ true,\n    );\n    index += 8;\n    if (fragmentKeyLengthHigh !== 0) {\n      throw new Error(\"Invalid batch mesh fragment response.\");\n    }\n    if (\n      index + fragmentKeyLength + /* num vertices */ 8 + /*num indices*/ 8 >\n      length\n    ) {\n      throw new Error(\"Invalid batch mesh fragment response.\");\n    }\n    const fragmentKey = new TextDecoder().decode(\n      new Uint8Array(response, index, fragmentKeyLength),\n    );\n    const fullKey = prefix + fragmentKey;\n    index += fragmentKeyLength;\n    const numVertices = dataView.getUint32(index, /*littleEndian=*/ true);\n    const numVerticesHigh = dataView.getUint32(\n      index + 4,\n      /*littleEndian=*/ true,\n    );\n    index += 8;\n    const numTriangles = dataView.getUint32(index, /*littleEndian=*/ true);\n    const numTrianglesHigh = dataView.getUint32(\n      index + 4,\n      /*littleEndian=*/ true,\n    );\n    index += 8;\n    if (numVerticesHigh !== 0 || numTrianglesHigh !== 0) {\n      throw new Error(\"Invalid batch mesh fragment response.\");\n    }\n    const endOffset = index + numTriangles * 12 + numVertices * 12;\n    if (endOffset > length) {\n      throw new Error(\"Invalid batch mesh fragment response.\");\n    }\n    callback({\n      fullKey,\n      buffer: response,\n      verticesOffset: index,\n      numVertices,\n      indicesOffset: index + 12 * numVertices,\n      numIndices: numTriangles * 3,\n    });\n    index = endOffset;\n  }\n}\n\nfunction combineBatchMeshFragments(fragments: BatchMeshResponseFragment[]) {\n  let totalVertices = 0;\n  let totalIndices = 0;\n  for (const fragment of fragments) {\n    totalVertices += fragment.numVertices;\n    totalIndices += fragment.numIndices;\n  }\n  const vertexBuffer = new Float32Array(totalVertices * 3);\n  const indexBuffer = new Uint32Array(totalIndices);\n  let vertexOffset = 0;\n  let indexOffset = 0;\n  for (const fragment of fragments) {\n    vertexBuffer.set(\n      new Float32Array(\n        fragment.buffer,\n        fragment.verticesOffset,\n        fragment.numVertices * 3,\n      ),\n      vertexOffset * 3,\n    );\n    const { numIndices } = fragment;\n    const sourceIndices = new Uint32Array(\n      fragment.buffer,\n      fragment.indicesOffset,\n      numIndices,\n    );\n    convertEndian32(sourceIndices, Endianness.LITTLE);\n    for (let i = 0; i < numIndices; ++i) {\n      indexBuffer[indexOffset++] = sourceIndices[i] + vertexOffset;\n    }\n    vertexOffset += fragment.numVertices;\n  }\n  convertEndian32(vertexBuffer, Endianness.LITTLE);\n  return { vertexPositions: vertexBuffer, indices: indexBuffer };\n}\n\nasync function makeBatchMeshRequest<T>(\n  credentialsProvider: CredentialsProvider<OAuth2Credentials>,\n  parameters: {\n    instance: BrainmapsInstance;\n    volumeId: string;\n    meshName: string;\n  },\n  ids: Map<string, T>,\n  abortSignal: AbortSignal,\n): Promise<ArrayBuffer> {\n  const path = \"/v1/objects/meshes:batch\";\n  const batches: BatchMeshFragment[] = [];\n  let prevObjectId: string | undefined;\n  let batchSize = 0;\n  const pendingIds = new Map<string, T>();\n  for (const [id, idData] of ids) {\n    pendingIds.set(id, idData);\n    ids.delete(id);\n    const splitIndex = id.indexOf(\"\\0\");\n    const objectId = id.substring(0, splitIndex);\n    const fragmentId = id.substring(splitIndex + 1);\n    if (objectId !== prevObjectId) {\n      batches.push({ object_id: objectId, fragment_keys: [] });\n    }\n    batches[batches.length - 1].fragment_keys.push(fragmentId);\n    if (++batchSize === maxMeshBatchSize) break;\n  }\n  const payload: BatchMeshFragmentPayload = {\n    volume_id: parameters.volumeId,\n    mesh_name: parameters.meshName,\n    batches: batches,\n  };\n  try {\n    return await (\n      await makeRequest(parameters.instance, credentialsProvider, {\n        method: \"POST\",\n        path,\n        payload: JSON.stringify(payload),\n        signal: abortSignal,\n      })\n    ).arrayBuffer();\n  } finally {\n    for (const [id, idData] of pendingIds) {\n      ids.set(id, idData);\n    }\n  }\n}\n\n@registerSharedObject()\nexport class BrainmapsMultiscaleMeshSource extends BrainmapsSource(\n  MultiscaleMeshSource,\n  MultiscaleMeshSourceParameters,\n) {\n  private listFragmentsParams = (() => {\n    const { parameters } = this;\n    const { changeSpec } = parameters;\n    if (changeSpec !== undefined) {\n      return `&header.changeStackId=${changeSpec.changeStackId}`;\n    }\n    return \"\";\n  })();\n\n  download(chunk: BrainmapsMultiscaleManifestChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const path =\n      `/v1/objects/${parameters.volumeId}/meshes/` +\n      `${parameters.info.lods[0].info.name}:listfragments?` +\n      `object_id=${chunk.objectId}&return_supervoxel_ids=true` +\n      this.listFragmentsParams;\n    return makeRequest(parameters.instance, this.credentialsProvider, {\n      method: \"GET\",\n      path,\n      signal: abortSignal,\n    })\n      .then((response) => response.json())\n      .then((response) => decodeMultiscaleManifestChunk(chunk, response));\n  }\n\n  async downloadFragment(\n    chunk: MultiscaleFragmentChunk,\n    abortSignal: AbortSignal,\n  ) {\n    const { parameters } = this;\n\n    const manifestChunk =\n      chunk.manifestChunk! as BrainmapsMultiscaleManifestChunk;\n    const { fragmentSupervoxelIds } = manifestChunk;\n    const manifest = manifestChunk.manifest!;\n    const { lod } = chunk;\n    const { octree } = manifest;\n    const numBaseChunks = fragmentSupervoxelIds.length;\n    const row = chunk.chunkIndex;\n    let startChunkIndex = row;\n    while (startChunkIndex >= numBaseChunks) {\n      startChunkIndex = octree[startChunkIndex * 5 + 3];\n    }\n    let endChunkIndex = row + 1;\n    while (endChunkIndex > numBaseChunks) {\n      endChunkIndex = octree[endChunkIndex * 5 - 1] & 0x7fffffff;\n    }\n    const { relativeBlockShape, gridShape } = parameters.info.lods[lod];\n    const xBits = Math.ceil(Math.log2(gridShape[0]));\n    const yBits = Math.ceil(Math.log2(gridShape[1]));\n    const zBits = Math.ceil(Math.log2(gridShape[2]));\n\n    let ids = new Map<string, number>();\n    for (\n      let chunkIndex = startChunkIndex;\n      chunkIndex < endChunkIndex;\n      ++chunkIndex\n    ) {\n      // Determine number of x, y, and z bits to skip.\n      const gridX = Math.floor(octree[chunkIndex * 5] / relativeBlockShape[0]);\n      const gridY = Math.floor(\n        octree[chunkIndex * 5 + 1] / relativeBlockShape[1],\n      );\n      const gridZ = Math.floor(\n        octree[chunkIndex * 5 + 2] / relativeBlockShape[2],\n      );\n      const fragmentKey = encodeZIndexCompressed3d(\n        tempUint64,\n        xBits,\n        yBits,\n        zBits,\n        gridX,\n        gridY,\n        gridZ,\n      )\n        .toString(16)\n        .padStart(16, \"0\");\n      const entry = fragmentSupervoxelIds[chunkIndex];\n      for (const supervoxelId of entry.supervoxelIds) {\n        ids.set(supervoxelId + \"\\0\" + fragmentKey, chunkIndex);\n      }\n    }\n\n    const prevLod = Math.max(0, lod - 1);\n\n    const fragments: (BatchMeshResponseFragment & { chunkIndex: number })[] =\n      [];\n\n    const idArray = Array.from(ids);\n    idArray.sort((a, b) => defaultStringCompare(a[0], b[0]));\n    ids = new Map(idArray);\n\n    const meshName = parameters.info.lods[lod].info.name;\n\n    const parallelRequests = true;\n\n    await new Promise((resolve, reject) => {\n      let requestsInProgress = 0;\n      let error = false;\n      const maybeIssueMoreRequests = () => {\n        if (error) return;\n        while (ids.size !== 0) {\n          ++requestsInProgress;\n          makeBatchMeshRequest(\n            this.credentialsProvider,\n            {\n              instance: parameters.instance,\n              volumeId: parameters.volumeId,\n              meshName,\n            },\n            ids,\n            abortSignal,\n          )\n            .then((response) => {\n              --requestsInProgress;\n              decodeBatchMeshResponse(\n                response,\n                (\n                  fragment: BatchMeshResponseFragment & { chunkIndex: number },\n                ) => {\n                  const chunkIndex = ids.get(fragment.fullKey)!;\n                  if (!ids.delete(fragment.fullKey)) {\n                    throw new Error(\n                      `Received unexpected fragment key: ${JSON.stringify(\n                        fragment.fullKey,\n                      )}.`,\n                    );\n                  }\n                  fragment.chunkIndex = chunkIndex;\n                  fragments.push(fragment);\n                },\n              );\n              maybeIssueMoreRequests();\n            })\n            .catch((e) => {\n              error = true;\n              reject(e);\n            });\n          if (!parallelRequests) break;\n        }\n        // Notify the chunk queue of the number of download slots being used.  This partially limits\n        // parallelism by maximum number of concurrent downloads, and avoids fetch errors due to an\n        // excessive number of concurrent requests.\n        //\n        // Note that the limit on the number of concurrent downloads is not enforced perfectly.  If\n        // the new value of `downloadSlots` results in the total number of concurrent downloads\n        // exceeding the maximum allowed, the concurrent requests are still issued.  However, no\n        // additional lower-priority chunks will be promoted to `ChunkState.DOWNLOADING` until a\n        // download slot is available.\n        chunk.downloadSlots = Math.max(1, requestsInProgress);\n        if (requestsInProgress === 0) {\n          resolve(undefined);\n          return;\n        }\n      };\n      maybeIssueMoreRequests();\n    });\n\n    // Combine fragments\n    fragments.sort((a, b) => a.chunkIndex - b.chunkIndex);\n    let indexOffset = 0;\n    const numSubChunks = 1 << (3 * (lod - prevLod));\n    const subChunkOffsets = new Uint32Array(numSubChunks + 1);\n    let prevSubChunkIndex = 0;\n    for (const fragment of fragments) {\n      const row = fragment.chunkIndex;\n      const subChunkIndex =\n        getOctreeChildIndex(\n          octree[row * 5] >>> prevLod,\n          octree[row * 5 + 1] >>> prevLod,\n          octree[row * 5 + 2] >>> prevLod,\n        ) &\n        (numSubChunks - 1);\n      subChunkOffsets.fill(\n        indexOffset,\n        prevSubChunkIndex + 1,\n        subChunkIndex + 1,\n      );\n      prevSubChunkIndex = subChunkIndex;\n      indexOffset += fragment.numIndices;\n    }\n    subChunkOffsets.fill(indexOffset, prevSubChunkIndex + 1, numSubChunks + 1);\n    assignMultiscaleMeshFragmentData(\n      chunk,\n      { ...combineBatchMeshFragments(fragments), subChunkOffsets },\n      VertexPositionFormat.float32,\n    );\n  }\n}\n\nfunction groupFragmentsIntoBatches(ids: string[]) {\n  const batches = [];\n  let index = 0;\n  const length = ids.length;\n  while (index < length) {\n    batches.push(JSON.stringify(ids.slice(index, index + maxMeshBatchSize)));\n    index += maxMeshBatchSize;\n  }\n  return batches;\n}\n\nfunction decodeManifestChunkWithSupervoxelIds(\n  chunk: ManifestChunk,\n  response: any,\n) {\n  verifyObject(response);\n  const fragmentKeys = verifyObjectProperty(\n    response,\n    \"fragmentKey\",\n    verifyStringArray,\n  );\n  const supervoxelIds = verifyObjectProperty(\n    response,\n    \"supervoxelId\",\n    verifyStringArray,\n  );\n  const length = fragmentKeys.length;\n  if (length !== supervoxelIds.length) {\n    throw new Error(\n      \"Expected fragmentKey and supervoxelId arrays to have the same length.\",\n    );\n  }\n  const fragmentIds = supervoxelIds.map(\n    (supervoxelId, index) => supervoxelId + \"\\0\" + fragmentKeys[index],\n  );\n  chunk.fragmentIds = groupFragmentsIntoBatches(fragmentIds);\n}\n\n@registerSharedObject()\nexport class BrainmapsMeshSource extends BrainmapsSource(\n  MeshSource,\n  MeshSourceParameters,\n) {\n  private listFragmentsParams = (() => {\n    const { parameters } = this;\n    const { changeSpec } = parameters;\n    if (changeSpec !== undefined) {\n      return `&header.changeStackId=${changeSpec.changeStackId}`;\n    }\n    return \"\";\n  })();\n\n  download(chunk: ManifestChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const path =\n      `/v1/objects/${parameters.volumeId}/meshes/` +\n      `${parameters.meshName}:listfragments?` +\n      `object_id=${chunk.objectId}&return_supervoxel_ids=true` +\n      this.listFragmentsParams;\n    return makeRequest(parameters.instance, this.credentialsProvider, {\n      signal: abortSignal,\n      method: \"GET\",\n      path,\n    })\n      .then((response) => response.json())\n      .then((response) =>\n        decodeManifestChunkWithSupervoxelIds(chunk, response),\n      );\n  }\n\n  async downloadFragment(chunk: FragmentChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n\n    const ids = new Map<string, null>();\n    for (const id of JSON.parse(chunk.fragmentId!)) {\n      ids.set(id, null);\n    }\n\n    const fragments: BatchMeshResponseFragment[] = [];\n\n    const { credentialsProvider } = this;\n\n    while (ids.size !== 0) {\n      const response = await makeBatchMeshRequest(\n        credentialsProvider,\n        parameters,\n        ids,\n        abortSignal,\n      );\n      decodeBatchMeshResponse(response, (fragment) => {\n        if (!ids.delete(fragment.fullKey)) {\n          throw new Error(\n            `Received unexpected fragment key: ${JSON.stringify(\n              fragment.fullKey,\n            )}.`,\n          );\n        }\n        fragments.push(fragment);\n      });\n    }\n    assignMeshFragmentData(chunk, combineBatchMeshFragments(fragments));\n  }\n}\n\nfunction decodeSkeletonChunk(chunk: SkeletonChunk, response: ArrayBuffer) {\n  const dv = new DataView(response);\n  const numVertices = dv.getUint32(0, true);\n  const numVerticesHigh = dv.getUint32(4, true);\n  if (numVerticesHigh !== 0) {\n    throw new Error(\"The number of vertices should not exceed 2^32-1.\");\n  }\n  const numEdges = dv.getUint32(8, true);\n  const numEdgesHigh = dv.getUint32(12, true);\n  if (numEdgesHigh !== 0) {\n    throw new Error(\"The number of edges should not exceed 2^32-1.\");\n  }\n  decodeSkeletonVertexPositionsAndIndices(\n    chunk,\n    response,\n    Endianness.LITTLE,\n    /*vertexByteOffset=*/ 16,\n    numVertices,\n    /*indexByteOffset=*/ undefined,\n    /*numEdges=*/ numEdges,\n  );\n}\n\n@registerSharedObject()\nexport class BrainmapsSkeletonSource extends BrainmapsSource(\n  SkeletonSource,\n  SkeletonSourceParameters,\n) {\n  download(chunk: SkeletonChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const payload: SkeletonPayload = {\n      object_id: `${chunk.objectId}`,\n    };\n    const path =\n      `/v1/objects/${parameters.volumeId}` +\n      `/meshes/${parameters.meshName}` +\n      \"/skeleton:binary\";\n    applyChangeStack(parameters.changeSpec, payload);\n    return makeRequest(parameters.instance, this.credentialsProvider, {\n      method: \"POST\",\n      path,\n      payload: JSON.stringify(payload),\n      signal: abortSignal,\n    })\n      .then((response) => response.arrayBuffer())\n      .then((response) => decodeSkeletonChunk(chunk, response));\n  }\n}\n\nconst spatialAnnotationTypes = [\"LOCATION\", \"LINE\", \"VOLUME\"];\n\nfunction parseCommaSeparatedPoint(x: string) {\n  const pattern = /(-?[0-9]+),(-?[0-9]+),(-?[0-9]+)/;\n  const cornerParts = x.match(pattern);\n  if (cornerParts === null) {\n    throw new Error(`Error parsing number triplet: ${JSON.stringify(x)}.`);\n  }\n  return vec3.fromValues(\n    parseFloat(cornerParts[1]),\n    parseFloat(cornerParts[2]),\n    parseFloat(cornerParts[3]),\n  );\n}\n\nfunction getIdPrefix(parameters: AnnotationSourceParameters) {\n  return parameters.volumeId + \":\" + parameters.changestack + \":\";\n}\n\nfunction parseBrainmapsAnnotationId(idPrefix: string, fullId: string) {\n  if (!fullId.startsWith(idPrefix)) {\n    throw new Error(\n      `Received annotation id ${JSON.stringify(\n        fullId,\n      )} does not have expected prefix of ${JSON.stringify(idPrefix)}.`,\n    );\n  }\n  const id = fullId.substring(idPrefix.length);\n  return id;\n}\n\nfunction parseObjectLabels(obj: any): Uint64[][] | undefined {\n  if (obj == null) {\n    return undefined;\n  }\n  return [parseArray(obj, (x) => Uint64.parseString(\"\" + x, 10))];\n}\n\nfunction parseAnnotation(\n  entry: any,\n  idPrefix: string,\n  expectedId?: string,\n): Annotation {\n  const corner = verifyObjectProperty(entry, \"corner\", (x) =>\n    parseCommaSeparatedPoint(verifyString(x)),\n  );\n  const size = verifyObjectProperty(entry, \"size\", (x) =>\n    parseCommaSeparatedPoint(verifyString(x)),\n  );\n  const description = verifyObjectProperty(\n    entry,\n    \"payload\",\n    verifyOptionalString,\n  );\n  const spatialAnnotationType = verifyObjectProperty(\n    entry,\n    \"type\",\n    verifyString,\n  );\n  const fullId = verifyObjectProperty(entry, \"id\", verifyString);\n  const id = parseBrainmapsAnnotationId(idPrefix, fullId);\n  const segments = verifyObjectProperty(\n    entry,\n    \"objectLabels\",\n    parseObjectLabels,\n  );\n  if (expectedId !== undefined && id !== expectedId) {\n    throw new Error(\n      `Received annotation has unexpected id ${JSON.stringify(fullId)}.`,\n    );\n  }\n  switch (spatialAnnotationType) {\n    case \"LOCATION\": {\n      if (vec3.equals(size, kZeroVec)) {\n        return {\n          type: AnnotationType.POINT,\n          id,\n          point: corner,\n          description,\n          relatedSegments: segments,\n          properties: [],\n        };\n      }\n      const radii = vec3.scale(vec3.create(), size, 0.5);\n      const center = vec3.add(vec3.create(), corner, radii);\n      return {\n        type: AnnotationType.ELLIPSOID,\n        id,\n        center,\n        radii,\n        description,\n        relatedSegments: segments,\n        properties: [],\n      };\n    }\n    case \"LINE\":\n      return {\n        type: AnnotationType.LINE,\n        id,\n        pointA: corner,\n        pointB: vec3.add(vec3.create(), corner, size),\n        description,\n        relatedSegments: segments,\n        properties: [],\n      };\n    case \"VOLUME\":\n      return {\n        type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,\n        id,\n        pointA: corner,\n        pointB: vec3.add(vec3.create(), corner, size),\n        description,\n        relatedSegments: segments,\n        properties: [],\n      };\n    default:\n      throw new Error(\n        `Unknown spatial annotation type: ${JSON.stringify(\n          spatialAnnotationType,\n        )}.`,\n      );\n  }\n}\n\nfunction parseAnnotationResponse(\n  response: any,\n  idPrefix: string,\n  expectedId?: string,\n): Annotation {\n  verifyObject(response);\n  const entry = verifyObjectProperty(response, \"annotations\", (x) =>\n    parseFixedLengthArray(<any[]>[undefined], x, verifyObject),\n  )[0];\n  return parseAnnotation(entry, idPrefix, expectedId);\n}\n\nconst annotationPropertySerializers = makeAnnotationPropertySerializers(\n  /*rank=*/ 3,\n  /*propertySpecs=*/ [],\n);\n\nfunction parseAnnotations(\n  chunk: AnnotationGeometryChunk | AnnotationSubsetGeometryChunk,\n  responses: any[],\n) {\n  const serializer = new AnnotationSerializer(annotationPropertySerializers);\n  const source = <BrainmapsAnnotationSource>chunk.source.parent;\n  const idPrefix = getIdPrefix(source.parameters);\n  responses.forEach((response, responseIndex) => {\n    try {\n      verifyObject(response);\n      const annotationsArray = verifyObjectProperty(\n        response,\n        \"annotations\",\n        (x) => (x === undefined ? [] : x),\n      );\n      if (!Array.isArray(annotationsArray)) {\n        throw new Error(\n          `Expected array, but received ${JSON.stringify(\n            typeof annotationsArray,\n          )}.`,\n        );\n      }\n      for (const entry of annotationsArray) {\n        try {\n          serializer.add(parseAnnotation(entry, idPrefix));\n        } catch (e) {\n          throw new Error(`Error parsing annotation: ${e.message}`);\n        }\n      }\n    } catch (parseError) {\n      throw new Error(\n        `Error parsing ${spatialAnnotationTypes[responseIndex]} annotations: ${parseError.message}`,\n      );\n    }\n  });\n  chunk.data = Object.assign(\n    new AnnotationGeometryData(),\n    serializer.serialize(),\n  );\n}\n\nfunction getSpatialAnnotationTypeFromId(id: string) {\n  const index = id.indexOf(\".\");\n  return id.substring(0, index);\n}\n\nfunction toCommaSeparated(v: vec3) {\n  return `${Math.round(v[0])},${Math.round(v[1])},${Math.round(v[2])}`;\n}\n\nfunction getFullSpatialAnnotationId(\n  parameters: AnnotationSourceParameters,\n  id: string,\n) {\n  return `${parameters.volumeId}:${parameters.changestack}:${id}`;\n}\n\nfunction annotationToBrainmaps(annotation: Annotation): any {\n  const payload = annotation.description || \"\";\n  const objectLabels =\n    annotation.relatedSegments === undefined\n      ? undefined\n      : annotation.relatedSegments[0].map((x) => x.toString());\n  switch (annotation.type) {\n    case AnnotationType.LINE: {\n      const { pointA, pointB } = annotation;\n      const size = vec3.subtract(vec3.create(), pointB as vec3, pointA as vec3);\n      return {\n        type: \"LINE\",\n        corner: toCommaSeparated(pointA as vec3),\n        size: toCommaSeparated(size),\n        object_labels: objectLabels,\n        payload,\n      };\n    }\n    case AnnotationType.AXIS_ALIGNED_BOUNDING_BOX: {\n      const { pointA, pointB } = annotation;\n      const minPoint = vector.min(vec3.create(), pointA, pointB);\n      const maxPoint = vector.max(vec3.create(), pointA, pointB);\n      const size = vec3.subtract(maxPoint, maxPoint, minPoint);\n      return {\n        type: \"VOLUME\",\n        corner: toCommaSeparated(minPoint),\n        size: toCommaSeparated(size),\n        object_labels: objectLabels,\n        payload,\n      };\n    }\n    case AnnotationType.POINT: {\n      return {\n        type: \"LOCATION\",\n        corner: toCommaSeparated(annotation.point as vec3),\n        size: \"0,0,0\",\n        object_labels: objectLabels,\n        payload,\n      };\n    }\n    case AnnotationType.ELLIPSOID: {\n      const corner = vec3.subtract(\n        vec3.create(),\n        annotation.center as vec3,\n        annotation.radii as vec3,\n      );\n      const size = vec3.scale(vec3.create(), annotation.radii as vec3, 2);\n      return {\n        type: \"LOCATION\",\n        corner: toCommaSeparated(corner),\n        size: toCommaSeparated(size),\n        object_labels: objectLabels,\n        payload,\n      };\n    }\n  }\n}\n\n@registerSharedObject() //\nexport class BrainmapsAnnotationGeometryChunkSource extends BrainmapsSource(\n  AnnotationGeometryChunkSourceBackend,\n  AnnotationSpatialIndexSourceParameters,\n) {\n  async download(chunk: AnnotationGeometryChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    return Promise.all(\n      spatialAnnotationTypes.map((spatialAnnotationType) =>\n        makeRequest(parameters.instance, this.credentialsProvider, {\n          signal: abortSignal,\n          method: \"POST\",\n          path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:get`,\n          payload: JSON.stringify({\n            type: spatialAnnotationType,\n            ignore_payload: true,\n          }),\n        }).then((response) => response.json()),\n      ),\n    ).then((values) => {\n      parseAnnotations(chunk, values);\n    });\n  }\n}\n\n@registerSharedObject()\nexport class BrainmapsAnnotationSource extends BrainmapsSource(\n  AnnotationSource,\n  AnnotationSourceParameters,\n) {\n  downloadSegmentFilteredGeometry(\n    chunk: AnnotationSubsetGeometryChunk,\n    _relationshipIndex: number,\n    abortSignal: AbortSignal,\n  ) {\n    const { parameters } = this;\n    return Promise.all(\n      spatialAnnotationTypes.map((spatialAnnotationType) =>\n        makeRequest(parameters.instance, this.credentialsProvider, {\n          signal: abortSignal,\n          method: \"POST\",\n          path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:get`,\n          payload: JSON.stringify({\n            type: spatialAnnotationType,\n            object_labels: [chunk.objectId.toString()],\n            ignore_payload: true,\n          }),\n        }).then((response) => response.json()),\n      ),\n    ).then((values) => {\n      parseAnnotations(chunk, values);\n    });\n  }\n\n  downloadMetadata(chunk: AnnotationMetadataChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const id = chunk.key!;\n    return makeRequest(parameters.instance, this.credentialsProvider, {\n      signal: abortSignal,\n      method: \"POST\",\n      path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:get`,\n      payload: JSON.stringify({\n        type: getSpatialAnnotationTypeFromId(id),\n        id: getFullSpatialAnnotationId(parameters, id),\n      }),\n    })\n      .then((response) => response.json())\n      .then(\n        (response) => {\n          chunk.annotation = parseAnnotationResponse(\n            response,\n            getIdPrefix(parameters),\n            id,\n          );\n        },\n        () => {\n          chunk.annotation = null;\n        },\n      );\n  }\n\n  add(annotation: Annotation) {\n    const { parameters } = this;\n    const brainmapsAnnotation = annotationToBrainmaps(annotation);\n    return makeRequest(parameters.instance, this.credentialsProvider, {\n      method: \"POST\",\n      path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:push`,\n      payload: JSON.stringify({ annotations: [brainmapsAnnotation] }),\n    })\n      .then((response) => response.json())\n      .then((response) => {\n        verifyObject(response);\n        const ids = verifyObjectProperty(response, \"ids\", verifyStringArray);\n        if (ids.length !== 1) {\n          throw new Error(\n            `Expected list of 1 id, but received ${JSON.stringify(ids)}.`,\n          );\n        }\n        const idPrefix = getIdPrefix(this.parameters);\n        return parseBrainmapsAnnotationId(idPrefix, ids[0]);\n      });\n  }\n\n  update(id: AnnotationId, annotation: Annotation) {\n    const { parameters } = this;\n    const brainmapsAnnotation = annotationToBrainmaps(annotation);\n    brainmapsAnnotation.id = getFullSpatialAnnotationId(parameters, id);\n    return makeRequest(parameters.instance, this.credentialsProvider, {\n      method: \"POST\",\n      path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:push`,\n      payload: JSON.stringify({ annotations: [brainmapsAnnotation] }),\n    }).then((response) => response.json());\n  }\n\n  delete(id: AnnotationId) {\n    const { parameters } = this;\n    return makeRequest(parameters.instance, this.credentialsProvider, {\n      method: \"POST\",\n      path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:delete`,\n      payload: JSON.stringify({\n        type: getSpatialAnnotationTypeFromId(id),\n        ids: [getFullSpatialAnnotationId(parameters, id)],\n      }),\n    }).then((response) => response.json());\n  }\n}\n","/**\n * @license\n * Copyright 2022 William Silversmith\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport interface DecodedImage {\n  width: number;\n  height: number;\n  numComponents: number;\n  uint8Array: Uint8Array<ArrayBuffer>;\n}\n\nexport const decodePng = asyncComputation<\n  (\n    data: Uint8Array<ArrayBuffer>,\n    width: number | undefined,\n    height: number | undefined,\n    // Expected width * height\n    area: number | undefined,\n    numComponents: number | undefined,\n    bytesPerPixel: number,\n    convertToGrayscale: boolean,\n  ) => DecodedImage\n>(\"decodePng\");\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport pythonIntegration from \"#python_integration_build\";\nimport type {\n  CredentialsManager,\n  MaybeOptionalCredentialsProvider,\n} from \"#src/credentials_provider/index.js\";\nimport { fetchWithOAuth2Credentials } from \"#src/credentials_provider/oauth2.js\";\nimport { parseUrl } from \"#src/util/http_request.js\";\nimport { getRandomHexString } from \"#src/util/random.js\";\nimport { fetchS3Ok } from \"#src/util/s3.js\";\n\nexport type SpecialProtocolCredentials = any;\nexport type SpecialProtocolCredentialsProvider =\n  MaybeOptionalCredentialsProvider<SpecialProtocolCredentials>;\n\nfunction getMiddleAuthCredentialsProvider(\n  credentialsManager: CredentialsManager,\n  url: string,\n): SpecialProtocolCredentialsProvider {\n  return credentialsManager.getCredentialsProvider(\n    \"middleauthapp\",\n    new URL(url).origin,\n  );\n}\n\nfunction getNgauthCredentialsProvider(\n  credentialsManager: CredentialsManager,\n  serverUrl: string,\n  path: string,\n): SpecialProtocolCredentialsProvider {\n  const bucketPattern = /^\\/([^/]+)/;\n  const m = path.match(bucketPattern);\n  if (m === null) return undefined;\n  return pythonIntegration\n    ? credentialsManager.getCredentialsProvider(\"gcs\", { bucket: m[1] })\n    : credentialsManager.getCredentialsProvider(\"ngauth_gcs\", {\n        authServer: serverUrl,\n        bucket: m[1],\n      });\n}\n\nexport function parseSpecialUrl(\n  url: string,\n  credentialsManager: CredentialsManager,\n): { url: string; credentialsProvider: SpecialProtocolCredentialsProvider } {\n  const u = parseUrl(url);\n  switch (u.protocol) {\n    case \"gs\":\n    case \"gs+xml\":\n      return {\n        credentialsProvider: pythonIntegration\n          ? credentialsManager.getCredentialsProvider(\"gcs\", {\n              bucket: u.host,\n            })\n          : undefined,\n        url,\n      };\n    case \"gs+ngauth+http\":\n      return {\n        credentialsProvider: getNgauthCredentialsProvider(\n          credentialsManager,\n          `http://${u.host}`,\n          u.path,\n        ),\n        url: \"gs:/\" + u.path,\n      };\n    case \"gs+ngauth+https\":\n      return {\n        credentialsProvider: getNgauthCredentialsProvider(\n          credentialsManager,\n          `https://${u.host}`,\n          u.path,\n        ),\n        url: \"gs:/\" + u.path,\n      };\n    case \"gs+xml+ngauth+http\":\n      return {\n        credentialsProvider: getNgauthCredentialsProvider(\n          credentialsManager,\n          `http://${u.host}`,\n          u.path,\n        ),\n        url: \"gs+xml:/\" + u.path,\n      };\n    case \"gs+xml+ngauth+https\":\n      return {\n        credentialsProvider: getNgauthCredentialsProvider(\n          credentialsManager,\n          `https://${u.host}`,\n          u.path,\n        ),\n        url: \"gs+xml:/\" + u.path,\n      };\n    case \"middleauth+https\":\n      url = url.substr(\"middleauth+\".length);\n      return {\n        credentialsProvider: getMiddleAuthCredentialsProvider(\n          credentialsManager,\n          url,\n        ),\n        url: url,\n      };\n    case \"s3\":\n      return {\n        credentialsProvider: undefined,\n        url,\n      };\n    default:\n      return {\n        credentialsProvider: undefined,\n        url,\n      };\n  }\n}\n\nexport async function fetchSpecialOk(\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  url: string,\n  init: RequestInit,\n): Promise<Response> {\n  const u = parseUrl(url);\n  switch (u.protocol) {\n    case \"gs\":\n      // Include random query string parameter (ignored by GCS) to bypass GCS cache and ensure a\n      // cached response is never used.\n      //\n      // This addresses two issues related to GCS:\n      //\n      // 1. GCS fails to send an updated `Access-Control-Allow-Origin` header in 304 responses to\n      //    cache revalidation requests.\n      //\n      //    https://bugs.chromium.org/p/chromium/issues/detail?id=1214563#c2\n      //\n      //    The random query string parameter ensures cached responses are never used.\n      //\n      //    Note: This issue does not apply to gs+xml because with the XML API, the\n      //    Access-Control-Allow-Origin response header does not vary with the Origin.\n      //\n      // 2. If the object does not prohibit caching (e.g. public bucket and default `cache-control`\n      //    metadata value), GCS may return stale responses.\n      //\n      return fetchWithOAuth2Credentials(\n        credentialsProvider,\n        `https://www.googleapis.com/storage/v1/b/${u.host}/o/` +\n          `${encodeURIComponent(u.path.substring(1))}?alt=media` +\n          `&neuroglancer=${getRandomHexString()}`,\n        init,\n      );\n    case \"gs+xml\":\n      return fetchWithOAuth2Credentials(\n        credentialsProvider,\n        `https://storage.googleapis.com/${u.host}${u.path}` +\n          `?neuroglancer=${getRandomHexString()}`,\n        init,\n      );\n    case \"s3\":\n      return fetchS3Ok(u.host, u.path, init);\n    default:\n      return fetchWithOAuth2Credentials(credentialsProvider, url, init);\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fetchOk } from \"#src/util/http_request.js\";\nimport { getS3CompatiblePathCompletions } from \"#src/util/s3_bucket_listing.js\";\n\n// Support for s3:// special protocol.\n\nexport function fetchS3Ok(\n  bucket: string,\n  path: string,\n  requestInit: RequestInit,\n) {\n  return fetchOk(`https://${bucket}.s3.amazonaws.com${path}`, requestInit);\n}\n\nexport async function getS3PathCompletions(\n  bucket: string,\n  path: string,\n  abortSignal: AbortSignal,\n) {\n  return await getS3CompatiblePathCompletions(\n    undefined,\n    `s3://${bucket}`,\n    `https://${bucket}.s3.amazonaws.com`,\n    path,\n    abortSignal,\n  );\n}\n","/**\n * @license\n * Copyright 2016 Google Inc., 2023 Gergely Csucs\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeJpeg } from \"#src/async_computation/decode_jpeg_request.js\";\nimport { decodePng } from \"#src/async_computation/decode_png_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport {\n  ImageTileEncoding,\n  ImageTileSourceParameters,\n} from \"#src/datasource/deepzoom/base.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { transposeArray2d } from \"#src/util/array.js\";\nimport { isNotFoundError } from \"#src/util/http_request.js\";\nimport type { SpecialProtocolCredentials } from \"#src/util/special_protocol_request.js\";\nimport { fetchSpecialOk } from \"#src/util/special_protocol_request.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\n/* This is enough if support for these aren't needed:\n * - Firefox before 105 (OffscreenCanvas, 2022-09-20)\n * - Safari before 16.4 (OffscreenCanvas, 2023-03-27)\n */\n// declare var OffscreenCanvas: any; // shutting up some outdated compiler(?)\n\n@registerSharedObject()\nexport class DeepzoomImageTileSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    VolumeChunkSource,\n  ),\n  ImageTileSourceParameters,\n) {\n  gridShape = (() => {\n    const gridShape = new Uint32Array(2);\n    const { upperVoxelBound, chunkDataSize } = this.spec;\n    for (let i = 0; i < 2; ++i) {\n      gridShape[i] = Math.ceil(upperVoxelBound[i] / chunkDataSize[i]);\n    }\n    return gridShape;\n  })();\n\n  async download(chunk: VolumeChunk, abortSignal: AbortSignal): Promise<void> {\n    const { parameters } = this;\n\n    // /* This block is enough if support for these aren't needed:\n    //  * - Firefox before 105 (OffscreenCanvas, 2022-09-20)\n    //  * - Safari before 16.4 (OffscreenCanvas, 2023-03-27)\n    //  */\n    // const {tilesize, overlap} = parameters;\n    // const [x, y] = chunk.chunkGridPosition;\n    // const url = `${parameters.url}/${x}_${y}.${ImageTileEncoding[parameters.encoding].toLowerCase()}`;\n    // const response: Blob = await (await fetchSpecialOk(this.credentialsProvider, url, {signal: abortSignal})).blob();\n    // const tile = await createImageBitmap(response);\n    // const canvas = new OffscreenCanvas(tilesize, tilesize);\n    // const ctx = canvas.getContext(\"2d\")!;\n    // ctx.drawImage(tile, x === 0 ? 0 : -overlap, y === 0 ? 0 : -overlap);\n    // const id = ctx.getImageData(0, 0, tilesize, tilesize).data;\n    // const t2 = tilesize * tilesize;\n    // const d = chunk.data = new Uint8Array(t2 * 3);\n    // for (let i = 0; i < t2; i++) {\n    //   d[i] = id[i * 4];\n    //   d[i + t2] = id[i * 4 + 1];\n    //   d[i + 2 * t2] = id[i * 4 + 2];\n    // }\n    // Todo: ^ \"transposeArray2d\" likely does the same\n\n    const { tilesize, overlap, encoding } = parameters;\n    const [x, y] = chunk.chunkGridPosition;\n    const ox = x === 0 ? 0 : overlap;\n    const oy = y === 0 ? 0 : overlap;\n    const url = `${parameters.url}/${x}_${y}.${parameters.format}`;\n    try {\n      const responseBuffer = await (\n        await fetchSpecialOk(this.credentialsProvider, url, {\n          signal: abortSignal,\n        })\n      ).arrayBuffer();\n\n      let tilewidth = 0;\n      let tileheight = 0;\n      let tiledata: Uint8Array | undefined;\n      switch (encoding) {\n        case ImageTileEncoding.PNG: {\n          const pngbitmap = await requestAsyncComputation(\n            decodePng,\n            abortSignal,\n            [responseBuffer],\n            new Uint8Array(responseBuffer),\n            undefined,\n            undefined,\n            undefined,\n            3,\n            1,\n            false,\n          );\n          ({ width: tilewidth, height: tileheight } = pngbitmap);\n          tiledata = transposeArray2d(\n            pngbitmap.uint8Array,\n            tilewidth * tileheight,\n            3,\n          );\n          break;\n        }\n\n        case ImageTileEncoding.JPG:\n        case ImageTileEncoding.JPEG: {\n          const jpegbitmap = await requestAsyncComputation(\n            decodeJpeg,\n            abortSignal,\n            [responseBuffer],\n            new Uint8Array(responseBuffer),\n            undefined,\n            undefined,\n            undefined,\n            3,\n            false,\n          );\n          ({\n            uint8Array: tiledata,\n            width: tilewidth,\n            height: tileheight,\n          } = jpegbitmap);\n          break;\n        }\n      }\n      if (tiledata !== undefined) {\n        const t2 = tilesize * tilesize;\n        const twh = tilewidth * tileheight;\n        const d = (chunk.data = new Uint8Array(t2 * 3));\n        for (let k = 0; k < 3; k++)\n          for (let j = 0; j < tileheight; j++)\n            for (let i = 0; i < tilewidth; i++)\n              d[i + j * tilesize + k * t2] =\n                tiledata[i + ox + (j + oy) * tilewidth + k * twh];\n      }\n    } catch (e) {\n      if (!isNotFoundError(e)) throw e;\n    }\n  }\n}\n","/**\n * @license\n * This work is a derivative of the Google Neuroglancer project,\n * Copyright 2016 Google Inc.\n * The Derivative Work is covered by\n * Copyright 2019 Howard Hughes Medical Institute\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fetchWithCredentials } from \"#src/credentials_provider/http_request.js\";\nimport type { CredentialsProvider } from \"#src/credentials_provider/index.js\";\n\nexport interface DVIDToken {\n  // If token is undefined, it indicates anonymous credentials that may be retried.\n  token?: string;\n}\n\nexport const credentialsKey = \"DVID\";\n\nexport class DVIDInstance {\n  constructor(\n    public baseUrl: string,\n    public nodeKey: string,\n  ) {}\n\n  getNodeApiUrl(path = \"\"): string {\n    return `${this.baseUrl}/api/node/${this.nodeKey}${path}`;\n  }\n\n  getRepoInfoUrl(): string {\n    return `${this.baseUrl}/api/repos/info`;\n  }\n\n  getKeyValueUrl(dataName: string, key: string) {\n    return `${this.getNodeApiUrl()}/${dataName}/key/${key}`;\n  }\n\n  getKeyValueRangeUrl(dataName: string, startKey: string, endKey: string) {\n    return `${this.getNodeApiUrl()}/${dataName}/keyrange/${startKey}/${endKey}`;\n  }\n\n  getKeyValuesUrl(dataName: string) {\n    return `${this.getNodeApiUrl()}/${dataName}/keyvalues?jsontar=false`;\n  }\n}\n\nexport function appendQueryStringForDvid(\n  url: string,\n  user: string | null | undefined,\n) {\n  if (url.includes(\"?\")) {\n    url += \"&\";\n  } else {\n    url += \"?\";\n  }\n  url += \"app=Neuroglancer\";\n  if (user) {\n    url += `&u=${user}`;\n  }\n  return url;\n}\n\nexport function fetchWithDVIDCredentials(\n  credentialsProvider: CredentialsProvider<DVIDToken>,\n  input: string,\n  init: RequestInit,\n): Promise<Response> {\n  return fetchWithCredentials(\n    credentialsProvider,\n    input,\n    init,\n    (credentials: DVIDToken, init: RequestInit) => {\n      const newInit: RequestInit = { ...init };\n      if (credentials.token) {\n        newInit.headers = {\n          ...newInit.headers,\n          Authorization: `Bearer ${credentials}`,\n        };\n      }\n      return newInit;\n    },\n    (error) => {\n      const { status } = error;\n      if (status === 403 || status === 401) {\n        // Authorization needed.  Retry with refreshed token.\n        return \"refresh\";\n      }\n      throw error;\n    },\n  );\n}\n","/**\n * @license\n * This work is a derivative of the Google Neuroglancer project,\n * Copyright 2016 Google Inc.\n * The Derivative Work is covered by\n * Copyright 2020 Howard Hughes Medical Institute\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SkeletonChunk } from \"#src/skeleton/backend.js\";\n\nexport function decodeSwcSkeletonChunk(chunk: SkeletonChunk, swcStr: string) {\n  const swcObjects: Array<PointObj> = parseSwc(swcStr);\n\n  if (swcObjects.length < 1) {\n    throw new Error(\"ERROR parsing swc data\");\n  }\n\n  const indexMap = new Uint32Array(swcObjects.length);\n\n  let nodeCount = 0;\n  let edgeCount = 0;\n  swcObjects.forEach((swcObj, i) => {\n    if (swcObj) {\n      indexMap[i] = nodeCount++;\n      if (swcObj.parent >= 0) {\n        ++edgeCount;\n      }\n    }\n  });\n\n  const glVertices = new Float32Array(3 * nodeCount);\n  const glIndices = new Uint32Array(2 * edgeCount);\n\n  let nodeIndex = 0;\n  let edgetIndex = 0;\n  swcObjects.forEach((swcObj) => {\n    if (swcObj) {\n      glVertices[3 * nodeIndex] = swcObj.x;\n      glVertices[3 * nodeIndex + 1] = swcObj.y;\n      glVertices[3 * nodeIndex + 2] = swcObj.z;\n\n      if (swcObj.parent >= 0) {\n        glIndices[2 * edgetIndex] = nodeIndex;\n        glIndices[2 * edgetIndex + 1] = indexMap[swcObj.parent];\n        ++edgetIndex;\n      }\n      ++nodeIndex;\n    }\n  });\n\n  chunk.indices = glIndices;\n  chunk.vertexPositions = glVertices;\n}\n\n/*\n * Parses a standard SWC file into an array of point objects\n * modified from\n * https://github.com/JaneliaSciComp/SharkViewer/blob/d9969a7c513beee32ff9650b00bf79cda8f3c76a/html/js/sharkviewer_loader.js\n */\nfunction parseSwc(swcStr: string) {\n  const swcInputAr = swcStr.split(\"\\n\");\n  const swcObjectsAr: Array<PointObj> = [];\n  const float = \"-?\\\\d*(?:\\\\.\\\\d+)?\";\n  const pattern = new RegExp(\n    \"^[ \\\\t]*(\" +\n      [\n        \"\\\\d+\", // index\n        \"\\\\d+\", // type\n        float, // x\n        float, // y\n        float, // z\n        float, // radius\n        \"-1|\\\\d+\", // parent\n      ].join(\")[ \\\\t]+(\") +\n      \")[ \\\\t]*$\",\n  );\n\n  swcInputAr.forEach((e) => {\n    // if line meets swc point criteria, add it to the array\n    const match = e.match(pattern);\n    if (match) {\n      const point = (swcObjectsAr[parseInt(match[1], 10)] = new PointObj());\n      point.type = parseInt(match[2], 10);\n      point.x = parseFloat(match[3]);\n      point.y = parseFloat(match[4]);\n      point.z = parseFloat(match[5]);\n      point.radius = parseFloat(match[6]);\n      point.parent = parseInt(match[7], 10);\n    }\n  });\n  return swcObjectsAr;\n}\n\nclass PointObj {\n  type: number;\n  x: number;\n  y: number;\n  z: number;\n  radius: number;\n  parent: number;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport type { ChunkSourceParametersConstructor } from \"#src/chunk_manager/base.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport type { DVIDToken } from \"#src/datasource/dvid/api.js\";\nimport {\n  DVIDInstance,\n  fetchWithDVIDCredentials,\n  appendQueryStringForDvid,\n} from \"#src/datasource/dvid/api.js\";\nimport {\n  MeshSourceParameters,\n  SkeletonSourceParameters,\n  VolumeChunkEncoding,\n  VolumeChunkSourceParameters,\n} from \"#src/datasource/dvid/base.js\";\nimport type { FragmentChunk, ManifestChunk } from \"#src/mesh/backend.js\";\nimport {\n  assignMeshFragmentData,\n  decodeTriangleVertexPositionsAndIndices,\n  MeshSource,\n} from \"#src/mesh/backend.js\";\nimport type { SkeletonChunk } from \"#src/skeleton/backend.js\";\nimport { SkeletonSource } from \"#src/skeleton/backend.js\";\nimport { decodeSwcSkeletonChunk } from \"#src/skeleton/decode_swc_skeleton.js\";\nimport { decodeCompressedSegmentationChunk } from \"#src/sliceview/backend_chunk_decoders/compressed_segmentation.js\";\nimport { decodeJpegChunk } from \"#src/sliceview/backend_chunk_decoders/jpeg.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport type { SharedObject } from \"#src/worker_rpc.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nfunction DVIDSource<\n  Parameters,\n  TBase extends { new (...args: any[]): SharedObject },\n>(\n  Base: TBase,\n  parametersConstructor: ChunkSourceParametersConstructor<Parameters>,\n) {\n  return WithParameters(\n    WithSharedCredentialsProviderCounterpart<DVIDToken>()(Base),\n    parametersConstructor,\n  );\n}\n\n@registerSharedObject()\nexport class DVIDSkeletonSource extends DVIDSource(\n  SkeletonSource,\n  SkeletonSourceParameters,\n) {\n  download(chunk: SkeletonChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const bodyid = `${chunk.objectId}`;\n    const url =\n      `${parameters.baseUrl}/api/node/${parameters.nodeKey}` +\n      `/${parameters.dataInstanceKey}/key/` +\n      bodyid +\n      \"_swc\";\n    return fetchWithDVIDCredentials(\n      this.credentialsProvider,\n      appendQueryStringForDvid(url, parameters.user),\n      {\n        signal: abortSignal,\n      },\n    )\n      .then((response) => response.arrayBuffer())\n      .then((response) => {\n        const enc = new TextDecoder(\"utf-8\");\n        decodeSwcSkeletonChunk(chunk, enc.decode(response));\n      });\n  }\n}\n\nexport function decodeFragmentChunk(\n  chunk: FragmentChunk,\n  response: ArrayBuffer,\n) {\n  const dv = new DataView(response);\n  const numVertices = dv.getUint32(0, true);\n  assignMeshFragmentData(\n    chunk,\n    decodeTriangleVertexPositionsAndIndices(\n      response,\n      Endianness.LITTLE,\n      /*vertexByteOffset=*/ 4,\n      numVertices,\n    ),\n  );\n}\n\n@registerSharedObject()\nexport class DVIDMeshSource extends DVIDSource(\n  MeshSource,\n  MeshSourceParameters,\n) {\n  download(chunk: ManifestChunk) {\n    // DVID does not currently store meshes chunked, the main\n    // use-case is for low-resolution 3D views.\n    // for now, fragmentId is the body id\n    chunk.fragmentIds = [`${chunk.objectId}`];\n    return Promise.resolve(undefined);\n  }\n\n  downloadFragment(chunk: FragmentChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const dvidInstance = new DVIDInstance(\n      parameters.baseUrl,\n      parameters.nodeKey,\n    );\n    const meshUrl = dvidInstance.getKeyValueUrl(\n      parameters.dataInstanceKey,\n      `${chunk.fragmentId}.ngmesh`,\n    );\n\n    return fetchWithDVIDCredentials(\n      this.credentialsProvider,\n      appendQueryStringForDvid(meshUrl, parameters.user),\n      {\n        signal: abortSignal,\n      },\n    )\n      .then((response) => response.arrayBuffer())\n      .then((response) => decodeFragmentChunk(chunk, response));\n  }\n}\n\n@registerSharedObject()\nexport class DVIDVolumeChunkSource extends DVIDSource(\n  VolumeChunkSource,\n  VolumeChunkSourceParameters,\n) {\n  async download(chunk: VolumeChunk, abortSignal: AbortSignal) {\n    const params = this.parameters;\n    let path: string;\n    {\n      // chunkPosition must not be captured, since it will be invalidated by the next call to\n      // computeChunkBounds.\n      const chunkPosition = this.computeChunkBounds(chunk);\n      const chunkDataSize = chunk.chunkDataSize!;\n\n      // if the volume is an image, get a jpeg\n      path = this.getPath(chunkPosition, chunkDataSize);\n    }\n    const decoder = this.getDecoder(params);\n    const response = await fetchWithDVIDCredentials(\n      this.credentialsProvider,\n      appendQueryStringForDvid(`${params.baseUrl}${path}`, params.user),\n      { signal: abortSignal },\n    ).then((response) => response.arrayBuffer());\n    await decoder(\n      chunk,\n      abortSignal,\n      params.encoding === VolumeChunkEncoding.JPEG\n        ? response.slice(16)\n        : response,\n    );\n  }\n  getPath(chunkPosition: Float32Array, chunkDataSize: Uint32Array) {\n    const params = this.parameters;\n    if (params.encoding === VolumeChunkEncoding.JPEG) {\n      return (\n        `/api/node/${params.nodeKey}/${params.dataInstanceKey}/subvolblocks/` +\n        `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` +\n        `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}`\n      );\n    }\n    if (params.encoding === VolumeChunkEncoding.RAW) {\n      return (\n        `/api/node/${params.nodeKey}/${params.dataInstanceKey}/raw/0_1_2/` +\n        `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` +\n        `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}/jpeg`\n      );\n    }\n    if (params.encoding === VolumeChunkEncoding.COMPRESSED_SEGMENTATIONARRAY) {\n      return (\n        `/api/node/${params.nodeKey}/${params.dataInstanceKey}/raw/0_1_2/` +\n        `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` +\n        `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}?compression=googlegzip&scale=${params.dataScale}`\n      );\n    }\n    // encoding is COMPRESSED_SEGMENTATION\n    return (\n      `/api/node/${params.nodeKey}/${params.dataInstanceKey}/raw/0_1_2/` +\n      `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` +\n      `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}?compression=googlegzip`\n    );\n  }\n  getDecoder(params: any) {\n    if (\n      params.encoding === VolumeChunkEncoding.JPEG ||\n      params.encoding === VolumeChunkEncoding.RAW\n    ) {\n      return decodeJpegChunk;\n    }\n    // encoding is COMPRESSED_SEGMENTATION\n    return decodeCompressedSegmentationChunk;\n  }\n}\n","/**\n * @license\n * Copyright 2019 The Neuroglancer Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ShardingParameters } from \"#src/datasource/precomputed/base.js\";\nimport type {\n  ChunkLayoutOptions,\n  SliceViewChunkSource,\n  SliceViewChunkSpecification,\n  SliceViewChunkSpecificationBaseOptions,\n  SliceViewChunkSpecificationOptions,\n  DataType,\n} from \"#src/sliceview/base.js\";\nimport { makeSliceViewChunkSpecification } from \"#src/sliceview/base.js\";\nimport type { mat4 } from \"#src/util/geom.js\";\n\nimport { Uint64 } from \"#src/util/uint64.js\";\n\nexport const PYCG_APP_VERSION = 1;\nexport const GRAPHENE_MESH_NEW_SEGMENT_RPC_ID = \"GrapheneMeshSource:NewSegment\";\n\nexport enum VolumeChunkEncoding {\n  RAW = 0,\n  JPEG = 1,\n  COMPRESSED_SEGMENTATION = 2,\n}\n\nexport class VolumeChunkSourceParameters {\n  url: string;\n  encoding: VolumeChunkEncoding;\n  sharding: ShardingParameters | undefined;\n\n  static RPC_ID = \"graphene/VolumeChunkSource\";\n}\n\nexport class ChunkedGraphSourceParameters {\n  url: string;\n\n  static RPC_ID = \"graphene/ChunkedGraphSource\";\n}\n\nexport class MeshSourceParameters {\n  manifestUrl: string;\n  fragmentUrl: string;\n  lod: number;\n  sharding: Array<ShardingParameters> | undefined;\n  nBitsForLayerId: number;\n\n  static RPC_ID = \"graphene/MeshSource\";\n}\n\nexport class MultiscaleMeshMetadata {\n  transform: mat4;\n  lodScaleMultiplier: number;\n  vertexQuantizationBits: number;\n  sharding: Array<ShardingParameters> | undefined;\n}\n\nexport function isBaseSegmentId(segmentId: Uint64, nBitsForLayerId: number) {\n  const layerId = Uint64.rshift(new Uint64(), segmentId, 64 - nBitsForLayerId);\n  return Uint64.equal(layerId, Uint64.ONE);\n}\n\nexport function getGrapheneFragmentKey(fragmentId: string) {\n  const sharded = fragmentId.charAt(0) === \"~\";\n\n  if (sharded) {\n    const parts = fragmentId.substring(1).split(/:(.+)/);\n    return { key: parts[0], fragmentId: parts[1] };\n  }\n  return { key: fragmentId, fragmentId: fragmentId };\n}\n\nexport const CHUNKED_GRAPH_LAYER_RPC_ID = \"ChunkedGraphLayer\";\nexport const CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID =\n  \"ChunkedGraphLayer:updateSources\";\nexport const RENDER_RATIO_LIMIT = 5.0;\n\nexport interface ChunkedGraphChunkSpecificationBaseOptions\n  extends SliceViewChunkSpecificationBaseOptions {\n  /**\n   * Specifies offset for use by backend.ts:GenericVolumeChunkSource.computeChunkBounds in\n   * calculating chunk voxel coordinates.  The calculated chunk coordinates will be equal to the\n   * voxel position (in chunkLayout coordinates) plus this value.\n   *\n   * Defaults to kZeroVec if not specified.\n   */\n  baseVoxelOffset?: Float32Array;\n  dataType: DataType;\n}\n\nexport interface ChunkedGraphChunkSpecificationOptions\n  extends ChunkedGraphChunkSpecificationBaseOptions,\n    SliceViewChunkSpecificationOptions<Uint32Array> {}\n\n/**\n * Specifies parameters for ChunkedGraphChunkSpecification.getDefaults.\n */\nexport interface ChunkedGraphChunkSpecificationGetDefaultsOptions\n  extends ChunkedGraphChunkSpecificationBaseOptions,\n    ChunkLayoutOptions {}\n\n/**\n * Specifies a chunk layout and voxel size.\n */\nexport interface ChunkedGraphChunkSpecification\n  extends SliceViewChunkSpecification<Uint32Array> {\n  baseVoxelOffset: Float32Array;\n  dataType: DataType;\n}\n\nexport function makeChunkedGraphChunkSpecification(\n  options: ChunkedGraphChunkSpecificationOptions,\n): ChunkedGraphChunkSpecification {\n  const { rank, dataType } = options;\n  const { baseVoxelOffset = new Float32Array(rank) } = options;\n\n  return {\n    ...makeSliceViewChunkSpecification(options),\n    baseVoxelOffset,\n    dataType,\n  };\n}\n\nexport interface ChunkedGraphChunkSource extends SliceViewChunkSource {\n  spec: ChunkedGraphChunkSpecification;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file\n * Provides a simple way to request a file on the backend with priority integration.\n */\n\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport { Chunk, ChunkSourceBase } from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier, ChunkState } from \"#src/chunk_manager/base.js\";\nimport { raceWithAbort, SharedAbortController } from \"#src/util/abort.js\";\nimport type { Borrowed, Owned } from \"#src/util/disposable.js\";\nimport { stableStringify } from \"#src/util/json.js\";\nimport { getObjectId } from \"#src/util/object_id.js\";\nimport type { SpecialProtocolCredentialsProvider } from \"#src/util/special_protocol_request.js\";\nimport { fetchSpecialOk } from \"#src/util/special_protocol_request.js\";\n\nexport type PriorityGetter = () => {\n  priorityTier: ChunkPriorityTier;\n  priority: number;\n};\n\ninterface FileDataRequester<Data> {\n  resolve: (data: Data) => void;\n  reject: (error: any) => void;\n  getPriority: PriorityGetter;\n  cleanup: () => void;\n}\n\nclass GenericSharedDataChunk<Key, Data> extends Chunk {\n  decodedKey?: Key;\n  data?: Data;\n  requesters?: Set<FileDataRequester<Data>>;\n\n  initialize(key: string) {\n    super.initialize(key);\n    this.requesters = new Set<FileDataRequester<Data>>();\n  }\n\n  downloadSucceeded() {\n    super.downloadSucceeded();\n    const { requesters, data } = this;\n    this.requesters = undefined;\n    for (const requester of requesters!) {\n      requester.resolve(data!);\n    }\n  }\n\n  downloadFailed(error: any) {\n    super.downloadFailed(error);\n    const { requesters } = this;\n    this.requesters = undefined;\n    for (const requester of requesters!) {\n      requester.reject(error);\n    }\n  }\n\n  freeSystemMemory() {\n    this.data = undefined;\n  }\n}\n\nexport interface GenericSharedDataSourceOptions<Key, Data> {\n  encodeKey?: (key: Key) => string;\n  download: (\n    key: Key,\n    abortSignal: AbortSignal,\n  ) => Promise<{ size: number; data: Data }>;\n  sourceQueueLevel?: number;\n}\n\nexport class GenericSharedDataSource<Key, Data> extends ChunkSourceBase {\n  declare chunks: Map<string, GenericSharedDataChunk<Key, Data>>;\n\n  private encodeKeyFunction: (key: Key) => string;\n\n  private downloadFunction: (\n    key: Key,\n    abortSignal: AbortSignal,\n  ) => Promise<{ size: number; data: Data }>;\n\n  constructor(\n    chunkManager: Owned<ChunkManager>,\n    options: GenericSharedDataSourceOptions<Key, Data>,\n  ) {\n    super(chunkManager);\n    this.registerDisposer(chunkManager);\n    const { encodeKey = stableStringify } = options;\n    this.downloadFunction = options.download;\n    this.encodeKeyFunction = encodeKey;\n    const { sourceQueueLevel = 0 } = options;\n    this.sourceQueueLevel = sourceQueueLevel;\n\n    // This source is unusual in that it updates its own chunk priorities.\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPrioritiesLate.add(() => {\n        this.updateChunkPriorities();\n      }),\n    );\n  }\n\n  updateChunkPriorities() {\n    const { chunkManager } = this;\n    for (const chunk of this.chunks.values()) {\n      const { requesters } = chunk;\n      if (requesters !== undefined) {\n        for (const requester of requesters) {\n          const { priorityTier, priority } = requester.getPriority();\n          if (priorityTier === ChunkPriorityTier.RECENT) continue;\n          chunkManager.requestChunk(\n            chunk,\n            priorityTier,\n            priority,\n            ChunkState.SYSTEM_MEMORY_WORKER,\n          );\n        }\n      }\n    }\n  }\n\n  async download(\n    chunk: GenericSharedDataChunk<Key, Data>,\n    abortSignal: AbortSignal,\n  ) {\n    const { size, data } = await this.downloadFunction(\n      chunk.decodedKey!,\n      abortSignal,\n    );\n    chunk.systemMemoryBytes = size;\n    chunk.data = data;\n  }\n\n  /**\n   * Precondition: priorityTier <= ChunkPriorityTier.LAST_ORDERED_TIER\n   */\n  getData(key: Key, getPriority: PriorityGetter, abortSignal: AbortSignal) {\n    const encodedKey = this.encodeKeyFunction(key);\n    let chunk = this.chunks.get(encodedKey);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_<GenericSharedDataChunk<Key, Data>>(\n        GenericSharedDataChunk,\n      );\n      chunk.decodedKey = key;\n      chunk.initialize(encodedKey);\n      this.addChunk(chunk);\n    }\n    return new Promise<Data>((resolve, reject) => {\n      // If the data is already available or the request has already failed, resolve/reject the\n      // promise immediately.\n      switch (chunk!.state) {\n        case ChunkState.FAILED:\n          reject(chunk!.error);\n          return;\n\n        case ChunkState.SYSTEM_MEMORY_WORKER:\n          resolve(chunk!.data!);\n          return;\n      }\n      function handleAbort() {\n        const { requesters } = chunk!;\n        if (requesters !== undefined) {\n          requesters.delete(requester);\n          chunk!.chunkManager!.scheduleUpdateChunkPriorities();\n        }\n        reject(abortSignal.reason);\n      }\n\n      const requester: FileDataRequester<Data> = {\n        resolve,\n        reject,\n        getPriority,\n        cleanup: () => abortSignal.removeEventListener(\"abort\", handleAbort),\n      };\n      chunk!.requesters!.add(requester);\n      abortSignal.addEventListener(\"abort\", handleAbort, { once: true });\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    });\n  }\n\n  static get<Key, Data>(\n    chunkManager: Borrowed<ChunkManager>,\n    memoizeKey: string,\n    options: GenericSharedDataSourceOptions<Key, Data>,\n  ) {\n    return chunkManager.memoize.get(\n      `getFileSource:${memoizeKey}`,\n      () => new GenericSharedDataSource(chunkManager.addRef(), options),\n    );\n  }\n\n  static getData<Key, Data>(\n    chunkManager: Borrowed<ChunkManager>,\n    memoizeKey: string,\n    options: GenericSharedDataSourceOptions<Key, Data>,\n    key: Key,\n    getPriority: PriorityGetter,\n    abortSignal: AbortSignal,\n  ) {\n    const source = GenericSharedDataSource.get(\n      chunkManager,\n      memoizeKey,\n      options,\n    );\n    const result = source.getData(key, getPriority, abortSignal);\n    source.dispose();\n    return result;\n  }\n\n  static getUrl<Data>(\n    chunkManager: Borrowed<ChunkManager>,\n    credentialsProvider: SpecialProtocolCredentialsProvider,\n    decodeFunction: (\n      buffer: ArrayBuffer,\n      abortSignal: AbortSignal,\n    ) => Promise<{ size: number; data: Data }>,\n    url: string,\n    getPriority: PriorityGetter,\n    abortSignal: AbortSignal,\n  ) {\n    return GenericSharedDataSource.getData<string, Data>(\n      chunkManager,\n      `${getObjectId(decodeFunction)}`,\n      {\n        download: (url: string, abortSignal: AbortSignal) =>\n          fetchSpecialOk(credentialsProvider, url, { signal: abortSignal })\n            .then((response) => response.arrayBuffer())\n            .then((response) => decodeFunction(response, abortSignal)),\n      },\n      url,\n      getPriority,\n      abortSignal,\n    );\n  }\n}\n\nclass AsyncCacheChunk<Data> extends Chunk {\n  promise: Promise<Data> | undefined;\n  outstandingRequests: number = 0;\n  sharedAbortController: SharedAbortController | undefined;\n\n  initialize(key: string) {\n    super.initialize(key);\n  }\n\n  freeSystemMemory() {\n    this.promise = undefined;\n  }\n}\n\nexport interface SimpleAsyncCacheOptions<Key, Value> {\n  encodeKey?: (key: Key) => string;\n  get: (\n    key: Key,\n    abortSignal: AbortSignal,\n  ) => Promise<{ size: number; data: Value }>;\n}\n\nexport class SimpleAsyncCache<Key, Value> extends ChunkSourceBase {\n  declare chunks: Map<string, AsyncCacheChunk<Value>>;\n\n  constructor(\n    chunkManager: Owned<ChunkManager>,\n    options: SimpleAsyncCacheOptions<Key, Value>,\n  ) {\n    super(chunkManager);\n    this.registerDisposer(chunkManager);\n    this.downloadFunction = options.get;\n    this.encodeKeyFunction = options.encodeKey ?? stableStringify;\n  }\n  encodeKeyFunction: (key: Key) => string;\n  downloadFunction: (\n    key: Key,\n    abortSignal: AbortSignal,\n  ) => Promise<{ size: number; data: Value }>;\n\n  get(key: Key, abortSignal?: AbortSignal): Promise<Value> {\n    const encodedKey = this.encodeKeyFunction(key);\n    let chunk = this.chunks.get(encodedKey);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_<AsyncCacheChunk<Value>>(AsyncCacheChunk);\n      chunk.initialize(encodedKey);\n      this.addChunk(chunk);\n    }\n    if (\n      chunk.promise === undefined ||\n      chunk.sharedAbortController?.signal.aborted\n    ) {\n      let completed = false;\n      const sharedAbortController = (chunk!.sharedAbortController =\n        new SharedAbortController());\n      sharedAbortController.signal.addEventListener(\"abort\", () => {\n        if (!completed) {\n          chunk!.promise = undefined;\n        }\n      });\n      chunk.promise = (async () => {\n        try {\n          const { data, size } = await this.downloadFunction(\n            key,\n            sharedAbortController.signal,\n          );\n          chunk.systemMemoryBytes = size;\n          chunk!.queueManager.updateChunkState(\n            chunk!,\n            ChunkState.SYSTEM_MEMORY,\n          );\n          return data;\n        } catch (e) {\n          chunk!.queueManager.updateChunkState(chunk!, ChunkState.FAILED);\n          throw e;\n        } finally {\n          completed = true;\n          sharedAbortController[Symbol.dispose]();\n        }\n      })();\n    }\n    chunk!.sharedAbortController!.addConsumer(abortSignal);\n    chunk!.sharedAbortController!.start();\n    return raceWithAbort(chunk.promise, abortSignal);\n  }\n}\n\nexport function makeSimpleAsyncCache<Key, Data>(\n  chunkManager: ChunkManager,\n  memoizeKey: string,\n  options: SimpleAsyncCacheOptions<Key, Data>,\n) {\n  return chunkManager.memoize.get(\n    `simpleAsyncCache:${memoizeKey}`,\n    () => new SimpleAsyncCache(chunkManager.addRef(), options),\n  );\n}\n","/**\n * @license\n * Copyright 2021 William Silversmith\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const decodeCompresso =\n  asyncComputation<(data: Uint8Array<ArrayBuffer>) => Uint8Array<ArrayBuffer>>(\n    \"decodeCompresso\",\n  );\n","/**\n * @license\n * Copyright 2021 William Silvermsith.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeCompresso } from \"#src/async_computation/decode_compresso_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\n\nexport async function decodeCompressoChunk(\n  chunk: VolumeChunk,\n  abortSignal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  const image = await requestAsyncComputation(\n    decodeCompresso,\n    abortSignal,\n    [response],\n    new Uint8Array(response),\n  );\n\n  await decodeRawChunk(chunk, abortSignal, image.buffer);\n}\n","/**\n * @license\n * Copyright 2024 William Silversmith\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { DecodedImage } from \"#src/async_computation/decode_png_request.js\";\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const decodeJxl =\n  asyncComputation<\n    (\n      data: Uint8Array,\n      area: number | undefined,\n      numComponents: number | undefined,\n      bytesPerPixel: number,\n    ) => DecodedImage\n  >(\"decodeJxl\");\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeJxl } from \"#src/async_computation/decode_jxl_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\n\nexport async function decodeJxlChunk(\n  chunk: VolumeChunk,\n  abortSignal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  const chunkDataSize = chunk.chunkDataSize!;\n  const { uint8Array: decoded } = await requestAsyncComputation(\n    decodeJxl,\n    abortSignal,\n    [response],\n    new Uint8Array(response),\n    chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2],\n    chunkDataSize[3] || 1,\n    1, // bytesPerPixel\n  );\n  await postProcessRawData(chunk, abortSignal, decoded);\n}\n","/**\n * @license\n * Copyright 2022 William Silvermsith.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodePng } from \"#src/async_computation/decode_png_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { DATA_TYPE_BYTES } from \"#src/util/data_type.js\";\n\nexport async function decodePngChunk(\n  chunk: VolumeChunk,\n  abortSignal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  const chunkDataSize = chunk.chunkDataSize!;\n  const dataType = chunk.source!.spec.dataType;\n  const { uint8Array: image } = await requestAsyncComputation(\n    decodePng,\n    abortSignal,\n    [response],\n    /*buffer=*/ new Uint8Array(response),\n    /*width=*/ undefined,\n    /*height=*/ undefined,\n    /*area=*/ chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2],\n    /*numComponents=*/ chunkDataSize[3] || 1,\n    /*bytesPerPixel=*/ DATA_TYPE_BYTES[dataType],\n    /*convertToGrayscale=*/ false,\n  );\n\n  await decodeRawChunk(chunk, abortSignal, image.buffer);\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getByteRangeHeader } from \"#src/util/http_request.js\";\nimport type { SpecialProtocolCredentialsProvider } from \"#src/util/special_protocol_request.js\";\nimport { fetchSpecialOk } from \"#src/util/special_protocol_request.js\";\nimport type { Uint64 } from \"#src/util/uint64.js\";\n\n/**\n * On Chromium, multiple concurrent byte range requests to the same URL are serialized unless the\n * cache is disabled.  Disabling the cache works around the problem.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=969828\n */\nconst cacheMode =\n  navigator.userAgent.indexOf(\"Chrome\") !== -1 ? \"no-store\" : \"default\";\n\nexport function fetchSpecialHttpByteRange(\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  url: string,\n  startOffset: Uint64 | number,\n  endOffset: Uint64 | number,\n  abortSignal: AbortSignal,\n): Promise<ArrayBuffer> {\n  return fetchSpecialOk(credentialsProvider, url, {\n    headers: getByteRangeHeader(startOffset, endOffset),\n    cache: cacheMode,\n    signal: abortSignal,\n  }).then((response) => response.arrayBuffer());\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Uint64 } from \"#src/util/uint64.js\";\n\n/**\n * This is a very simple string hash function.  It isn't secure, but\n * is suitable for sharding of requests.\n */\nexport function simpleStringHash(s: string): number {\n  let h = 0;\n  const length = s.length;\n  for (let i = 0; i < length; ++i) {\n    h = (h * 31 + s.charCodeAt(i)) | 0;\n  }\n  return h;\n}\n\n/**\n * MurmurHash3_x86_32 mixing function\n */\nexport function murmurHash3_x86_32Mix(h: number, k: number): number {\n  k = Math.imul(k, 0xcc9e2d51) >>> 0;\n  k = ((k << 15) | (k >>> 17)) >>> 0;\n  k = Math.imul(k, 0x1b873593) >>> 0;\n  h ^= k;\n  h = ((h << 13) | (h >>> 19)) >>> 0;\n  h = (Math.imul(h, 5) + 0xe6546b64) >>> 0;\n  return h;\n}\n\n/**\n * MurmurHash3_x86_32 finalization function\n */\nexport function murmurHash3_x86_32Finalize(h: number, len: number) {\n  h ^= len;\n  h ^= h >>> 16;\n  h = Math.imul(h, 0x85ebca6b) >>> 0;\n  h ^= h >>> 13;\n  h *= 0xc2b2ae35;\n  h ^= h >>> 16;\n  return h >>> 0;\n}\n\n/**\n * MurmurHash3_x86_32, specialized for 8 bytes of input.\n */\nexport function murmurHash3_x86_32Hash64Bits(\n  seed: number,\n  low: number,\n  high: number,\n): number {\n  let h = seed;\n  h = murmurHash3_x86_32Mix(h, low);\n  h = murmurHash3_x86_32Mix(h, high);\n  return murmurHash3_x86_32Finalize(h, 8);\n}\n\nfunction murmurHash3_x86_128Mix(h: number) {\n  h ^= h >>> 16;\n  h = Math.imul(h, 0x85ebca6b);\n  h ^= h >>> 13;\n  h = Math.imul(h, 0xc2b2ae35);\n  h ^= h >>> 16;\n  return h;\n}\n\nfunction rotl32(x: number, r: number) {\n  return (x << r) | (x >>> (32 - r));\n}\n\n/**\n * MurmurHash3_x86_128, specialized for 8 bytes of input.\n *\n * Only the low 8 bytes of output are returned.\n */\nexport function murmurHash3_x86_128Hash64Bits(\n  out: Uint64,\n  seed: number,\n  low: number,\n  high: number,\n): Uint64 {\n  let h1 = seed;\n  let h2 = seed;\n  let h3 = seed;\n  let h4 = seed;\n  const c1 = 0x239b961b;\n  const c2 = 0xab0e9789;\n  const c3 = 0x38b34ae5;\n  // const c4 = 0xa1e38b93;\n\n  let k2 = Math.imul(high, c2);\n  k2 = rotl32(k2, 16);\n  k2 = Math.imul(k2, c3);\n  h2 ^= k2;\n\n  let k1 = Math.imul(low, c1);\n  k1 = rotl32(k1, 15);\n  k1 = Math.imul(k1, c2);\n  h1 ^= k1;\n\n  const len = 8;\n\n  h1 ^= len;\n  h2 ^= len;\n  h3 ^= len;\n  h4 ^= len;\n\n  h1 = (h1 + h2) >>> 0;\n  h1 = (h1 + h3) >>> 0;\n  h1 = (h1 + h4) >>> 0;\n  h2 = (h2 + h1) >>> 0;\n  h3 = (h3 + h1) >>> 0;\n  h4 = (h4 + h1) >>> 0;\n\n  h1 = murmurHash3_x86_128Mix(h1);\n  h2 = murmurHash3_x86_128Mix(h2);\n  h3 = murmurHash3_x86_128Mix(h3);\n  h4 = murmurHash3_x86_128Mix(h4);\n\n  h1 = (h1 + h2) >>> 0;\n  h1 = (h1 + h3) >>> 0;\n  h1 = (h1 + h4) >>> 0;\n  h2 = (h2 + h1) >>> 0;\n\n  // h3 = (h3 + h1) >>> 0;\n  // h4 = (h4 + h1) >>> 0;\n\n  out.low = h1;\n  out.high = h2;\n  return out;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AnnotationGeometryChunk,\n  AnnotationMetadataChunk,\n  AnnotationSubsetGeometryChunk,\n} from \"#src/annotation/backend.js\";\nimport {\n  AnnotationGeometryData,\n  AnnotationSource,\n  AnnotationGeometryChunkSourceBackend,\n} from \"#src/annotation/backend.js\";\nimport type { Annotation } from \"#src/annotation/index.js\";\nimport {\n  AnnotationPropertySerializer,\n  annotationTypeHandlers,\n  annotationTypes,\n} from \"#src/annotation/index.js\";\nimport type { Chunk, ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport { GenericSharedDataSource } from \"#src/chunk_manager/generic_file_source.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport type { ShardingParameters } from \"#src/datasource/precomputed/base.js\";\nimport {\n  AnnotationSourceParameters,\n  AnnotationSpatialIndexSourceParameters,\n  DataEncoding,\n  IndexedSegmentPropertySourceParameters,\n  MeshSourceParameters,\n  MultiscaleMeshSourceParameters,\n  ShardingHashFunction,\n  SkeletonSourceParameters,\n  VolumeChunkEncoding,\n  VolumeChunkSourceParameters,\n} from \"#src/datasource/precomputed/base.js\";\nimport type {\n  FragmentChunk,\n  ManifestChunk,\n  MultiscaleFragmentChunk,\n  MultiscaleManifestChunk,\n} from \"#src/mesh/backend.js\";\nimport {\n  assignMeshFragmentData,\n  assignMultiscaleMeshFragmentData,\n  computeOctreeChildOffsets,\n  decodeJsonManifestChunk,\n  decodeTriangleVertexPositionsAndIndices,\n  generateHigherOctreeLevel,\n  MeshSource,\n  MultiscaleMeshSource,\n} from \"#src/mesh/backend.js\";\nimport { decodeDracoPartitioned } from \"#src/mesh/draco/index.js\";\nimport { IndexedSegmentPropertySourceBackend } from \"#src/segmentation_display_state/backend.js\";\nimport type { SkeletonChunk } from \"#src/skeleton/backend.js\";\nimport { SkeletonSource } from \"#src/skeleton/backend.js\";\nimport { decodeSkeletonChunk } from \"#src/skeleton/decode_precomputed_skeleton.js\";\nimport { decodeCompressedSegmentationChunk } from \"#src/sliceview/backend_chunk_decoders/compressed_segmentation.js\";\nimport { decodeCompressoChunk } from \"#src/sliceview/backend_chunk_decoders/compresso.js\";\nimport type { ChunkDecoder } from \"#src/sliceview/backend_chunk_decoders/index.js\";\nimport { decodeJpegChunk } from \"#src/sliceview/backend_chunk_decoders/jpeg.js\";\nimport { decodeJxlChunk } from \"#src/sliceview/backend_chunk_decoders/jxl.js\";\nimport { decodePngChunk } from \"#src/sliceview/backend_chunk_decoders/png.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { fetchSpecialHttpByteRange } from \"#src/util/byte_range_http_requests.js\";\nimport type { Borrowed } from \"#src/util/disposable.js\";\nimport { convertEndian32, Endianness } from \"#src/util/endian.js\";\nimport { vec3 } from \"#src/util/geom.js\";\nimport { decodeGzip } from \"#src/util/gzip.js\";\nimport { murmurHash3_x86_128Hash64Bits } from \"#src/util/hash.js\";\nimport { isNotFoundError } from \"#src/util/http_request.js\";\nimport { stableStringify } from \"#src/util/json.js\";\nimport { getObjectId } from \"#src/util/object_id.js\";\nimport type {\n  SpecialProtocolCredentials,\n  SpecialProtocolCredentialsProvider,\n} from \"#src/util/special_protocol_request.js\";\nimport { fetchSpecialOk } from \"#src/util/special_protocol_request.js\";\nimport { Uint64 } from \"#src/util/uint64.js\";\nimport {\n  encodeZIndexCompressed,\n  encodeZIndexCompressed3d,\n  zorder3LessThan,\n} from \"#src/util/zorder.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\n// Set to true to validate the multiscale index.\nconst DEBUG_MULTISCALE_INDEX = false;\n\nconst shardingHashFunctions: Map<ShardingHashFunction, (out: Uint64) => void> =\n  new Map([\n    [\n      ShardingHashFunction.MURMURHASH3_X86_128,\n      (out) => {\n        murmurHash3_x86_128Hash64Bits(out, 0, out.low, out.high);\n      },\n    ],\n    [ShardingHashFunction.IDENTITY, (_out) => {}],\n  ]);\n\ninterface ShardInfo {\n  shardUrl: string;\n  offset: Uint64;\n}\n\ninterface DecodedMinishardIndex {\n  data: Uint32Array;\n  shardUrl: string;\n}\n\ninterface MinishardIndexSource\n  extends GenericSharedDataSource<Uint64, DecodedMinishardIndex | undefined> {\n  sharding: ShardingParameters;\n  credentialsProvider: SpecialProtocolCredentialsProvider;\n}\n\nfunction getMinishardIndexDataSource(\n  chunkManager: Borrowed<ChunkManager>,\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  parameters: { url: string; sharding: ShardingParameters | undefined },\n): MinishardIndexSource | undefined {\n  const { url, sharding } = parameters;\n  if (sharding === undefined) return undefined;\n  const source = GenericSharedDataSource.get<\n    Uint64,\n    DecodedMinishardIndex | undefined\n  >(\n    chunkManager,\n    stableStringify({\n      type: \"precomputed:shardedDataSource\",\n      url,\n      sharding,\n      credentialsProvider: getObjectId(credentialsProvider),\n    }),\n    {\n      download: async (shardAndMinishard: Uint64, abortSignal: AbortSignal) => {\n        const minishard = Uint64.lowMask(new Uint64(), sharding.minishardBits);\n        Uint64.and(minishard, minishard, shardAndMinishard);\n        const shard = Uint64.lowMask(new Uint64(), sharding.shardBits);\n        const temp = new Uint64();\n        Uint64.rshift(temp, shardAndMinishard, sharding.minishardBits);\n        Uint64.and(shard, shard, temp);\n        const shardUrl = `${url}/${shard\n          .toString(16)\n          .padStart(Math.ceil(sharding.shardBits / 4), \"0\")}.shard`;\n        // Retrive minishard index start/end offsets.\n        const shardIndexSize = new Uint64(16);\n        Uint64.lshift(shardIndexSize, shardIndexSize, sharding.minishardBits);\n\n        // Multiply minishard by 16.\n        const shardIndexStart = Uint64.lshift(new Uint64(), minishard, 4);\n        const shardIndexEnd = Uint64.addUint32(\n          new Uint64(),\n          shardIndexStart,\n          16,\n        );\n        let shardIndexResponse: ArrayBuffer;\n        try {\n          shardIndexResponse = await fetchSpecialHttpByteRange(\n            credentialsProvider,\n            shardUrl,\n            shardIndexStart,\n            shardIndexEnd,\n            abortSignal,\n          );\n        } catch (e) {\n          if (isNotFoundError(e)) return { data: undefined, size: 0 };\n          throw e;\n        }\n        if (shardIndexResponse.byteLength !== 16) {\n          throw new Error(\"Failed to retrieve minishard offset\");\n        }\n        const shardIndexDv = new DataView(shardIndexResponse);\n        const minishardStartOffset = new Uint64(\n          shardIndexDv.getUint32(0, /*littleEndian=*/ true),\n          shardIndexDv.getUint32(4, /*littleEndian=*/ true),\n        );\n        const minishardEndOffset = new Uint64(\n          shardIndexDv.getUint32(8, /*littleEndian=*/ true),\n          shardIndexDv.getUint32(12, /*littleEndian=*/ true),\n        );\n        if (Uint64.equal(minishardStartOffset, minishardEndOffset)) {\n          return { data: undefined, size: 0 };\n        }\n        // The start/end offsets in the shard index are relative to the end of the shard\n        // index.\n        Uint64.add(minishardStartOffset, minishardStartOffset, shardIndexSize);\n        Uint64.add(minishardEndOffset, minishardEndOffset, shardIndexSize);\n\n        let minishardIndexResponse = await fetchSpecialHttpByteRange(\n          credentialsProvider,\n          shardUrl,\n          minishardStartOffset,\n          minishardEndOffset,\n          abortSignal,\n        );\n        if (sharding.minishardIndexEncoding === DataEncoding.GZIP) {\n          minishardIndexResponse = await decodeGzip(\n            minishardIndexResponse,\n            \"gzip\",\n          );\n        }\n        if (minishardIndexResponse.byteLength % 24 !== 0) {\n          throw new Error(\n            `Invalid minishard index length: ${minishardIndexResponse.byteLength}`,\n          );\n        }\n        const minishardIndex = new Uint32Array(minishardIndexResponse);\n        convertEndian32(minishardIndex, Endianness.LITTLE);\n\n        const minishardIndexSize = minishardIndex.byteLength / 24;\n        let prevEntryKeyLow = 0;\n        let prevEntryKeyHigh = 0;\n        // Offsets in the minishard index are relative to the end of the shard index.\n        let prevStartLow = shardIndexSize.low;\n        let prevStartHigh = shardIndexSize.high;\n        for (let i = 0; i < minishardIndexSize; ++i) {\n          let entryKeyLow = prevEntryKeyLow + minishardIndex[i * 2];\n          let entryKeyHigh = prevEntryKeyHigh + minishardIndex[i * 2 + 1];\n          if (entryKeyLow >= 4294967296) {\n            entryKeyLow -= 4294967296;\n            entryKeyHigh += 1;\n          }\n          prevEntryKeyLow = minishardIndex[i * 2] = entryKeyLow;\n          prevEntryKeyHigh = minishardIndex[i * 2 + 1] = entryKeyHigh;\n          let startLow =\n            prevStartLow + minishardIndex[(minishardIndexSize + i) * 2];\n          let startHigh =\n            prevStartHigh + minishardIndex[(minishardIndexSize + i) * 2 + 1];\n          if (startLow >= 4294967296) {\n            startLow -= 4294967296;\n            startHigh += 1;\n          }\n          minishardIndex[(minishardIndexSize + i) * 2] = startLow;\n          minishardIndex[(minishardIndexSize + i) * 2 + 1] = startHigh;\n          const sizeLow = minishardIndex[(2 * minishardIndexSize + i) * 2];\n          const sizeHigh = minishardIndex[(2 * minishardIndexSize + i) * 2 + 1];\n          let endLow = startLow + sizeLow;\n          let endHigh = startHigh + sizeHigh;\n          if (endLow >= 4294967296) {\n            endLow -= 4294967296;\n            endHigh += 1;\n          }\n          prevStartLow = endLow;\n          prevStartHigh = endHigh;\n          minishardIndex[(2 * minishardIndexSize + i) * 2] = endLow;\n          minishardIndex[(2 * minishardIndexSize + i) * 2 + 1] = endHigh;\n        }\n        return {\n          data: { data: minishardIndex, shardUrl },\n          size: minishardIndex.byteLength,\n        };\n      },\n      encodeKey: (key: Uint64) => key.toString(),\n      sourceQueueLevel: 1,\n    },\n  ) as MinishardIndexSource;\n  source.sharding = sharding;\n  source.credentialsProvider = credentialsProvider;\n  return source;\n}\n\nfunction findMinishardEntry(\n  minishardIndex: DecodedMinishardIndex,\n  key: Uint64,\n): { startOffset: Uint64; endOffset: Uint64 } | undefined {\n  const minishardIndexData = minishardIndex.data;\n  const minishardIndexSize = minishardIndexData.length / 6;\n  const keyLow = key.low;\n  const keyHigh = key.high;\n  for (let i = 0; i < minishardIndexSize; ++i) {\n    if (\n      minishardIndexData[i * 2] !== keyLow ||\n      minishardIndexData[i * 2 + 1] !== keyHigh\n    ) {\n      continue;\n    }\n    const startOffset = new Uint64(\n      minishardIndexData[(minishardIndexSize + i) * 2],\n      minishardIndexData[(minishardIndexSize + i) * 2 + 1],\n    );\n    const endOffset = new Uint64(\n      minishardIndexData[(2 * minishardIndexSize + i) * 2],\n      minishardIndexData[(2 * minishardIndexSize + i) * 2 + 1],\n    );\n    return { startOffset, endOffset };\n  }\n  return undefined;\n}\n\nasync function getShardedData(\n  minishardIndexSource: MinishardIndexSource,\n  chunk: Chunk,\n  key: Uint64,\n  abortSignal: AbortSignal,\n): Promise<{ shardInfo: ShardInfo; data: ArrayBuffer } | undefined> {\n  const { sharding } = minishardIndexSource;\n  const hashFunction = shardingHashFunctions.get(sharding.hash)!;\n  const hashCode = Uint64.rshift(new Uint64(), key, sharding.preshiftBits);\n  hashFunction(hashCode);\n  const shardAndMinishard = Uint64.lowMask(\n    new Uint64(),\n    sharding.minishardBits + sharding.shardBits,\n  );\n  Uint64.and(shardAndMinishard, shardAndMinishard, hashCode);\n  const getPriority = () => ({\n    priorityTier: chunk.priorityTier,\n    priority: chunk.priority,\n  });\n  const minishardIndex = await minishardIndexSource.getData(\n    shardAndMinishard,\n    getPriority,\n    abortSignal,\n  );\n  if (minishardIndex === undefined) return undefined;\n  const minishardEntry = findMinishardEntry(minishardIndex, key);\n  if (minishardEntry === undefined) return undefined;\n  const { startOffset, endOffset } = minishardEntry;\n  let data = await fetchSpecialHttpByteRange(\n    minishardIndexSource.credentialsProvider,\n    minishardIndex.shardUrl,\n    startOffset,\n    endOffset,\n    abortSignal,\n  );\n  if (minishardIndexSource.sharding.dataEncoding === DataEncoding.GZIP) {\n    data = await decodeGzip(data, \"gzip\");\n  }\n  return {\n    data,\n    shardInfo: { shardUrl: minishardIndex.shardUrl, offset: startOffset },\n  };\n}\n\nfunction getOrNotFoundError<T>(v: T | undefined) {\n  if (v === undefined) throw new Error(\"not found\");\n  return v;\n}\n\nconst chunkDecoders = new Map<VolumeChunkEncoding, ChunkDecoder>();\nchunkDecoders.set(VolumeChunkEncoding.RAW, decodeRawChunk);\nchunkDecoders.set(VolumeChunkEncoding.JPEG, decodeJpegChunk);\nchunkDecoders.set(\n  VolumeChunkEncoding.COMPRESSED_SEGMENTATION,\n  decodeCompressedSegmentationChunk,\n);\nchunkDecoders.set(VolumeChunkEncoding.COMPRESSO, decodeCompressoChunk);\nchunkDecoders.set(VolumeChunkEncoding.PNG, decodePngChunk);\nchunkDecoders.set(VolumeChunkEncoding.JXL, decodeJxlChunk);\n\n@registerSharedObject()\nexport class PrecomputedVolumeChunkSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    VolumeChunkSource,\n  ),\n  VolumeChunkSourceParameters,\n) {\n  chunkDecoder = chunkDecoders.get(this.parameters.encoding)!;\n  private minishardIndexSource = getMinishardIndexDataSource(\n    this.chunkManager,\n    this.credentialsProvider,\n    this.parameters,\n  );\n\n  gridShape = (() => {\n    const gridShape = new Uint32Array(3);\n    const { upperVoxelBound, chunkDataSize } = this.spec;\n    for (let i = 0; i < 3; ++i) {\n      gridShape[i] = Math.ceil(upperVoxelBound[i] / chunkDataSize[i]);\n    }\n    return gridShape;\n  })();\n\n  async download(chunk: VolumeChunk, abortSignal: AbortSignal): Promise<void> {\n    const { parameters } = this;\n\n    const { minishardIndexSource } = this;\n    let response: ArrayBuffer | undefined;\n    if (minishardIndexSource === undefined) {\n      let url: string;\n      {\n        // chunkPosition must not be captured, since it will be invalidated by the next call to\n        // computeChunkBounds.\n        const chunkPosition = this.computeChunkBounds(chunk);\n        const chunkDataSize = chunk.chunkDataSize!;\n        url =\n          `${parameters.url}/${chunkPosition[0]}-${\n            chunkPosition[0] + chunkDataSize[0]\n          }_` +\n          `${chunkPosition[1]}-${chunkPosition[1] + chunkDataSize[1]}_` +\n          `${chunkPosition[2]}-${chunkPosition[2] + chunkDataSize[2]}`;\n      }\n      try {\n        response = await fetchSpecialOk(this.credentialsProvider, url, {\n          signal: abortSignal,\n        }).then((response) => response.arrayBuffer());\n      } catch (e) {\n        if (isNotFoundError(e)) {\n          response = undefined;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      this.computeChunkBounds(chunk);\n      const { gridShape } = this;\n      const { chunkGridPosition } = chunk;\n      const xBits = Math.ceil(Math.log2(gridShape[0]));\n      const yBits = Math.ceil(Math.log2(gridShape[1]));\n      const zBits = Math.ceil(Math.log2(gridShape[2]));\n      const chunkIndex = encodeZIndexCompressed3d(\n        new Uint64(),\n        xBits,\n        yBits,\n        zBits,\n        chunkGridPosition[0],\n        chunkGridPosition[1],\n        chunkGridPosition[2],\n      );\n      response = (\n        await getShardedData(\n          minishardIndexSource,\n          chunk,\n          chunkIndex,\n          abortSignal,\n        )\n      )?.data;\n    }\n    if (response !== undefined) {\n      await this.chunkDecoder(chunk, abortSignal, response);\n    }\n  }\n}\n\nexport function decodeManifestChunk(chunk: ManifestChunk, response: any) {\n  return decodeJsonManifestChunk(chunk, response, \"fragments\");\n}\n\nexport function decodeFragmentChunk(\n  chunk: FragmentChunk,\n  response: ArrayBuffer,\n) {\n  const dv = new DataView(response);\n  const numVertices = dv.getUint32(0, true);\n  assignMeshFragmentData(\n    chunk,\n    decodeTriangleVertexPositionsAndIndices(\n      response,\n      Endianness.LITTLE,\n      /*vertexByteOffset=*/ 4,\n      numVertices,\n    ),\n  );\n}\n\n@registerSharedObject()\nexport class PrecomputedMeshSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    MeshSource,\n  ),\n  MeshSourceParameters,\n) {\n  async download(chunk: ManifestChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const response = await fetchSpecialOk(\n      this.credentialsProvider,\n      `${parameters.url}/${chunk.objectId}:${parameters.lod}`,\n      { signal: abortSignal },\n    );\n    decodeManifestChunk(chunk, await response.json());\n  }\n\n  async downloadFragment(chunk: FragmentChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const response = await fetchSpecialOk(\n      this.credentialsProvider,\n      `${parameters.url}/${chunk.fragmentId}`,\n      { signal: abortSignal },\n    );\n    decodeFragmentChunk(chunk, await response.arrayBuffer());\n  }\n}\n\ninterface PrecomputedMultiscaleManifestChunk extends MultiscaleManifestChunk {\n  /**\n   * Byte offsets into data file for each octree node.\n   *\n   * Stored as Float64Array to allow 53-bit integer values.\n   */\n  offsets: Float64Array;\n  shardInfo?: ShardInfo;\n}\n\nfunction decodeMultiscaleManifestChunk(\n  chunk: PrecomputedMultiscaleManifestChunk,\n  response: ArrayBuffer,\n) {\n  if (response.byteLength < 28 || response.byteLength % 4 !== 0) {\n    throw new Error(`Invalid index file size: ${response.byteLength}`);\n  }\n  const dv = new DataView(response);\n  let offset = 0;\n  const chunkShape = vec3.fromValues(\n    dv.getFloat32(offset, /*littleEndian=*/ true),\n    dv.getFloat32(offset + 4, /*littleEndian=*/ true),\n    dv.getFloat32(offset + 8, /*littleEndian=*/ true),\n  );\n  offset += 12;\n  const gridOrigin = vec3.fromValues(\n    dv.getFloat32(offset, /*littleEndian=*/ true),\n    dv.getFloat32(offset + 4, /*littleEndian=*/ true),\n    dv.getFloat32(offset + 8, /*littleEndian=*/ true),\n  );\n  offset += 12;\n  const numStoredLods = dv.getUint32(offset, /*littleEndian=*/ true);\n  offset += 4;\n  if (response.byteLength < offset + (4 + 4 + 4 * 3) * numStoredLods) {\n    throw new Error(\n      `Invalid index file size for ${numStoredLods} lods: ${response.byteLength}`,\n    );\n  }\n  const storedLodScales = new Float32Array(response, offset, numStoredLods);\n  offset += 4 * numStoredLods;\n  convertEndian32(storedLodScales, Endianness.LITTLE);\n  const vertexOffsets = new Float32Array(response, offset, numStoredLods * 3);\n  convertEndian32(vertexOffsets, Endianness.LITTLE);\n  offset += 12 * numStoredLods;\n  const numFragmentsPerLod = new Uint32Array(response, offset, numStoredLods);\n  offset += 4 * numStoredLods;\n  convertEndian32(numFragmentsPerLod, Endianness.LITTLE);\n  const totalFragments = numFragmentsPerLod.reduce((a, b) => a + b);\n  if (response.byteLength !== offset + 16 * totalFragments) {\n    throw new Error(\n      `Invalid index file size for ${numStoredLods} lods and ` +\n        `${totalFragments} total fragments: ${response.byteLength}`,\n    );\n  }\n  const fragmentInfo = new Uint32Array(response, offset);\n  convertEndian32(fragmentInfo, Endianness.LITTLE);\n  const clipLowerBound = vec3.fromValues(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n  );\n  const clipUpperBound = vec3.fromValues(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n  );\n  let numLods = Math.max(1, storedLodScales.length);\n  // Compute `clipLowerBound` and `clipUpperBound` and `numLods`.  Note that `numLods` is >=\n  // `storedLodScales.length`; it may contain additional levels since at the highest level the\n  // octree must be a single node.\n  {\n    let fragmentBase = 0;\n    for (let lodIndex = 0; lodIndex < numStoredLods; ++lodIndex) {\n      const numFragments = numFragmentsPerLod[lodIndex];\n      if (DEBUG_MULTISCALE_INDEX) {\n        for (let i = 1; i < numFragments; ++i) {\n          const x0 = fragmentInfo[fragmentBase + numFragments * 0 + (i - 1)];\n          const y0 = fragmentInfo[fragmentBase + numFragments * 1 + (i - 1)];\n          const z0 = fragmentInfo[fragmentBase + numFragments * 2 + (i - 1)];\n          const x1 = fragmentInfo[fragmentBase + numFragments * 0 + i];\n          const y1 = fragmentInfo[fragmentBase + numFragments * 1 + i];\n          const z1 = fragmentInfo[fragmentBase + numFragments * 2 + i];\n          if (!zorder3LessThan(x0, y0, z0, x1, y1, z1)) {\n            console.log(\n              \"Fragment index violates zorder constraint: \" +\n                `lod=${lodIndex}, ` +\n                `chunk ${i - 1} = [${x0},${y0},${z0}], ` +\n                `chunk ${i} = [${x1},${y1},${z1}]`,\n            );\n          }\n        }\n      }\n      for (let i = 0; i < 3; ++i) {\n        let upperBoundValue = Number.NEGATIVE_INFINITY;\n        let lowerBoundValue = Number.POSITIVE_INFINITY;\n        const base = fragmentBase + numFragments * i;\n        for (let j = 0; j < numFragments; ++j) {\n          const v = fragmentInfo[base + j];\n          upperBoundValue = Math.max(upperBoundValue, v);\n          lowerBoundValue = Math.min(lowerBoundValue, v);\n        }\n        if (numFragments !== 0) {\n          while (\n            upperBoundValue >>> (numLods - lodIndex - 1) !==\n            lowerBoundValue >>> (numLods - lodIndex - 1)\n          ) {\n            ++numLods;\n          }\n          if (lodIndex === 0) {\n            clipLowerBound[i] = Math.min(\n              clipLowerBound[i],\n              (1 << lodIndex) * lowerBoundValue,\n            );\n            clipUpperBound[i] = Math.max(\n              clipUpperBound[i],\n              (1 << lodIndex) * (upperBoundValue + 1),\n            );\n          }\n        }\n      }\n      fragmentBase += numFragments * 4;\n    }\n  }\n\n  // Compute upper bound on number of nodes that will be in the octree, so that we can allocate a\n  // sufficiently large buffer without having to worry about resizing.\n  let maxFragments = 0;\n  {\n    let prevNumFragments = 0;\n    let prevLodIndex = 0;\n    for (let lodIndex = 0; lodIndex < numStoredLods; ++lodIndex) {\n      const numFragments = numFragmentsPerLod[lodIndex];\n      maxFragments += prevNumFragments * (lodIndex - prevLodIndex);\n      prevLodIndex = lodIndex;\n      prevNumFragments = numFragments;\n      maxFragments += numFragments;\n    }\n    maxFragments += (numLods - 1 - prevLodIndex) * prevNumFragments;\n  }\n  const octreeTemp = new Uint32Array(5 * maxFragments);\n  const offsetsTemp = new Float64Array(maxFragments + 1);\n  let octree: Uint32Array;\n  {\n    let priorStart = 0;\n    let baseRow = 0;\n    let dataOffset = 0;\n    let fragmentBase = 0;\n    for (let lodIndex = 0; lodIndex < numStoredLods; ++lodIndex) {\n      const numFragments = numFragmentsPerLod[lodIndex];\n      // Copy in indices\n      for (let j = 0; j < numFragments; ++j) {\n        for (let i = 0; i < 3; ++i) {\n          octreeTemp[5 * (baseRow + j) + i] =\n            fragmentInfo[fragmentBase + j + i * numFragments];\n        }\n        const dataSize = fragmentInfo[fragmentBase + j + 3 * numFragments];\n        dataOffset += dataSize;\n        offsetsTemp[baseRow + j + 1] = dataOffset;\n        if (dataSize === 0) {\n          // Mark node as empty.\n          octreeTemp[5 * (baseRow + j) + 4] = 0x80000000;\n        }\n      }\n\n      fragmentBase += 4 * numFragments;\n\n      if (lodIndex !== 0) {\n        // Connect with prior level\n        computeOctreeChildOffsets(\n          octreeTemp,\n          priorStart,\n          baseRow,\n          baseRow + numFragments,\n        );\n      }\n\n      priorStart = baseRow;\n      baseRow += numFragments;\n      while (\n        lodIndex + 1 < numLods &&\n        (lodIndex + 1 >= storedLodScales.length ||\n          storedLodScales[lodIndex + 1] === 0)\n      ) {\n        const curEnd = generateHigherOctreeLevel(\n          octreeTemp,\n          priorStart,\n          baseRow,\n        );\n        offsetsTemp.fill(dataOffset, baseRow + 1, curEnd + 1);\n        priorStart = baseRow;\n        baseRow = curEnd;\n        ++lodIndex;\n      }\n    }\n    octree = octreeTemp.slice(0, 5 * baseRow);\n    chunk.offsets = offsetsTemp.slice(0, baseRow + 1);\n  }\n  const source = chunk.source! as PrecomputedMultiscaleMeshSource;\n  const { lodScaleMultiplier } = source.parameters.metadata;\n  const lodScales = new Float32Array(numLods);\n  lodScales.set(storedLodScales, 0);\n  for (let i = 0; i < storedLodScales.length; ++i) {\n    lodScales[i] *= lodScaleMultiplier;\n  }\n  chunk.manifest = {\n    chunkShape,\n    chunkGridSpatialOrigin: gridOrigin,\n    clipLowerBound: vec3.add(\n      clipLowerBound,\n      gridOrigin,\n      vec3.multiply(clipLowerBound, clipLowerBound, chunkShape),\n    ),\n    clipUpperBound: vec3.add(\n      clipUpperBound,\n      gridOrigin,\n      vec3.multiply(clipUpperBound, clipUpperBound, chunkShape),\n    ),\n    octree,\n    lodScales,\n    vertexOffsets,\n  };\n}\n\nasync function decodeMultiscaleFragmentChunk(\n  chunk: MultiscaleFragmentChunk,\n  response: ArrayBuffer,\n) {\n  const { lod } = chunk;\n  const source = chunk.manifestChunk!\n    .source! as PrecomputedMultiscaleMeshSource;\n  const rawMesh = await decodeDracoPartitioned(\n    new Uint8Array(response),\n    source.parameters.metadata.vertexQuantizationBits,\n    lod !== 0,\n  );\n  assignMultiscaleMeshFragmentData(\n    chunk,\n    rawMesh,\n    source.format.vertexPositionFormat,\n  );\n}\n\n@registerSharedObject() //\nexport class PrecomputedMultiscaleMeshSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    MultiscaleMeshSource,\n  ),\n  MultiscaleMeshSourceParameters,\n) {\n  private minishardIndexSource = getMinishardIndexDataSource(\n    this.chunkManager,\n    this.credentialsProvider,\n    { url: this.parameters.url, sharding: this.parameters.metadata.sharding },\n  );\n\n  async download(\n    chunk: PrecomputedMultiscaleManifestChunk,\n    abortSignal: AbortSignal,\n  ): Promise<void> {\n    const { parameters, minishardIndexSource } = this;\n    let data: ArrayBuffer;\n    if (minishardIndexSource === undefined) {\n      data = await fetchSpecialOk(\n        this.credentialsProvider,\n        `${parameters.url}/${chunk.objectId}.index`,\n        { signal: abortSignal },\n      ).then((response) => response.arrayBuffer());\n    } else {\n      ({ data, shardInfo: chunk.shardInfo } = getOrNotFoundError(\n        await getShardedData(\n          minishardIndexSource,\n          chunk,\n          chunk.objectId,\n          abortSignal,\n        ),\n      ));\n    }\n    decodeMultiscaleManifestChunk(chunk, data);\n  }\n\n  async downloadFragment(\n    chunk: MultiscaleFragmentChunk,\n    abortSignal: AbortSignal,\n  ): Promise<void> {\n    const { parameters } = this;\n    const manifestChunk =\n      chunk.manifestChunk! as PrecomputedMultiscaleManifestChunk;\n    const chunkIndex = chunk.chunkIndex;\n    const { shardInfo, offsets } = manifestChunk;\n    const startOffset = offsets[chunkIndex];\n    const endOffset = offsets[chunkIndex + 1];\n    let requestUrl: string;\n    let adjustedStartOffset: Uint64 | number;\n    let adjustedEndOffset: Uint64 | number;\n    if (shardInfo !== undefined) {\n      requestUrl = shardInfo.shardUrl;\n      const fullDataSize = offsets[offsets.length - 1];\n      let startLow = shardInfo.offset.low - fullDataSize + startOffset;\n      let startHigh = shardInfo.offset.high;\n      let endLow = startLow + endOffset - startOffset;\n      let endHigh = startHigh;\n      while (startLow < 0) {\n        startLow += 4294967296;\n        startHigh -= 1;\n      }\n      while (endLow < 0) {\n        endLow += 4294967296;\n        endHigh -= 1;\n      }\n      while (endLow > 4294967296) {\n        endLow -= 4294967296;\n        endHigh += 1;\n      }\n      adjustedStartOffset = new Uint64(startLow, startHigh);\n      adjustedEndOffset = new Uint64(endLow, endHigh);\n    } else {\n      requestUrl = `${parameters.url}/${manifestChunk.objectId}`;\n      adjustedStartOffset = startOffset;\n      adjustedEndOffset = endOffset;\n    }\n    const response = await fetchSpecialHttpByteRange(\n      this.credentialsProvider,\n      requestUrl,\n      adjustedStartOffset,\n      adjustedEndOffset,\n      abortSignal,\n    );\n    await decodeMultiscaleFragmentChunk(chunk, response);\n  }\n}\n\nasync function fetchByUint64(\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  url: string,\n  chunk: Chunk,\n  minishardIndexSource: MinishardIndexSource | undefined,\n  id: Uint64,\n  abortSignal: AbortSignal,\n) {\n  if (minishardIndexSource === undefined) {\n    try {\n      return await fetchSpecialOk(credentialsProvider, `${url}/${id}`, {\n        signal: abortSignal,\n      }).then((response) => response.arrayBuffer());\n    } catch (e) {\n      if (isNotFoundError(e)) return undefined;\n      throw e;\n    }\n  }\n  const result = await getShardedData(\n    minishardIndexSource,\n    chunk,\n    id,\n    abortSignal,\n  );\n  if (result === undefined) return undefined;\n  return result.data;\n}\n\n@registerSharedObject() //\nexport class PrecomputedSkeletonSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    SkeletonSource,\n  ),\n  SkeletonSourceParameters,\n) {\n  private minishardIndexSource = getMinishardIndexDataSource(\n    this.chunkManager,\n    this.credentialsProvider,\n    { url: this.parameters.url, sharding: this.parameters.metadata.sharding },\n  );\n  async download(chunk: SkeletonChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const response = getOrNotFoundError(\n      await fetchByUint64(\n        this.credentialsProvider,\n        parameters.url,\n        chunk,\n        this.minishardIndexSource,\n        chunk.objectId,\n        abortSignal,\n      ),\n    );\n    decodeSkeletonChunk(chunk, response, parameters.metadata.vertexAttributes);\n  }\n}\n\nfunction parseAnnotations(\n  buffer: ArrayBuffer,\n  parameters: AnnotationSourceParameters,\n  propertySerializer: AnnotationPropertySerializer,\n): AnnotationGeometryData {\n  const dv = new DataView(buffer);\n  if (buffer.byteLength <= 8) throw new Error(\"Expected at least 8 bytes\");\n  const countLow = dv.getUint32(0, /*littleEndian=*/ true);\n  const countHigh = dv.getUint32(4, /*littleEndian=*/ true);\n  if (countHigh !== 0) throw new Error(\"Annotation count too high\");\n  const numBytes = propertySerializer.serializedBytes;\n  const expectedBytes = 8 + (numBytes + 8) * countLow;\n  if (buffer.byteLength !== expectedBytes) {\n    throw new Error(\n      `Expected ${expectedBytes} bytes, but received: ${buffer.byteLength} bytes`,\n    );\n  }\n  const idOffset = 8 + numBytes * countLow;\n  const id = new Uint64();\n  const ids = new Array<string>(countLow);\n  for (let i = 0; i < countLow; ++i) {\n    id.low = dv.getUint32(idOffset + i * 8, /*littleEndian=*/ true);\n    id.high = dv.getUint32(idOffset + i * 8 + 4, /*littleEndian=*/ true);\n    ids[i] = id.toString();\n  }\n  const geometryData = new AnnotationGeometryData();\n  const origData = new Uint8Array(buffer, 8, numBytes * countLow);\n  let data: Uint8Array<ArrayBuffer>;\n  const { propertyGroupBytes } = propertySerializer;\n  if (propertyGroupBytes.length > 1) {\n    // Need to transpose the property data.\n    data = new Uint8Array(origData.length);\n\n    let origOffset = 0;\n    let groupOffset = 0;\n    for (\n      let groupIndex = 0;\n      groupIndex < propertyGroupBytes.length;\n      ++groupIndex\n    ) {\n      const groupBytesPerAnnotation = propertyGroupBytes[groupIndex];\n      for (\n        let annotationIndex = 0;\n        annotationIndex < countLow;\n        ++annotationIndex\n      ) {\n        const origBase = origOffset + annotationIndex * numBytes;\n        const newBase = groupOffset + annotationIndex * groupBytesPerAnnotation;\n        for (let i = 0; i < groupBytesPerAnnotation; ++i) {\n          data[newBase + i] = origData[origBase + i];\n        }\n      }\n      origOffset += groupBytesPerAnnotation;\n      groupOffset += groupBytesPerAnnotation * countLow;\n    }\n  } else {\n    data = origData;\n  }\n  geometryData.data = data;\n  // FIXME: convert endian in order to support big endian platforms\n  const typeToOffset = (geometryData.typeToOffset = new Array<number>(\n    annotationTypes.length,\n  ));\n  typeToOffset.fill(0);\n  typeToOffset[parameters.type] = 0;\n  const typeToIds = (geometryData.typeToIds = new Array<string[]>(\n    annotationTypes.length,\n  ));\n  const typeToIdMaps = (geometryData.typeToIdMaps = new Array<\n    Map<string, number>\n  >(annotationTypes.length));\n  typeToIds.fill([]);\n  typeToIds[parameters.type] = ids;\n  typeToIdMaps.fill(new Map());\n  typeToIdMaps[parameters.type] = new Map(ids.map((id, i) => [id, i]));\n  return geometryData;\n}\n\nfunction parseSingleAnnotation(\n  buffer: ArrayBuffer,\n  parameters: AnnotationSourceParameters,\n  propertySerializer: AnnotationPropertySerializer,\n  id: string,\n): Annotation {\n  const handler = annotationTypeHandlers[parameters.type];\n  const baseNumBytes = propertySerializer.serializedBytes;\n  const numRelationships = parameters.relationships.length;\n  const minNumBytes = baseNumBytes + 4 * numRelationships;\n  if (buffer.byteLength < minNumBytes) {\n    throw new Error(\n      `Expected at least ${minNumBytes} bytes, but received: ${buffer.byteLength}`,\n    );\n  }\n  const dv = new DataView(buffer);\n  const annotation = handler.deserialize(\n    dv,\n    0,\n    /*isLittleEndian=*/ true,\n    parameters.rank,\n    id,\n  );\n  propertySerializer.deserialize(\n    dv,\n    /*offset=*/ 0,\n    /*annotationIndex=*/ 0,\n    /*annotationCount=*/ 1,\n    /*isLittleEndian=*/ true,\n    (annotation.properties = new Array(parameters.properties.length)),\n  );\n  let offset = baseNumBytes;\n  const relatedSegments: Uint64[][] = (annotation.relatedSegments = []);\n  relatedSegments.length = numRelationships;\n  for (let i = 0; i < numRelationships; ++i) {\n    const count = dv.getUint32(offset, /*littleEndian=*/ true);\n    if (buffer.byteLength < minNumBytes + count * 8) {\n      throw new Error(\n        `Expected at least ${minNumBytes} bytes, but received: ${buffer.byteLength}`,\n      );\n    }\n    offset += 4;\n    const segments: Uint64[] = (relatedSegments[i] = []);\n    for (let j = 0; j < count; ++j) {\n      segments[j] = new Uint64(\n        dv.getUint32(offset, /*littleEndian=*/ true),\n        dv.getUint32(offset + 4, /*littleEndian=*/ true),\n      );\n      offset += 8;\n    }\n  }\n  if (offset !== buffer.byteLength) {\n    throw new Error(\n      `Expected ${offset} bytes, but received: ${buffer.byteLength}`,\n    );\n  }\n  return annotation;\n}\n\n@registerSharedObject() //\nexport class PrecomputedAnnotationSpatialIndexSourceBackend extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    AnnotationGeometryChunkSourceBackend,\n  ),\n  AnnotationSpatialIndexSourceParameters,\n) {\n  private minishardIndexSource = getMinishardIndexDataSource(\n    this.chunkManager,\n    this.credentialsProvider,\n    this.parameters,\n  );\n  declare parent: PrecomputedAnnotationSourceBackend;\n  async download(chunk: AnnotationGeometryChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n\n    const { minishardIndexSource } = this;\n    const { parent } = this;\n    let response: ArrayBuffer | undefined;\n    const { chunkGridPosition } = chunk;\n    if (minishardIndexSource === undefined) {\n      const url = `${parameters.url}/${chunkGridPosition.join(\"_\")}`;\n      try {\n        response = await fetchSpecialOk(this.credentialsProvider, url, {\n          signal: abortSignal,\n        }).then((response) => response.arrayBuffer());\n      } catch (e) {\n        if (!isNotFoundError(e)) throw e;\n      }\n    } else {\n      const { upperChunkBound } = this.spec;\n      const { chunkGridPosition } = chunk;\n      const chunkIndex = encodeZIndexCompressed(\n        new Uint64(),\n        chunkGridPosition,\n        upperChunkBound,\n      );\n      const result = await getShardedData(\n        minishardIndexSource,\n        chunk,\n        chunkIndex,\n        abortSignal,\n      );\n      if (result !== undefined) response = result.data;\n    }\n    if (response !== undefined) {\n      chunk.data = parseAnnotations(\n        response,\n        parent.parameters,\n        parent.annotationPropertySerializer,\n      );\n    }\n  }\n}\n\n@registerSharedObject() //\nexport class PrecomputedAnnotationSourceBackend extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    AnnotationSource,\n  ),\n  AnnotationSourceParameters,\n) {\n  private byIdMinishardIndexSource = getMinishardIndexDataSource(\n    this.chunkManager,\n    this.credentialsProvider,\n    this.parameters.byId,\n  );\n  private relationshipIndexSource = this.parameters.relationships.map((x) =>\n    getMinishardIndexDataSource(this.chunkManager, this.credentialsProvider, x),\n  );\n  annotationPropertySerializer = new AnnotationPropertySerializer(\n    this.parameters.rank,\n    annotationTypeHandlers[this.parameters.type].serializedBytes(\n      this.parameters.rank,\n    ),\n    this.parameters.properties,\n  );\n\n  async downloadSegmentFilteredGeometry(\n    chunk: AnnotationSubsetGeometryChunk,\n    relationshipIndex: number,\n    abortSignal: AbortSignal,\n  ) {\n    const { parameters } = this;\n    const response = await fetchByUint64(\n      this.credentialsProvider,\n      parameters.relationships[relationshipIndex].url,\n      chunk,\n      this.relationshipIndexSource[relationshipIndex],\n      chunk.objectId,\n      abortSignal,\n    );\n    if (response !== undefined) {\n      chunk.data = parseAnnotations(\n        response,\n        this.parameters,\n        this.annotationPropertySerializer,\n      );\n    }\n  }\n\n  async downloadMetadata(\n    chunk: AnnotationMetadataChunk,\n    abortSignal: AbortSignal,\n  ) {\n    const { parameters } = this;\n    const id = Uint64.parseString(chunk.key!);\n    const response = await fetchByUint64(\n      this.credentialsProvider,\n      parameters.byId.url,\n      chunk,\n      this.byIdMinishardIndexSource,\n      id,\n      abortSignal,\n    );\n    if (response === undefined) {\n      chunk.annotation = null;\n    } else {\n      chunk.annotation = parseSingleAnnotation(\n        response,\n        this.parameters,\n        this.annotationPropertySerializer,\n        chunk.key!,\n      );\n    }\n  }\n}\n\n@registerSharedObject()\nexport class PrecomputedIndexedSegmentPropertySourceBackend extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    IndexedSegmentPropertySourceBackend,\n  ),\n  IndexedSegmentPropertySourceParameters,\n) {\n  minishardIndexSource = getMinishardIndexDataSource(\n    this.chunkManager,\n    this.credentialsProvider,\n    this.parameters,\n  );\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SkeletonChunk } from \"#src/skeleton/backend.js\";\nimport { decodeSkeletonVertexPositionsAndIndices } from \"#src/skeleton/backend.js\";\nimport type { VertexAttributeInfo } from \"#src/skeleton/base.js\";\nimport { DATA_TYPE_BYTES } from \"#src/util/data_type.js\";\nimport {\n  convertEndian16,\n  convertEndian32,\n  Endianness,\n} from \"#src/util/endian.js\";\n\nexport function decodeSkeletonChunk(\n  chunk: SkeletonChunk,\n  response: ArrayBuffer,\n  vertexAttributes: Map<string, VertexAttributeInfo>,\n) {\n  const dv = new DataView(response);\n  const numVertices = dv.getUint32(0, true);\n  const numEdges = dv.getUint32(4, true);\n\n  const vertexPositionsStartOffset = 8;\n\n  let curOffset = 8 + numVertices * 4 * 3;\n  decodeSkeletonVertexPositionsAndIndices(\n    chunk,\n    response,\n    Endianness.LITTLE,\n    /*vertexByteOffset=*/ vertexPositionsStartOffset,\n    numVertices,\n    /*indexByteOffset=*/ curOffset,\n    /*numEdges=*/ numEdges,\n  );\n  curOffset += numEdges * 4 * 2;\n  const attributes: Uint8Array[] = [];\n  for (const info of vertexAttributes.values()) {\n    const bytesPerVertex = DATA_TYPE_BYTES[info.dataType] * info.numComponents;\n    const totalBytes = bytesPerVertex * numVertices;\n    const attribute = new Uint8Array(response, curOffset, totalBytes);\n    switch (bytesPerVertex) {\n      case 2:\n        convertEndian16(attribute, Endianness.LITTLE);\n        break;\n      case 4:\n      case 8:\n        convertEndian32(attribute, Endianness.LITTLE);\n        break;\n    }\n    attributes.push(attribute);\n    curOffset += totalBytes;\n  }\n  chunk.vertexAttributes = attributes;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debounce } from \"lodash-es\";\nimport {\n  WithParameters,\n  withChunkManager,\n  Chunk,\n  ChunkSource,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier, ChunkState } from \"#src/chunk_manager/base.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport type { ChunkedGraphChunkSpecification } from \"#src/datasource/graphene/base.js\";\nimport {\n  getGrapheneFragmentKey,\n  GRAPHENE_MESH_NEW_SEGMENT_RPC_ID,\n  ChunkedGraphSourceParameters,\n  MeshSourceParameters,\n  CHUNKED_GRAPH_LAYER_RPC_ID,\n  CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID,\n  RENDER_RATIO_LIMIT,\n  isBaseSegmentId,\n} from \"#src/datasource/graphene/base.js\";\nimport { decodeManifestChunk } from \"#src/datasource/precomputed/backend.js\";\nimport type { FragmentChunk, ManifestChunk } from \"#src/mesh/backend.js\";\nimport { assignMeshFragmentData, MeshSource } from \"#src/mesh/backend.js\";\nimport { decodeDraco } from \"#src/mesh/draco/index.js\";\nimport type { DisplayDimensionRenderInfo } from \"#src/navigation_state.js\";\nimport type {\n  RenderedViewBackend,\n  RenderLayerBackendAttachment,\n} from \"#src/render_layer_backend.js\";\nimport { RenderLayerBackend } from \"#src/render_layer_backend.js\";\nimport { withSegmentationLayerBackendState } from \"#src/segmentation_display_state/backend.js\";\nimport { forEachVisibleSegment } from \"#src/segmentation_display_state/base.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { SliceViewChunkSourceBackend } from \"#src/sliceview/backend.js\";\nimport { deserializeTransformedSources } from \"#src/sliceview/backend.js\";\nimport type {\n  TransformedSource,\n  SliceViewProjectionParameters,\n} from \"#src/sliceview/base.js\";\nimport {\n  forEachPlaneIntersectingVolumetricChunk,\n  getNormalizedChunkLayout,\n} from \"#src/sliceview/base.js\";\nimport { computeChunkBounds } from \"#src/sliceview/volume/backend.js\";\nimport { Uint64Set } from \"#src/uint64_set.js\";\nimport { fetchSpecialHttpByteRange } from \"#src/util/byte_range_http_requests.js\";\nimport { vec3, vec3Key } from \"#src/util/geom.js\";\nimport type {\n  SpecialProtocolCredentials,\n  SpecialProtocolCredentialsProvider,\n} from \"#src/util/special_protocol_request.js\";\nimport { fetchSpecialOk } from \"#src/util/special_protocol_request.js\";\nimport { Uint64 } from \"#src/util/uint64.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport { registerSharedObject, registerRPC } from \"#src/worker_rpc.js\";\n\nfunction getVerifiedFragmentPromise(\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  chunk: FragmentChunk,\n  parameters: MeshSourceParameters,\n  abortSignal: AbortSignal,\n) {\n  if (chunk.fragmentId && chunk.fragmentId.charAt(0) === \"~\") {\n    const parts = chunk.fragmentId.substr(1).split(\":\");\n    const startOffset = Number(parts[1]);\n    const endOffset = startOffset + Number(parts[2]);\n    return fetchSpecialHttpByteRange(\n      credentialsProvider,\n      `${parameters.fragmentUrl}/initial/${parts[0]}`,\n      startOffset,\n      endOffset,\n      abortSignal,\n    );\n  }\n  return fetchSpecialOk(\n    credentialsProvider,\n    `${parameters.fragmentUrl}/dynamic/${chunk.fragmentId}`,\n    { signal: abortSignal },\n  ).then((response) => response.arrayBuffer());\n}\n\nfunction getFragmentDownloadPromise(\n  credentialsProvider: SpecialProtocolCredentialsProvider,\n  chunk: FragmentChunk,\n  parameters: MeshSourceParameters,\n  abortSignal: AbortSignal,\n) {\n  let fragmentDownloadPromise;\n  if (parameters.sharding) {\n    fragmentDownloadPromise = getVerifiedFragmentPromise(\n      credentialsProvider,\n      chunk,\n      parameters,\n      abortSignal,\n    );\n  } else {\n    fragmentDownloadPromise = fetchSpecialOk(\n      credentialsProvider,\n      `${parameters.fragmentUrl}/${chunk.fragmentId}`,\n      { signal: abortSignal },\n    ).then((response) => response.arrayBuffer());\n  }\n  return fragmentDownloadPromise;\n}\n\nasync function decodeDracoFragmentChunk(\n  chunk: FragmentChunk,\n  response: ArrayBuffer,\n) {\n  const rawMesh = await decodeDraco(new Uint8Array(response));\n  assignMeshFragmentData(chunk, rawMesh);\n}\n\n@registerSharedObject()\nexport class GrapheneMeshSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    MeshSource,\n  ),\n  MeshSourceParameters,\n) {\n  manifestRequestCount = new Map<string, number>();\n  newSegments = new Uint64Set();\n\n  addNewSegment(segment: Uint64) {\n    const { newSegments } = this;\n    newSegments.add(segment);\n    const TEN_MINUTES = 1000 * 60 * 10;\n    setTimeout(() => {\n      newSegments.delete(segment);\n    }, TEN_MINUTES);\n  }\n\n  async download(chunk: ManifestChunk, abortSignal: AbortSignal) {\n    const { parameters, newSegments, manifestRequestCount } = this;\n    if (isBaseSegmentId(chunk.objectId, parameters.nBitsForLayerId)) {\n      return decodeManifestChunk(chunk, { fragments: [] });\n    }\n    const url = `${parameters.manifestUrl}/manifest`;\n    const manifestUrl = `${url}/${chunk.objectId}:${parameters.lod}?verify=1&prepend_seg_ids=1`;\n    await fetchSpecialOk(this.credentialsProvider, manifestUrl, {\n      signal: abortSignal,\n    })\n      .then((response) => response.json())\n      .then((response) => {\n        const chunkIdentifier = manifestUrl;\n        if (newSegments.has(chunk.objectId)) {\n          const requestCount =\n            (manifestRequestCount.get(chunkIdentifier) || 0) + 1;\n          manifestRequestCount.set(chunkIdentifier, requestCount);\n          setTimeout(\n            () => {\n              this.chunkManager.queueManager.updateChunkState(\n                chunk,\n                ChunkState.QUEUED,\n              );\n            },\n            2 ** requestCount * 1000,\n          );\n        } else {\n          manifestRequestCount.delete(chunkIdentifier);\n        }\n        return decodeManifestChunk(chunk, response);\n      });\n  }\n\n  async downloadFragment(chunk: FragmentChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const response = await getFragmentDownloadPromise(\n      undefined,\n      chunk,\n      parameters,\n      abortSignal,\n    );\n    await decodeDracoFragmentChunk(chunk, response);\n  }\n\n  getFragmentKey(objectKey: string | null, fragmentId: string) {\n    objectKey;\n    return getGrapheneFragmentKey(fragmentId);\n  }\n}\n\nexport class ChunkedGraphChunk extends Chunk {\n  chunkGridPosition: Float32Array;\n  source: GrapheneChunkedGraphChunkSource | null = null;\n  segment: Uint64;\n  leaves: Uint64[] = [];\n  chunkDataSize: Uint32Array | null;\n\n  initializeVolumeChunk(key: string, chunkGridPosition: Float32Array) {\n    super.initialize(key);\n    this.chunkGridPosition = Float32Array.from(chunkGridPosition);\n  }\n\n  initializeChunkedGraphChunk(\n    key: string,\n    chunkGridPosition: Float32Array,\n    segment: Uint64,\n  ) {\n    this.initializeVolumeChunk(key, chunkGridPosition);\n    this.chunkDataSize = null;\n    this.systemMemoryBytes = 16;\n    this.gpuMemoryBytes = 0;\n    this.segment = segment;\n  }\n\n  downloadSucceeded() {\n    this.systemMemoryBytes = 16; // this.segment\n    this.systemMemoryBytes += 16 * this.leaves.length;\n    this.queueManager.updateChunkState(this, ChunkState.SYSTEM_MEMORY_WORKER);\n    if (this.priorityTier < ChunkPriorityTier.RECENT) {\n      this.source!.chunkManager.scheduleUpdateChunkPriorities();\n    }\n    super.downloadSucceeded();\n  }\n\n  freeSystemMemory() {\n    this.leaves = [];\n  }\n}\n\nfunction decodeChunkedGraphChunk(leaves: string[]) {\n  const final: Uint64[] = new Array(leaves.length);\n  for (let i = 0; i < final.length; ++i) {\n    final[i] = Uint64.parseString(leaves[i]);\n  }\n  return final;\n}\n\n@registerSharedObject()\nexport class GrapheneChunkedGraphChunkSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    ChunkSource,\n  ),\n  ChunkedGraphSourceParameters,\n) {\n  spec: ChunkedGraphChunkSpecification;\n  declare chunks: Map<string, ChunkedGraphChunk>;\n  tempChunkDataSize: Uint32Array;\n  tempChunkPosition: Float32Array;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.spec = options.spec;\n    const rank = this.spec.rank;\n    this.tempChunkDataSize = new Uint32Array(rank);\n    this.tempChunkPosition = new Float32Array(rank);\n  }\n\n  async download(\n    chunk: ChunkedGraphChunk,\n    abortSignal: AbortSignal,\n  ): Promise<void> {\n    const { parameters } = this;\n    const chunkPosition = this.computeChunkBounds(chunk);\n    const chunkDataSize = chunk.chunkDataSize!;\n    const bounds =\n      `${chunkPosition[0]}-${chunkPosition[0] + chunkDataSize[0]}_` +\n      `${chunkPosition[1]}-${chunkPosition[1] + chunkDataSize[1]}_` +\n      `${chunkPosition[2]}-${chunkPosition[2] + chunkDataSize[2]}`;\n\n    const request = fetchSpecialOk(\n      this.credentialsProvider,\n      `${parameters.url}/${chunk.segment}/leaves?int64_as_str=1&bounds=${bounds}`,\n      { signal: abortSignal },\n    );\n    await this.withErrorMessage(\n      request,\n      `Fetching leaves of segment ${chunk.segment} in region ${bounds}: `,\n    )\n      .then((res) => res.json())\n      .then((res) => {\n        chunk.leaves = decodeChunkedGraphChunk(res.leaf_ids);\n      })\n      .catch((err) => console.error(err));\n  }\n\n  getChunk(chunkGridPosition: Float32Array, segment: Uint64) {\n    const key = `${vec3Key(chunkGridPosition)}-${segment}`;\n    let chunk = <ChunkedGraphChunk>this.chunks.get(key);\n\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(ChunkedGraphChunk);\n      chunk.initializeChunkedGraphChunk(key, chunkGridPosition, segment);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n\n  computeChunkBounds(chunk: ChunkedGraphChunk) {\n    return computeChunkBounds(this, chunk);\n  }\n\n  async withErrorMessage(\n    promise: Promise<Response>,\n    errorPrefix: string,\n  ): Promise<Response> {\n    const response = await promise;\n    if (response.ok) {\n      return response;\n    }\n    let msg: string;\n    try {\n      msg = (await response.json()).message;\n    } catch {\n      msg = await response.text();\n    }\n    throw new Error(`[${response.status}] ${errorPrefix}${msg}`);\n  }\n}\n\ninterface ChunkedGraphRenderLayerAttachmentState {\n  displayDimensionRenderInfo: DisplayDimensionRenderInfo;\n  transformedSource?: TransformedSource<\n    ChunkedGraphLayer,\n    GrapheneChunkedGraphChunkSource\n  >;\n}\n\nconst tempChunkPosition = vec3.create();\nconst tempCenter = vec3.create();\nconst tempChunkSize = vec3.create();\n\n@registerSharedObject(CHUNKED_GRAPH_LAYER_RPC_ID)\nexport class ChunkedGraphLayer extends withSegmentationLayerBackendState(\n  withSharedVisibility(withChunkManager(RenderLayerBackend)),\n) {\n  source: GrapheneChunkedGraphChunkSource;\n  localPosition: SharedWatchableValue<Float32Array>;\n  leafRequestsActive: SharedWatchableValue<boolean>;\n  nBitsForLayerId: SharedWatchableValue<number>;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = this.registerDisposer(\n      rpc.getRef<GrapheneChunkedGraphChunkSource>(options.source),\n    );\n    this.localPosition = rpc.get(options.localPosition);\n    this.leafRequestsActive = rpc.get(options.leafRequestsActive);\n    this.nBitsForLayerId = rpc.get(options.nBitsForLayerId);\n\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateChunkPriorities();\n        this.debouncedupdateDisplayState();\n      }),\n    );\n  }\n\n  attach(\n    attachment: RenderLayerBackendAttachment<\n      RenderedViewBackend,\n      ChunkedGraphRenderLayerAttachmentState\n    >,\n  ): void {\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    const { view } = attachment;\n    attachment.registerDisposer(scheduleUpdateChunkPriorities);\n    attachment.registerDisposer(\n      view.projectionParameters.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(\n      view.visibility.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.state = {\n      displayDimensionRenderInfo:\n        view.projectionParameters.value.displayDimensionRenderInfo,\n    };\n  }\n\n  // Used for the sliceview to set a limit on when to\n  // make get_leaves to the ChunkedGraph\n  get renderRatioLimit() {\n    return RENDER_RATIO_LIMIT;\n  }\n\n  private updateChunkPriorities() {\n    const { source, chunkManager } = this;\n    chunkManager.registerLayer(this);\n    for (const attachment of this.attachments.values()) {\n      const { view } = attachment;\n      const visibility = view.visibility.value;\n      if (visibility === Number.NEGATIVE_INFINITY) {\n        continue;\n      }\n\n      const attachmentState =\n        attachment.state! as ChunkedGraphRenderLayerAttachmentState;\n      const { transformedSource: tsource } = attachmentState;\n      const projectionParameters = view.projectionParameters\n        .value as SliceViewProjectionParameters;\n\n      if (!tsource) {\n        continue;\n      }\n\n      const pixelSize = projectionParameters.pixelSize * 1.1;\n      const smallestVoxelSize = tsource.effectiveVoxelSize;\n      this.leafRequestsActive.value =\n        this.renderRatioLimit >= pixelSize / Math.min(...smallestVoxelSize);\n      if (!this.leafRequestsActive.value) {\n        continue;\n      }\n\n      const priorityTier = getPriorityTier(visibility);\n      const basePriority = getBasePriority(visibility);\n\n      const { chunkLayout } = tsource;\n      const { size, finiteRank } = chunkLayout;\n\n      const chunkSize = tempChunkSize;\n      const localCenter = tempCenter;\n      vec3.copy(chunkSize, size);\n      for (let i = finiteRank; i < 3; ++i) {\n        chunkSize[i] = 0;\n        localCenter[i] = 0;\n      }\n      const { centerDataPosition } = projectionParameters;\n      chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);\n\n      forEachPlaneIntersectingVolumetricChunk(\n        projectionParameters,\n        this.localPosition.value,\n        tsource,\n        getNormalizedChunkLayout(projectionParameters, chunkLayout),\n        (positionInChunks) => {\n          vec3.multiply(tempChunkPosition, positionInChunks, chunkSize);\n          const priority = -vec3.distance(localCenter, tempChunkPosition);\n          const { curPositionInChunks } = tsource;\n\n          forEachVisibleSegment(this, (segment, _) => {\n            if (isBaseSegmentId(segment, this.nBitsForLayerId.value)) return; // TODO maybe support highBitRepresentation?\n            const chunk = source.getChunk(curPositionInChunks, segment.clone());\n            chunkManager.requestChunk(\n              chunk,\n              priorityTier,\n              basePriority + priority,\n              ChunkState.SYSTEM_MEMORY_WORKER,\n            );\n            ++this.numVisibleChunksNeeded;\n            if (chunk.state === ChunkState.GPU_MEMORY) {\n              ++this.numVisibleChunksAvailable;\n            }\n          });\n        },\n      );\n    }\n  }\n\n  private forEachSelectedRootWithLeaves(\n    callback: (rootObjectKey: string, leaves: Uint64[]) => void,\n  ) {\n    const { source } = this;\n\n    for (const chunk of source.chunks.values()) {\n      if (\n        chunk.state === ChunkState.SYSTEM_MEMORY_WORKER &&\n        chunk.priorityTier < ChunkPriorityTier.RECENT\n      ) {\n        if (this.visibleSegments.has(chunk.segment) && chunk.leaves.length) {\n          callback(chunk.segment.toString(), chunk.leaves);\n        }\n      }\n    }\n  }\n\n  private debouncedupdateDisplayState = debounce(() => {\n    this.updateDisplayState();\n  }, 100);\n\n  private updateDisplayState() {\n    const visibleLeaves = new Map<string, Uint64Set>();\n    const capacities = new Map<string, number>();\n\n    // Reserve\n    this.forEachSelectedRootWithLeaves((rootObjectKey, leaves) => {\n      if (!capacities.has(rootObjectKey)) {\n        capacities.set(rootObjectKey, leaves.length);\n      } else {\n        capacities.set(\n          rootObjectKey,\n          capacities.get(rootObjectKey)! + leaves.length,\n        );\n      }\n    });\n\n    // Collect unique leaves\n    this.forEachSelectedRootWithLeaves((rootObjectKey, leaves) => {\n      if (!visibleLeaves.has(rootObjectKey)) {\n        visibleLeaves.set(rootObjectKey, new Uint64Set());\n        visibleLeaves\n          .get(rootObjectKey)!\n          .reserve(capacities.get(rootObjectKey)!);\n        visibleLeaves\n          .get(rootObjectKey)!\n          .add(Uint64.parseString(rootObjectKey));\n      }\n      visibleLeaves.get(rootObjectKey)!.add(leaves);\n    });\n\n    for (const [root, leaves] of visibleLeaves) {\n      // TODO: Delete segments not visible anymore from segmentEquivalences - requires a faster data\n      // structure, though.\n\n      /*if (this.segmentEquivalences.has(Uint64.parseString(root))) {\n        this.segmentEquivalences.delete([...this.segmentEquivalences.setElements(Uint64.parseString(root))].filter(x\n      => !leaves.has(x) && !this.visibleSegments.has(x)));\n      }*/\n      const filteredLeaves = [...leaves].filter(\n        (x) => !this.segmentEquivalences.has(x),\n      );\n\n      const rootInt = Uint64.parseString(root);\n\n      for (const leaf of filteredLeaves) {\n        this.segmentEquivalences.link(rootInt, leaf);\n      }\n    }\n  }\n}\n\nregisterRPC(CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, function (x) {\n  const view = this.get(x.view) as RenderedViewBackend;\n  const layer = this.get(x.layer) as ChunkedGraphLayer;\n  const attachment = layer.attachments.get(\n    view,\n  )! as RenderLayerBackendAttachment<\n    RenderedViewBackend,\n    ChunkedGraphRenderLayerAttachmentState\n  >;\n  attachment.state!.transformedSource = deserializeTransformedSources<\n    SliceViewChunkSourceBackend,\n    ChunkedGraphLayer\n  >(this, x.sources, layer)[0][0] as unknown as TransformedSource<\n    ChunkedGraphLayer,\n    GrapheneChunkedGraphChunkSource\n  >;\n  attachment.state!.displayDimensionRenderInfo = x.displayDimensionRenderInfo;\n  layer.chunkManager.scheduleUpdateChunkPriorities();\n});\n\nregisterRPC(GRAPHENE_MESH_NEW_SEGMENT_RPC_ID, function (x) {\n  const obj = <GrapheneMeshSource>this.get(x.rpcId);\n  obj.addNewSegment(Uint64.parseString(x.segment));\n});\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const decodeBlosc =\n  asyncComputation<(data: Uint8Array<ArrayBuffer>) => Uint8Array<ArrayBuffer>>(\n    \"decodeBlosc\",\n  );\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const decodeZstd =\n  asyncComputation<(data: Uint8Array<ArrayBuffer>) => Uint8Array<ArrayBuffer>>(\n    \"decodeZstd\",\n  );\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeBlosc } from \"#src/async_computation/decode_blosc_request.js\";\nimport { decodeZstd } from \"#src/async_computation/decode_zstd_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport {\n  VolumeChunkEncoding,\n  VolumeChunkSourceParameters,\n} from \"#src/datasource/n5/base.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport { decodeGzip } from \"#src/util/gzip.js\";\nimport { isNotFoundError } from \"#src/util/http_request.js\";\nimport type { SpecialProtocolCredentials } from \"#src/util/special_protocol_request.js\";\nimport { fetchSpecialOk } from \"#src/util/special_protocol_request.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nasync function decodeChunk(\n  chunk: VolumeChunk,\n  abortSignal: AbortSignal,\n  response: ArrayBuffer,\n  encoding: VolumeChunkEncoding,\n) {\n  const dv = new DataView(response);\n  const mode = dv.getUint16(0, /*littleEndian=*/ false);\n  if (mode !== 0) {\n    throw new Error(`Unsupported mode: ${mode}.`);\n  }\n  const numDimensions = dv.getUint16(2, /*littleEndian=*/ false);\n  if (numDimensions !== chunk.source!.spec.rank) {\n    throw new Error(\"Number of dimensions must be 3.\");\n  }\n  let offset = 4;\n  const shape = new Uint32Array(numDimensions);\n  for (let i = 0; i < numDimensions; ++i) {\n    shape[i] = dv.getUint32(offset, /*littleEndian=*/ false);\n    offset += 4;\n  }\n  chunk.chunkDataSize = shape;\n  let buffer = new Uint8Array(response, offset);\n  switch (encoding) {\n    case VolumeChunkEncoding.ZLIB:\n      buffer = new Uint8Array(await decodeGzip(buffer, \"deflate\"));\n      break;\n    case VolumeChunkEncoding.GZIP:\n      buffer = new Uint8Array(await decodeGzip(buffer, \"gzip\"));\n      break;\n    case VolumeChunkEncoding.BLOSC:\n      buffer = await requestAsyncComputation(\n        decodeBlosc,\n        abortSignal,\n        [buffer.buffer],\n        buffer,\n      );\n      break;\n    case VolumeChunkEncoding.ZSTD:\n      buffer = await requestAsyncComputation(\n        decodeZstd,\n        abortSignal,\n        [buffer.buffer],\n        buffer,\n      );\n      break;\n  }\n  await decodeRawChunk(\n    chunk,\n    abortSignal,\n    buffer.buffer,\n    Endianness.BIG,\n    buffer.byteOffset,\n    buffer.byteLength,\n  );\n}\n\n@registerSharedObject()\nexport class PrecomputedVolumeChunkSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    VolumeChunkSource,\n  ),\n  VolumeChunkSourceParameters,\n) {\n  async download(chunk: VolumeChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const { chunkGridPosition } = chunk;\n    let url = parameters.url;\n    const rank = this.spec.rank;\n    for (let i = 0; i < rank; ++i) {\n      url += `/${chunkGridPosition[i]}`;\n    }\n    try {\n      const response = await fetchSpecialOk(this.credentialsProvider, url, {\n        signal: abortSignal,\n      });\n      await decodeChunk(\n        chunk,\n        abortSignal,\n        await response.arrayBuffer(),\n        parameters.encoding,\n      );\n    } catch (e) {\n      if (!isNotFoundError(e)) throw e;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\nimport type { SingleMesh } from \"#src/single_mesh/backend.js\";\n\nexport const parseOBJFromArrayBuffer = asyncComputation<\n  (buffer: ArrayBuffer) => {\n    data: SingleMesh;\n    size: number;\n  }\n>(\"parseOBJFromArrayBuffer\");\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { parseOBJFromArrayBuffer } from \"#src/async_computation/obj_mesh_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { GenericSharedDataSource } from \"#src/chunk_manager/generic_file_source.js\";\nimport { registerSingleMeshFactory } from \"#src/single_mesh/backend.js\";\n\n/**\n * This needs to be a global function, because it identifies the instance of GenericSharedDataSource\n * to use.\n */\nfunction parse(buffer: ArrayBuffer, abortSignal: AbortSignal) {\n  return requestAsyncComputation(\n    parseOBJFromArrayBuffer,\n    abortSignal,\n    [buffer],\n    buffer,\n  );\n}\n\nregisterSingleMeshFactory(\"obj\", {\n  description: \"OBJ\",\n  getMesh: (chunkManager, credentialsProvider, url, getPriority, abortSignal) =>\n    GenericSharedDataSource.getUrl(\n      chunkManager,\n      credentialsProvider,\n      parse,\n      url,\n      getPriority,\n      abortSignal,\n    ),\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeJpeg } from \"#src/async_computation/decode_jpeg_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport { TileChunkSourceParameters } from \"#src/datasource/render/base.js\";\nimport type { ChunkDecoder } from \"#src/sliceview/backend_chunk_decoders/index.js\";\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport { vec3 } from \"#src/util/geom.js\";\nimport { fetchOk } from \"#src/util/http_request.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nconst chunkDecoders = new Map<string, ChunkDecoder>();\nchunkDecoders.set(\n  \"jpg\",\n  async (\n    chunk: VolumeChunk,\n    abortSignal: AbortSignal,\n    response: ArrayBuffer,\n  ) => {\n    const chunkDataSize = chunk.chunkDataSize!;\n    const { uint8Array: decoded } = await requestAsyncComputation(\n      decodeJpeg,\n      abortSignal,\n      [response],\n      new Uint8Array(response),\n      undefined,\n      undefined,\n      chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2],\n      3,\n      true,\n    );\n    await postProcessRawData(chunk, abortSignal, decoded);\n  },\n);\nchunkDecoders.set(\"raw16\", (chunk, abortSignal, response) => {\n  return decodeRawChunk(chunk, abortSignal, response, Endianness.BIG);\n});\n\n@registerSharedObject()\nexport class TileChunkSource extends WithParameters(\n  VolumeChunkSource,\n  TileChunkSourceParameters,\n) {\n  chunkDecoder = chunkDecoders.get(this.parameters.encoding)!;\n\n  queryString = (() => {\n    const { parameters } = this;\n    const query_params: string[] = [];\n    if (parameters.channel !== undefined) {\n      query_params.push(\"channels=\" + parameters.channel);\n    }\n    if (parameters.minIntensity !== undefined) {\n      query_params.push(\n        `minIntensity=${JSON.stringify(parameters.minIntensity)}`,\n      );\n    }\n    if (parameters.maxIntensity !== undefined) {\n      query_params.push(\n        `maxIntensity=${JSON.stringify(parameters.maxIntensity)}`,\n      );\n    }\n    if (parameters.maxTileSpecsToRender !== undefined) {\n      query_params.push(\n        `maxTileSpecsToRender=${JSON.stringify(\n          parameters.maxTileSpecsToRender,\n        )}`,\n      );\n    }\n    if (parameters.filter !== undefined) {\n      query_params.push(`filter=${JSON.stringify(parameters.filter)}`);\n    }\n    return query_params.join(\"&\");\n  })();\n\n  async download(chunk: VolumeChunk, abortSignal: AbortSignal) {\n    const { parameters } = this;\n    const { chunkGridPosition } = chunk;\n\n    // Calculate scale.\n    const scale = 1.0 / 2 ** parameters.level;\n\n    // Needed by JPEG decoder.\n    chunk.chunkDataSize = this.spec.chunkDataSize;\n\n    const xTileSize = chunk.chunkDataSize[0] * 2 ** parameters.level;\n    const yTileSize = chunk.chunkDataSize[1] * 2 ** parameters.level;\n\n    // Convert grid position to global coordinates position.\n    const chunkPosition = vec3.create();\n\n    chunkPosition[0] = chunkGridPosition[0] * xTileSize;\n    chunkPosition[1] = chunkGridPosition[1] * yTileSize;\n    chunkPosition[2] = chunkGridPosition[2];\n\n    // GET\n    // /v1/owner/{owner}/project/{project}/stack/{stack}/z/{z}/box/{x},{y},{width},{height},{scale}/jpeg-image\n    let imageMethod: string;\n    if (parameters.encoding === \"raw16\") {\n      imageMethod = \"raw16-image\";\n    } else {\n      imageMethod = \"jpeg-image\";\n    }\n    const path = `/render-ws/v1/owner/${parameters.owner}/project/${parameters.project}/stack/${parameters.stack}/z/${chunkPosition[2]}/box/${chunkPosition[0]},${chunkPosition[1]},${xTileSize},${yTileSize},${scale}/${imageMethod}`;\n    const response = await fetchOk(\n      `${parameters.baseUrl}${path}?${this.queryString}`,\n      { signal: abortSignal },\n    );\n    await this.chunkDecoder(chunk, abortSignal, await response.arrayBuffer());\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\nimport type { TriangularMesh } from \"#src/datasource/vtk/parse.js\";\n\nexport const parseVTKFromArrayBuffer = asyncComputation<\n  (buffer: ArrayBuffer) => {\n    data: TriangularMesh;\n    size: number;\n  }\n>(\"parseVTKFromArrayBuffer\");\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { parseVTKFromArrayBuffer } from \"#src/async_computation/vtk_mesh_request.js\";\nimport { GenericSharedDataSource } from \"#src/chunk_manager/generic_file_source.js\";\nimport type { SingleMesh } from \"#src/single_mesh/backend.js\";\nimport { registerSingleMeshFactory } from \"#src/single_mesh/backend.js\";\nimport { DataType } from \"#src/util/data_type.js\";\n\n/**\n * This needs to be a global function, because it identifies the instance of GenericSharedDataSource\n * to use.\n */\nfunction parse(buffer: ArrayBuffer, abortSignal: AbortSignal) {\n  return requestAsyncComputation(\n    parseVTKFromArrayBuffer,\n    abortSignal,\n    [buffer],\n    buffer,\n  );\n}\n\nregisterSingleMeshFactory(\"vtk\", {\n  description: \"VTK\",\n  getMesh: (chunkManager, credentialsProvider, url, getPriority, abortSignal) =>\n    GenericSharedDataSource.getUrl(\n      chunkManager,\n      credentialsProvider,\n      parse,\n      url,\n      getPriority,\n      abortSignal,\n    ).then((mesh) => {\n      const result: SingleMesh = {\n        info: {\n          numTriangles: mesh.numTriangles,\n          numVertices: mesh.numVertices,\n          vertexAttributes: [],\n        },\n        indices: mesh.indices,\n        vertexPositions: mesh.vertexPositions,\n        vertexAttributes: [],\n      };\n      for (const attribute of mesh.vertexAttributes) {\n        result.info.vertexAttributes.push({\n          name: attribute.name,\n          dataType: DataType.FLOAT32,\n          numComponents: attribute.numComponents,\n        });\n        result.vertexAttributes.push(attribute.data);\n      }\n      return result;\n    }),\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport type {\n  CodecArrayInfo,\n  CodecChainSpec,\n} from \"#src/datasource/zarr/codec/index.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport type { ReadableKvStore } from \"#src/kvstore/index.js\";\nimport type { RefCounted } from \"#src/util/disposable.js\";\n\nexport interface Codec {\n  name: string;\n  kind: CodecKind;\n}\n\nexport interface ArrayToArrayCodec<Configuration = unknown> extends Codec {\n  kind: CodecKind.arrayToArray;\n  decode(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n    encoded: ArrayBufferView<ArrayBuffer>,\n    abortSignal: AbortSignal,\n  ): Promise<ArrayBufferView<ArrayBuffer>>;\n}\n\nexport interface ArrayToBytesCodec<Configuration = unknown> extends Codec {\n  kind: CodecKind.arrayToBytes;\n  decode(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n    encoded: Uint8Array<ArrayBuffer>,\n    abortSignal: AbortSignal,\n  ): Promise<ArrayBufferView<ArrayBuffer>>;\n}\n\nexport type ShardingKey<BaseKey> = {\n  base: BaseKey;\n  subChunk: number[];\n};\n\nexport interface ShardingCodec<Configuration = unknown> extends Codec {\n  kind: CodecKind.arrayToBytes;\n  getShardedKvStore<BaseKey>(\n    configuration: Configuration,\n    chunkManager: ChunkManager,\n    base: ReadableKvStore<BaseKey>,\n  ): ReadableKvStore<ShardingKey<BaseKey>> & RefCounted;\n}\n\nexport interface BytesToBytesCodec<Configuration = unknown> extends Codec {\n  kind: CodecKind.bytesToBytes;\n  decode(\n    configuration: Configuration,\n    encoded: Uint8Array<ArrayBuffer>,\n    abortSignal: AbortSignal,\n  ): Promise<Uint8Array<ArrayBuffer>>;\n}\n\nconst codecRegistry = {\n  [CodecKind.arrayToArray]: new Map<string, ArrayToArrayCodec>(),\n  [CodecKind.arrayToBytes]: new Map<string, ArrayToBytesCodec>(),\n  [CodecKind.bytesToBytes]: new Map<string, BytesToBytesCodec>(),\n  sharding: new Map<string, ShardingCodec>(),\n};\n\nexport function registerCodec<Configuration>(\n  codec:\n    | ArrayToArrayCodec<Configuration>\n    | ArrayToBytesCodec<Configuration>\n    | BytesToBytesCodec<Configuration>\n    | ShardingCodec<Configuration>,\n) {\n  if (codec.kind === CodecKind.arrayToBytes && \"getShardedKvStore\" in codec) {\n    codecRegistry.sharding.set(codec.name, codec as any);\n  } else {\n    codecRegistry[codec.kind].set(codec.name, codec as any);\n  }\n}\n\nexport async function decodeArray(\n  codecs: CodecChainSpec,\n  encoded: Uint8Array<ArrayBuffer>,\n  abortSignal: AbortSignal,\n): Promise<ArrayBufferView<ArrayBuffer>> {\n  const bytesToBytes = codecs[CodecKind.bytesToBytes];\n  for (let i = bytesToBytes.length; i--; ) {\n    const codec = bytesToBytes[i];\n    const impl = codecRegistry[CodecKind.bytesToBytes].get(codec.name);\n    if (impl === undefined) {\n      throw new Error(`Unsupported codec: ${JSON.stringify(codec.name)}`);\n    }\n    encoded = await impl.decode(codec.configuration, encoded, abortSignal);\n  }\n\n  let decoded: ArrayBufferView<ArrayBuffer>;\n  {\n    const codec = codecs[CodecKind.arrayToBytes];\n    const impl = codecRegistry[CodecKind.arrayToBytes].get(codec.name);\n    if (impl === undefined) {\n      throw new Error(`Unsupported codec: ${JSON.stringify(codec.name)}`);\n    }\n    decoded = await impl.decode(\n      codec.configuration,\n      codecs.arrayInfo[codecs.arrayInfo.length - 1],\n      encoded,\n      abortSignal,\n    );\n  }\n\n  const arrayToArray = codecs[CodecKind.arrayToArray];\n  for (let i = arrayToArray.length; i--; ) {\n    const codec = arrayToArray[i];\n    const impl = codecRegistry[CodecKind.arrayToArray].get(codec.name);\n    if (impl === undefined) {\n      throw new Error(`Unsupported codec: ${JSON.stringify(codec.name)}`);\n    }\n    decoded = await impl.decode(\n      codec.configuration,\n      codecs.arrayInfo[i],\n      decoded,\n      abortSignal,\n    );\n  }\n\n  return decoded;\n}\n\nexport function applySharding(\n  chunkManager: ChunkManager,\n  codecs: CodecChainSpec,\n  baseKvStore: ReadableKvStore<string>,\n): {\n  kvStore: ReadableKvStore<unknown>;\n  getChunkKey: (\n    chunkGridPosition: ArrayLike<number>,\n    baseKey: string,\n  ) => unknown;\n  decodeCodecs: CodecChainSpec;\n} {\n  let kvStore: ReadableKvStore<unknown> = baseKvStore;\n  let curCodecs = codecs;\n  while (true) {\n    const { shardingInfo } = curCodecs;\n    if (shardingInfo === undefined) break;\n    const codec = curCodecs[CodecKind.arrayToBytes];\n    const impl = codecRegistry.sharding.get(codec.name);\n    if (impl === undefined) {\n      throw new Error(`Unsupported codec: ${JSON.stringify(codec.name)}`);\n    }\n    kvStore = impl.getShardedKvStore(\n      codec.configuration,\n      chunkManager,\n      kvStore,\n    );\n    curCodecs = shardingInfo.subChunkCodecs;\n  }\n\n  const decodeCodecs = curCodecs;\n\n  function getChunkKey(\n    chunkGridPosition: ArrayLike<number>,\n    baseKey: string,\n  ): unknown {\n    let key: unknown = baseKey;\n    const rank = chunkGridPosition.length;\n    let curCodecs = codecs;\n    while (curCodecs.shardingInfo !== undefined) {\n      const layoutInfo = codecs.layoutInfo[codecs.layoutInfo.length - 1];\n      const { physicalToLogicalDimension, readChunkShape } = layoutInfo;\n      const { subChunkShape, subChunkGridShape, subChunkCodecs } =\n        curCodecs.shardingInfo;\n      const subChunk = new Array<number>(rank);\n      for (\n        let fOrderPhysicalDim = 0;\n        fOrderPhysicalDim < rank;\n        ++fOrderPhysicalDim\n      ) {\n        const subChunkDim =\n          physicalToLogicalDimension[rank - 1 - fOrderPhysicalDim];\n        subChunk[subChunkDim] =\n          Math.floor(\n            (chunkGridPosition[fOrderPhysicalDim] *\n              readChunkShape[subChunkDim]) /\n              subChunkShape[subChunkDim],\n          ) % subChunkGridShape[subChunkDim];\n      }\n      key = { base: key, subChunk };\n      curCodecs = subChunkCodecs;\n    }\n    return key;\n  }\n\n  return { kvStore, getChunkKey, decodeCodecs };\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeBlosc } from \"#src/async_computation/decode_blosc_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport type { Configuration } from \"#src/datasource/zarr/codec/blosc/resolve.js\";\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\n\nregisterCodec({\n  name: \"blosc\",\n  kind: CodecKind.bytesToBytes,\n  decode(configuration: Configuration, encoded, abortSignal: AbortSignal) {\n    configuration;\n    return requestAsyncComputation(\n      decodeBlosc,\n      abortSignal,\n      [encoded.buffer],\n      encoded,\n    );\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeZstd } from \"#src/async_computation/decode_zstd_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport type { Configuration } from \"#src/datasource/zarr/codec/zstd/resolve.js\";\n\nregisterCodec({\n  name: \"zstd\",\n  kind: CodecKind.bytesToBytes,\n  decode(configuration: Configuration, encoded, abortSignal: AbortSignal) {\n    configuration;\n    return requestAsyncComputation(\n      decodeZstd,\n      abortSignal,\n      [encoded.buffer],\n      encoded,\n    );\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Configuration } from \"#src/datasource/zarr/codec/bytes/resolve.js\";\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport type { CodecArrayInfo } from \"#src/datasource/zarr/codec/index.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport { DATA_TYPE_BYTES, makeDataTypeArrayView } from \"#src/util/data_type.js\";\nimport { convertEndian } from \"#src/util/endian.js\";\n\nregisterCodec({\n  name: \"bytes\",\n  kind: CodecKind.arrayToBytes,\n  async decode(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n    encoded,\n    abortSignal: AbortSignal,\n  ) {\n    abortSignal;\n    const { dataType, chunkShape } = decodedArrayInfo;\n    const numElements = chunkShape.reduce((a, b) => a * b, 1);\n    const bytesPerElement = DATA_TYPE_BYTES[dataType];\n    const expectedBytes = numElements * bytesPerElement;\n    if (encoded.byteLength !== expectedBytes) {\n      throw new Error(\n        `Raw-format chunk is ${encoded.byteLength} bytes, ` +\n          `but ${numElements} * ${bytesPerElement} = ${expectedBytes} bytes are expected.`,\n      );\n    }\n    const data = makeDataTypeArrayView(\n      dataType,\n      encoded.buffer,\n      encoded.byteOffset,\n      encoded.byteLength,\n    );\n    convertEndian(data, configuration.endian, bytesPerElement);\n    return data;\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Configuration } from \"#src/datasource/zarr/codec/crc32c/resolve.js\";\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\n\nconst checksumSize = 4;\n\nregisterCodec({\n  name: \"crc32c\",\n  kind: CodecKind.bytesToBytes,\n  async decode(\n    configuration: Configuration,\n    encoded,\n    abortSignal: AbortSignal,\n  ) {\n    configuration;\n    abortSignal;\n    if (encoded.length < checksumSize) {\n      throw new Error(\n        `Expected buffer of size at least ${checksumSize} bytes but received: ${encoded.length} bytes`,\n      );\n    }\n    // TODO(jbms): Actually verify checksum.\n    return encoded.subarray(0, encoded.length - checksumSize);\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport type { Configuration } from \"#src/datasource/zarr/codec/gzip/resolve.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport { decodeGzip } from \"#src/util/gzip.js\";\n\nfor (const [name, compressionFormat] of [\n  [\"gzip\", \"gzip\"],\n  [\"zlib\", \"deflate\"],\n] as const) {\n  registerCodec({\n    name,\n    kind: CodecKind.bytesToBytes,\n    async decode(\n      configuration: Configuration,\n      encoded,\n      abortSignal: AbortSignal,\n    ) {\n      configuration;\n      return new Uint8Array(\n        await decodeGzip(encoded, compressionFormat, abortSignal),\n      );\n    },\n  });\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  verifyObject,\n  verifyObjectProperty,\n  verifyString,\n} from \"#src/util/json.js\";\n\nexport function parseNameAndConfiguration<Name, Configuration>(\n  obj: unknown,\n  parseName: (name: string) => Name,\n  parseConfiguration: (configuration: unknown, name: Name) => Configuration,\n): { name: Name; configuration: Configuration } {\n  verifyObject(obj);\n  const name = verifyObjectProperty(obj, \"name\", (value) =>\n    parseName(verifyString(value)),\n  );\n  const configuration = verifyObjectProperty(obj, \"configuration\", (value) => {\n    if (value === undefined) {\n      value = {};\n    } else {\n      verifyObject(value);\n    }\n    return parseConfiguration(value, name);\n  });\n  return { name, configuration };\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { parseCodecChainSpec } from \"#src/datasource/zarr/codec/resolve.js\";\nimport type {\n  ArrayMetadata,\n  DimensionSeparator,\n  Metadata,\n  NodeType,\n} from \"#src/datasource/zarr/metadata/index.js\";\nimport { ChunkKeyEncoding } from \"#src/datasource/zarr/metadata/index.js\";\nimport { parseNameAndConfiguration } from \"#src/datasource/zarr/metadata/parse_util.js\";\nimport { DATA_TYPE_BYTES, DataType } from \"#src/util/data_type.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport {\n  parseArray,\n  parseFixedLengthArray,\n  verifyConstant,\n  verifyEnumString,\n  verifyInt,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalFixedLengthArrayOfStringOrNull,\n  verifyOptionalObjectProperty,\n  verifyString,\n} from \"#src/util/json.js\";\nimport { parseNumpyDtype } from \"#src/util/numpy_dtype.js\";\nimport { allSiPrefixes } from \"#src/util/si_units.js\";\n\nfunction parseShape(obj: unknown): number[] {\n  return parseArray(obj, (x) => {\n    if (typeof x !== \"number\" || !Number.isInteger(x) || x < 0) {\n      throw new Error(\n        `Expected non-negative integer, but received: ${JSON.stringify(x)}`,\n      );\n    }\n    return x;\n  });\n}\n\nexport function parseChunkShape(obj: unknown, rank: number): number[] {\n  return parseFixedLengthArray(new Array<number>(rank), obj, (x) => {\n    if (typeof x !== \"number\" || !Number.isInteger(x) || x <= 0) {\n      throw new Error(\n        `Expected positive integer, but received: ${JSON.stringify(x)}`,\n      );\n    }\n    return x;\n  });\n}\n\nexport function parseDimensionSeparator(value: unknown): \"/\" | \".\" {\n  if (value !== \".\" && value !== \"/\") {\n    throw new Error(\n      `Expected \".\" or \"/\", but received: ${JSON.stringify(value)}`,\n    );\n  }\n  return value;\n}\n\nconst UNITS = new Map<string, { unit: string; scale: number }>([\n  [\"\", { unit: \"\", scale: 1 }],\n  [\"angstrom\", { unit: \"m\", scale: 1e-10 }],\n  [\"foot\", { unit: \"m\", scale: 0.3048 }],\n  [\"inch\", { unit: \"m\", scale: 0.0254 }],\n  [\"mile\", { unit: \"m\", scale: 1609.34 }],\n  // eslint-disable-next-line no-loss-of-precision\n  [\"parsec\", { unit: \"m\", scale: 3.0856775814913673e16 }],\n  [\"yard\", { unit: \"m\", scale: 0.9144 }],\n  [\"minute\", { unit: \"s\", scale: 60 }],\n  [\"hour\", { unit: \"s\", scale: 60 * 60 }],\n  [\"day\", { unit: \"s\", scale: 60 * 60 * 24 }],\n]);\n\nfor (const unit of [\"meter\", \"second\"]) {\n  for (const siPrefix of allSiPrefixes) {\n    const { longPrefix, prefix } = siPrefix;\n    if (longPrefix === undefined) continue;\n    const unitInfo = { unit: unit[0], scale: 10 ** siPrefix.exponent };\n    UNITS.set(`${longPrefix}${unit}`, unitInfo);\n    UNITS.set(`${prefix}${unit[0]}`, unitInfo);\n  }\n}\n\nexport function parseDimensionUnit(obj: unknown): {\n  scale: number;\n  unit: string;\n} {\n  if (obj === null) {\n    // Default unit\n    return { scale: 1, unit: \"\" };\n  }\n  if (typeof obj !== \"string\") {\n    throw new Error(`Expected string but received: ${JSON.stringify(obj)}`);\n  }\n  const s = obj.trim();\n  const numberPattern =\n    /^([-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)(?:[eE][-+]?\\d+)?)\\s*(.*)/;\n  const m = s.match(numberPattern);\n  let scale: number;\n  let derivedUnit: string;\n  if (m === null) {\n    scale = 1;\n    derivedUnit = s;\n  } else {\n    scale = Number(m[1]);\n    derivedUnit = m[2];\n  }\n  const unitInfo = UNITS.get(derivedUnit);\n  if (unitInfo === undefined) {\n    throw new Error(`Unsupported unit: ${JSON.stringify(derivedUnit)}`);\n  }\n  return { unit: unitInfo.unit, scale: scale * unitInfo.scale };\n}\n\nfunction parseFillValue(dataType: DataType, value: unknown) {\n  switch (dataType) {\n    case DataType.UINT8:\n    case DataType.INT8:\n    case DataType.UINT16:\n    case DataType.INT16:\n    case DataType.UINT32:\n    case DataType.INT32:\n    case DataType.UINT64:\n      if (typeof value !== \"number\" || !Number.isInteger(value)) {\n        throw new Error(\n          `Expected integer but received: ${JSON.stringify(value)}`,\n        );\n      }\n      return value;\n    case DataType.FLOAT32:\n      if (typeof value === \"number\") {\n        return value;\n      }\n      if (typeof value === \"string\") {\n        if (value === \"Infinity\") {\n          return Number.POSITIVE_INFINITY;\n        }\n        if (value === \"-Infinity\") {\n          return Number.NEGATIVE_INFINITY;\n        }\n        if (value === \"NaN\") {\n          return new Float32Array(Uint32Array.of(0x7fc00000).buffer)[0];\n        }\n        if (value.match(/^0x[a-fA-F0-9]+$/)) {\n          return new Float32Array(Uint32Array.of(Number(value)).buffer)[0];\n        }\n      }\n      throw new Error(\n        `Expected number, \"Infinity\", \"-Infinity\", \"NaN\", or hex string but received: ${JSON.stringify(\n          value,\n        )}`,\n      );\n  }\n}\n\nexport function parseV3Metadata(\n  obj: unknown,\n  expectedNodeType: NodeType | undefined,\n): Metadata {\n  try {\n    verifyObject(obj);\n    verifyObjectProperty(obj, \"zarr_format\", (value) => {\n      verifyConstant(value, 3);\n    });\n    const nodeType: NodeType = verifyObjectProperty(\n      obj,\n      \"node_type\",\n      (value) => {\n        if (expectedNodeType !== undefined) {\n          verifyConstant(value, expectedNodeType);\n        }\n        if (value !== \"array\" && value !== \"group\") {\n          throw new Error(\n            `Expected \"array\" or \"group\" but received: ${JSON.stringify(\n              value,\n            )}`,\n          );\n        }\n        return value;\n      },\n    );\n    expectedNodeType = nodeType;\n\n    if (nodeType === \"group\") {\n      return {\n        zarrVersion: 3,\n        nodeType: \"group\",\n        userAttributes: verifyOptionalObjectProperty(\n          obj,\n          \"attributes\",\n          verifyObject,\n          {},\n        ),\n      };\n    }\n\n    const shape = verifyObjectProperty(obj, \"shape\", parseShape);\n    const rank = shape.length;\n\n    const dimensionNames = verifyObjectProperty(\n      obj,\n      \"dimension_names\",\n      (names) =>\n        verifyOptionalFixedLengthArrayOfStringOrNull(names ?? undefined, rank),\n    );\n\n    const dataType = verifyObjectProperty(obj, \"data_type\", (x) =>\n      verifyEnumString(x, DataType, /^[a-z0-9]+$/),\n    );\n\n    const { configuration: chunkShape } = verifyObjectProperty(\n      obj,\n      \"chunk_grid\",\n      (chunkGrid) =>\n        parseNameAndConfiguration(\n          chunkGrid,\n          (name) => verifyConstant(name, \"regular\"),\n          (configuration) =>\n            verifyObjectProperty(configuration, \"chunk_shape\", (chunks) =>\n              parseChunkShape(chunks, rank),\n            ),\n        ),\n    );\n\n    const { userAttributes, dimensionUnits } = verifyObjectProperty(\n      obj,\n      \"attributes\",\n      (x) => {\n        if (x === undefined) {\n          x = {};\n        }\n        verifyObject(x);\n        const dimensionUnits = verifyObjectProperty(\n          x,\n          \"dimension_units\",\n          (units) => verifyOptionalFixedLengthArrayOfStringOrNull(units, rank),\n        );\n        return { userAttributes: x, dimensionUnits };\n      },\n    );\n\n    const { configuration: dimensionSeparator, name: chunkKeyEncoding } =\n      verifyObjectProperty(obj, \"chunk_key_encoding\", (value) =>\n        parseNameAndConfiguration(\n          value,\n          (name) => verifyEnumString(name, ChunkKeyEncoding, /^(v2|default)$/),\n          (configuration, chunkKeyEncoding) =>\n            verifyOptionalObjectProperty(\n              configuration,\n              \"separator\",\n              parseDimensionSeparator,\n              chunkKeyEncoding === ChunkKeyEncoding.DEFAULT ? \"/\" : \".\",\n            ),\n        ),\n      );\n\n    const fillValue = verifyObjectProperty(obj, \"fill_value\", (value) =>\n      parseFillValue(dataType, value),\n    );\n\n    const codecs = verifyObjectProperty(obj, \"codecs\", (value) =>\n      parseCodecChainSpec(value, { dataType, chunkShape }),\n    );\n\n    return {\n      zarrVersion: 3,\n      nodeType,\n      rank,\n      shape,\n      chunkShape,\n      dataType,\n      fillValue,\n      dimensionNames,\n      dimensionUnits,\n      chunkKeyEncoding,\n      dimensionSeparator,\n      userAttributes,\n      codecs,\n    };\n  } catch (e) {\n    const nodeStr =\n      expectedNodeType === undefined ? \"\" : `${expectedNodeType} `;\n    throw new Error(`Error parsing zarr v3 ${nodeStr}metadata: ${e.message}`);\n  }\n}\n\nexport function parseV2Metadata(\n  obj: unknown,\n  attrs: Record<string, unknown>,\n  explicitDimensionSeparator: \".\" | \"/\" | undefined,\n): ArrayMetadata {\n  try {\n    verifyObject(obj);\n    verifyObjectProperty(obj, \"zarr_format\", (value) => {\n      verifyConstant(value, 2);\n    });\n    const shape = verifyObjectProperty(obj, \"shape\", parseShape);\n    const rank = shape.length;\n    const chunkShape = verifyObjectProperty(obj, \"chunks\", (chunks) =>\n      parseChunkShape(chunks, rank),\n    );\n    const order = verifyObjectProperty(obj, \"order\", (order) => {\n      if (order !== \"C\" && order !== \"F\") {\n        throw new Error(\n          `Expected \"C\" or \"F\", but received: ${JSON.stringify(order)}`,\n        );\n      }\n      return order;\n    });\n    const dimensionSeparator: DimensionSeparator = verifyOptionalObjectProperty(\n      obj,\n      \"dimension_separator\",\n      explicitDimensionSeparator === undefined\n        ? parseDimensionSeparator\n        : (value) => verifyConstant(value, explicitDimensionSeparator),\n      explicitDimensionSeparator ?? \".\",\n    );\n    const numpyDtype = verifyObjectProperty(obj, \"dtype\", (dtype) =>\n      parseNumpyDtype(verifyString(dtype)),\n    );\n\n    const dataType = numpyDtype.dataType;\n    const fillValue = verifyObjectProperty(obj, \"fill_value\", (value) => {\n      if (value === null) {\n        return 0;\n      }\n      return parseFillValue(dataType, value);\n    });\n\n    const codecs = [];\n    if (order === \"F\") {\n      codecs.push({\n        name: \"transpose\",\n        configuration: { order: Array.from(shape, (_, i) => rank - i - 1) },\n      });\n    }\n    codecs.push({\n      name: \"bytes\",\n      configuration: {\n        endian: numpyDtype.endianness === Endianness.LITTLE ? \"little\" : \"big\",\n      },\n    });\n    verifyObjectProperty(obj, \"compressor\", (compressor) => {\n      if (compressor === null) return;\n      verifyObject(compressor);\n      const id = verifyObjectProperty(compressor, \"id\", verifyString);\n      switch (id) {\n        case \"blosc\":\n          codecs.push({\n            name: \"blosc\",\n            configuration: {\n              cname: verifyObjectProperty(compressor, \"cname\", verifyString),\n              clevel: verifyObjectProperty(compressor, \"clevel\", verifyInt),\n              typesize: DATA_TYPE_BYTES[dataType],\n              shuffle: verifyObjectProperty(\n                compressor,\n                \"shuffle\",\n                (shuffle) => {\n                  switch (shuffle) {\n                    case -1:\n                      return DATA_TYPE_BYTES[dataType] === 1\n                        ? \"bitshuffle\"\n                        : \"shuffle\";\n                    case 0:\n                      return \"noshuffle\";\n                    case 1:\n                      return \"shuffle\";\n                    case 2:\n                      return \"bitshuffle\";\n                  }\n                  throw new Error(`Invalid value: ${JSON.stringify(shuffle)}`);\n                },\n              ),\n              blocksize: verifyOptionalObjectProperty(\n                compressor,\n                \"blocksize\",\n                verifyInt,\n                0,\n              ),\n            },\n          });\n          break;\n        case \"zlib\":\n        case \"gzip\":\n        case \"zstd\":\n          codecs.push({\n            name: id,\n            configuration: {\n              level: verifyObjectProperty(compressor, \"level\", verifyInt),\n            },\n          });\n          break;\n        default:\n          throw new Error(`Unsupported compressor: ${JSON.stringify(id)}`);\n      }\n    });\n\n    const codecChainSpec = parseCodecChainSpec(codecs, {\n      dataType,\n      chunkShape,\n    });\n\n    return {\n      zarrVersion: 2,\n      nodeType: \"array\",\n      rank,\n      shape,\n      chunkShape,\n      dataType,\n      fillValue,\n      dimensionNames: verifyObjectProperty(\n        attrs,\n        \"_ARRAY_DIMENSIONS\",\n        (names) => verifyOptionalFixedLengthArrayOfStringOrNull(names, rank),\n      ),\n      dimensionUnits: verifyObjectProperty(attrs, \"dimension_units\", (units) =>\n        verifyOptionalFixedLengthArrayOfStringOrNull(units, rank),\n      ),\n      userAttributes: attrs,\n      dimensionSeparator,\n      chunkKeyEncoding: ChunkKeyEncoding.V2,\n      codecs: codecChainSpec,\n    };\n  } catch (e) {\n    throw new Error(`Error parsing zarr v2 metadata: ${e.message}`);\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ByteRange {\n  offset: number;\n  length: number;\n}\n\nexport function composeByteRangeRequest(\n  outer: ByteRange,\n  inner: ByteRangeRequest | undefined,\n): { outer: ByteRange; inner: ByteRange } {\n  if (inner === undefined) {\n    return { outer, inner: { offset: 0, length: outer.length } };\n  }\n  if (\"suffixLength\" in inner) {\n    const length = Math.min(outer.length, inner.suffixLength);\n    return {\n      outer: { offset: outer.offset + (outer.length - length), length },\n      inner: { offset: outer.length - length, length },\n    };\n  }\n  if (inner.offset + inner.length > outer.length) {\n    throw new Error(\n      `Requested byte range ${JSON.stringify(\n        inner,\n      )} not valid for value of length ${outer.length}`,\n    );\n  }\n  return {\n    outer: { offset: outer.offset + inner.offset, length: inner.length },\n    inner,\n  };\n}\n\nexport type ByteRangeRequest =\n  | ByteRange\n  | {\n      suffixLength: number;\n    };\n\nexport interface ReadResponse {\n  data: Uint8Array<ArrayBuffer>;\n  dataRange: ByteRange;\n  totalSize: number | undefined;\n}\n\nexport interface ReadOptions {\n  byteRange?: ByteRangeRequest;\n  abortSignal?: AbortSignal;\n}\n\nexport interface ListOptions {\n  prefix: string;\n  abortSignal?: AbortSignal;\n}\n\nexport interface ListEntry {\n  key: string;\n}\n\nexport interface ListResponse {\n  entries: ListEntry[];\n  directories: string[];\n}\n\nexport interface ReadableKvStore<Key = string> {\n  read(key: Key, options: ReadOptions): Promise<ReadResponse | undefined>;\n}\n\nexport interface ListableKvStore {\n  list(options: ListOptions): Promise<ListResponse>;\n}\n\nexport interface KvStore extends ReadableKvStore, ListableKvStore {}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport { SimpleAsyncCache } from \"#src/chunk_manager/generic_file_source.js\";\nimport {\n  decodeArray,\n  registerCodec,\n} from \"#src/datasource/zarr/codec/decode.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport type { Configuration } from \"#src/datasource/zarr/codec/sharding_indexed/resolve.js\";\nimport { ShardIndexLocation } from \"#src/datasource/zarr/codec/sharding_indexed/resolve.js\";\nimport type {\n  ByteRangeRequest,\n  ReadableKvStore,\n  ReadOptions,\n  ReadResponse,\n} from \"#src/kvstore/index.js\";\nimport { composeByteRangeRequest } from \"#src/kvstore/index.js\";\nimport type { Owned } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\n\ntype ShardIndex = BigUint64Array | undefined;\n\nconst MISSING_VALUE = BigInt(\"18446744073709551615\");\n\nclass ShardedKvStore<BaseKey>\n  extends RefCounted\n  implements ReadableKvStore<{ base: BaseKey; subChunk: number[] }>\n{\n  private indexCache: Owned<SimpleAsyncCache<BaseKey, ShardIndex>>;\n  private indexStrides: number[];\n  constructor(\n    private configuration: Configuration,\n    chunkManager: ChunkManager,\n    private base: ReadableKvStore<BaseKey>,\n  ) {\n    super();\n    this.indexCache = this.registerDisposer(\n      new SimpleAsyncCache(chunkManager.addRef(), {\n        get: async (key: BaseKey, abortSignal: AbortSignal) => {\n          const { indexCodecs } = configuration;\n          const encodedSize =\n            indexCodecs.encodedSize[indexCodecs.encodedSize.length - 1];\n          let byteRange: ByteRangeRequest;\n          switch (configuration.indexLocation) {\n            case ShardIndexLocation.START:\n              byteRange = { offset: 0, length: encodedSize! };\n              break;\n            case ShardIndexLocation.END:\n              byteRange = { suffixLength: encodedSize! };\n              break;\n          }\n          const response = await base.read(key, {\n            abortSignal,\n            byteRange,\n          });\n          if (response === undefined) {\n            return { size: 0, data: undefined };\n          }\n          const index = await decodeArray(\n            configuration.indexCodecs,\n            response.data,\n            abortSignal,\n          );\n          return {\n            size: index.byteLength,\n            data: new BigUint64Array(\n              index.buffer,\n              index.byteOffset,\n              index.byteLength / 8,\n            ),\n          };\n        },\n      }),\n    );\n    const { subChunkGridShape } = this.configuration;\n    const rank = subChunkGridShape.length;\n    const physicalToLogicalIndexDimension =\n      this.configuration.indexCodecs.layoutInfo[0].physicalToLogicalDimension;\n    const indexStrides = (this.indexStrides = new Array(rank + 1));\n    let stride = 1;\n    for (\n      let physicalIndexDim = rank;\n      physicalIndexDim >= 0;\n      --physicalIndexDim\n    ) {\n      const logicalIndexDim = physicalToLogicalIndexDimension[physicalIndexDim];\n      indexStrides[logicalIndexDim] = stride;\n      stride *=\n        logicalIndexDim === rank ? 2 : subChunkGridShape[logicalIndexDim];\n    }\n  }\n\n  async read(\n    key: { base: BaseKey; subChunk: number[] },\n    options: ReadOptions,\n  ): Promise<ReadResponse | undefined> {\n    const shardIndex = await this.indexCache.get(key.base, options.abortSignal);\n    if (shardIndex === undefined) {\n      // Shard not present.\n      return undefined;\n    }\n    const rank = this.configuration.subChunkShape.length;\n    const { subChunk } = key;\n    const { indexStrides } = this;\n    let indexOffset = 0;\n    for (let logicalIndexDim = 0; logicalIndexDim < rank; ++logicalIndexDim) {\n      const pos = subChunk[logicalIndexDim];\n      indexOffset += pos * indexStrides[logicalIndexDim];\n    }\n    const dataOffset = shardIndex[indexOffset];\n    const dataLength = shardIndex[indexOffset + indexStrides[rank]];\n    if (dataOffset === MISSING_VALUE && dataLength === MISSING_VALUE) {\n      // Sub-chunk not present.\n      return undefined;\n    }\n    const fullByteRange = {\n      offset: Number(dataOffset),\n      length: Number(dataLength),\n    };\n    const { outer: outerByteRange, inner: innerByteRange } =\n      composeByteRangeRequest(fullByteRange, options.byteRange);\n    if (outerByteRange.length === 0) {\n      return {\n        data: new Uint8Array(0),\n        dataRange: innerByteRange,\n        totalSize: fullByteRange.length,\n      };\n    }\n    const response = await this.base.read(key.base, {\n      abortSignal: options.abortSignal,\n      byteRange: outerByteRange,\n    });\n    if (response === undefined) {\n      // Shard unexpectedly deleted.\n      return undefined;\n    }\n    if (\n      response.dataRange.offset !== outerByteRange.offset ||\n      response.dataRange.length !== outerByteRange.length\n    ) {\n      throw new Error(\n        `Received truncated response, expected ${JSON.stringify(\n          outerByteRange,\n        )} but received ${JSON.stringify(response.dataRange)}`,\n      );\n    }\n    return {\n      data: response.data,\n      dataRange: innerByteRange,\n      totalSize: fullByteRange.length,\n    };\n  }\n}\n\nregisterCodec({\n  name: \"sharding_indexed\",\n  kind: CodecKind.arrayToBytes,\n  getShardedKvStore<BaseKey>(\n    configuration: Configuration,\n    chunkManager: ChunkManager,\n    base: ReadableKvStore<BaseKey>,\n  ): ReadableKvStore<{ base: BaseKey; subChunk: number[] }> & RefCounted {\n    return new ShardedKvStore(configuration, chunkManager, base);\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport type { CodecArrayInfo } from \"#src/datasource/zarr/codec/index.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport type { Configuration } from \"#src/datasource/zarr/codec/transpose/resolve.js\";\n\nregisterCodec({\n  name: \"transpose\",\n  kind: CodecKind.arrayToArray,\n  async decode(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n    encoded,\n    abortSignal: AbortSignal,\n  ) {\n    decodedArrayInfo;\n    abortSignal;\n    configuration;\n    return encoded;\n  },\n});\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport \"#src/datasource/zarr/codec/blosc/decode.js\";\nimport \"#src/datasource/zarr/codec/zstd/decode.js\";\nimport \"#src/datasource/zarr/codec/bytes/decode.js\";\nimport \"#src/datasource/zarr/codec/crc32c/decode.js\";\n\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport { VolumeChunkSourceParameters } from \"#src/datasource/zarr/base.js\";\nimport {\n  applySharding,\n  decodeArray,\n} from \"#src/datasource/zarr/codec/decode.js\";\nimport \"#src/datasource/zarr/codec/gzip/decode.js\";\nimport \"#src/datasource/zarr/codec/sharding_indexed/decode.js\";\nimport \"#src/datasource/zarr/codec/transpose/decode.js\";\nimport { ChunkKeyEncoding } from \"#src/datasource/zarr/metadata/index.js\";\nimport { getSpecialProtocolKvStore } from \"#src/kvstore/special/index.js\";\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport type { SpecialProtocolCredentials } from \"#src/util/special_protocol_request.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\n@registerSharedObject()\nexport class ZarrVolumeChunkSource extends WithParameters(\n  WithSharedCredentialsProviderCounterpart<SpecialProtocolCredentials>()(\n    VolumeChunkSource,\n  ),\n  VolumeChunkSourceParameters,\n) {\n  private chunkKvStore = applySharding(\n    this.chunkManager,\n    this.parameters.metadata.codecs,\n    getSpecialProtocolKvStore(\n      this.credentialsProvider,\n      this.parameters.url + \"/\",\n    ),\n  );\n\n  async download(chunk: VolumeChunk, abortSignal: AbortSignal) {\n    chunk.chunkDataSize = this.spec.chunkDataSize;\n    const { parameters } = this;\n    const { chunkGridPosition } = chunk;\n    const { metadata } = parameters;\n    let baseKey = \"\";\n    const rank = this.spec.rank;\n    const { physicalToLogicalDimension } = metadata.codecs.layoutInfo[0];\n    let sep: string;\n    if (metadata.chunkKeyEncoding === ChunkKeyEncoding.DEFAULT) {\n      baseKey += \"c\";\n      sep = metadata.dimensionSeparator;\n    } else {\n      sep = \"\";\n      if (rank === 0) {\n        baseKey += \"0\";\n      }\n    }\n    const keyCoords = new Array<number>(rank);\n    const { readChunkShape } = metadata.codecs.layoutInfo[0];\n    const { chunkShape } = metadata;\n    for (\n      let fOrderPhysicalDim = 0;\n      fOrderPhysicalDim < rank;\n      ++fOrderPhysicalDim\n    ) {\n      const decodedDim =\n        physicalToLogicalDimension[rank - 1 - fOrderPhysicalDim];\n      keyCoords[decodedDim] = Math.floor(\n        (chunkGridPosition[fOrderPhysicalDim] * readChunkShape[decodedDim]) /\n          chunkShape[decodedDim],\n      );\n    }\n    for (let i = 0; i < rank; ++i) {\n      baseKey += `${sep}${keyCoords[i]}`;\n      sep = metadata.dimensionSeparator;\n    }\n    const { chunkKvStore } = this;\n    const response = await chunkKvStore.kvStore.read(\n      chunkKvStore.getChunkKey(chunkGridPosition, baseKey),\n      { abortSignal },\n    );\n    if (response !== undefined) {\n      const decoded = await decodeArray(\n        chunkKvStore.decodeCodecs,\n        response.data,\n        abortSignal,\n      );\n      await postProcessRawData(chunk, abortSignal, decoded);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RPC } from \"#src/worker_rpc.js\";\n\nexport const rpc = new RPC(self, /*waitUntilReady=*/ false);\nrpc.sendReady();\n(globalThis as any).rpc = rpc;\n"],"names":["VisibleSegmentEquivalencePolicy","Uint64","WatchableValue","newValue","value_","NullarySignal","TrackableValue","value","validator","defaultValue","x","undefined","registerNested","f","watchables","values","w","count","context","RefCounted","result","handleChange","debounce","changed","i","watchable","signalDisposers","invokeDisposers","Symbol","disposers","disposer","index","target","type","listener","options","cancellable","RefCountedValue","mat4","vec3","kZeroVec","vec4","kOneVec","kInfinityVec","Infinity","prod3","vec3Key","transformVectorByMat4","out","a","m","y","z","transformVectorByMat4Transpose","translationRotationScaleZReflectionToMat4","translation","rotation","scale","zReflection","mat3FromMat4","m00","m01","m02","m10","m11","m12","m20","m21","m22","getFrustrumPlanes","m30","m31","m32","m03","m13","m23","m33","nearA","nearB","nearC","farA","farB","farC","nearNorm","Math","nearD","farNorm","farD","isAABBVisible","xLower","yLower","zLower","xUpper","yUpper","zUpper","clippingPlanes","b","c","sum","isAABBIntersectingPlane","d","maxSum","epsilon","minSum","getViewFrustrumVolume","projectionMat","depth","width","near","baseArea","getViewFrustrumDepthRange","far","quat","verifyFloat","obj","t","parseFloat","Number","Error","JSON","verifyFiniteFloat","verifyFiniteNonNegativeFloat","verifyFinitePositiveFloat","parseFiniteVec","length","Array","stableStringify","s","size","keys","Object","key","SINGLE_QUOTE_STRING_PATTERN","DOUBLE_QUOTE_STRING_PATTERN","SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN","RegExp","DOUBLE_QUOTE_PATTERN","pythonLiteralParse","pythonLiteralToJSON","before","replacement","singleQuoteString","convertStringLiteral","quoteInitial","quoteReplace","quoteSearch","inner","expectArray","parseArray","parseElement","parseFixedLengthArray","verifyObject","verifyInt","parseInt","verifyString","verifyOptionalString","verifyObjectProperty","propertyName","parseError","verifyOptionalObjectProperty","verifyFloat01","verifyEnumString","enumType","pattern","objUpperCase","verifyStringArray","verifyIntegerArray","verifyBoolean","pivots","createIdentity","rows","cols","identity","lda","n","start","inverse","ldb","copy","col","aOff","bOff","row","inverseInplace","determinant","Uint32Array","k","kColOff","pivotRow","bestPivot","mag","off","temp","tempPivot","pivotValue","pivotInv","j","factor","jColOff","targetCol","colOff","targetColOff","off1","off2","Signal","Set","handler","arguments","handlers","onceWrapper","args","wasmModule","dracoModulePromise","cachedCredentials","pendingCredentials","pendingAbortController","decodeResult","ChunkState","ChunkPriorityTier","ChunkDownloadStatistics","ChunkMemoryStatistics","NavigationLinkType","self","peer","link","DataType","Endianness","AnnotationType","getUncached","NiftiDataType","name","factory","ShardIndexLocation","resolver","credentialsProvider","scopedAbortCallback","signal","callback","wrappedCallback","SharedAbortController","Map","AbortController","abortSignal","raceWithAbort","promise","Promise","resolve","reject","cleanup","reason","IS_WORKER","Window","PROMISE_RESPONSE_ID","PROMISE_CANCEL_ID","READY_ID","registerRPC","RPCError","message","registerPromiseRPC","id","abortController","transfers","error","request","INITIAL_RPC_ID","SharedObject","rpc","rpcId","generation","initializeSharedObjectCounterpart","SharedObjectCounterpart","sharedObjectConstructors","registerSharedObject","identifier","constructorFunction","typeName","CHANGED_RPC_METHOD_ID","SharedWatchableValue","base","numChunkStatistics","numChunkStates","getChunkDownloadStatisticIndex","statistic","head","next","prev","Implementation","compare","aChild","node","cur","curNext","root","newRoot","child","nextMarkGeneration","Chunk","msg","_transfers","newState","oldState","bytes","updateChunkStatistics","ChunkSourceBase","chunkManager","Float64Array","chunkType","freeChunks","freeChunksLength","chunk","chunks","keyListeners","idx","listeners","sign","state","statistics","systemMemoryBytes","gpuMemoryBytes","ChunkSource","cancelChunkDownload","controller","ChunkPriorityQueue","heapOperations","linkedListOperations","priorityTier","heapRoots","recentHead","tier","makeChunkPriorityQueue1","PairingHeap1","LinkedList1","tryToFreeCapacity","capacity","priority","evictionCandidates","evict","evictionCandidate","evictionTier","AvailableCapacity","itemLimit","sizeLimit","items","ChunkQueueManager","PairingHeap0","LinkedList0","getCapacity","setTimeout","add","queue","source","queueManager","evictFromGPUMemory","promotionCandidates","promotionCandidate","promotionLambda","systemMemoryEvictionCandidates","systemMemoryCapacity","promotionCandidateResult","startChunkDownload","downloadAbortController","startTime","Date","endTime","console","sourceQueueLevel","gpuMemoryGeneration","ChunkRenderLayerBackend","ChunkManager","StringMemoize","throttle","layer","requestedState","newPriorityTier","tiers","existingTierChunks","newTierChunks","WithParameters","Base","parametersConstructor","C","withChunkManager","results","RenderLayerBackendAttachment","view","RenderLayerBackend","attachment","RENDERED_VIEW_ADD_LAYER_RPC_ID","RENDERED_VIEW_REMOVE_LAYER_RPC_ID","SharedProjectionParametersBackend","PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID","oldValue","arraysEqual","allSiPrefixes","siPrefixesWithAlternatives","supportedUnits","exponentToPrefix","prefix","exponent","unit","kEmptyFloat32Vec","Float32Array","kEmptyFloat64Vec","makeCoordinateSpace","space","names","units","scales","valid","rank","timestamps","ids","_","boundingBoxes","coordinateArrays","bounds","computeCombinedBounds","outputRank","lowerBounds","upperBounds","halfIntegerBounds","integerBounds","boundingBox","outputDim","computeCombinedLowerUpperBound","outputDimension","baseLowerBounds","baseUpperBounds","transform","inputRank","offset","stride","targetLower","targetUpper","hasCoefficient","inputDim","lower","upper","lowerFloor","upperFloor","voxelCenterAtIntegerCoordinates","integerCount","halfIntegerCount","emptyInvalidCoordinateSpace","vector","getCenterBound","isValidDimensionName","allowNumericalNames","WeakMap","TrackableNavigationLink","TrackableEnum","tempQuat","makeLinked","operations","selfMinusPeer","updatingSelf","previousLinkValue","handleLinkUpdate","linkValue","Position","coordinateSpace","coordinates","curCoordinateSpace","coordinates_","prevCoordinateSpace","getBoundingBoxCenter","newCoordinates","prevCoordinates","newScales","prevDimensionIds","oldScales","newDim","newDimId","oldDim","other","aCoordinates","bCoordinates","sourceCoordinates","member","restorable","LinkedBase","restoreLinkedFromJson","json","OrientationState","orientation","q","mat","mat3","usedAxes","maxComponent","argmaxComponent","peerToSelf","updatingPeer","selfToPeer","TrackableRelativeDisplayScales","nonEmpty","factors","oldDimensionIds","newDimensionIds","oldFactors","newFactors","oldIndex","mapPerDimensionValues","arrayConstructor","input","oldCoordinateSpace","newCoordinateSpace","newRank","output","validateDisplayDimensionRenderInfoProperty","expected","actual","TrackableDisplayDimensions","newDimensionIndices","Int32Array","oldDimensionIndices","oldRank","displayRank","displayDimensionIndices","displayDimensionNames","dimensionNamesFromJson","dimensions","expectDimensionName","validateDimensionNames","seenNames","dimensionIndices","RenderViewport","RenderedPanel","element","visibility","boundsGeneration","clientRect","canvasRect","canvas","canvasPixelWidth","canvasPixelHeight","screenToCanvasPixelScaleX","screenToCanvasPixelScaleY","canvasLeft","canvasTop","logicalLeft","logicalTop","logicalWidth","logicalHeight","logicalRight","logicalBottom","clippedTop","clippedLeft","clippedRight","clippedBottom","parent","rect","viewport","clippedWidth","clippedHeight","gl","canvasRelativeClippedTop","canvasRelativeClippedLeft","height","bottom","WebGL2RenderingContext","glBottom","canvasHeight","DATA_TYPE_BYTES","DATA_TYPE_ARRAY_CONSTRUCTOR","Uint8Array","Int8Array","Uint16Array","Int16Array","DATA_TYPE_JAVASCRIPT_ELEMENTS_PER_ARRAY_ELEMENT","makeDataTypeArrayView","dataType","buffer","byteOffset","byteLength","bytesPerElement","javascriptElementsPerArrayElement","tempMat4","updateFixedCurPositionInChunks","tsource","globalPosition","localPosition","curPositionInChunks","fixedPositionWithinChunk","nonDisplayLowerClipBound","nonDisplayUpperClipBound","chunkDataSize","getChunkPositionFromCombinedGlobalLocalPositions","chunkPosition","layerRank","combinedGlobalLocalToChunkTransform","globalRank","localRank","chunkDim","globalDim","localDim","chunkSize","tempChunkLayout","ChunkLayout","SliceViewBase","projectionParameters","visibleSourcesInvalidated","oldViewMatrix","newViewMatrix","curDisplayDimensionRenderInfo","visibleLayers","renderLayer","visibleLayerSources","allSources","visibleSources","preferredOrientationIndex","pickBestAlternativeSource","viewMatrix","alternatives","numAlternatives","bestAlternativeIndex","bestSliceArea","alternativeIndex","chunkLayout","sliceArea","estimateSliceAreaPerChunk","viewZProjection","chunkVolume","sources","tempVisibleVolumetricChunkLower","tempVisibleVolumetricChunkUpper","tempVisibleVolumetricModelViewProjection","tempVisibleVolumetricClippingPlanes","forEachVolumetricChunkWithinFrustrum","transformedSource","predicate","lowerChunkDisplayBound","upperChunkDisplayBound","chunkDisplayDimensionIndices","recurse","splitDim","splitSize","volume","prevLower","prevUpper","splitPoint","forEachVisibleVolumetricChunk","modelViewProjection","forEachPlaneIntersectingVolumetricChunk","invModelViewProjection","xCoeff","yCoeff","zCoeff","getNormalizedChunkLayout","finiteRank","invTransform","invViewMatrix","chunkRenderDim","xc","yc","zc","scaleFactor","VelocityEstimator","velocityHalfLifeMilliseconds","modelHalfLifeMilliseconds","position","time","numSamples","deltaT","velocityAlpha","modelAlpha","velocity","prevPosition","mean","variance","curVelocitySample","prevVelocity","newVelocity","meanPrev","varPrev","delta","withSharedVisibility","getPriorityTier","getBasePriority","tempChunkPosition","tempCenter","tempChunkSize","disposeTransformedSources","SliceViewIntermediateBase","SliceViewCounterpartBase","SliceViewBackend","centerDataPosition","basePriority","curVisibleChunks","numVisibleSources","prefetchOffsets","getPrefetchChunkOffsets","velocityEstimator","offsets","chunkRank","meanVec","varianceVec","isDisplayDimension","meanValue","varianceValue","coeff","initialFraction","adjustedMean","adjustedStddevTimesSqrt2","cdf","erf","p","a5","curChunk","minChunk","maxChunk","groupStart","probability","newGroupStart","end","PREFETCH_ENTRY_SIZE","localCenter","sourceBasePriority","SCALE_PRIORITY_MULTIPLIER","curMarkGeneration","positionInChunks","visibleChunk","newPriority","jumpOffset","newIndex","layerInfo","displayDimensionRenderInfo","deserializeTransformedSources","serializedSources","serializedSource","SliceViewChunk","chunkGridPosition","SliceViewChunkSourceBackend","SliceViewRenderLayerBackend","sliceView","filterVisibleSources","prevVoxelSize","pixelSize","smallestVoxelSize","renderScaleTarget","canImproveOnVoxelSize","voxelSize","targetSize","improvesOnPrevVoxelSize","prevSize","scaleIndex","disposeRecompute","PerspectiveViewBackend","PerspectiveViewRenderLayerBackend","tempMat3","tempCenterDataPosition","VolumeRenderingRenderLayerBackend","scheduleUpdateChunkPriorities","transformedSources","displayDim","forEachVisibleVolumeRenderingChunk","volumeRenderingDepthSamples","beginScale","voxelPhysicalScales","canonicalToPhysicalScale","depthRange","targetViewVolume","targetViewSpacing","viewDet","histogramInformation","getViewVolume","bestScaleIndex","bestViewVolume","viewVolume","physicalSpacing","optimalSamples","firstChunk","priorityIndex","ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID","parseRGBAColorSpecification","document","parseColorSerialization","packColor","serializeColor","float32ToString","ENDIANNESS","swapEndian16","array","swapEndian32","convertEndian32","convertEndian","elementBytes","swapEndian64","float64Buf","getRandomHexString","numBits","numValues","data","crypto","AnnotationReference","annotationTypes","annotationPropertyTypeHandlers","property","AnnotationPropertySerializer","firstGroupInitialOffset","propertySpecs","serializedBytes","propertyGroupBytes","getPropertyOffsets","numProperties","permutation","getAlignment","propertyGroupIndex","propertyGroupOffset","nextPropertyGroup","outputIndex","propertyIndex","spec","numBytes","alignment","alignmentOffset","newEndOffset","newStartOffset","newAlignedEndOffset","groupOffsetCode","groupIndex","serializeCode","deserializeCode","group","propId","offsetExpr","Function","makeAnnotationPropertySerializers","serializers","annotationType","annotationTypeHandlers","serializeFloatVector","isLittleEndian","vec","serializeTwoFloatVectors","vecA","vecB","deserializeFloatVector","deserializeTwoFloatVectors","annotation","pointA","pointB","point","center","radii","makeAnnotationId","AnnotationSerializer","propertySerializers","serializeAnnotations","allAnnotations","totalBytes","typeToOffset","serializedPropertiesBytes","propertySerializer","annotations","typeToIds","typeToIdMaps","ArrayBuffer","dataView","DataView","serializeProperties","serialize","geometryDataStride","ADD_METHOD_ID","CLEAR_METHOD_ID","HIGH_BIT_REPRESENTATIVE_CHANGED_ID","DELETE_SET_METHOD_ID","SharedDisjointUint64Sets","DisjointUint64Sets","highBitRepresentative","updateHighBitRepresentative","String","tempA","tempB","pendingLow","pendingHigh","backupPendingLow","backupPendingHigh","HashTableBase","hashSeeds","initialSize","numHashes","emptySlots","mungedEmptyKey","chooseMungedEmptyKey","h","table","emptyLow","emptyHigh","getRandomValues","byteArray","hashIndex","low","high","hash","hashCombine","entryStride","newLow","newHigh","tempLow","tempHigh","attempt","maxAttempts","tableIndex","tableSize","oldTable","desiredTableSize","rehashAttempt","HashSetUint64","pendingValueLow","pendingValueHigh","backupPendingValueLow","backupPendingValueHigh","HashMapUint64","Uint64Map","Uint64Set","v","tmp","VISIBLE_SEGMENTS_STATE_PROPERTIES","onVisibleSegmentsStateChanged","onTemporaryVisibleSegmentsStateChanged","getObjectKey","objectId","forEachVisibleSegment","visibleSegments","segmentEquivalences","equivalencePolicy","rootObjectId","rootObjectId2","segmentId","receiveVisibleSegmentsState","withSegmentationLayerBackendState","IndexedSegmentPropertySourceBackend","AnnotationMetadataChunk","AnnotationGeometryData","GeometryChunkMixin","AnnotationGeometryChunk","AnnotationSubsetGeometryChunk","AnnotationMetadataChunkSource","AnnotationGeometryChunkSourceBackend","AnnotationSubsetGeometryChunkSource","AnnotationSource","metadataChunkSource","newAnnotation","annotationId","fixAnnotationAfterStructuredCloning","relatedSegments","numRelationships","segments","AnnotationSpatiallyIndexedRenderLayerBackend","attachmentState","forEachVisibleAnnotationChunk","viewFrustrumVolume","baseSource","sourceVolume","lowerClipDisplayBound","upperClipDisplayBound","effectiveVolume","viewportArea","physicalDensityTarget","targetNumAnnotations","totalPhysicalDensity","physicalVolume","limit","sliceFraction","newTotalPhysicalDensity","totalPhysicalSpacing","totalPixelSpacing","drawFraction","desiredCount","AnnotationLayerSharedObjectCounterpart","states","segmentFilteredSources","SharedCredentialsProviderCounterpart","invalidCredentials","CREDENTIALS_PROVIDER_GET_RPC_ID","credentials","WithSharedCredentialsProviderCounterpart","HttpError","url","status","statusText","response","TypeError","pickDelay","attemptNumber","maxDelayMilliseconds","fetchOk","init","requestAttempt","fetch","tempUint64","isNotFoundError","e","fetchWithCredentials","applyCredentials","errorHandler","credentialsAttempt","fetchWithBossCredentials","headers","Headers","collisions","getBaseIndex","entry","getEdgeIndex","vertexAIndex","edgeIndex","vertexBIndex","vertexCIndex","encodeZIndexCompressed3d","zindex","xBits","yBits","zBits","maxBits","outputBit","outputNum","isHigh","writeBit","bit","lessMsb","zorder3LessThan","x0","y0","z0","x1","y1","z1","mostSignificant0","mostSignificant1","ManifestChunk","serializeMeshData","vertexPositions","indices","vertexNormals","strips","vertexPositionsBuffer","indicesBuffer","getMeshDataSize","FragmentChunk","manifestChunk","fragmentId","decodeJsonManifestChunk","keysPropertyName","computeVertexNormals","positions","faceNormal","v1v0","v2v1","numIndices","i0","i1","i2","numVertices","snorm8","signNotZero","decodeVertexPositionsAndIndices","verticesPerPrimitive","endianness","vertexByteOffset","indexByteOffset","numPrimitives","decodeTriangleVertexPositionsAndIndices","numTriangles","MeshSource","fragmentSource","objectKey","fragmentKey","parsedFragmentId","FragmentSource","MeshLayer","fragmentChunk","MultiscaleManifestChunk","MultiscaleFragmentChunk","subChunkOffsets","MultiscaleMeshSource","lod","chunkIndex","MultiscaleFragmentSource","tempModelMatrix","MultiscaleMeshLayer","maxVisibility","manifestChunks","get3dModelToDisplaySpaceMatrix","fullRank","globalToRenderLayerDimensions","modelToRenderLayerTransform","layerDim","modelDim","globalDimensionNames","displayDimDesc","detailCutoff","maxLod","getDesiredMultiscaleMeshChunks","manifest","viewportWidth","viewportHeight","octree","lodScales","chunkGridSpatialOrigin","chunkShape","minWXcoeff","minWYcoeff","minWZcoeff","getPointW","minWClip","objectXLower","objectYLower","objectZLower","objectXUpper","objectYUpper","objectZUpper","handleChunk","priorLodScale","rowOffset","gridX","gridY","gridZ","childBegin","childEndAndEmpty","minW","getBoxW","lodScale","nextPriorLodScale","childEnd","childRow","_renderScale","empty","convertMeshData","vertexPositionFormat","encodedIndices","encodedVertexPositions","normals","encodedNormals","encodeNormals32fx3ToOctahedron8x2","outIndex","invL1Norm","VertexPositionFormat","inputIndex","assignMeshFragmentData","assignMultiscaleMeshFragmentData","generateHigherOctreeLevel","priorStart","priorEnd","curEnd","asyncComputation","encodeCompressedSegmentationUint32","encodeCompressedSegmentationUint64","numWorkers","freeWorkers","pendingTasks","tasks","maxWorkers","navigator","nextTaskId","returnWorker","worker","task","requestAsyncComputation","transfer","abortHandler","launchWorker","Worker","URL","ready","callbacks","postProcessRawData","shape","decodeGzip","format","decompressedStream","Response","DecompressionStream","supportedDataTypes","endiannessChar","typeChar","NumpyArray","fortranOrder","decodeBossNpzChunk","parseResult","parseNpy","headerObject","majorVersion","minorVersion","headerLength","dv","header","TextDecoder","dataOffset","dtype","numElements","dim","parseNumpyDtype","typestr","javascriptElements","parsedDataType","decodeJpeg","decodeJpegChunk","decoded","computeChunkBounds","tempChunkDataSize","upperVoxelBound","baseVoxelOffset","origChunkDataSize","partial","newChunkDataSize","VolumeChunkSource","VolumeChunk","chunkDecoders","acceptHeaders","BossSource","BossVolumeChunkSource","VolumeChunkSourceParameters","parameters","BossMeshSource","MeshSourceParameters","decodeFragmentChunk","fetchWithOAuth2Credentials","makeRequest","instance","httpCall","SkeletonChunk","total","vertexAttributes","vertexData","vertexAttributeOffsets","SkeletonSource","SkeletonLayer","decodeSkeletonVertexPositionsAndIndices","numEdges","meshData","decodeCompressedSegmentationChunk","decodeRawChunk","expectedBytes","CHUNK_DECODERS","VolumeChunkEncoding","applyChangeStack","changeStack","payload","BrainmapsSource","BrainmapsVolumeChunkSource","VolumeSourceParameters","encoding","path","decodeBatchMeshResponse","objectIdLow","objectIdHigh","objectIdString","fragmentKeyLength","fragmentKeyLengthHigh","fullKey","numVerticesHigh","numTrianglesHigh","endOffset","combineBatchMeshFragments","fragments","totalVertices","totalIndices","fragment","vertexBuffer","indexBuffer","vertexOffset","indexOffset","sourceIndices","makeBatchMeshRequest","prevObjectId","batches","batchSize","pendingIds","idData","splitIndex","BrainmapsMultiscaleMeshSource","MultiscaleMeshSourceParameters","changeSpec","decodeMultiscaleManifestChunk","clipLowerBound","clipUpperBound","fragmentKeys","supervoxelIds","fragmentSupervoxelIds","gridShape","fragmentIdAndCorners","getFragmentCorner","decodeZIndexCompressed","maxCoordBits","inputBit","inputValue","coordBit","minNumLods","minCoord","maxCoord","corner","lods","lodIndex","octreeTemp","numBaseChunks","startChunkIndex","endChunkIndex","relativeBlockShape","supervoxelId","prevLod","idArray","defaultStringCompare","meshName","requestsInProgress","maybeIssueMoreRequests","numSubChunks","prevSubChunkIndex","subChunkIndex","getOctreeChildIndex","BrainmapsMeshSource","decodeManifestChunkWithSupervoxelIds","fragmentIds","groupFragmentsIntoBatches","BrainmapsSkeletonSource","SkeletonSourceParameters","decodeSkeletonChunk","numEdgesHigh","spatialAnnotationTypes","parseCommaSeparatedPoint","cornerParts","getIdPrefix","parseBrainmapsAnnotationId","idPrefix","fullId","parseObjectLabels","parseAnnotation","expectedId","description","spatialAnnotationType","annotationPropertySerializers","parseAnnotations","responses","serializer","responseIndex","annotationsArray","getSpatialAnnotationTypeFromId","toCommaSeparated","getFullSpatialAnnotationId","annotationToBrainmaps","objectLabels","minPoint","maxPoint","BrainmapsAnnotationGeometryChunkSource","AnnotationSpatialIndexSourceParameters","BrainmapsAnnotationSource","AnnotationSourceParameters","_relationshipIndex","brainmapsAnnotation","decodePng","fetchSpecialOk","u","parseUrl","match","encodeURIComponent","bucket","DeepzoomImageTileSource","ImageTileSourceParameters","tilesize","overlap","ox","oy","tiledata","responseBuffer","tilewidth","tileheight","ImageTileEncoding","pngbitmap","transposeArray2d","majorSize","minorSize","transpose","jpegbitmap","t2","twh","DVIDInstance","baseUrl","nodeKey","dataName","startKey","endKey","appendQueryStringForDvid","user","fetchWithDVIDCredentials","newInit","PointObj","DVIDSource","DVIDSkeletonSource","bodyid","decodeSwcSkeletonChunk","swcStr","swcObjects","parseSwc","swcInputAr","swcObjectsAr","float","indexMap","nodeCount","edgeCount","swcObj","glVertices","glIndices","nodeIndex","edgetIndex","enc","DVIDMeshSource","meshUrl","dvidInstance","DVIDVolumeChunkSource","params","decoder","ChunkedGraphSourceParameters","isBaseSegmentId","nBitsForLayerId","layerId","GenericSharedDataChunk","requesters","requester","GenericSharedDataSource","encodeKey","getPriority","encodedKey","handleAbort","memoizeKey","decodeFunction","getObjectId","AsyncCacheChunk","SimpleAsyncCache","completed","sharedAbortController","numPartitions","libraryEnv","memoryIndex","numFaces","indicesPointer","vertexPositionsPointer","subchunkOffsetsPointer","memory","code","getDracoModulePromise","WebAssembly","decodeDracoPartitioned","vertexQuantizationBits","partition","heap","r","decodeDraco","decodeCompresso","decodeCompressoChunk","image","decodeJxl","decodeJxlChunk","decodePngChunk","cacheMode","fetchSpecialHttpByteRange","startOffset","endOffsetStr","murmurHash3_x86_128Mix","rotl32","shardingHashFunctions","ShardingHashFunction","seed","h1","h2","h3","h4","k2","k1","_out","getMinishardIndexDataSource","sharding","shardAndMinishard","shardIndexResponse","minishard","shard","shardUrl","shardIndexSize","shardIndexStart","shardIndexEnd","shardIndexDv","minishardStartOffset","minishardEndOffset","minishardIndexResponse","DataEncoding","minishardIndex","minishardIndexSize","prevEntryKeyLow","prevEntryKeyHigh","prevStartLow","prevStartHigh","entryKeyLow","entryKeyHigh","startLow","startHigh","sizeLow","sizeHigh","endLow","endHigh","getShardedData","minishardIndexSource","hashFunction","hashCode","minishardEntry","findMinishardEntry","minishardIndexData","keyLow","keyHigh","getOrNotFoundError","PrecomputedVolumeChunkSource","decodeManifestChunk","PrecomputedMeshSource","decodeMultiscaleFragmentChunk","PrecomputedMultiscaleMeshSource","gridOrigin","numStoredLods","storedLodScales","vertexOffsets","numFragmentsPerLod","totalFragments","fragmentInfo","numLods","fragmentBase","numFragments","upperBoundValue","lowerBoundValue","maxFragments","prevNumFragments","prevLodIndex","offsetsTemp","baseRow","dataSize","computeOctreeChildOffsets","childStart","parentEnd","childNode","parentNode","parentX","parentY","parentZ","childX","childY","childZ","lodScaleMultiplier","requestUrl","adjustedStartOffset","adjustedEndOffset","shardInfo","fullDataSize","fetchByUint64","PrecomputedSkeletonSource","curOffset","attributes","info","bytesPerVertex","attribute","convertEndian16","countLow","countHigh","idOffset","geometryData","origData","origOffset","groupOffset","groupBytesPerAnnotation","annotationIndex","origBase","newBase","PrecomputedAnnotationSpatialIndexSourceBackend","upperChunkBound","encodeZIndexCompressed","PrecomputedAnnotationSourceBackend","relationshipIndex","parseSingleAnnotation","baseNumBytes","minNumBytes","PrecomputedIndexedSegmentPropertySourceBackend","IndexedSegmentPropertySourceParameters","decodeDracoFragmentChunk","GrapheneMeshSource","segment","newSegments","manifestRequestCount","manifestUrl","requestCount","fragmentDownloadPromise","getVerifiedFragmentPromise","parts","getGrapheneFragmentKey","ChunkedGraphChunk","GrapheneChunkedGraphChunkSource","res","decodeChunkedGraphChunk","leaves","final","err","errorPrefix","ChunkedGraphLayer","visibleLeaves","capacities","rootObjectKey","filteredLeaves","rootInt","leaf","decodeBlosc","decodeZstd","decodeChunk","mode","numDimensions","NiftiFileData","decodeNiftiFile","_cancellationToken","isCompressed","readHeader","getNiftiFileData","getNiftiHeaderInfo","DATA_TYPE_CONVERSIONS","GET_NIFTI_VOLUME_INFO_RPC_ID","affine","dataTypeInfo","spatialInvScale","spatialUnit","NIFTI1","timeUnit","timeInvScale","sourceScales","viewScales","sourceNames","viewNames","quatern_b","quatern_c","quatern_d","quatern_a","qfac","qoffset","method2Transform","matrix","copyRank","NiftiVolumeChunkSource","imageBuffer","readImage","parseOBJFromArrayBuffer","SingleMeshChunk","transferSet","singleMeshFactories","registerSingleMeshFactory","protocolPattern","getCombinedMesh","getMesh","getDataSource","factories","dataSource","SingleMeshSource","SingleMeshSourceParametersWithInfo","SINGLE_MESH_CHUNK_KEY","SingleMeshLayerBase","SingleMeshLayer","parse","GET_SINGLE_MESH_INFO_RPC_ID","mesh","TileChunkSource","TileChunkSourceParameters","query_params","imageMethod","xTileSize","yTileSize","parseVTKFromArrayBuffer","codecRegistry","CodecKind","registerCodec","codec","decodeArray","codecs","encoded","bytesToBytes","impl","arrayToArray","configuration","decodedArrayInfo","compressionFormat","getCodecResolver","parseNameAndConfiguration","parseName","parseConfiguration","parseCodecChainSpec","arrayInfo","layoutInfo","encodedSize","codecSpecs","numCodecs","initialConfiguration","encodedArrayInfo","arrayResolver","arrayToBytes","finalLayoutInfo","initialEncodedSize","shardingInfo","arrayToBytesResolver","codecSpec","newEncodedSize","bytesResolver","UNITS","siPrefix","longPrefix","unitInfo","composeByteRangeRequest","outer","subChunkShape","indexLocation","subChunkGridShape","outerSize","innerSize","indexShape","indexCodecs","subChunkCodecs","MISSING_VALUE","BigInt","ShardedKvStore","byteRange","BigUint64Array","physicalToLogicalIndexDimension","indexStrides","physicalIndexDim","logicalIndexDim","shardIndex","subChunk","pos","dataLength","fullByteRange","outerByteRange","innerByteRange","byteRangeCacheMode","SpecialProtocolKvStore","headResponse","contentLength","byteRangeRequest","totalSize","requestInit","rangeHeader","getRangeHeader","contentRange","beginPos","endPos","ZarrVolumeChunkSource","applySharding","baseKvStore","kvStore","curCodecs","decodeCodecs","getChunkKey","baseKey","physicalToLogicalDimension","readChunkShape","fOrderPhysicalDim","subChunkDim","sep","metadata","ChunkKeyEncoding","keyCoords","decodedDim","chunkKvStore","RPC","waitUntilReady","promiseWithResolversAndAbortCallback","abortCallback","globalThis"],"mappings":"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"}